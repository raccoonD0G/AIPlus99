{"requirement": "Create an actor with a static mesh component that can be changed in the editor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    // Sets default values for this actor's properties\n    AMyStaticMeshActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Mesh\")\n    UStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Create Static Mesh Component\n    StaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n    RootComponent = StaticMeshComponent;\n\n    // Optionally set a default static mesh\n    // static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.YourMesh\"));\n    // if (MeshAsset.Succeeded())\n    // {\n    //     StaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n    // }\n}\n\n// Called when the game starts or when spawned\nvoid AMyStaticMeshActor::BeginPlay()\n{\n    Super::BeginPlay();\n    \n}\n\n// Called every frame\nvoid AMyStaticMeshActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    \n}\n```"}
{"requirement": "Implement an actor that rotates continuously around a vertical axis every Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    // Sets default values for this actor's properties\n    ARotatingActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category = \"Rotation\")\n    float RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    RotationSpeed = 45.0f; // Degrees per second\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    // Get current rotation\n    FRotator CurrentRotation = GetActorRotation();\n\n    // Calculate new rotation\n    CurrentRotation.Yaw += RotationSpeed * DeltaTime;\n\n    // Set the new rotation\n    SetActorRotation(CurrentRotation);\n}\n```"}
{"requirement": "Create a component with a float property exposed to Blueprints using UPROPERTY(EditAnywhere).", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFloatComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:\n    UFloatComponent();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Float\")\n    float MyFloat;\n};\n```", "cpp_code": "```cpp\n#include \"UFloatComponent.h\"\n\nUFloatComponent::UFloatComponent()\n{\n    PrimaryComponentTick.bCanEverTick = false;\n\n    // Initialize the float property\n    MyFloat = 0.0f;\n}\n\nvoid UFloatComponent::BeginPlay()\n{\n    Super::BeginPlay();\n\n    // Custom initialization code can be added here\n}\n```"}
{"requirement": "Bind the 'Space' key to a function that prints 'Jump!' to the log in SetupPlayerInputComponent.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"JumpActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AJumpActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AJumpActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Setup player input component\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    // Function to be called when Space key is pressed\n    void PrintJumpMessage();\n};\n```", "cpp_code": "```cpp\n#include \"JumpActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAJumpActor::AJumpActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AJumpActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid AJumpActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid AJumpActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    if (PlayerInputComponent)\n    {\n        PlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, &AJumpActor::PrintJumpMessage);\n    }\n}\n\n// Function to be called when Space key is pressed\nvoid AJumpActor::PrintJumpMessage()\n{\n    UE_LOG(LogTemp, Warning, TEXT(\"Jump!\"));\n}\n```"}
{"requirement": "Implement an actor that moves forward constantly at a speed defined by a UPROPERTY(EditAnywhere).", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AMovingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n    float MoveSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n\nAMovingActor::AMovingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    MoveSpeed = 100.0f; // Default speed\n}\n\nvoid AMovingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    \n    FVector NewLocation = GetActorLocation() + GetActorForwardVector() * MoveSpeed * DeltaTime;\n    SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a static mesh actor that changes its scale when 'V' is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleChangeActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AScaleChangeActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AScaleChangeActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n    UStaticMeshComponent* MeshComponent;\n\nprivate:\n    void ChangeScale();\n\n    FVector OriginalScale;\n    FVector TargetScale;\n    bool bIsScaled;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAScaleChangeActor::AScaleChangeActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n    if (MeshAsset.Succeeded())\n    {\n        MeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n\n    OriginalScale = FVector(1.0f, 1.0f, 1.0f);\n    TargetScale = FVector(2.0f, 2.0f, 2.0f);\n    bIsScaled = false;\n}\n\nvoid AScaleChangeActor::BeginPlay()\n{\n    Super::BeginPlay();\n    SetActorScale3D(OriginalScale);\n}\n\nvoid AScaleChangeActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AScaleChangeActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n    PlayerInputComponent->BindAction(\"ChangeScale\", IE_Pressed, this, &AScaleChangeActor::ChangeScale);\n}\n\nvoid AScaleChangeActor::ChangeScale()\n{\n    if (bIsScaled)\n    {\n        SetActorScale3D(OriginalScale);\n    }\n    else\n    {\n        SetActorScale3D(TargetScale);\n    }\n    bIsScaled = !bIsScaled;\n}\n```"}
{"requirement": "React to OnBeginOverlap in an actor by printing the name of the overlapped object.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AOverlapActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION()\n    void OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapActor::AOverlapActor()\n{\n    // Set this actor to call Tick() every frame.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Create and set the mesh component\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    // Set up overlap event\n    MeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n    if (OtherActor && OtherActor != this)\n    {\n        FString ActorName = OtherActor->GetName();\n        GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, ActorName);\n    }\n}\n```"}
{"requirement": "Create a component with a BlueprintCallable function that doubles a given integer.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UDoubleIntComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UDoubleIntComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUDoubleIntComponent();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Math\")\n\tint32 DoubleInteger(int32 InputValue) const;\n};\n```", "cpp_code": "```cpp\n#include \"UDoubleIntComponent.h\"\n\nUDoubleIntComponent::UDoubleIntComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nint32 UDoubleIntComponent::DoubleInteger(int32 InputValue) const\n{\n\treturn InputValue * 2;\n}\n```"}
{"requirement": "Implement an AI Controller that changes a boolean property when a target is sensed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"Perception/AIPerceptionComponent.h\"\n#include \"AEnemyAIController.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AEnemyAIController : public AAIController\n{\n    GENERATED_BODY()\n\npublic:\n    AEnemyAIController();\n\nprotected:\n    virtual void BeginPlay() override;\n\nprivate:\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"AI\", meta = (AllowPrivateAccess = \"true\"))\n    bool bIsTargetSensed;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"AI\", meta = (AllowPrivateAccess = \"true\"))\n    UAIPerceptionComponent* AIPerceptionComponent;\n\n    UFUNCTION()\n    void OnTargetSensed(AActor* Actor, FAIStimulus Stimulus);\n};\n```", "cpp_code": "```cpp\n#include \"AEnemyAIController.h\"\n#include \"Perception/AISenseConfig_Sight.h\"\n#include \"Perception/AIPerceptionComponent.h\"\n#include \"Perception/AIPerceptionStimuliSourceComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nAEnemyAIController::AEnemyAIController()\n{\n    AIPerceptionComponent = CreateDefaultSubobject<UAIPerceptionComponent>(TEXT(\"AIPerceptionComponent\"));\n    SetPerceptionComponent(*AIPerceptionComponent);\n\n    UAISenseConfig_Sight* SightConfig = CreateDefaultSubobject<UAISenseConfig_Sight>(TEXT(\"SightConfig\"));\n    if(SightConfig)\n    {\n        SightConfig->SightRadius = 500.0f;\n        SightConfig->LoseSightRadius = 600.0f;\n        SightConfig->PeripheralVisionAngleDegrees = 90.0f;\n        SightConfig->SetMaxAge(5.0f);\n        AIPerceptionComponent->ConfigureSense(*SightConfig);\n        AIPerceptionComponent->SetDominantSense(SightConfig->GetSenseImplementation());\n    }\n\n    AIPerceptionComponent->OnTargetPerceptionUpdated.AddDynamic(this, &AEnemyAIController::OnTargetSensed);\n\n    bIsTargetSensed = false;\n}\n\nvoid AEnemyAIController::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AEnemyAIController::OnTargetSensed(AActor* Actor, FAIStimulus Stimulus)\n{\n    bIsTargetSensed = Stimulus.WasSuccessfullySensed();\n}\n```"}
{"requirement": "Load a static mesh asset using ConstructorHelpers in the constructor of an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UStaticMeshComponent.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AMyStaticMeshActor();\n\nprotected:\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n    UStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"ConstructorHelpers.h\"\n\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n    // Set this actor to call Tick() every frame.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Create the Static Mesh Component\n    StaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n    RootComponent = StaticMeshComponent;\n\n    // Load a static mesh asset using ConstructorHelpers\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.YourMeshName\"));\n    if (MeshAsset.Succeeded())\n    {\n        StaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n}\n```"}
{"requirement": "Bind the 'F' key to a function that toggles visibility of the actor in SetupPlayerInputComponent.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AToggleVisibilityActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AToggleVisibilityActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Function to toggle visibility\n    void ToggleVisibility();\n\n    // Setup player input component\n    virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n     // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n     PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleVisibilityActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n    // Toggle the visibility of the actor\n    SetActorHiddenInGame(!bHidden);\n}\n\nvoid AToggleVisibilityActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    // Bind the 'F' key to toggle visibility\n    PlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleVisibilityActor::ToggleVisibility);\n}\n```"}
{"requirement": "Create an actor that moves up and down smoothly using a sine wave pattern every Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SineWaveMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ASineWaveMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASineWaveMover();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Initial location of the actor\n\tFVector InitialLocation;\n\n\t// Frequency of the sine wave\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Frequency;\n\n\t// Amplitude of the sine wave\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Amplitude;\n\n\t// Elapsed time\n\tfloat ElapsedTime;\n};\n```", "cpp_code": "```cpp\n#include \"SineWaveMover.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nASineWaveMover::ASineWaveMover()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Set default values\n\tFrequency = 1.0f;\n\tAmplitude = 100.0f;\n\tElapsedTime = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASineWaveMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Store the initial location\n\tInitialLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid ASineWaveMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Increase the elapsed time\n\tElapsedTime += DeltaTime;\n\n\t// Calculate new Z position using sine wave pattern\n\tfloat NewZ = InitialLocation.Z + Amplitude * FMath::Sin(Frequency * ElapsedTime);\n\n\t// Update actor's location\n\tSetActorLocation(FVector(InitialLocation.X, InitialLocation.Y, NewZ));\n}\n```"}
{"requirement": "Expose a UPROPERTY(EditAnywhere) float that controls the actor's rotation speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotationSpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotationSpeedActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ARotationSpeedActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n    float RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotationSpeedActor.h\"\n\nARotationSpeedActor::ARotationSpeedActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    RotationSpeed = 45.0f; // Default rotation speed\n}\n\nvoid ARotationSpeedActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ARotationSpeedActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    // Example rotation logic\n    FRotator NewRotation = GetActorRotation();\n    NewRotation.Yaw += RotationSpeed * DeltaTime;\n    SetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a BlueprintAssignable delegate in a component that broadcasts on a specific condition.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UExampleComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnConditionMet);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UExampleComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:\n    UExampleComponent();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n    UPROPERTY(BlueprintAssignable, Category=\"Events\")\n    FOnConditionMet OnConditionMet;\n\nprivate:\n    void CheckCondition();\n\n    bool bConditionMet;\n};\n```", "cpp_code": "```cpp\n#include \"UExampleComponent.h\"\n\nUExampleComponent::UExampleComponent()\n{\n    PrimaryComponentTick.bCanEverTick = true;\n    bConditionMet = false;\n}\n\nvoid UExampleComponent::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid UExampleComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n    CheckCondition();\n}\n\nvoid UExampleComponent::CheckCondition()\n{\n    if (!bConditionMet) // Replace this with your actual condition\n    {\n        bConditionMet = true;\n        OnConditionMet.Broadcast();\n    }\n}\n```"}
{"requirement": "Create a visible actor with a mesh and a light component that can be toggled on and off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ALightToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALightToggleActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    ALightToggleActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    UPROPERTY(VisibleAnywhere)\n    UPointLightComponent* LightComponent;\n\n    UFUNCTION()\n    void ToggleLight();\n};\n```", "cpp_code": "```cpp\n#include \"ALightToggleActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nALightToggleActor::ALightToggleActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n    if (MeshAsset.Succeeded())\n    {\n        MeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n\n    LightComponent = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"LightComponent\"));\n    LightComponent->SetupAttachment(RootComponent);\n    LightComponent->SetVisibility(true);\n}\n\nvoid ALightToggleActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ALightToggleActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ALightToggleActor::ToggleLight()\n{\n    if (LightComponent)\n    {\n        LightComponent->ToggleVisibility();\n    }\n}\n```"}
{"requirement": "Bind a function to log 'Hello World' when the 'H' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AHKeyLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AHKeyLogger : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AHKeyLogger();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    void LogHelloWorld();\n};\n```", "cpp_code": "```cpp\n#include \"AHKeyLogger.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nAHKeyLogger::AHKeyLogger()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AHKeyLogger::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AHKeyLogger::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AHKeyLogger::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    if (PlayerInputComponent)\n    {\n        PlayerInputComponent->BindAction(\"LogHelloWorld\", IE_Pressed, this, &AHKeyLogger::LogHelloWorld);\n    }\n}\n\nvoid AHKeyLogger::LogHelloWorld()\n{\n    UE_LOG(LogTemp, Warning, TEXT(\"Hello World\"));\n}\n```"}
{"requirement": "Implement an actor that changes color randomly every second using Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARandomColorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n\tfloat TimeSinceLastColorChange;\n\n\tvoid ChangeColor();\n};\n```", "cpp_code": "```cpp\n#include \"RandomColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nARandomColorActor::ARandomColorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tTimeSinceLastColorChange = 0.0f;\n}\n\nvoid ARandomColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARandomColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeSinceLastColorChange += DeltaTime;\n\n\tif (TimeSinceLastColorChange >= 1.0f)\n\t{\n\t\tChangeColor();\n\t\tTimeSinceLastColorChange = 0.0f;\n\t}\n}\n\nvoid ARandomColorActor::ChangeColor()\n{\n\tUMaterialInstanceDynamic* DynMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\tif (DynMaterial)\n\t{\n\t\tFLinearColor RandomColor = FLinearColor::MakeRandomColor();\n\t\tDynMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), RandomColor);\n\t}\n}\n```"}
{"requirement": "Create a component with a boolean property that controls visibility and is exposed to Blueprints.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"MyVisibilityComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass UMyVisibilityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMyVisibilityComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Visibility\")\n\tvoid SetVisibility(bool bNewVisibility);\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Visibility\")\n\tbool bIsVisible;\n};\n```", "cpp_code": "```cpp\n#include \"MyVisibilityComponent.h\"\n\nUMyVisibilityComponent::UMyVisibilityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\tbIsVisible = true;\n}\n\nvoid UMyVisibilityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Initially set visibility based on bIsVisible\n\tSetVisibility(bIsVisible);\n}\n\nvoid UMyVisibilityComponent::SetVisibility(bool bNewVisibility)\n{\n\tbIsVisible = bNewVisibility;\n\t// Assuming the component is attached to an actor with a mesh\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tif (UStaticMeshComponent* MeshComp = Owner->FindComponentByClass<UStaticMeshComponent>())\n\t\t{\n\t\t\tMeshComp->SetVisibility(bIsVisible);\n\t\t}\n\t}\n}\n```"}
{"requirement": "React to OnBeginOverlap by increasing a score integer in the player character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyOverlapActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyOverlapActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AMyOverlapActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UFUNCTION()\n    void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n};\n\nUCLASS()\nclass MYGAME_API AMyPlayerCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    AMyPlayerCharacter();\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Score\")\n    int32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"MyOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"MyPlayerCharacter.h\"\n#include \"Engine/Engine.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyOverlapActor::AMyOverlapActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    MeshComponent->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n    MeshComponent->SetCollisionObjectType(ECollisionChannel::ECC_WorldDynamic);\n    MeshComponent->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);\n    MeshComponent->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Overlap);\n\n    MeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyOverlapActor::OnOverlapBegin);\n}\n\nvoid AMyOverlapActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AMyOverlapActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AMyOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n    if (AMyPlayerCharacter* PlayerCharacter = Cast<AMyPlayerCharacter>(OtherActor))\n    {\n        PlayerCharacter->Score++;\n        if (GEngine)\n        {\n            GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Score: %d\"), PlayerCharacter->Score));\n        }\n    }\n}\n\nAMyPlayerCharacter::AMyPlayerCharacter()\n{\n    Score = 0;\n}\n```"}
{"requirement": "Load a sound asset using ConstructorHelpers and play it when a function is called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"SoundPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayerActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ASoundPlayerActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Function to play the sound\n    UFUNCTION(BlueprintCallable, Category=\"Sound\")\n    void PlaySound();\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Sound\")\n    USoundCue* SoundCue;\n\n    UPROPERTY()\n    UAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SoundPlayerActor.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Components/AudioComponent.h\"\n\nASoundPlayerActor::ASoundPlayerActor()\n{\n    // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = false;\n\n    // Initialize Audio Component\n    AudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n    AudioComponent->bAutoActivate = false; // Don't play the sound immediately\n    RootComponent = AudioComponent;\n\n    // Find SoundCue asset\n    static ConstructorHelpers::FObjectFinder<USoundCue> SoundCueObject(TEXT(\"/Game/Audio/YourSoundCue.YourSoundCue\"));\n    if (SoundCueObject.Succeeded())\n    {\n        SoundCue = SoundCueObject.Object;\n        AudioComponent->SetSound(SoundCue);\n    }\n}\n\nvoid ASoundPlayerActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ASoundPlayerActor::PlaySound()\n{\n    if (AudioComponent && SoundCue)\n    {\n        AudioComponent->Play();\n    }\n}\n```"}
{"requirement": "Create an actor with a movable component that moves forward when 'W' is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"MovableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovableActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AMovableActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n    virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent);\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    UPROPERTY(VisibleAnywhere)\n    UCharacterMovementComponent* MovementComponent;\n\n    void MoveForward(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"MovableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAMovableActor::AMovableActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    MovementComponent = CreateDefaultSubobject<UCharacterMovementComponent>(TEXT(\"MovementComponent\"));\n    MovementComponent->SetupAttachment(RootComponent);\n}\n\nvoid AMovableActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AMovableActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AMovableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    PlayerInputComponent->BindAxis(\"MoveForward\", this, &AMovableActor::MoveForward);\n}\n\nvoid AMovableActor::MoveForward(float Value)\n{\n    if (Value != 0.0f)\n    {\n        FVector Direction = GetActorForwardVector();\n        AddActorLocalOffset(Direction * Value);\n    }\n}\n```"}
{"requirement": "Implement a static mesh actor that changes material when overlapping with another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMaterialOnOverlap.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMaterialOnOverlap : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AChangeMaterialOnOverlap();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UFUNCTION()\n    void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    UPROPERTY(EditAnywhere)\n    UMaterialInterface* OriginalMaterial;\n\n    UPROPERTY(EditAnywhere)\n    UMaterialInterface* OverlappedMaterial;\n\n    UPROPERTY(VisibleAnywhere)\n    class UBoxComponent* CollisionComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialOnOverlap.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAChangeMaterialOnOverlap::AChangeMaterialOnOverlap()\n{\n    // Set this actor to call Tick() every frame.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Create and set up the mesh component\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    // Load a static mesh for the component\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n    if (MeshAsset.Succeeded())\n    {\n        MeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n\n    // Create and set up the collision component\n    CollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n    CollisionComponent->SetupAttachment(RootComponent);\n    CollisionComponent->SetBoxExtent(FVector(50.f, 50.f, 50.f));\n    CollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AChangeMaterialOnOverlap::OnOverlapBegin);\n\n    // Load materials\n    static ConstructorHelpers::FObjectFinder<UMaterialInterface> OriginalMat(TEXT(\"/Game/StarterContent/Materials/M_Brick_Clay_Old.M_Brick_Clay_Old\"));\n    if (OriginalMat.Succeeded())\n    {\n        OriginalMaterial = OriginalMat.Object;\n        MeshComponent->SetMaterial(0, OriginalMaterial);\n    }\n\n    static ConstructorHelpers::FObjectFinder<UMaterialInterface> OverlappedMat(TEXT(\"/Game/StarterContent/Materials/M_Metal_Burnished_Steel.M_Metal_Burnished_Steel\"));\n    if (OverlappedMat.Succeeded())\n    {\n        OverlappedMaterial = OverlappedMat.Object;\n    }\n}\n\n// Called when the game starts or when spawned\nvoid AChangeMaterialOnOverlap::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid AChangeMaterialOnOverlap::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialOnOverlap::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n    if (OtherActor && (OtherActor != this) && OtherComp)\n    {\n        MeshComponent->SetMaterial(0, OverlappedMaterial);\n    }\n}\n```"}
{"requirement": "Create a component with a BlueprintCallable function to reset its position to the origin.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UResetPositionComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UResetPositionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUResetPositionComponent();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Position\")\n\tvoid ResetPositionToOrigin();\n};\n```", "cpp_code": "```cpp\n#include \"UResetPositionComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUResetPositionComponent::UResetPositionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UResetPositionComponent::ResetPositionToOrigin()\n{\n\tif(AActor* Owner = GetOwner())\n\t{\n\t\tOwner->SetActorLocation(FVector::ZeroVector);\n\t}\n}\n```"}
{"requirement": "Bind 'P' key to toggle between two different camera perspectives in SetupPlayerInputComponent.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"CameraToggleCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ACameraToggleCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    ACameraToggleCharacter();\n\nprotected:\n    virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UCameraComponent* FirstPersonCameraComponent;\n\n    UPROPERTY(VisibleAnywhere)\n    UCameraComponent* ThirdPersonCameraComponent;\n\n    bool bIsFirstPersonView;\n\n    void ToggleCameraPerspective();\n};\n```", "cpp_code": "```cpp\n#include \"CameraToggleCharacter.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n\nACameraToggleCharacter::ACameraToggleCharacter()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    FirstPersonCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FirstPersonCamera\"));\n    FirstPersonCameraComponent->SetupAttachment(GetMesh());\n    FirstPersonCameraComponent->bUsePawnControlRotation = true;\n\n    ThirdPersonCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"ThirdPersonCamera\"));\n    ThirdPersonCameraComponent->SetupAttachment(RootComponent);\n    ThirdPersonCameraComponent->bUsePawnControlRotation = true;\n\n    bIsFirstPersonView = true;\n    ThirdPersonCameraComponent->Deactivate();\n}\n\nvoid ACameraToggleCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    PlayerInputComponent->BindAction(\"ToggleCamera\", IE_Pressed, this, &ACameraToggleCharacter::ToggleCameraPerspective);\n}\n\nvoid ACameraToggleCharacter::ToggleCameraPerspective()\n{\n    if (bIsFirstPersonView)\n    {\n        FirstPersonCameraComponent->Deactivate();\n        ThirdPersonCameraComponent->Activate();\n    }\n    else\n    {\n        ThirdPersonCameraComponent->Deactivate();\n        FirstPersonCameraComponent->Activate();\n    }\n    bIsFirstPersonView = !bIsFirstPersonView;\n}\n```"}
{"requirement": "Create an actor that scales its mesh up and down over time using Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tfloat RunningTime;\n\tfloat ScaleFactor;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRunningTime = 0.f;\n\tScaleFactor = 1.f;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRunningTime += DeltaTime;\n\tScaleFactor = 1.0f + FMath::Sin(RunningTime) * 0.5f;\n\tMeshComponent->SetWorldScale3D(FVector(ScaleFactor));\n}\n```"}
{"requirement": "Implement a UMG widget with a button that closes the game when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UQuitGameWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UQuitGameWidget : public UUserWidget\n{\n    GENERATED_BODY()\n\npublic:\n    virtual void NativeConstruct() override;\n\nprotected:\n    UPROPERTY(meta = (BindWidget))\n    class UButton* QuitButton;\n\n    UFUNCTION()\n    void OnQuitButtonClicked();\n};\n```", "cpp_code": "```cpp\n#include \"UQuitGameWidget.h\"\n#include \"Components/Button.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nvoid UQuitGameWidget::NativeConstruct()\n{\n    Super::NativeConstruct();\n\n    if (QuitButton)\n    {\n        QuitButton->OnClicked.AddDynamic(this, &UQuitGameWidget::OnQuitButtonClicked);\n    }\n}\n\nvoid UQuitGameWidget::OnQuitButtonClicked()\n{\n    if (UWorld* World = GetWorld())\n    {\n        UGameplayStatics::SetGamePaused(World, false);\n        World->GetFirstPlayerController()->ConsoleCommand(\"quit\");\n    }\n}\n```"}
{"requirement": "Create an actor that spawns a particle effect at its location on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ParticleEffectActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AParticleEffectActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAParticleEffectActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Particle system to spawn\n\tUPROPERTY(EditAnywhere, Category=\"Effects\")\n\tUParticleSystem* ParticleEffect;\n\n\t// Function to spawn particle effect\n\tUFUNCTION()\n\tvoid SpawnParticleEffect();\n\n\t// Setup player input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ParticleEffectActor.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAParticleEffectActor::AParticleEffectActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AParticleEffectActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AParticleEffectActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input\nvoid AParticleEffectActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"SpawnParticle\", IE_Pressed, this, &AParticleEffectActor::SpawnParticleEffect);\n}\n\n// Function to spawn particle effect\nvoid AParticleEffectActor::SpawnParticleEffect()\n{\n\tif (ParticleEffect)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ParticleEffect, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Implement a function callable from Blueprints that logs the actor's current location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogActorLocation.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ALogActorLocation : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ALogActorLocation();\n\n    UFUNCTION(BlueprintCallable, Category=\"Logging\")\n    void LogCurrentLocation();\n};\n```", "cpp_code": "```cpp\n#include \"LogActorLocation.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nALogActorLocation::ALogActorLocation()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALogActorLocation::LogCurrentLocation()\n{\n    FVector Location = GetActorLocation();\n    UE_LOG(LogTemp, Log, TEXT(\"Actor's current location: %s\"), *Location.ToString());\n}\n```"}
{"requirement": "Bind a function to toggle an actor's collision enabled state with the 'C' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleCollisionActor.generated.h\"\n\nUCLASS()\nclass AToggleCollisionActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AToggleCollisionActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    UFUNCTION()\n    void ToggleCollision();\n\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* StaticMesh;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleCollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nAToggleCollisionActor::AToggleCollisionActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    StaticMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMesh\"));\n    RootComponent = StaticMesh;\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n    if (MeshAsset.Succeeded())\n    {\n        StaticMesh->SetStaticMesh(MeshAsset.Object);\n    }\n}\n\nvoid AToggleCollisionActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AToggleCollisionActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AToggleCollisionActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    PlayerInputComponent->BindAction(\"ToggleCollision\", IE_Pressed, this, &AToggleCollisionActor::ToggleCollision);\n}\n\nvoid AToggleCollisionActor::ToggleCollision()\n{\n    if (StaticMesh->GetCollisionEnabled() == ECollisionEnabled::NoCollision)\n    {\n        StaticMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n    }\n    else\n    {\n        StaticMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n    }\n}\n```"}
{"requirement": "Create a component with a BlueprintAssignable delegate that triggers on a specific event.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UEventTriggerComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnEventTriggered);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UEventTriggerComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:    \n    UEventTriggerComponent();\n\n    UPROPERTY(BlueprintAssignable, Category=\"Events\")\n    FOnEventTriggered OnEventTriggered;\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    void TriggerEvent();\n};\n```", "cpp_code": "```cpp\n#include \"UEventTriggerComponent.h\"\n\nUEventTriggerComponent::UEventTriggerComponent()\n{\n    PrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UEventTriggerComponent::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid UEventTriggerComponent::TriggerEvent()\n{\n    OnEventTriggered.Broadcast();\n}\n```"}
{"requirement": "Implement an actor with a skeletal mesh and play an animation montage on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Animation/AnimMontage.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"AnimationMontageActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AAnimationMontageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAnimationMontageActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta=(AllowPrivateAccess=\"true\"))\n\tUSkeletalMeshComponent* SkeletalMesh;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Animation\", meta=(AllowPrivateAccess=\"true\"))\n\tUAnimMontage* AnimationMontage;\n};\n```", "cpp_code": "```cpp\n#include \"AnimationMontageActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAAnimationMontageActor::AAnimationMontageActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSkeletalMesh = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMesh\"));\n\tRootComponent = SkeletalMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<USkeletalMesh> SkeletalMeshAsset(TEXT(\"/Game/YourPath/YourSkeletalMesh.YourSkeletalMesh\"));\n\tif (SkeletalMeshAsset.Succeeded())\n\t{\n\t\tSkeletalMesh->SetSkeletalMesh(SkeletalMeshAsset.Object);\n\t}\n\n\tUBoxComponent* CollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionBox\"));\n\tCollisionBox->SetupAttachment(RootComponent);\n\tCollisionBox->SetBoxExtent(FVector(100.f));\n\tCollisionBox->OnComponentBeginOverlap.AddDynamic(this, &AAnimationMontageActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UAnimMontage> MontageAsset(TEXT(\"/Game/YourPath/YourAnimMontage.YourAnimMontage\"));\n\tif (MontageAsset.Succeeded())\n\t{\n\t\tAnimationMontage = MontageAsset.Object;\n\t}\n}\n\nvoid AAnimationMontageActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAnimationMontageActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AAnimationMontageActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (AnimationMontage && SkeletalMesh)\n\t{\n\t\tUAnimInstance* AnimInstance = SkeletalMesh->GetAnimInstance();\n\t\tif (AnimInstance)\n\t\t{\n\t\t\tAnimInstance->Montage_Play(AnimationMontage);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Load a material asset using ConstructorHelpers and apply it to a mesh component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UMyMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AUMyMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAUMyMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"UMyMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAUMyMeshActor::AUMyMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Load and apply the material\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> Material(TEXT(\"/Game/Path/To/Your/Material.YourMaterial\"));\n\tif (Material.Succeeded())\n\t{\n\t\tMeshComponent->SetMaterial(0, Material.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AUMyMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AUMyMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that follows a simple AI behavior tree to move between waypoints.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AIWaypointActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAIWaypointActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AAIWaypointActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, Category = \"AI\")\n    TArray<AActor*> Waypoints;\n\n    UPROPERTY(EditAnywhere, Category = \"AI\")\n    float MovementSpeed;\n\nprivate:\n    int32 CurrentWaypointIndex;\n};\n```", "cpp_code": "```cpp\n#include \"AIWaypointActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAAIWaypointActor::AAIWaypointActor()\n{\n    // Set this actor to call Tick() every frame\n    PrimaryActorTick.bCanEverTick = true;\n\n    MovementSpeed = 200.f;\n    CurrentWaypointIndex = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AAIWaypointActor::BeginPlay()\n{\n    Super::BeginPlay();\n\n    if (Waypoints.Num() > 0)\n    {\n        SetActorLocation(Waypoints[CurrentWaypointIndex]->GetActorLocation());\n    }\n}\n\n// Called every frame\nvoid AAIWaypointActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (Waypoints.Num() == 0)\n    {\n        return;\n    }\n\n    AActor* CurrentWaypoint = Waypoints[CurrentWaypointIndex];\n    FVector Direction = (CurrentWaypoint->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n    FVector NewLocation = GetActorLocation() + Direction * MovementSpeed * DeltaTime;\n    SetActorLocation(NewLocation);\n\n    float DistanceToWaypoint = FVector::Dist(GetActorLocation(), CurrentWaypoint->GetActorLocation());\n    if (DistanceToWaypoint < 100.f)\n    {\n        CurrentWaypointIndex = (CurrentWaypointIndex + 1) % Waypoints.Num();\n    }\n}\n```"}
{"requirement": "Bind 'R' key to reset an actor's location to its initial position.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResettableActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AResettableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAResettableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to reset the actor's location\n\tvoid ResetLocation();\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Initial location of the actor\n\tFVector InitialLocation;\n};\n```", "cpp_code": "```cpp\n#include \"ResettableActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAResettableActor::AResettableActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AResettableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Store the initial location\n\tInitialLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid AResettableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResettableActor::ResetLocation()\n{\n\tSetActorLocation(InitialLocation);\n}\n\nvoid AResettableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the R key to ResetLocation function\n\tPlayerInputComponent->BindAction(\"ResetLocation\", IE_Pressed, this, &AResettableActor::ResetLocation);\n}\n```"}
{"requirement": "Implement a component with a float property to control the intensity of a light.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULightIntensityComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULightIntensityComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:    \n    ULightIntensityComponent();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light\")\n    float LightIntensity;\n};\n```", "cpp_code": "```cpp\n#include \"ULightIntensityComponent.h\"\n\nULightIntensityComponent::ULightIntensityComponent()\n{\n    PrimaryComponentTick.bCanEverTick = false;\n\n    // Default value for light intensity\n    LightIntensity = 1000.0f;\n}\n\nvoid ULightIntensityComponent::BeginPlay()\n{\n    Super::BeginPlay();\n\n    // You can initialize or modify the light intensity here if needed\n}\n```"}
{"requirement": "Create a rotating actor that changes its rotation speed with a UPROPERTY(metadata=ClampMin).", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    ARotatingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(ClampMin=\"0.0\"))\n    float RotationSpeed;\n\nprivate:\n    UStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nARotatingActor::ARotatingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n    if (MeshAsset.Succeeded())\n    {\n        MeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n\n    RotationSpeed = 100.0f; // Default rotation speed\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    FRotator NewRotation = GetActorRotation();\n    NewRotation.Yaw += RotationSpeed * DeltaTime;\n    SetActorRotation(NewRotation);\n}\n```"}
{"requirement": "React to OnBeginOverlap by changing the actor's mesh to a different one.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AMyActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UFUNCTION()\n    void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* StaticMeshComponent;\n\n    UPROPERTY(EditAnywhere)\n    UStaticMesh* NewMesh;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyActor::AMyActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    StaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n    RootComponent = StaticMeshComponent;\n\n    StaticMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyActor::OnOverlapBegin);\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMesh\"));\n    if (MeshAsset.Succeeded())\n    {\n        StaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n}\n\nvoid AMyActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AMyActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n    if (NewMesh)\n    {\n        StaticMeshComponent->SetStaticMesh(NewMesh);\n    }\n}\n```"}
{"requirement": "Create a UMG widget with a text block that updates with the player's score.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"PlayerScoreWidget.generated.h\"\n\nUCLASS()\nclass MYGAME_API UPlayerScoreWidget : public UUserWidget\n{\n    GENERATED_BODY()\n\npublic:\n    UPlayerScoreWidget(const FObjectInitializer& ObjectInitializer);\n\n    UFUNCTION(BlueprintCallable, Category=\"Score\")\n    void UpdateScore(int32 NewScore);\n\nprotected:\n    virtual void NativeConstruct() override;\n\nprivate:\n    UPROPERTY(meta = (BindWidget))\n    class UTextBlock* ScoreTextBlock;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerScoreWidget.h\"\n#include \"Components/TextBlock.h\"\n\nUPlayerScoreWidget::UPlayerScoreWidget(const FObjectInitializer& ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n}\n\nvoid UPlayerScoreWidget::NativeConstruct()\n{\n    Super::NativeConstruct();\n    // Initial setup if needed\n}\n\nvoid UPlayerScoreWidget::UpdateScore(int32 NewScore)\n{\n    if (ScoreTextBlock)\n    {\n        ScoreTextBlock->SetText(FText::AsNumber(NewScore));\n    }\n}\n```"}
{"requirement": "Implement a function in an actor to print its velocity every Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintVelocityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APrintVelocityActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    APrintVelocityActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"PrintVelocityActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/MovementComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAPrintVelocityActor::APrintVelocityActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid APrintVelocityActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid APrintVelocityActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    FVector Velocity = GetVelocity();\n    UE_LOG(LogTemp, Log, TEXT(\"Actor Velocity: %s\"), *Velocity.ToString());\n}\n```"}
{"requirement": "Bind a function to log the actor's forward vector when 'V' is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogForwardVectorActor.generated.h\"\n\nUCLASS()\nclass ALogForwardVectorActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ALogForwardVectorActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Function to log the forward vector\n    void LogForwardVector();\n\n    // Setup player input component\n    virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"LogForwardVectorActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nALogForwardVectorActor::ALogForwardVectorActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALogForwardVectorActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ALogForwardVectorActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid ALogForwardVectorActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n    PlayerInputComponent->BindAction(\"LogForwardVector\", IE_Pressed, this, &ALogForwardVectorActor::LogForwardVector);\n}\n\n// Function to log the forward vector\nvoid ALogForwardVectorActor::LogForwardVector()\n{\n    FVector ForwardVector = GetActorForwardVector();\n    UE_LOG(LogTemp, Log, TEXT(\"Forward Vector: %s\"), *ForwardVector.ToString());\n}\n```"}
{"requirement": "Create a component with a BlueprintCallable function to set a new color on a mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UColorChangerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UColorChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUColorChangerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION(BlueprintCallable, Category=\"Mesh\")\n\tvoid SetMeshColor(FLinearColor NewColor);\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"UColorChangerComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nUColorChangerComponent::UColorChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\t// Find and attach the static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComponent->SetupAttachment(this);\n}\n\nvoid UColorChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UColorChangerComponent::SetMeshColor(FLinearColor NewColor)\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Load a texture asset using ConstructorHelpers and apply it to a material dynamically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UTextureLoaderActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AUTextureLoaderActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AUTextureLoaderActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    UPROPERTY(EditAnywhere)\n    UMaterialInterface* BaseMaterial;\n\n    UPROPERTY(EditAnywhere)\n    UMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"UTextureLoaderActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAUTextureLoaderActor::AUTextureLoaderActor()\n{\n    PrimaryActorTick.bCanEverTick = false;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/Path/To/Your/Mesh.Mesh'\"));\n    if (MeshAsset.Succeeded())\n    {\n        MeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n\n    static ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialAsset(TEXT(\"Material'/Game/Path/To/Your/Material.Material'\"));\n    if (MaterialAsset.Succeeded())\n    {\n        BaseMaterial = MaterialAsset.Object;\n    }\n\n    static ConstructorHelpers::FObjectFinder<UTexture> TextureAsset(TEXT(\"Texture2D'/Game/Path/To/Your/Texture.Texture'\"));\n    if (TextureAsset.Succeeded())\n    {\n        DynamicMaterialInstance = UMaterialInstanceDynamic::Create(BaseMaterial, this);\n        DynamicMaterialInstance->SetTextureParameterValue(FName(\"TextureParameterName\"), TextureAsset.Object);\n        MeshComponent->SetMaterial(0, DynamicMaterialInstance);\n    }\n}\n\nvoid AUTextureLoaderActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n```"}
{"requirement": "Create an actor that rotates towards a target point over time using Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    ARotatingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n    FVector TargetPoint;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n    float RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\nARotatingActor::ARotatingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    RotationSpeed = 45.0f; // Default speed of rotation in degrees per second\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    FRotator CurrentRotation = GetActorRotation();\n    FVector Direction = TargetPoint - GetActorLocation();\n    Direction.Z = 0; // Ignore Z axis for 2D rotation\n    Direction.Normalize();\n\n    FRotator TargetRotation = UKismetMathLibrary::MakeRotFromX(Direction);\n    FRotator NewRotation = FMath::RInterpConstantTo(CurrentRotation, TargetRotation, DeltaTime, RotationSpeed);\n\n    SetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a simple AI Controller that moves an NPC character towards the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"GameFramework/Character.h\"\n#include \"AAICharacterController.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AAICharacterController : public AAIController\n{\n    GENERATED_BODY()\n\npublic:\n    AAICharacterController();\n\nprotected:\n    virtual void BeginPlay() override;\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    APawn* PlayerPawn;\n};\n```", "cpp_code": "```cpp\n#include \"AAICharacterController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Character.h\"\n\nAAICharacterController::AAICharacterController()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AAICharacterController::BeginPlay()\n{\n    Super::BeginPlay();\n\n    PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid AAICharacterController::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (PlayerPawn)\n    {\n        MoveToActor(PlayerPawn, 5.0f);\n    }\n}\n```"}
{"requirement": "Bind a function to toggle an actor's physics simulation with the 'P' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TogglePhysicsActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATogglePhysicsActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ATogglePhysicsActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    void TogglePhysics();\n};\n```", "cpp_code": "```cpp\n#include \"TogglePhysicsActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nATogglePhysicsActor::ATogglePhysicsActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/YourPath/YourMesh.YourMesh\"));\n    if (MeshAsset.Succeeded())\n    {\n        MeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n}\n\nvoid ATogglePhysicsActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ATogglePhysicsActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ATogglePhysicsActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    PlayerInputComponent->BindAction(\"TogglePhysics\", IE_Pressed, this, &ATogglePhysicsActor::TogglePhysics);\n}\n\nvoid ATogglePhysicsActor::TogglePhysics()\n{\n    if (MeshComponent)\n    {\n        bool bIsSimulating = MeshComponent->IsSimulatingPhysics();\n        MeshComponent->SetSimulatePhysics(!bIsSimulating);\n    }\n}\n```"}
{"requirement": "Create a component with a UPROPERTY(EditAnywhere) to set an actor's initial health value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"HealthComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UHealthComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this component's properties\n    UHealthComponent();\n\nprotected:\n    // Called when the game starts\n    virtual void BeginPlay() override;\n\npublic:\n    // Actor's initial health value\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n    float InitialHealth;\n};\n```", "cpp_code": "```cpp\n#include \"HealthComponent.h\"\n\n// Sets default values for this component's properties\nUHealthComponent::UHealthComponent()\n{\n    // Set this component to be initialized when the game starts, and to be ticked every frame. You can turn these features\n    // off to improve performance if you don't need them.\n    PrimaryComponentTick.bCanEverTick = false;\n\n    // Initialize the default health value\n    InitialHealth = 100.0f;\n}\n\n// Called when the game starts\nvoid UHealthComponent::BeginPlay()\n{\n    Super::BeginPlay();\n\n    // You can initialize or modify InitialHealth here if needed\n}\n```"}
{"requirement": "React to OnBeginOverlap by playing a specific sound at the actor's location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"ASoundOverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASoundOverlapActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ASoundOverlapActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    UPROPERTY(VisibleAnywhere, Category = \"Audio\")\n    UAudioComponent* AudioComponent;\n\n    UPROPERTY(EditAnywhere, Category = \"Audio\")\n    USoundCue* SoundToPlay;\n\n    UPROPERTY(VisibleAnywhere, Category = \"Collision\")\n    UBoxComponent* BoxComponent;\n\n    UFUNCTION()\n    void OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"ASoundOverlapActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundOverlapActor::ASoundOverlapActor()\n{\n    PrimaryActorTick.bCanEverTick = false;\n\n    BoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n    RootComponent = BoxComponent;\n\n    AudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n    AudioComponent->SetupAttachment(RootComponent);\n    AudioComponent->bAutoActivate = false;\n\n    BoxComponent->OnComponentBeginOverlap.AddDynamic(this, &ASoundOverlapActor::OnBeginOverlap);\n}\n\nvoid ASoundOverlapActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ASoundOverlapActor::OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n    if(SoundToPlay)\n    {\n        UGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n    }\n}\n```"}
{"requirement": "Create an actor with a camera component that follows the player character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CameraFollowerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACameraFollowerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACameraFollowerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The camera component that will follow the player\n\tUPROPERTY(VisibleAnywhere)\n\tUCameraComponent* CameraComponent;\n\n\t// The player character the camera will follow\n\tAPawn* PlayerCharacter;\n\n\t// Function to update the camera position\n\tvoid UpdateCameraPosition();\n};\n```", "cpp_code": "```cpp\n#include \"CameraFollowerActor.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nACameraFollowerActor::ACameraFollowerActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the camera component\n\tCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"CameraComponent\"));\n\tRootComponent = CameraComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ACameraFollowerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Get the player character\n\tPlayerCharacter = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\n// Called every frame\nvoid ACameraFollowerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update the camera position to follow the player\n\tUpdateCameraPosition();\n}\n\n// Function to update the camera position\nvoid ACameraFollowerActor::UpdateCameraPosition()\n{\n\tif (PlayerCharacter)\n\t{\n\t\tFVector PlayerLocation = PlayerCharacter->GetActorLocation();\n\t\t// Simple follow logic (can be expanded with smoothing, offsets, etc.)\n\t\tSetActorLocation(PlayerLocation);\n\t}\n}\n```"}
{"requirement": "Implement a function that prints the actor's rotation to the console when called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintRotationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API APrintRotationActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    APrintRotationActor();\n\n    // Function to print the actor's rotation\n    UFUNCTION(BlueprintCallable, Category = \"Debug\")\n    void PrintRotation() const;\n};\n```", "cpp_code": "```cpp\n#include \"PrintRotationActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n\nAPrintRotationActor::APrintRotationActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APrintRotationActor::PrintRotation() const\n{\n    FRotator ActorRotation = GetActorRotation();\n    UE_LOG(LogTemp, Log, TEXT(\"Actor Rotation: Pitch=%f, Yaw=%f, Roll=%f\"), ActorRotation.Pitch, ActorRotation.Yaw, ActorRotation.Roll);\n}\n```"}
{"requirement": "Bind a function to log the actor's distance from the origin when 'D' is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceLoggerActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADistanceLoggerActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ADistanceLoggerActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Setup player input\n    virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\n    // Function to log distance from origin\n    void LogDistanceFromOrigin();\n};\n```", "cpp_code": "```cpp\n#include \"DistanceLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nADistanceLoggerActor::ADistanceLoggerActor()\n{\n    // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ADistanceLoggerActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ADistanceLoggerActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ADistanceLoggerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n    PlayerInputComponent->BindAction(\"LogDistance\", IE_Pressed, this, &ADistanceLoggerActor::LogDistanceFromOrigin);\n}\n\nvoid ADistanceLoggerActor::LogDistanceFromOrigin()\n{\n    FVector ActorLocation = GetActorLocation();\n    float Distance = ActorLocation.Size();\n    UE_LOG(LogTemp, Log, TEXT(\"Distance from Origin: %f\"), Distance);\n}\n```"}
{"requirement": "Create a component with a float property exposed to Blueprints to control speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"USpeedControlComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API USpeedControlComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:\n    USpeedControlComponent();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Speed\")\n    float Speed;\n};\n```", "cpp_code": "```cpp\n#include \"USpeedControlComponent.h\"\n\nUSpeedControlComponent::USpeedControlComponent()\n{\n    PrimaryComponentTick.bCanEverTick = true;\n    Speed = 0.0f;\n}\n\nvoid USpeedControlComponent::BeginPlay()\n{\n    Super::BeginPlay();\n}\n```"}
{"requirement": "Load a blueprint class using ConstructorHelpers and spawn it in the level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"ABlueprintSpawner.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ABlueprintSpawner : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ABlueprintSpawner();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY()\n    TSubclassOf<AActor> BlueprintToSpawn;\n};\n```", "cpp_code": "```cpp\n#include \"ABlueprintSpawner.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nABlueprintSpawner::ABlueprintSpawner()\n{\n    // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Find the blueprint class\n    static ConstructorHelpers::FObjectFinder<UClass> BlueprintClass(TEXT(\"/Game/Blueprints/MyBlueprintClass.MyBlueprintClass_C\"));\n    if (BlueprintClass.Succeeded())\n    {\n        BlueprintToSpawn = BlueprintClass.Object;\n    }\n}\n\n// Called when the game starts or when spawned\nvoid ABlueprintSpawner::BeginPlay()\n{\n    Super::BeginPlay();\n    \n    if (BlueprintToSpawn)\n    {\n        FActorSpawnParameters SpawnParams;\n        GetWorld()->SpawnActor<AActor>(BlueprintToSpawn, GetActorLocation(), GetActorRotation(), SpawnParams);\n    }\n}\n\n// Called every frame\nvoid ABlueprintSpawner::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its material when clicked by the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ClickableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AClickableActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AClickableActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION()\n    void OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    UPROPERTY(EditAnywhere)\n    UMaterialInterface* DefaultMaterial;\n\n    UPROPERTY(EditAnywhere)\n    UMaterialInterface* ClickedMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"ClickableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"Engine/World.h\"\n#include \"ConstructorHelpers.h\"\n\nAClickableActor::AClickableActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n    if (MeshAsset.Succeeded())\n    {\n        MeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n\n    MeshComponent->SetNotifyRigidBodyCollision(true);\n    MeshComponent->OnClicked.AddDynamic(this, &AClickableActor::OnClicked);\n\n    static ConstructorHelpers::FObjectFinder<UMaterialInterface> DefaultMat(TEXT(\"/Game/Path/To/DefaultMaterial.DefaultMaterial\"));\n    if (DefaultMat.Succeeded())\n    {\n        DefaultMaterial = DefaultMat.Object;\n    }\n\n    static ConstructorHelpers::FObjectFinder<UMaterialInterface> ClickedMat(TEXT(\"/Game/Path/To/ClickedMaterial.ClickedMaterial\"));\n    if (ClickedMat.Succeeded())\n    {\n        ClickedMaterial = ClickedMat.Object;\n    }\n\n    MeshComponent->SetMaterial(0, DefaultMaterial);\n}\n\nvoid AClickableActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AClickableActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AClickableActor::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n    if (MeshComponent && ClickedMaterial)\n    {\n        MeshComponent->SetMaterial(0, ClickedMaterial);\n    }\n}\n```"}
{"requirement": "Implement a UMG widget that displays the actor's name and can be updated dynamically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UActorNameWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UActorNameWidget : public UUserWidget\n{\n    GENERATED_BODY()\n\npublic:\n    UFUNCTION(BlueprintCallable, Category=\"ActorName\")\n    void UpdateActorName(FString NewName);\n\nprotected:\n    UPROPERTY(BlueprintReadOnly, meta=(BindWidget))\n    class UTextBlock* ActorNameText;\n};\n```", "cpp_code": "```cpp\n#include \"UActorNameWidget.h\"\n#include \"Components/TextBlock.h\"\n\nvoid UActorNameWidget::UpdateActorName(FString NewName)\n{\n    if (ActorNameText)\n    {\n        ActorNameText->SetText(FText::FromString(NewName));\n    }\n}\n```"}
{"requirement": "Bind a function to toggle an actor's scale between two sizes with the 'T' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleScaleActor.generated.h\"\n\nUCLASS()\nclass AToggleScaleActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AToggleScaleActor();\n\nprotected:\n    virtual void BeginPlay() override;\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category = \"Scale\")\n    FVector SmallScale;\n\n    UPROPERTY(EditAnywhere, Category = \"Scale\")\n    FVector LargeScale;\n\n    UFUNCTION()\n    void ToggleScale();\n\n    bool bIsSmallScale;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleScaleActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAToggleScaleActor::AToggleScaleActor()\n{\n    PrimaryActorTick.bCanEverTick = false;\n    SmallScale = FVector(1.0f, 1.0f, 1.0f);\n    LargeScale = FVector(2.0f, 2.0f, 2.0f);\n    bIsSmallScale = true;\n}\n\nvoid AToggleScaleActor::BeginPlay()\n{\n    Super::BeginPlay();\n    SetActorScale3D(SmallScale);\n}\n\nvoid AToggleScaleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n    PlayerInputComponent->BindAction(\"ToggleScale\", IE_Pressed, this, &AToggleScaleActor::ToggleScale);\n}\n\nvoid AToggleScaleActor::ToggleScale()\n{\n    if (bIsSmallScale)\n    {\n        SetActorScale3D(LargeScale);\n    }\n    else\n    {\n        SetActorScale3D(SmallScale);\n    }\n    bIsSmallScale = !bIsSmallScale;\n}\n```"}
{"requirement": "Create a component with a UPROPERTY(EditAnywhere) to control the component's visibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UVisibilityControlComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UVisibilityControlComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:\n    UVisibilityControlComponent();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Visibility\")\n    bool bIsVisible;\n\n    void UpdateVisibility();\n};\n```", "cpp_code": "```cpp\n#include \"UVisibilityControlComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUVisibilityControlComponent::UVisibilityControlComponent()\n{\n    PrimaryComponentTick.bCanEverTick = true;\n    bIsVisible = true;\n}\n\nvoid UVisibilityControlComponent::BeginPlay()\n{\n    Super::BeginPlay();\n    UpdateVisibility();\n}\n\nvoid UVisibilityControlComponent::UpdateVisibility()\n{\n    if (GetOwner())\n    {\n        GetOwner()->SetActorHiddenInGame(!bIsVisible);\n    }\n}\n```"}
{"requirement": "React to OnBeginOverlap by disabling the actor's mesh visibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapReactActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapReactActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AOverlapReactActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* StaticMeshComponent;\n\n    UFUNCTION()\n    void OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapReactActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapReactActor::AOverlapReactActor()\n{\n    // Set this actor to call Tick() every frame\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Create and attach a StaticMeshComponent\n    StaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n    RootComponent = StaticMeshComponent;\n\n    // Set up overlap event\n    StaticMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapReactActor::OnBeginOverlap);\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapReactActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapReactActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AOverlapReactActor::OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n    if (StaticMeshComponent)\n    {\n        StaticMeshComponent->SetVisibility(false);\n    }\n}\n```"}
{"requirement": "Create an actor that updates its position based on a sine wave pattern using Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SineWaveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASineWaveActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    // Sets default values for this actor's properties\n    ASineWaveActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"SineWave\")\n    float Amplitude;\n\n    UPROPERTY(EditAnywhere, Category=\"SineWave\")\n    float Frequency;\n\n    float RunningTime;\n};\n```", "cpp_code": "```cpp\n#include \"SineWaveActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nASineWaveActor::ASineWaveActor()\n{\n    // Set this actor to call Tick() every frame.\n    PrimaryActorTick.bCanEverTick = true;\n\n    Amplitude = 100.0f;\n    Frequency = 1.0f;\n    RunningTime = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASineWaveActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ASineWaveActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    RunningTime += DeltaTime;\n    float DeltaHeight = Amplitude * FMath::Sin(Frequency * RunningTime);\n    FVector NewLocation = GetActorLocation();\n    NewLocation.Z += DeltaHeight;\n    SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Implement a function to log the total time an actor has been active every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ActiveTimeLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AActiveTimeLoggerActor : public AActor\n{\n    GENERATED_BODY()\n\npublic: \n    AActiveTimeLoggerActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic: \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    float TotalActiveTime;\n    FTimerHandle TimerHandle_LogActiveTime;\n\n    void LogActiveTime();\n};\n```", "cpp_code": "```cpp\n#include \"ActiveTimeLoggerActor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nAActiveTimeLoggerActor::AActiveTimeLoggerActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    TotalActiveTime = 0.0f;\n}\n\nvoid AActiveTimeLoggerActor::BeginPlay()\n{\n    Super::BeginPlay();\n    GetWorld()->GetTimerManager().SetTimer(TimerHandle_LogActiveTime, this, &AActiveTimeLoggerActor::LogActiveTime, 1.0f, true);\n}\n\nvoid AActiveTimeLoggerActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    TotalActiveTime += DeltaTime;\n}\n\nvoid AActiveTimeLoggerActor::LogActiveTime()\n{\n    UE_LOG(LogTemp, Log, TEXT(\"Actor has been active for %f seconds\"), TotalActiveTime);\n}\n```"}
{"requirement": "Bind a function to change the actor's material when 'M' is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ChangeMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMaterialActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    AChangeMaterialActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    UPROPERTY(EditAnywhere)\n    UMaterialInterface* NewMaterial;\n\n    void ChangeMaterial();\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"ConstructorHelpers.h\"\n\nAChangeMaterialActor::AChangeMaterialActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n    if (MeshAsset.Succeeded())\n    {\n        MeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n\n    static ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialAsset(TEXT(\"/Game/Path/To/Your/Material.Material\"));\n    if (MaterialAsset.Succeeded())\n    {\n        NewMaterial = MaterialAsset.Object;\n    }\n}\n\nvoid AChangeMaterialActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AChangeMaterialActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n    PlayerInputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AChangeMaterialActor::ChangeMaterial);\n}\n\nvoid AChangeMaterialActor::ChangeMaterial()\n{\n    if (MeshComponent && NewMaterial)\n    {\n        MeshComponent->SetMaterial(0, NewMaterial);\n    }\n}\n```"}
{"requirement": "Create a component with a BlueprintCallable function to reset a counter to zero.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ResetCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UResetCounterComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:\n    UResetCounterComponent();\n\n    UFUNCTION(BlueprintCallable, Category=\"Counter\")\n    void ResetCounterToZero();\n\nprivate:\n    UPROPERTY()\n    int32 Counter;\n};\n```", "cpp_code": "```cpp\n#include \"ResetCounterComponent.h\"\n\nUResetCounterComponent::UResetCounterComponent()\n{\n    PrimaryComponentTick.bCanEverTick = false;\n    Counter = 0;\n}\n\nvoid UResetCounterComponent::ResetCounterToZero()\n{\n    Counter = 0;\n}\n```"}
{"requirement": "Load a sound cue using ConstructorHelpers and play it in response to an event.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourSoundPlayingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourSoundPlayingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AYourSoundPlayingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category = \"Sound\")\n    void PlaySound();\n\nprivate:\n    UPROPERTY(EditAnywhere, Category = \"Sound\")\n    USoundCue* SoundCue;\n};\n```", "cpp_code": "```cpp\n#include \"YourSoundPlayingActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAYourSoundPlayingActor::AYourSoundPlayingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    static ConstructorHelpers::FObjectFinder<USoundCue> SoundCueObject(TEXT(\"/Game/Audio/YourSoundCue.YourSoundCue\"));\n    if (SoundCueObject.Succeeded())\n    {\n        SoundCue = SoundCueObject.Object;\n    }\n}\n\nvoid AYourSoundPlayingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AYourSoundPlayingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AYourSoundPlayingActor::PlaySound()\n{\n    if (SoundCue)\n    {\n        UGameplayStatics::PlaySoundAtLocation(this, SoundCue, GetActorLocation());\n    }\n}\n```"}
{"requirement": "Create a camera actor that smoothly interpolates its position between two points.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CameraInterpolationActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACameraInterpolationActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    ACameraInterpolationActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n    FVector StartLocation;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n    FVector EndLocation;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n    float InterpolationSpeed;\n\nprivate:\n    FVector CurrentLocation;\n};\n```", "cpp_code": "```cpp\n#include \"CameraInterpolationActor.h\"\n\nACameraInterpolationActor::ACameraInterpolationActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    InterpolationSpeed = 0.5f;\n}\n\nvoid ACameraInterpolationActor::BeginPlay()\n{\n    Super::BeginPlay();\n    CurrentLocation = StartLocation;\n}\n\nvoid ACameraInterpolationActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (!FMath::IsNearlyEqual((CurrentLocation - EndLocation).Size(), 0.0f, KINDA_SMALL_NUMBER))\n    {\n        CurrentLocation = FMath::VInterpTo(CurrentLocation, EndLocation, DeltaTime, InterpolationSpeed);\n        SetActorLocation(CurrentLocation);\n    }\n}\n```"}
{"requirement": "Implement a simple AI that stops moving when close to a specific target.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"AICharacter.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAICharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    AAICharacter();\n\nprotected:\n    virtual void BeginPlay() override;\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(EditAnywhere)\n    float StopDistance;\n\n    UPROPERTY(EditAnywhere)\n    AActor* TargetActor;\n};\n```", "cpp_code": "```cpp\n#include \"AICharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAAICharacter::AAICharacter()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    StopDistance = 100.0f; // Distance at which the AI will stop\n    TargetActor = nullptr; // This should be set in the editor or dynamically\n}\n\nvoid AAICharacter::BeginPlay()\n{\n    Super::BeginPlay();\n    // Additional initialization if needed\n}\n\nvoid AAICharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (TargetActor)\n    {\n        float DistanceToTarget = FVector::Dist(GetActorLocation(), TargetActor->GetActorLocation());\n        if (DistanceToTarget > StopDistance)\n        {\n            FVector Direction = (TargetActor->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n            AddMovementInput(Direction);\n        }\n    }\n}\n```"}
{"requirement": "Bind a function to rotate the actor 90 degrees clockwise when 'R' is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotateActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotateActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ARotateActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Rotate function\n    void RotateActorClockwise();\n\n    // Setup player input\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"RotateActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nARotateActor::ARotateActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ARotateActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ARotateActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\n// Rotate 90 degrees clockwise\nvoid ARotateActor::RotateActorClockwise()\n{\n    FRotator NewRotation = GetActorRotation();\n    NewRotation.Yaw += 90.0f;\n    SetActorRotation(NewRotation);\n}\n\n// Setup player input\nvoid ARotateActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    // Bind the RotateActorClockwise function to the 'R' key\n    PlayerInputComponent->BindAction(\"Rotate\", IE_Pressed, this, &ARotateActor::RotateActorClockwise);\n}\n```"}
{"requirement": "Create a component with a boolean property that toggles between two states on command.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UToggleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUToggleComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Toggles the boolean state\n\tUFUNCTION(BlueprintCallable, Category=\"Toggle\")\n\tvoid ToggleState();\n\n\t// Returns the current state\n\tUFUNCTION(BlueprintCallable, Category=\"Toggle\")\n\tbool GetState() const;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Toggle\")\n\tbool bIsToggled;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleComponent.h\"\n\n// Sets default values for this component's properties\nUToggleComponent::UToggleComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\tbIsToggled = false;\n}\n\n// Called when the game starts\nvoid UToggleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UToggleComponent::ToggleState()\n{\n\tbIsToggled = !bIsToggled;\n}\n\nbool UToggleComponent::GetState() const\n{\n\treturn bIsToggled;\n}\n```"}
{"requirement": "React to OnBeginOverlap by logging the time of collision to the console.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionLoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionLoggingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ACollisionLoggingActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UFUNCTION()\n    void OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionLoggingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nACollisionLoggingActor::ACollisionLoggingActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    MeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionLoggingActor::OnBeginOverlap);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionLoggingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionLoggingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ACollisionLoggingActor::OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n    if(GEngine)\n    {\n        FString CurrentTime = FDateTime::Now().ToString();\n        GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Collision Time: %s\"), *CurrentTime));\n    }\n}\n```"}
{"requirement": "Create an actor that changes its mesh color based on its speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AColorChangingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    UPROPERTY(EditAnywhere, Category=\"Movement\")\n    float SpeedThreshold;\n\n    void UpdateMeshColor();\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAColorChangingActor::AColorChangingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n    if (MeshAsset.Succeeded())\n    {\n        MeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n\n    SpeedThreshold = 100.0f;\n}\n\nvoid AColorChangingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AColorChangingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    UpdateMeshColor();\n}\n\nvoid AColorChangingActor::UpdateMeshColor()\n{\n    FVector Velocity = GetVelocity();\n    float Speed = Velocity.Size();\n\n    UMaterialInstanceDynamic* MaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n    if (MaterialInstance)\n    {\n        FLinearColor NewColor = (Speed > SpeedThreshold) ? FLinearColor::Red : FLinearColor::Blue;\n        MaterialInstance->SetVectorParameterValue(\"BaseColor\", NewColor);\n    }\n}\n```"}
{"requirement": "Implement a UMG widget with a progress bar that updates with actor's health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"HealthWidget.generated.h\"\n\nUCLASS()\nclass AYourGame_API UHealthWidget : public UUserWidget\n{\n    GENERATED_BODY()\n\npublic:\n    UFUNCTION(BlueprintCallable, Category = \"Health\")\n    void UpdateHealthBar(float HealthPercentage);\n\nprotected:\n    UPROPERTY(meta = (BindWidget))\n    class UProgressBar* HealthProgressBar;\n};\n```", "cpp_code": "```cpp\n#include \"HealthWidget.h\"\n#include \"Components/ProgressBar.h\"\n\nvoid UHealthWidget::UpdateHealthBar(float HealthPercentage)\n{\n    if (HealthProgressBar)\n    {\n        HealthProgressBar->SetPercent(HealthPercentage);\n    }\n}\n```"}
{"requirement": "Bind a function to play a sound when the 'S' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"ASoundPlayer.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayer : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ASoundPlayer();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    UFUNCTION()\n    void PlaySound();\n\n    UPROPERTY(EditAnywhere, Category = \"Sound\")\n    USoundCue* SoundCue;\n};\n```", "cpp_code": "```cpp\n#include \"ASoundPlayer.h\"\n#include \"Components/InputComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundPlayer::ASoundPlayer()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASoundPlayer::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ASoundPlayer::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n    PlayerInputComponent->BindAction(\"PlaySound\", IE_Pressed, this, &ASoundPlayer::PlaySound);\n}\n\nvoid ASoundPlayer::PlaySound()\n{\n    if (SoundCue)\n    {\n        UGameplayStatics::PlaySoundAtLocation(this, SoundCue, GetActorLocation());\n    }\n}\n```"}
{"requirement": "Create a component with a function callable from Blueprints to increase a score.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UScoreComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UScoreComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:\n    UScoreComponent();\n\n    UFUNCTION(BlueprintCallable, Category=\"Score\")\n    void IncreaseScore(int32 Amount);\n\n    UPROPERTY(BlueprintReadOnly, Category=\"Score\")\n    int32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"UScoreComponent.h\"\n\nUScoreComponent::UScoreComponent()\n{\n    PrimaryComponentTick.bCanEverTick = false;\n    Score = 0;\n}\n\nvoid UScoreComponent::IncreaseScore(int32 Amount)\n{\n    Score += Amount;\n}\n```"}
{"requirement": "Load a skeletal mesh using ConstructorHelpers and set it to an actor component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"ASkeletalMeshLoaderActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASkeletalMeshLoaderActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    ASkeletalMeshLoaderActor();\n\nprotected:\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Mesh\")\n    USkeletalMeshComponent* SkeletalMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ASkeletalMeshLoaderActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nASkeletalMeshLoaderActor::ASkeletalMeshLoaderActor()\n{\n    PrimaryActorTick.bCanEverTick = false;\n\n    SkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n    RootComponent = SkeletalMeshComponent;\n\n    static ConstructorHelpers::FObjectFinder<USkeletalMesh> SkeletalMeshAsset(TEXT(\"/Game/YourPath/YourSkeletalMesh.YourSkeletalMesh\"));\n    if (SkeletalMeshAsset.Succeeded())\n    {\n        SkeletalMeshComponent->SetSkeletalMesh(SkeletalMeshAsset.Object);\n    }\n}\n```"}
{"requirement": "Create an actor that spawns another actor at its location when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpawnerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpawnerActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ASpawnerActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Setup player input component\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n    // Function to spawn another actor\n    UFUNCTION()\n    void SpawnNewActor();\n\n    // Class of the actor to spawn\n    UPROPERTY(EditAnywhere, Category = \"Spawning\")\n    TSubclassOf<AActor> ActorToSpawn;\n};\n```", "cpp_code": "```cpp\n#include \"SpawnerActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nASpawnerActor::ASpawnerActor()\n{\n     // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n     PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASpawnerActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ASpawnerActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid ASpawnerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    // Bind the SpawnNewActor function to a key press (e.g., the space bar)\n    PlayerInputComponent->BindAction(\"SpawnActor\", IE_Pressed, this, &ASpawnerActor::SpawnNewActor);\n}\n\n// Function to spawn another actor\nvoid ASpawnerActor::SpawnNewActor()\n{\n    if (ActorToSpawn)\n    {\n        FActorSpawnParameters SpawnParams;\n        SpawnParams.Owner = this;\n        SpawnParams.Instigator = GetInstigator();\n\n        // Get the current location and rotation\n        FVector Location = GetActorLocation();\n        FRotator Rotation = GetActorRotation();\n\n        // Spawn the actor\n        GetWorld()->SpawnActor<AActor>(ActorToSpawn, Location, Rotation, SpawnParams);\n    }\n}\n```"}
{"requirement": "Implement a function in an actor to print its current velocity every Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintVelocityActor.generated.h\"\n\nUCLASS()\nclass APrintVelocityActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    APrintVelocityActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"PrintVelocityActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/MovementComponent.h\"\n#include \"Engine/World.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nAPrintVelocityActor::APrintVelocityActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APrintVelocityActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid APrintVelocityActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    FVector Velocity = FVector::ZeroVector;\n    UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(GetRootComponent());\n    if (PrimitiveComponent)\n    {\n        Velocity = PrimitiveComponent->GetComponentVelocity();\n    }\n\n    UE_LOG(LogTemp, Log, TEXT(\"Velocity: %s\"), *Velocity.ToString());\n}\n```"}
{"requirement": "Bind a function to toggle an actor's material between two states with the 'N' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleMaterialActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AToggleMaterialActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    UPROPERTY(EditAnywhere)\n    UMaterialInterface* MaterialOne;\n\n    UPROPERTY(EditAnywhere)\n    UMaterialInterface* MaterialTwo;\n\n    bool bUseMaterialOne;\n\n    void ToggleMaterial();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Components/InputComponent.h\"\n\nAToggleMaterialActor::AToggleMaterialActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n    if (MeshAsset.Succeeded())\n    {\n        MeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n\n    bUseMaterialOne = true;\n}\n\nvoid AToggleMaterialActor::BeginPlay()\n{\n    Super::BeginPlay();\n\n    if (MaterialOne)\n    {\n        MeshComponent->SetMaterial(0, MaterialOne);\n    }\n}\n\nvoid AToggleMaterialActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AToggleMaterialActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    PlayerInputComponent->BindAction(\"ToggleMaterial\", IE_Pressed, this, &AToggleMaterialActor::ToggleMaterial);\n}\n\nvoid AToggleMaterialActor::ToggleMaterial()\n{\n    if (bUseMaterialOne && MaterialTwo)\n    {\n        MeshComponent->SetMaterial(0, MaterialTwo);\n    }\n    else if (!bUseMaterialOne && MaterialOne)\n    {\n        MeshComponent->SetMaterial(0, MaterialOne);\n    }\n    bUseMaterialOne = !bUseMaterialOne;\n}\n```"}
{"requirement": "Create a component with a UPROPERTY(EditAnywhere) to set the actor's maximum speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"MaximumSpeedComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UMaximumSpeedComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:    \n    UMaximumSpeedComponent();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n    float MaxSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MaximumSpeedComponent.h\"\n\nUMaximumSpeedComponent::UMaximumSpeedComponent()\n{\n    PrimaryComponentTick.bCanEverTick = false;\n    MaxSpeed = 600.0f; // Default maximum speed\n}\n\nvoid UMaximumSpeedComponent::BeginPlay()\n{\n    Super::BeginPlay();\n    \n    // Initialization logic if needed\n}\n```"}
{"requirement": "React to OnBeginOverlap by changing the actor's location to a specified point.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AOverlapActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AOverlapActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    UFUNCTION()\n    void OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n    UPROPERTY(EditAnywhere)\n    FVector NewLocation;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nAOverlapActor::AOverlapActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    MeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n    if (MeshAsset.Succeeded())\n    {\n        MeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n\n    NewLocation = FVector(100.0f, 100.0f, 100.0f);\n}\n\nvoid AOverlapActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n    if (OtherActor && (OtherActor != this) && OtherComp)\n    {\n        SetActorLocation(NewLocation);\n    }\n}\n```"}
{"requirement": "Create an actor with a light component that changes intensity over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"LightIntensityChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALightIntensityChanger : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    // Sets default values for this actor's properties\n    ALightIntensityChanger();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UPointLightComponent* PointLight;\n    \n    UPROPERTY(EditAnywhere, Category=\"Light\")\n    float IntensityChangeRate;\n    \n    float TimeElapsed;\n};\n```", "cpp_code": "```cpp\n#include \"LightIntensityChanger.h\"\n\n// Sets default values\nALightIntensityChanger::ALightIntensityChanger()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Create PointLight component and attach it to the root\n    PointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n    RootComponent = PointLight;\n\n    // Initial values\n    IntensityChangeRate = 50.0f;\n    TimeElapsed = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ALightIntensityChanger::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ALightIntensityChanger::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    // Update time elapsed\n    TimeElapsed += DeltaTime;\n\n    // Calculate new intensity\n    float NewIntensity = FMath::Abs(FMath::Sin(TimeElapsed) * IntensityChangeRate);\n\n    // Set the intensity of the light\n    PointLight->SetIntensity(NewIntensity);\n}\n```"}
{"requirement": "Implement a simple AI controller that changes a property when an actor is detected.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ADetectingAIController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADetectingAIController : public AAIController\n{\n    GENERATED_BODY()\n\npublic:\n    ADetectingAIController();\n\nprotected:\n    virtual void BeginPlay() override;\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(EditAnywhere)\n    float DetectionRadius;\n\n    UPROPERTY(EditAnywhere)\n    bool bIsActorDetected;\n\n    void DetectActors();\n};\n```", "cpp_code": "```cpp\n#include \"ADetectingAIController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nADetectingAIController::ADetectingAIController()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    DetectionRadius = 500.0f;\n    bIsActorDetected = false;\n}\n\nvoid ADetectingAIController::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ADetectingAIController::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    DetectActors();\n}\n\nvoid ADetectingAIController::DetectActors()\n{\n    FVector MyLocation = GetPawn()->GetActorLocation();\n    TArray<FOverlapResult> OverlapResults;\n    FCollisionShape CollisionShape;\n    CollisionShape.SetSphere(DetectionRadius);\n\n    bool bHasOverlap = GetWorld()->OverlapMultiByChannel(\n        OverlapResults,\n        MyLocation,\n        FQuat::Identity,\n        ECC_Pawn,\n        CollisionShape\n    );\n\n    if (bHasOverlap)\n    {\n        bIsActorDetected = true;\n    }\n    else\n    {\n        bIsActorDetected = false;\n    }\n\n    // Debug\n    DrawDebugSphere(GetWorld(), MyLocation, DetectionRadius, 24, FColor::Green, false, 1.0f);\n}\n```"}
{"requirement": "Bind a function to log the actor's name when the 'Name' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogActorName.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALogActorName : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ALogActorName();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Function to log actor's name\n    void LogName();\n\n    // Setup player input component\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"LogActorName.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nALogActorName::ALogActorName()\n{\n     // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALogActorName::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ALogActorName::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\n// Function to log actor's name\nvoid ALogActorName::LogName()\n{\n    UE_LOG(LogTemp, Warning, TEXT(\"Actor Name: %s\"), *GetName());\n}\n\n// Setup player input component\nvoid ALogActorName::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n    PlayerInputComponent->BindAction(\"Name\", IE_Pressed, this, &ALogActorName::LogName);\n}\n```"}
{"requirement": "Create a component with a BlueprintCallable function to reset the actor's health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UHealthResetComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UHealthResetComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:    \n    UHealthResetComponent();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    UFUNCTION(BlueprintCallable, Category=\"Health\")\n    void ResetHealth();\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Health\")\n    float DefaultHealth;\n\n    UPROPERTY(VisibleAnywhere, Category=\"Health\")\n    float CurrentHealth;\n};\n```", "cpp_code": "```cpp\n#include \"UHealthResetComponent.h\"\n\nUHealthResetComponent::UHealthResetComponent()\n{\n    PrimaryComponentTick.bCanEverTick = false;\n\n    // Initialize default health value\n    DefaultHealth = 100.0f;\n    CurrentHealth = DefaultHealth;\n}\n\nvoid UHealthResetComponent::BeginPlay()\n{\n    Super::BeginPlay();\n\n    // Initial setup if needed\n    CurrentHealth = DefaultHealth;\n}\n\nvoid UHealthResetComponent::ResetHealth()\n{\n    CurrentHealth = DefaultHealth;\n}\n```"}
{"requirement": "Load a particle system using ConstructorHelpers and play it at the actor's location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"ParticleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AParticleActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AParticleActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere, Category = \"Effects\")\n    UParticleSystemComponent* ParticleSystemComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ParticleActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Particles/ParticleSystem.h\"\n\nAParticleActor::AParticleActor()\n{\n    PrimaryActorTick.bCanEverTick = false;\n\n    ParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystemComponent\"));\n    ParticleSystemComponent->SetupAttachment(RootComponent);\n\n    static ConstructorHelpers::FObjectFinder<UParticleSystem> ParticleAsset(TEXT(\"/Game/Path/To/Your/ParticleSystem.ParticleSystem\"));\n    if (ParticleAsset.Succeeded())\n    {\n        ParticleSystemComponent->SetTemplate(ParticleAsset.Object);\n    }\n}\n\nvoid AParticleActor::BeginPlay()\n{\n    Super::BeginPlay();\n\n    if (ParticleSystemComponent && ParticleSystemComponent->Template)\n    {\n        ParticleSystemComponent->Activate();\n    }\n}\n```"}
{"requirement": "Create an actor that rotates towards a player character smoothly using Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SmoothRotatingActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASmoothRotatingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    ASmoothRotatingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Rotation\")\n    float RotationSpeed;\n\n    AActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"SmoothRotatingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASmoothRotatingActor::ASmoothRotatingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    RotationSpeed = 45.0f; // Default rotation speed in degrees per second\n}\n\nvoid ASmoothRotatingActor::BeginPlay()\n{\n    Super::BeginPlay();\n    \n    // Assume there is only one player controller\n    APlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n    if (PlayerController)\n    {\n        PlayerActor = PlayerController->GetPawn();\n    }\n}\n\nvoid ASmoothRotatingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (PlayerActor)\n    {\n        FVector Direction = PlayerActor->GetActorLocation() - GetActorLocation();\n        FRotator TargetRotation = Direction.Rotation();\n        FRotator CurrentRotation = GetActorRotation();\n        FRotator NewRotation = FMath::RInterpTo(CurrentRotation, TargetRotation, DeltaTime, RotationSpeed);\n        SetActorRotation(NewRotation);\n    }\n}\n```"}
{"requirement": "Implement a UMG widget with a button that teleports the player when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"TeleportPlayerWidget.generated.h\"\n\nUCLASS()\nclass MYGAME_API UTeleportPlayerWidget : public UUserWidget\n{\n    GENERATED_BODY()\n\npublic:\n    UTeleportPlayerWidget(const FObjectInitializer& ObjectInitializer);\n\n    UFUNCTION(BlueprintCallable, Category = \"Teleport\")\n    void OnTeleportButtonClicked();\n\nprivate:\n    UPROPERTY(EditAnywhere, Category = \"Teleport\")\n    FVector TeleportLocation;\n};\n```", "cpp_code": "```cpp\n#include \"TeleportPlayerWidget.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\nUTeleportPlayerWidget::UTeleportPlayerWidget(const FObjectInitializer& ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n    // Set a default teleport location\n    TeleportLocation = FVector(1000.0f, 1000.0f, 300.0f);\n}\n\nvoid UTeleportPlayerWidget::OnTeleportButtonClicked()\n{\n    APlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n    if (PlayerController)\n    {\n        APawn* PlayerPawn = PlayerController->GetPawn();\n        if (PlayerPawn)\n        {\n            PlayerPawn->SetActorLocation(TeleportLocation);\n        }\n    }\n}\n```"}
{"requirement": "Bind a function to toggle an actor's visibility with the 'V' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AToggleVisibilityActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    UFUNCTION()\n    void ToggleVisibility();\n\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerInput.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n    // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n    if (MeshAsset.Succeeded())\n    {\n        MeshComponent->SetStaticMesh(MeshAsset.Object);\n    }\n}\n\n// Called when the game starts or when spawned\nvoid AToggleVisibilityActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    if (PlayerInputComponent)\n    {\n        PlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleVisibilityActor::ToggleVisibility);\n    }\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n    if (MeshComponent)\n    {\n        MeshComponent->SetVisibility(!MeshComponent->IsVisible());\n    }\n}\n```"}
{"requirement": "Create a component with a float property exposed to Blueprints to control brightness.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UBrightnessComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UBrightnessComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:\n    UBrightnessComponent();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Brightness\")\n    float Brightness;\n};\n```", "cpp_code": "```cpp\n#include \"UBrightnessComponent.h\"\n\nUBrightnessComponent::UBrightnessComponent()\n{\n    PrimaryComponentTick.bCanEverTick = false;\n\n    // Initialize Brightness with a default value\n    Brightness = 1.0f;\n}\n\nvoid UBrightnessComponent::BeginPlay()\n{\n    Super::BeginPlay();\n\n    // Additional initialization if needed\n}\n```"}
{"requirement": "React to OnBeginOverlap by playing a random sound from an array.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"SoundOverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundOverlapActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    ASoundOverlapActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n    UBoxComponent* BoxComponent;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n    UAudioComponent* AudioComponent;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n    TArray<USoundCue*> SoundArray;\n\n    UFUNCTION()\n    void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"SoundOverlapActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundOverlapActor::ASoundOverlapActor()\n{\n    PrimaryActorTick.bCanEverTick = false;\n\n    BoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n    RootComponent = BoxComponent;\n    BoxComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n    BoxComponent->OnComponentBeginOverlap.AddDynamic(this, &ASoundOverlapActor::OnOverlapBegin);\n\n    AudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n    AudioComponent->SetupAttachment(RootComponent);\n    AudioComponent->bAutoActivate = false;\n}\n\nvoid ASoundOverlapActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ASoundOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n    if (SoundArray.Num() > 0)\n    {\n        int32 RandomIndex = FMath::RandRange(0, SoundArray.Num() - 1);\n        USoundCue* RandomSound = SoundArray[RandomIndex];\n        if (RandomSound)\n        {\n            AudioComponent->SetSound(RandomSound);\n            AudioComponent->Play();\n        }\n    }\n}\n```"}
{"requirement": "Create an actor with a skeletal mesh that plays an animation on key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"MySkeletalMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMySkeletalMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMySkeletalMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tUAnimSequence* AnimationToPlay;\n\n\tvoid PlayAnimation();\n};\n```", "cpp_code": "```cpp\n#include \"MySkeletalMeshActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAMySkeletalMeshActor::AMySkeletalMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AMySkeletalMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMySkeletalMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input\nvoid AMySkeletalMeshActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"PlayAnimation\", IE_Pressed, this, &AMySkeletalMeshActor::PlayAnimation);\n}\n\n// Play animation function\nvoid AMySkeletalMeshActor::PlayAnimation()\n{\n\tif (AnimationToPlay && SkeletalMeshComponent)\n\t{\n\t\tSkeletalMeshComponent->PlayAnimation(AnimationToPlay, false);\n\t}\n}\n```"}
{"requirement": "Implement a function to log the total distance an actor has moved every second.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceLoggerActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ADistanceLoggerActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    FVector LastLocation;\n    float TotalDistanceMoved;\n    float TimeAccumulator;\n\n    void LogDistance();\n};\n```", "cpp_code": "```cpp\n#include \"DistanceLoggerActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nADistanceLoggerActor::ADistanceLoggerActor()\n{\n    // Set this actor to call Tick() every frame.\n    PrimaryActorTick.bCanEverTick = true;\n    TotalDistanceMoved = 0.0f;\n    TimeAccumulator = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ADistanceLoggerActor::BeginPlay()\n{\n    Super::BeginPlay();\n    LastLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid ADistanceLoggerActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    FVector CurrentLocation = GetActorLocation();\n    float DistanceMoved = FVector::Dist(LastLocation, CurrentLocation);\n    TotalDistanceMoved += DistanceMoved;\n    LastLocation = CurrentLocation;\n\n    TimeAccumulator += DeltaTime;\n    if (TimeAccumulator >= 1.0f)\n    {\n        LogDistance();\n        TimeAccumulator -= 1.0f;\n    }\n}\n\nvoid ADistanceLoggerActor::LogDistance()\n{\n    UE_LOG(LogTemp, Log, TEXT(\"Total Distance Moved: %f\"), TotalDistanceMoved);\n}\n```"}
{"requirement": "Bind a function to change the actor's mesh when the 'M' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AChangeMeshActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AChangeMeshActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    UPROPERTY(EditAnywhere)\n    UStaticMesh* NewMesh;\n\n    void ChangeMesh();\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAChangeMeshActor::AChangeMeshActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> DefaultMesh(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n    if (DefaultMesh.Succeeded())\n    {\n        MeshComponent->SetStaticMesh(DefaultMesh.Object);\n    }\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> FoundNewMesh(TEXT(\"/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere\"));\n    if (FoundNewMesh.Succeeded())\n    {\n        NewMesh = FoundNewMesh.Object;\n    }\n}\n\nvoid AChangeMeshActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AChangeMeshActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AChangeMeshActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n    PlayerInputComponent->BindAction(\"ChangeMesh\", IE_Pressed, this, &AChangeMeshActor::ChangeMesh);\n}\n\nvoid AChangeMeshActor::ChangeMesh()\n{\n    if (NewMesh)\n    {\n        MeshComponent->SetStaticMesh(NewMesh);\n    }\n}\n```"}
{"requirement": "Create a component with a BlueprintCallable function to decrement a counter.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UDecrementCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UDecrementCounterComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:    \n    UDecrementCounterComponent();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Counter\")\n    int32 Counter;\n\n    UFUNCTION(BlueprintCallable, Category=\"Counter\")\n    void DecrementCounter();\n};\n```", "cpp_code": "```cpp\n#include \"UDecrementCounterComponent.h\"\n\nUDecrementCounterComponent::UDecrementCounterComponent()\n{\n    PrimaryComponentTick.bCanEverTick = false;\n    Counter = 0;\n}\n\nvoid UDecrementCounterComponent::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid UDecrementCounterComponent::DecrementCounter()\n{\n    --Counter;\n}\n```"}
{"requirement": "Load a widget blueprint using ConstructorHelpers and display it on the screen.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"WidgetBlueprintLoaderActor.generated.h\"\n\nUCLASS()\nclass AWidgetBlueprintLoaderActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWidgetBlueprintLoaderActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"UI\")\n\tTSubclassOf<UUserWidget> WidgetClass;\n\n\tUUserWidget* WidgetInstance;\n};\n```", "cpp_code": "```cpp\n#include \"WidgetBlueprintLoaderActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Blueprint/UserWidget.h\"\n\nAWidgetBlueprintLoaderActor::AWidgetBlueprintLoaderActor()\n{\n\tstatic ConstructorHelpers::FClassFinder<UUserWidget> WidgetBPClass(TEXT(\"/Game/Path/To/YourWidgetBlueprint\"));\n\tif (WidgetBPClass.Succeeded())\n\t{\n\t\tWidgetClass = WidgetBPClass.Class;\n\t}\n}\n\nvoid AWidgetBlueprintLoaderActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (WidgetClass)\n\t{\n\t\tWidgetInstance = CreateWidget<UUserWidget>(GetWorld(), WidgetClass);\n\t\tif (WidgetInstance)\n\t\t{\n\t\t\tWidgetInstance->AddToViewport();\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that moves towards a target point when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AMovingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    void MoveTowardsTarget();\n\n    UPROPERTY(EditAnywhere)\n    FVector TargetLocation;\n\n    UPROPERTY(EditAnywhere)\n    float MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAMovingActor::AMovingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    MovementSpeed = 100.0f;\n    TargetLocation = FVector(0.0f, 0.0f, 0.0f);\n}\n\nvoid AMovingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AMovingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n    PlayerInputComponent->BindAction(\"MoveToTarget\", IE_Pressed, this, &AMovingActor::MoveTowardsTarget);\n}\n\nvoid AMovingActor::MoveTowardsTarget()\n{\n    FVector CurrentLocation = GetActorLocation();\n    FVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n    FVector NewLocation = CurrentLocation + (Direction * MovementSpeed * GetWorld()->GetDeltaSeconds());\n    SetActorLocation(NewLocation);\n}\n```"}
