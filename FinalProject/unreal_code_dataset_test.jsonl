{"requirement": "Create an actor with a static mesh component that can be changed in the editor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMyStaticMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Mesh\")\n\tUStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Static Mesh Component\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Optionally set a default static mesh\n\t// static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.YourMesh\"));\n\t// if (MeshAsset.Succeeded())\n\t// {\n\t//\t StaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t// }\n}\n\n// Called when the game starts or when spawned\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyStaticMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Implement an actor that rotates continuously around a vertical axis every Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationSpeed = 45.0f; // Degrees per second\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Get current rotation\n\tFRotator CurrentRotation = GetActorRotation();\n\n\t// Calculate new rotation\n\tCurrentRotation.Yaw += RotationSpeed * DeltaTime;\n\n\t// Set the new rotation\n\tSetActorRotation(CurrentRotation);\n}\n```"}
{"requirement": "Create a component with a float property exposed to Blueprints using UPROPERTY(EditAnywhere).", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFloatComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFloatComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Float\")\n\tfloat MyFloat;\n};\n```", "cpp_code": "```cpp\n#include \"UFloatComponent.h\"\n\nUFloatComponent::UFloatComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\t// Initialize the float property\n\tMyFloat = 0.0f;\n}\n\nvoid UFloatComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Custom initialization code can be added here\n}\n```"}
{"requirement": "Bind the 'Space' key to a function that prints 'Jump!' to the log in SetupPlayerInputComponent.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"JumpActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AJumpActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAJumpActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to be called when Space key is pressed\n\tvoid PrintJumpMessage();\n};\n```", "cpp_code": "```cpp\n#include \"JumpActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAJumpActor::AJumpActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AJumpActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AJumpActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid AJumpActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, &AJumpActor::PrintJumpMessage);\n\t}\n}\n\n// Function to be called when Space key is pressed\nvoid AJumpActor::PrintJumpMessage()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Jump!\"));\n}\n```"}
{"requirement": "Implement an actor that moves forward constantly at a speed defined by a UPROPERTY(EditAnywhere).", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MoveSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMoveSpeed = 100.0f; // Default speed\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tFVector NewLocation = GetActorLocation() + GetActorForwardVector() * MoveSpeed * DeltaTime;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a static mesh actor that changes its scale when 'V' is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleChangeActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AScaleChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScaleChangeActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\nprivate:\n\tvoid ChangeScale();\n\n\tFVector OriginalScale;\n\tFVector TargetScale;\n\tbool bIsScaled;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAScaleChangeActor::AScaleChangeActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tOriginalScale = FVector(1.0f, 1.0f, 1.0f);\n\tTargetScale = FVector(2.0f, 2.0f, 2.0f);\n\tbIsScaled = false;\n}\n\nvoid AScaleChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetActorScale3D(OriginalScale);\n}\n\nvoid AScaleChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScaleChangeActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ChangeScale\", IE_Pressed, this, &AScaleChangeActor::ChangeScale);\n}\n\nvoid AScaleChangeActor::ChangeScale()\n{\n\tif (bIsScaled)\n\t{\n\t\tSetActorScale3D(OriginalScale);\n\t}\n\telse\n\t{\n\t\tSetActorScale3D(TargetScale);\n\t}\n\tbIsScaled = !bIsScaled;\n}\n```"}
{"requirement": "React to OnBeginOverlap in an actor by printing the name of the overlapped object.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapActor::AOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set up overlap event\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tFString ActorName = OtherActor->GetName();\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, ActorName);\n\t}\n}\n```"}
{"requirement": "Create a component with a BlueprintCallable function that doubles a given integer.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UDoubleIntComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UDoubleIntComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUDoubleIntComponent();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Math\")\n\tint32 DoubleInteger(int32 InputValue) const;\n};\n```", "cpp_code": "```cpp\n#include \"UDoubleIntComponent.h\"\n\nUDoubleIntComponent::UDoubleIntComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nint32 UDoubleIntComponent::DoubleInteger(int32 InputValue) const\n{\n\treturn InputValue * 2;\n}\n```"}
{"requirement": "Implement an AI Controller that changes a boolean property when a target is sensed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"Perception/AIPerceptionComponent.h\"\n#include \"AEnemyAIController.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AEnemyAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAEnemyAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"AI\", meta = (AllowPrivateAccess = \"true\"))\n\tbool bIsTargetSensed;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"AI\", meta = (AllowPrivateAccess = \"true\"))\n\tUAIPerceptionComponent* AIPerceptionComponent;\n\n\tUFUNCTION()\n\tvoid OnTargetSensed(AActor* Actor, FAIStimulus Stimulus);\n};\n```", "cpp_code": "```cpp\n#include \"AEnemyAIController.h\"\n#include \"Perception/AISenseConfig_Sight.h\"\n#include \"Perception/AIPerceptionComponent.h\"\n#include \"Perception/AIPerceptionStimuliSourceComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nAEnemyAIController::AEnemyAIController()\n{\n\tAIPerceptionComponent = CreateDefaultSubobject<UAIPerceptionComponent>(TEXT(\"AIPerceptionComponent\"));\n\tSetPerceptionComponent(*AIPerceptionComponent);\n\n\tUAISenseConfig_Sight* SightConfig = CreateDefaultSubobject<UAISenseConfig_Sight>(TEXT(\"SightConfig\"));\n\tif(SightConfig)\n\t{\n\t\tSightConfig->SightRadius = 500.0f;\n\t\tSightConfig->LoseSightRadius = 600.0f;\n\t\tSightConfig->PeripheralVisionAngleDegrees = 90.0f;\n\t\tSightConfig->SetMaxAge(5.0f);\n\t\tAIPerceptionComponent->ConfigureSense(*SightConfig);\n\t\tAIPerceptionComponent->SetDominantSense(SightConfig->GetSenseImplementation());\n\t}\n\n\tAIPerceptionComponent->OnTargetPerceptionUpdated.AddDynamic(this, &AEnemyAIController::OnTargetSensed);\n\n\tbIsTargetSensed = false;\n}\n\nvoid AEnemyAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AEnemyAIController::OnTargetSensed(AActor* Actor, FAIStimulus Stimulus)\n{\n\tbIsTargetSensed = Stimulus.WasSuccessfullySensed();\n}\n```"}
{"requirement": "Load a static mesh asset using ConstructorHelpers in the constructor of an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UStaticMeshComponent.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyStaticMeshActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"ConstructorHelpers.h\"\n\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the Static Mesh Component\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Load a static mesh asset using ConstructorHelpers\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.YourMeshName\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n```"}
{"requirement": "Bind the 'F' key to a function that toggles visibility of the actor in SetupPlayerInputComponent.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleVisibilityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to toggle visibility\n\tvoid ToggleVisibility();\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\t// Toggle the visibility of the actor\n\tSetActorHiddenInGame(!bHidden);\n}\n\nvoid AToggleVisibilityActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the 'F' key to toggle visibility\n\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleVisibilityActor::ToggleVisibility);\n}\n```"}
{"requirement": "Create an actor that moves up and down smoothly using a sine wave pattern every Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SineWaveMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ASineWaveMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASineWaveMover();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Initial location of the actor\n\tFVector InitialLocation;\n\n\t// Frequency of the sine wave\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Frequency;\n\n\t// Amplitude of the sine wave\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Amplitude;\n\n\t// Elapsed time\n\tfloat ElapsedTime;\n};\n```", "cpp_code": "```cpp\n#include \"SineWaveMover.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nASineWaveMover::ASineWaveMover()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Set default values\n\tFrequency = 1.0f;\n\tAmplitude = 100.0f;\n\tElapsedTime = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASineWaveMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Store the initial location\n\tInitialLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid ASineWaveMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Increase the elapsed time\n\tElapsedTime += DeltaTime;\n\n\t// Calculate new Z position using sine wave pattern\n\tfloat NewZ = InitialLocation.Z + Amplitude * FMath::Sin(Frequency * ElapsedTime);\n\n\t// Update actor's location\n\tSetActorLocation(FVector(InitialLocation.X, InitialLocation.Y, NewZ));\n}\n```"}
{"requirement": "Expose a UPROPERTY(EditAnywhere) float that controls the actor's rotation speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotationSpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotationSpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotationSpeedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotationSpeedActor.h\"\n\nARotationSpeedActor::ARotationSpeedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationSpeed = 45.0f; // Default rotation speed\n}\n\nvoid ARotationSpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotationSpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Example rotation logic\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a BlueprintAssignable delegate in a component that broadcasts on a specific condition.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UExampleComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnConditionMet);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UExampleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUExampleComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Events\")\n\tFOnConditionMet OnConditionMet;\n\nprivate:\n\tvoid CheckCondition();\n\n\tbool bConditionMet;\n};\n```", "cpp_code": "```cpp\n#include \"UExampleComponent.h\"\n\nUExampleComponent::UExampleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tbConditionMet = false;\n}\n\nvoid UExampleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UExampleComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tCheckCondition();\n}\n\nvoid UExampleComponent::CheckCondition()\n{\n\tif (!bConditionMet) // Replace this with your actual condition\n\t{\n\t\tbConditionMet = true;\n\t\tOnConditionMet.Broadcast();\n\t}\n}\n```"}
{"requirement": "Create a visible actor with a mesh and a light component that can be toggled on and off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ALightToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALightToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tALightToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUPointLightComponent* LightComponent;\n\n\tUFUNCTION()\n\tvoid ToggleLight();\n};\n```", "cpp_code": "```cpp\n#include \"ALightToggleActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nALightToggleActor::ALightToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tLightComponent = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"LightComponent\"));\n\tLightComponent->SetupAttachment(RootComponent);\n\tLightComponent->SetVisibility(true);\n}\n\nvoid ALightToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALightToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ALightToggleActor::ToggleLight()\n{\n\tif (LightComponent)\n\t{\n\t\tLightComponent->ToggleVisibility();\n\t}\n}\n```"}
{"requirement": "Bind a function to log 'Hello World' when the 'H' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AHKeyLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AHKeyLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAHKeyLogger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid LogHelloWorld();\n};\n```", "cpp_code": "```cpp\n#include \"AHKeyLogger.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nAHKeyLogger::AHKeyLogger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AHKeyLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHKeyLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHKeyLogger::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"LogHelloWorld\", IE_Pressed, this, &AHKeyLogger::LogHelloWorld);\n\t}\n}\n\nvoid AHKeyLogger::LogHelloWorld()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Hello World\"));\n}\n```"}
{"requirement": "Implement an actor that changes color randomly every second using Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARandomColorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n\tfloat TimeSinceLastColorChange;\n\n\tvoid ChangeColor();\n};\n```", "cpp_code": "```cpp\n#include \"RandomColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nARandomColorActor::ARandomColorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tTimeSinceLastColorChange = 0.0f;\n}\n\nvoid ARandomColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARandomColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeSinceLastColorChange += DeltaTime;\n\n\tif (TimeSinceLastColorChange >= 1.0f)\n\t{\n\t\tChangeColor();\n\t\tTimeSinceLastColorChange = 0.0f;\n\t}\n}\n\nvoid ARandomColorActor::ChangeColor()\n{\n\tUMaterialInstanceDynamic* DynMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\tif (DynMaterial)\n\t{\n\t\tFLinearColor RandomColor = FLinearColor::MakeRandomColor();\n\t\tDynMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), RandomColor);\n\t}\n}\n```"}
{"requirement": "Create a component with a boolean property that controls visibility and is exposed to Blueprints.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"MyVisibilityComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass UMyVisibilityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMyVisibilityComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Visibility\")\n\tvoid SetVisibility(bool bNewVisibility);\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Visibility\")\n\tbool bIsVisible;\n};\n```", "cpp_code": "```cpp\n#include \"MyVisibilityComponent.h\"\n\nUMyVisibilityComponent::UMyVisibilityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\tbIsVisible = true;\n}\n\nvoid UMyVisibilityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Initially set visibility based on bIsVisible\n\tSetVisibility(bIsVisible);\n}\n\nvoid UMyVisibilityComponent::SetVisibility(bool bNewVisibility)\n{\n\tbIsVisible = bNewVisibility;\n\t// Assuming the component is attached to an actor with a mesh\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tif (UStaticMeshComponent* MeshComp = Owner->FindComponentByClass<UStaticMeshComponent>())\n\t\t{\n\t\t\tMeshComp->SetVisibility(bIsVisible);\n\t\t}\n\t}\n}\n```"}
{"requirement": "React to OnBeginOverlap by increasing a score integer in the player character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyOverlapActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n\nUCLASS()\nclass MYGAME_API AMyPlayerCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyPlayerCharacter();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Score\")\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"MyOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"MyPlayerCharacter.h\"\n#include \"Engine/Engine.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyOverlapActor::AMyOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tMeshComponent->SetCollisionObjectType(ECollisionChannel::ECC_WorldDynamic);\n\tMeshComponent->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);\n\tMeshComponent->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Overlap);\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyOverlapActor::OnOverlapBegin);\n}\n\nvoid AMyOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (AMyPlayerCharacter* PlayerCharacter = Cast<AMyPlayerCharacter>(OtherActor))\n\t{\n\t\tPlayerCharacter->Score++;\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Score: %d\"), PlayerCharacter->Score));\n\t\t}\n\t}\n}\n\nAMyPlayerCharacter::AMyPlayerCharacter()\n{\n\tScore = 0;\n}\n```"}
{"requirement": "Load a sound asset using ConstructorHelpers and play it when a function is called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"SoundPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundPlayerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Function to play the sound\n\tUFUNCTION(BlueprintCallable, Category=\"Sound\")\n\tvoid PlaySound();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Sound\")\n\tUSoundCue* SoundCue;\n\n\tUPROPERTY()\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SoundPlayerActor.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Components/AudioComponent.h\"\n\nASoundPlayerActor::ASoundPlayerActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// Initialize Audio Component\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->bAutoActivate = false; // Don't play the sound immediately\n\tRootComponent = AudioComponent;\n\n\t// Find SoundCue asset\n\tstatic ConstructorHelpers::FObjectFinder<USoundCue> SoundCueObject(TEXT(\"/Game/Audio/YourSoundCue.YourSoundCue\"));\n\tif (SoundCueObject.Succeeded())\n\t{\n\t\tSoundCue = SoundCueObject.Object;\n\t\tAudioComponent->SetSound(SoundCue);\n\t}\n}\n\nvoid ASoundPlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundPlayerActor::PlaySound()\n{\n\tif (AudioComponent && SoundCue)\n\t{\n\t\tAudioComponent->Play();\n\t}\n}\n```"}
{"requirement": "Create an actor with a movable component that moves forward when 'W' is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"MovableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMovableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUCharacterMovementComponent* MovementComponent;\n\n\tvoid MoveForward(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"MovableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAMovableActor::AMovableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMovementComponent = CreateDefaultSubobject<UCharacterMovementComponent>(TEXT(\"MovementComponent\"));\n\tMovementComponent->SetupAttachment(RootComponent);\n}\n\nvoid AMovableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMovableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMovableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &AMovableActor::MoveForward);\n}\n\nvoid AMovableActor::MoveForward(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tFVector Direction = GetActorForwardVector();\n\t\tAddActorLocalOffset(Direction * Value);\n\t}\n}\n```"}
{"requirement": "Implement a static mesh actor that changes material when overlapping with another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMaterialOnOverlap.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMaterialOnOverlap : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAChangeMaterialOnOverlap();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* OriginalMaterial;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* OverlappedMaterial;\n\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* CollisionComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialOnOverlap.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAChangeMaterialOnOverlap::AChangeMaterialOnOverlap()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set up the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Load a static mesh for the component\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Create and set up the collision component\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tCollisionComponent->SetupAttachment(RootComponent);\n\tCollisionComponent->SetBoxExtent(FVector(50.f, 50.f, 50.f));\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AChangeMaterialOnOverlap::OnOverlapBegin);\n\n\t// Load materials\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> OriginalMat(TEXT(\"/Game/StarterContent/Materials/M_Brick_Clay_Old.M_Brick_Clay_Old\"));\n\tif (OriginalMat.Succeeded())\n\t{\n\t\tOriginalMaterial = OriginalMat.Object;\n\t\tMeshComponent->SetMaterial(0, OriginalMaterial);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> OverlappedMat(TEXT(\"/Game/StarterContent/Materials/M_Metal_Burnished_Steel.M_Metal_Burnished_Steel\"));\n\tif (OverlappedMat.Succeeded())\n\t{\n\t\tOverlappedMaterial = OverlappedMat.Object;\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AChangeMaterialOnOverlap::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AChangeMaterialOnOverlap::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialOnOverlap::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tMeshComponent->SetMaterial(0, OverlappedMaterial);\n\t}\n}\n```"}
{"requirement": "Create a component with a BlueprintCallable function to reset its position to the origin.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UResetPositionComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UResetPositionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUResetPositionComponent();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Position\")\n\tvoid ResetPositionToOrigin();\n};\n```", "cpp_code": "```cpp\n#include \"UResetPositionComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUResetPositionComponent::UResetPositionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UResetPositionComponent::ResetPositionToOrigin()\n{\n\tif(AActor* Owner = GetOwner())\n\t{\n\t\tOwner->SetActorLocation(FVector::ZeroVector);\n\t}\n}\n```"}
{"requirement": "Bind 'P' key to toggle between two different camera perspectives in SetupPlayerInputComponent.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"CameraToggleCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ACameraToggleCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tACameraToggleCharacter();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUCameraComponent* FirstPersonCameraComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUCameraComponent* ThirdPersonCameraComponent;\n\n\tbool bIsFirstPersonView;\n\n\tvoid ToggleCameraPerspective();\n};\n```", "cpp_code": "```cpp\n#include \"CameraToggleCharacter.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n\nACameraToggleCharacter::ACameraToggleCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tFirstPersonCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FirstPersonCamera\"));\n\tFirstPersonCameraComponent->SetupAttachment(GetMesh());\n\tFirstPersonCameraComponent->bUsePawnControlRotation = true;\n\n\tThirdPersonCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"ThirdPersonCamera\"));\n\tThirdPersonCameraComponent->SetupAttachment(RootComponent);\n\tThirdPersonCameraComponent->bUsePawnControlRotation = true;\n\n\tbIsFirstPersonView = true;\n\tThirdPersonCameraComponent->Deactivate();\n}\n\nvoid ACameraToggleCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleCamera\", IE_Pressed, this, &ACameraToggleCharacter::ToggleCameraPerspective);\n}\n\nvoid ACameraToggleCharacter::ToggleCameraPerspective()\n{\n\tif (bIsFirstPersonView)\n\t{\n\t\tFirstPersonCameraComponent->Deactivate();\n\t\tThirdPersonCameraComponent->Activate();\n\t}\n\telse\n\t{\n\t\tThirdPersonCameraComponent->Deactivate();\n\t\tFirstPersonCameraComponent->Activate();\n\t}\n\tbIsFirstPersonView = !bIsFirstPersonView;\n}\n```"}
{"requirement": "Create an actor that scales its mesh up and down over time using Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tfloat RunningTime;\n\tfloat ScaleFactor;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRunningTime = 0.f;\n\tScaleFactor = 1.f;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRunningTime += DeltaTime;\n\tScaleFactor = 1.0f + FMath::Sin(RunningTime) * 0.5f;\n\tMeshComponent->SetWorldScale3D(FVector(ScaleFactor));\n}\n```"}
{"requirement": "Implement a UMG widget with a button that closes the game when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UQuitGameWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UQuitGameWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tvirtual void NativeConstruct() override;\n\nprotected:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UButton* QuitButton;\n\n\tUFUNCTION()\n\tvoid OnQuitButtonClicked();\n};\n```", "cpp_code": "```cpp\n#include \"UQuitGameWidget.h\"\n#include \"Components/Button.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nvoid UQuitGameWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\n\tif (QuitButton)\n\t{\n\t\tQuitButton->OnClicked.AddDynamic(this, &UQuitGameWidget::OnQuitButtonClicked);\n\t}\n}\n\nvoid UQuitGameWidget::OnQuitButtonClicked()\n{\n\tif (UWorld* World = GetWorld())\n\t{\n\t\tUGameplayStatics::SetGamePaused(World, false);\n\t\tWorld->GetFirstPlayerController()->ConsoleCommand(\"quit\");\n\t}\n}\n```"}
{"requirement": "Create an actor that spawns a particle effect at its location on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ParticleEffectActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AParticleEffectActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAParticleEffectActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Particle system to spawn\n\tUPROPERTY(EditAnywhere, Category=\"Effects\")\n\tUParticleSystem* ParticleEffect;\n\n\t// Function to spawn particle effect\n\tUFUNCTION()\n\tvoid SpawnParticleEffect();\n\n\t// Setup player input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ParticleEffectActor.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAParticleEffectActor::AParticleEffectActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AParticleEffectActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AParticleEffectActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input\nvoid AParticleEffectActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"SpawnParticle\", IE_Pressed, this, &AParticleEffectActor::SpawnParticleEffect);\n}\n\n// Function to spawn particle effect\nvoid AParticleEffectActor::SpawnParticleEffect()\n{\n\tif (ParticleEffect)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ParticleEffect, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Implement a function callable from Blueprints that logs the actor's current location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogActorLocation.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ALogActorLocation : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALogActorLocation();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Logging\")\n\tvoid LogCurrentLocation();\n};\n```", "cpp_code": "```cpp\n#include \"LogActorLocation.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nALogActorLocation::ALogActorLocation()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALogActorLocation::LogCurrentLocation()\n{\n\tFVector Location = GetActorLocation();\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor's current location: %s\"), *Location.ToString());\n}\n```"}
{"requirement": "Bind a function to toggle an actor's collision enabled state with the 'C' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleCollisionActor.generated.h\"\n\nUCLASS()\nclass AToggleCollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleCollisionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ToggleCollision();\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMesh;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleCollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nAToggleCollisionActor::AToggleCollisionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMesh\"));\n\tRootComponent = StaticMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMesh->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AToggleCollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleCollisionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleCollisionActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleCollision\", IE_Pressed, this, &AToggleCollisionActor::ToggleCollision);\n}\n\nvoid AToggleCollisionActor::ToggleCollision()\n{\n\tif (StaticMesh->GetCollisionEnabled() == ECollisionEnabled::NoCollision)\n\t{\n\t\tStaticMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\t}\n\telse\n\t{\n\t\tStaticMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t}\n}\n```"}
{"requirement": "Create a component with a BlueprintAssignable delegate that triggers on a specific event.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UEventTriggerComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnEventTriggered);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UEventTriggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUEventTriggerComponent();\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Events\")\n\tFOnEventTriggered OnEventTriggered;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvoid TriggerEvent();\n};\n```", "cpp_code": "```cpp\n#include \"UEventTriggerComponent.h\"\n\nUEventTriggerComponent::UEventTriggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UEventTriggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UEventTriggerComponent::TriggerEvent()\n{\n\tOnEventTriggered.Broadcast();\n}\n```"}
{"requirement": "Implement an actor with a skeletal mesh and play an animation montage on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Animation/AnimMontage.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"AnimationMontageActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AAnimationMontageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAnimationMontageActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta=(AllowPrivateAccess=\"true\"))\n\tUSkeletalMeshComponent* SkeletalMesh;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Animation\", meta=(AllowPrivateAccess=\"true\"))\n\tUAnimMontage* AnimationMontage;\n};\n```", "cpp_code": "```cpp\n#include \"AnimationMontageActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAAnimationMontageActor::AAnimationMontageActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSkeletalMesh = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMesh\"));\n\tRootComponent = SkeletalMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<USkeletalMesh> SkeletalMeshAsset(TEXT(\"/Game/YourPath/YourSkeletalMesh.YourSkeletalMesh\"));\n\tif (SkeletalMeshAsset.Succeeded())\n\t{\n\t\tSkeletalMesh->SetSkeletalMesh(SkeletalMeshAsset.Object);\n\t}\n\n\tUBoxComponent* CollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionBox\"));\n\tCollisionBox->SetupAttachment(RootComponent);\n\tCollisionBox->SetBoxExtent(FVector(100.f));\n\tCollisionBox->OnComponentBeginOverlap.AddDynamic(this, &AAnimationMontageActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UAnimMontage> MontageAsset(TEXT(\"/Game/YourPath/YourAnimMontage.YourAnimMontage\"));\n\tif (MontageAsset.Succeeded())\n\t{\n\t\tAnimationMontage = MontageAsset.Object;\n\t}\n}\n\nvoid AAnimationMontageActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAnimationMontageActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AAnimationMontageActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (AnimationMontage && SkeletalMesh)\n\t{\n\t\tUAnimInstance* AnimInstance = SkeletalMesh->GetAnimInstance();\n\t\tif (AnimInstance)\n\t\t{\n\t\t\tAnimInstance->Montage_Play(AnimationMontage);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Load a material asset using ConstructorHelpers and apply it to a mesh component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UMyMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AUMyMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAUMyMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"UMyMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAUMyMeshActor::AUMyMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Load and apply the material\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> Material(TEXT(\"/Game/Path/To/Your/Material.YourMaterial\"));\n\tif (Material.Succeeded())\n\t{\n\t\tMeshComponent->SetMaterial(0, Material.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AUMyMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AUMyMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that follows a simple AI behavior tree to move between waypoints.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AIWaypointActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAIWaypointActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAAIWaypointActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tTArray<AActor*> Waypoints;\n\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tfloat MovementSpeed;\n\nprivate:\n\tint32 CurrentWaypointIndex;\n};\n```", "cpp_code": "```cpp\n#include \"AIWaypointActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAAIWaypointActor::AAIWaypointActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementSpeed = 200.f;\n\tCurrentWaypointIndex = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AAIWaypointActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Waypoints.Num() > 0)\n\t{\n\t\tSetActorLocation(Waypoints[CurrentWaypointIndex]->GetActorLocation());\n\t}\n}\n\n// Called every frame\nvoid AAIWaypointActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (Waypoints.Num() == 0)\n\t{\n\t\treturn;\n\t}\n\n\tAActor* CurrentWaypoint = Waypoints[CurrentWaypointIndex];\n\tFVector Direction = (CurrentWaypoint->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n\tFVector NewLocation = GetActorLocation() + Direction * MovementSpeed * DeltaTime;\n\tSetActorLocation(NewLocation);\n\n\tfloat DistanceToWaypoint = FVector::Dist(GetActorLocation(), CurrentWaypoint->GetActorLocation());\n\tif (DistanceToWaypoint < 100.f)\n\t{\n\t\tCurrentWaypointIndex = (CurrentWaypointIndex + 1) % Waypoints.Num();\n\t}\n}\n```"}
{"requirement": "Bind 'R' key to reset an actor's location to its initial position.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResettableActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AResettableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAResettableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to reset the actor's location\n\tvoid ResetLocation();\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Initial location of the actor\n\tFVector InitialLocation;\n};\n```", "cpp_code": "```cpp\n#include \"ResettableActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAResettableActor::AResettableActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AResettableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Store the initial location\n\tInitialLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid AResettableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResettableActor::ResetLocation()\n{\n\tSetActorLocation(InitialLocation);\n}\n\nvoid AResettableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the R key to ResetLocation function\n\tPlayerInputComponent->BindAction(\"ResetLocation\", IE_Pressed, this, &AResettableActor::ResetLocation);\n}\n```"}
{"requirement": "Implement a component with a float property to control the intensity of a light.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULightIntensityComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULightIntensityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tULightIntensityComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light\")\n\tfloat LightIntensity;\n};\n```", "cpp_code": "```cpp\n#include \"ULightIntensityComponent.h\"\n\nULightIntensityComponent::ULightIntensityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\t// Default value for light intensity\n\tLightIntensity = 1000.0f;\n}\n\nvoid ULightIntensityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// You can initialize or modify the light intensity here if needed\n}\n```"}
{"requirement": "Create a rotating actor that changes its rotation speed with a UPROPERTY(metadata=ClampMin).", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(ClampMin=\"0.0\"))\n\tfloat RotationSpeed;\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRotationSpeed = 100.0f; // Default rotation speed\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "React to OnBeginOverlap by changing the actor's mesh to a different one.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMesh* NewMesh;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\tStaticMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (NewMesh)\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(NewMesh);\n\t}\n}\n```"}
{"requirement": "Create a UMG widget with a text block that updates with the player's score.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"PlayerScoreWidget.generated.h\"\n\nUCLASS()\nclass MYGAME_API UPlayerScoreWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPlayerScoreWidget(const FObjectInitializer& ObjectInitializer);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid UpdateScore(int32 NewScore);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UTextBlock* ScoreTextBlock;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerScoreWidget.h\"\n#include \"Components/TextBlock.h\"\n\nUPlayerScoreWidget::UPlayerScoreWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UPlayerScoreWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\t// Initial setup if needed\n}\n\nvoid UPlayerScoreWidget::UpdateScore(int32 NewScore)\n{\n\tif (ScoreTextBlock)\n\t{\n\t\tScoreTextBlock->SetText(FText::AsNumber(NewScore));\n\t}\n}\n```"}
{"requirement": "Implement a function in an actor to print its velocity every Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintVelocityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APrintVelocityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPrintVelocityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"PrintVelocityActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/MovementComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAPrintVelocityActor::APrintVelocityActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid APrintVelocityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APrintVelocityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector Velocity = GetVelocity();\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor Velocity: %s\"), *Velocity.ToString());\n}\n```"}
{"requirement": "Bind a function to log the actor's forward vector when 'V' is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogForwardVectorActor.generated.h\"\n\nUCLASS()\nclass ALogForwardVectorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALogForwardVectorActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to log the forward vector\n\tvoid LogForwardVector();\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"LogForwardVectorActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nALogForwardVectorActor::ALogForwardVectorActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALogForwardVectorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALogForwardVectorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid ALogForwardVectorActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"LogForwardVector\", IE_Pressed, this, &ALogForwardVectorActor::LogForwardVector);\n}\n\n// Function to log the forward vector\nvoid ALogForwardVectorActor::LogForwardVector()\n{\n\tFVector ForwardVector = GetActorForwardVector();\n\tUE_LOG(LogTemp, Log, TEXT(\"Forward Vector: %s\"), *ForwardVector.ToString());\n}\n```"}
{"requirement": "Create a component with a BlueprintCallable function to set a new color on a mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UColorChangerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UColorChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUColorChangerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION(BlueprintCallable, Category=\"Mesh\")\n\tvoid SetMeshColor(FLinearColor NewColor);\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"UColorChangerComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nUColorChangerComponent::UColorChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\t// Find and attach the static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComponent->SetupAttachment(this);\n}\n\nvoid UColorChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UColorChangerComponent::SetMeshColor(FLinearColor NewColor)\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Load a texture asset using ConstructorHelpers and apply it to a material dynamically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UTextureLoaderActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AUTextureLoaderActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAUTextureLoaderActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* BaseMaterial;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"UTextureLoaderActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAUTextureLoaderActor::AUTextureLoaderActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/Path/To/Your/Mesh.Mesh'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialAsset(TEXT(\"Material'/Game/Path/To/Your/Material.Material'\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tBaseMaterial = MaterialAsset.Object;\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UTexture> TextureAsset(TEXT(\"Texture2D'/Game/Path/To/Your/Texture.Texture'\"));\n\tif (TextureAsset.Succeeded())\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(BaseMaterial, this);\n\t\tDynamicMaterialInstance->SetTextureParameterValue(FName(\"TextureParameterName\"), TextureAsset.Object);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\nvoid AUTextureLoaderActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n```"}
{"requirement": "Create an actor that rotates towards a target point over time using Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tFVector TargetPoint;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationSpeed = 45.0f; // Default speed of rotation in degrees per second\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator CurrentRotation = GetActorRotation();\n\tFVector Direction = TargetPoint - GetActorLocation();\n\tDirection.Z = 0; // Ignore Z axis for 2D rotation\n\tDirection.Normalize();\n\n\tFRotator TargetRotation = UKismetMathLibrary::MakeRotFromX(Direction);\n\tFRotator NewRotation = FMath::RInterpConstantTo(CurrentRotation, TargetRotation, DeltaTime, RotationSpeed);\n\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a simple AI Controller that moves an NPC character towards the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"GameFramework/Character.h\"\n#include \"AAICharacterController.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AAICharacterController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAICharacterController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAPawn* PlayerPawn;\n};\n```", "cpp_code": "```cpp\n#include \"AAICharacterController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Character.h\"\n\nAAICharacterController::AAICharacterController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AAICharacterController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid AAICharacterController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerPawn)\n\t{\n\t\tMoveToActor(PlayerPawn, 5.0f);\n\t}\n}\n```"}
{"requirement": "Bind a function to toggle an actor's physics simulation with the 'P' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TogglePhysicsActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATogglePhysicsActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATogglePhysicsActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid TogglePhysics();\n};\n```", "cpp_code": "```cpp\n#include \"TogglePhysicsActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nATogglePhysicsActor::ATogglePhysicsActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/YourPath/YourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ATogglePhysicsActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATogglePhysicsActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATogglePhysicsActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"TogglePhysics\", IE_Pressed, this, &ATogglePhysicsActor::TogglePhysics);\n}\n\nvoid ATogglePhysicsActor::TogglePhysics()\n{\n\tif (MeshComponent)\n\t{\n\t\tbool bIsSimulating = MeshComponent->IsSimulatingPhysics();\n\t\tMeshComponent->SetSimulatePhysics(!bIsSimulating);\n\t}\n}\n```"}
{"requirement": "Create a component with a UPROPERTY(EditAnywhere) to set an actor's initial health value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"HealthComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UHealthComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUHealthComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Actor's initial health value\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat InitialHealth;\n};\n```", "cpp_code": "```cpp\n#include \"HealthComponent.h\"\n\n// Sets default values for this component's properties\nUHealthComponent::UHealthComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame. You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\t// Initialize the default health value\n\tInitialHealth = 100.0f;\n}\n\n// Called when the game starts\nvoid UHealthComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// You can initialize or modify InitialHealth here if needed\n}\n```"}
{"requirement": "React to OnBeginOverlap by playing a specific sound at the actor's location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"ASoundOverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASoundOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(VisibleAnywhere, Category = \"Audio\")\n\tUAudioComponent* AudioComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Audio\")\n\tUSoundCue* SoundToPlay;\n\n\tUPROPERTY(VisibleAnywhere, Category = \"Collision\")\n\tUBoxComponent* BoxComponent;\n\n\tUFUNCTION()\n\tvoid OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"ASoundOverlapActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundOverlapActor::ASoundOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tBoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tRootComponent = BoxComponent;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n\tAudioComponent->bAutoActivate = false;\n\n\tBoxComponent->OnComponentBeginOverlap.AddDynamic(this, &ASoundOverlapActor::OnBeginOverlap);\n}\n\nvoid ASoundOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundOverlapActor::OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif(SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create an actor with a camera component that follows the player character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CameraFollowerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACameraFollowerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACameraFollowerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The camera component that will follow the player\n\tUPROPERTY(VisibleAnywhere)\n\tUCameraComponent* CameraComponent;\n\n\t// The player character the camera will follow\n\tAPawn* PlayerCharacter;\n\n\t// Function to update the camera position\n\tvoid UpdateCameraPosition();\n};\n```", "cpp_code": "```cpp\n#include \"CameraFollowerActor.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nACameraFollowerActor::ACameraFollowerActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the camera component\n\tCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"CameraComponent\"));\n\tRootComponent = CameraComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ACameraFollowerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Get the player character\n\tPlayerCharacter = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\n// Called every frame\nvoid ACameraFollowerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update the camera position to follow the player\n\tUpdateCameraPosition();\n}\n\n// Function to update the camera position\nvoid ACameraFollowerActor::UpdateCameraPosition()\n{\n\tif (PlayerCharacter)\n\t{\n\t\tFVector PlayerLocation = PlayerCharacter->GetActorLocation();\n\t\t// Simple follow logic (can be expanded with smoothing, offsets, etc.)\n\t\tSetActorLocation(PlayerLocation);\n\t}\n}\n```"}
{"requirement": "Implement a function that prints the actor's rotation to the console when called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintRotationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API APrintRotationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPrintRotationActor();\n\n\t// Function to print the actor's rotation\n\tUFUNCTION(BlueprintCallable, Category = \"Debug\")\n\tvoid PrintRotation() const;\n};\n```", "cpp_code": "```cpp\n#include \"PrintRotationActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n\nAPrintRotationActor::APrintRotationActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APrintRotationActor::PrintRotation() const\n{\n\tFRotator ActorRotation = GetActorRotation();\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor Rotation: Pitch=%f, Yaw=%f, Roll=%f\"), ActorRotation.Pitch, ActorRotation.Yaw, ActorRotation.Roll);\n}\n```"}
{"requirement": "Bind a function to log the actor's distance from the origin when 'D' is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceLoggerActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADistanceLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADistanceLoggerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\n\t// Function to log distance from origin\n\tvoid LogDistanceFromOrigin();\n};\n```", "cpp_code": "```cpp\n#include \"DistanceLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nADistanceLoggerActor::ADistanceLoggerActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ADistanceLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADistanceLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADistanceLoggerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"LogDistance\", IE_Pressed, this, &ADistanceLoggerActor::LogDistanceFromOrigin);\n}\n\nvoid ADistanceLoggerActor::LogDistanceFromOrigin()\n{\n\tFVector ActorLocation = GetActorLocation();\n\tfloat Distance = ActorLocation.Size();\n\tUE_LOG(LogTemp, Log, TEXT(\"Distance from Origin: %f\"), Distance);\n}\n```"}
{"requirement": "Create a component with a float property exposed to Blueprints to control speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"USpeedControlComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API USpeedControlComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUSpeedControlComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Speed\")\n\tfloat Speed;\n};\n```", "cpp_code": "```cpp\n#include \"USpeedControlComponent.h\"\n\nUSpeedControlComponent::USpeedControlComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tSpeed = 0.0f;\n}\n\nvoid USpeedControlComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n```"}
{"requirement": "Load a blueprint class using ConstructorHelpers and spawn it in the level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"ABlueprintSpawner.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ABlueprintSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tABlueprintSpawner();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY()\n\tTSubclassOf<AActor> BlueprintToSpawn;\n};\n```", "cpp_code": "```cpp\n#include \"ABlueprintSpawner.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nABlueprintSpawner::ABlueprintSpawner()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Find the blueprint class\n\tstatic ConstructorHelpers::FObjectFinder<UClass> BlueprintClass(TEXT(\"/Game/Blueprints/MyBlueprintClass.MyBlueprintClass_C\"));\n\tif (BlueprintClass.Succeeded())\n\t{\n\t\tBlueprintToSpawn = BlueprintClass.Object;\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ABlueprintSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (BlueprintToSpawn)\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tGetWorld()->SpawnActor<AActor>(BlueprintToSpawn, GetActorLocation(), GetActorRotation(), SpawnParams);\n\t}\n}\n\n// Called every frame\nvoid ABlueprintSpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its material when clicked by the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ClickableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AClickableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAClickableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* DefaultMaterial;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* ClickedMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"ClickableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"Engine/World.h\"\n#include \"ConstructorHelpers.h\"\n\nAClickableActor::AClickableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetNotifyRigidBodyCollision(true);\n\tMeshComponent->OnClicked.AddDynamic(this, &AClickableActor::OnClicked);\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> DefaultMat(TEXT(\"/Game/Path/To/DefaultMaterial.DefaultMaterial\"));\n\tif (DefaultMat.Succeeded())\n\t{\n\t\tDefaultMaterial = DefaultMat.Object;\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> ClickedMat(TEXT(\"/Game/Path/To/ClickedMaterial.ClickedMaterial\"));\n\tif (ClickedMat.Succeeded())\n\t{\n\t\tClickedMaterial = ClickedMat.Object;\n\t}\n\n\tMeshComponent->SetMaterial(0, DefaultMaterial);\n}\n\nvoid AClickableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AClickableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AClickableActor::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tif (MeshComponent && ClickedMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, ClickedMaterial);\n\t}\n}\n```"}
{"requirement": "Implement a UMG widget that displays the actor's name and can be updated dynamically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UActorNameWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UActorNameWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"ActorName\")\n\tvoid UpdateActorName(FString NewName);\n\nprotected:\n\tUPROPERTY(BlueprintReadOnly, meta=(BindWidget))\n\tclass UTextBlock* ActorNameText;\n};\n```", "cpp_code": "```cpp\n#include \"UActorNameWidget.h\"\n#include \"Components/TextBlock.h\"\n\nvoid UActorNameWidget::UpdateActorName(FString NewName)\n{\n\tif (ActorNameText)\n\t{\n\t\tActorNameText->SetText(FText::FromString(NewName));\n\t}\n}\n```"}
{"requirement": "Bind a function to toggle an actor's scale between two sizes with the 'T' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleScaleActor.generated.h\"\n\nUCLASS()\nclass AToggleScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleScaleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Scale\")\n\tFVector SmallScale;\n\n\tUPROPERTY(EditAnywhere, Category = \"Scale\")\n\tFVector LargeScale;\n\n\tUFUNCTION()\n\tvoid ToggleScale();\n\n\tbool bIsSmallScale;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleScaleActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAToggleScaleActor::AToggleScaleActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tSmallScale = FVector(1.0f, 1.0f, 1.0f);\n\tLargeScale = FVector(2.0f, 2.0f, 2.0f);\n\tbIsSmallScale = true;\n}\n\nvoid AToggleScaleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetActorScale3D(SmallScale);\n}\n\nvoid AToggleScaleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ToggleScale\", IE_Pressed, this, &AToggleScaleActor::ToggleScale);\n}\n\nvoid AToggleScaleActor::ToggleScale()\n{\n\tif (bIsSmallScale)\n\t{\n\t\tSetActorScale3D(LargeScale);\n\t}\n\telse\n\t{\n\t\tSetActorScale3D(SmallScale);\n\t}\n\tbIsSmallScale = !bIsSmallScale;\n}\n```"}
{"requirement": "Create a component with a UPROPERTY(EditAnywhere) to control the component's visibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UVisibilityControlComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UVisibilityControlComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUVisibilityControlComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Visibility\")\n\tbool bIsVisible;\n\n\tvoid UpdateVisibility();\n};\n```", "cpp_code": "```cpp\n#include \"UVisibilityControlComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUVisibilityControlComponent::UVisibilityControlComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tbIsVisible = true;\n}\n\nvoid UVisibilityControlComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateVisibility();\n}\n\nvoid UVisibilityControlComponent::UpdateVisibility()\n{\n\tif (GetOwner())\n\t{\n\t\tGetOwner()->SetActorHiddenInGame(!bIsVisible);\n\t}\n}\n```"}
{"requirement": "React to OnBeginOverlap by disabling the actor's mesh visibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapReactActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapReactActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOverlapReactActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUFUNCTION()\n\tvoid OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapReactActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapReactActor::AOverlapReactActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a StaticMeshComponent\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Set up overlap event\n\tStaticMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapReactActor::OnBeginOverlap);\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapReactActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapReactActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapReactActor::OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (StaticMeshComponent)\n\t{\n\t\tStaticMeshComponent->SetVisibility(false);\n\t}\n}\n```"}
{"requirement": "Create an actor that updates its position based on a sine wave pattern using Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SineWaveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASineWaveActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tASineWaveActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"SineWave\")\n\tfloat Amplitude;\n\n\tUPROPERTY(EditAnywhere, Category=\"SineWave\")\n\tfloat Frequency;\n\n\tfloat RunningTime;\n};\n```", "cpp_code": "```cpp\n#include \"SineWaveActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nASineWaveActor::ASineWaveActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAmplitude = 100.0f;\n\tFrequency = 1.0f;\n\tRunningTime = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASineWaveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASineWaveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRunningTime += DeltaTime;\n\tfloat DeltaHeight = Amplitude * FMath::Sin(Frequency * RunningTime);\n\tFVector NewLocation = GetActorLocation();\n\tNewLocation.Z += DeltaHeight;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Implement a function to log the total time an actor has been active every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ActiveTimeLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AActiveTimeLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tAActiveTimeLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tfloat TotalActiveTime;\n\tFTimerHandle TimerHandle_LogActiveTime;\n\n\tvoid LogActiveTime();\n};\n```", "cpp_code": "```cpp\n#include \"ActiveTimeLoggerActor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nAActiveTimeLoggerActor::AActiveTimeLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTotalActiveTime = 0.0f;\n}\n\nvoid AActiveTimeLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorld()->GetTimerManager().SetTimer(TimerHandle_LogActiveTime, this, &AActiveTimeLoggerActor::LogActiveTime, 1.0f, true);\n}\n\nvoid AActiveTimeLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tTotalActiveTime += DeltaTime;\n}\n\nvoid AActiveTimeLoggerActor::LogActiveTime()\n{\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor has been active for %f seconds\"), TotalActiveTime);\n}\n```"}
{"requirement": "Bind a function to change the actor's material when 'M' is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ChangeMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAChangeMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n\n\tvoid ChangeMaterial();\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"ConstructorHelpers.h\"\n\nAChangeMaterialActor::AChangeMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialAsset(TEXT(\"/Game/Path/To/Your/Material.Material\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tNewMaterial = MaterialAsset.Object;\n\t}\n}\n\nvoid AChangeMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AChangeMaterialActor::ChangeMaterial);\n}\n\nvoid AChangeMaterialActor::ChangeMaterial()\n{\n\tif (MeshComponent && NewMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Create a component with a BlueprintCallable function to reset a counter to zero.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ResetCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UResetCounterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUResetCounterComponent();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Counter\")\n\tvoid ResetCounterToZero();\n\nprivate:\n\tUPROPERTY()\n\tint32 Counter;\n};\n```", "cpp_code": "```cpp\n#include \"ResetCounterComponent.h\"\n\nUResetCounterComponent::UResetCounterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tCounter = 0;\n}\n\nvoid UResetCounterComponent::ResetCounterToZero()\n{\n\tCounter = 0;\n}\n```"}
{"requirement": "Load a sound cue using ConstructorHelpers and play it in response to an event.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourSoundPlayingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourSoundPlayingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourSoundPlayingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Sound\")\n\tvoid PlaySound();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundCue;\n};\n```", "cpp_code": "```cpp\n#include \"YourSoundPlayingActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAYourSoundPlayingActor::AYourSoundPlayingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tstatic ConstructorHelpers::FObjectFinder<USoundCue> SoundCueObject(TEXT(\"/Game/Audio/YourSoundCue.YourSoundCue\"));\n\tif (SoundCueObject.Succeeded())\n\t{\n\t\tSoundCue = SoundCueObject.Object;\n\t}\n}\n\nvoid AYourSoundPlayingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourSoundPlayingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AYourSoundPlayingActor::PlaySound()\n{\n\tif (SoundCue)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundCue, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a camera actor that smoothly interpolates its position between two points.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CameraInterpolationActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACameraInterpolationActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tACameraInterpolationActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n\tFVector StartLocation;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n\tFVector EndLocation;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n\tfloat InterpolationSpeed;\n\nprivate:\n\tFVector CurrentLocation;\n};\n```", "cpp_code": "```cpp\n#include \"CameraInterpolationActor.h\"\n\nACameraInterpolationActor::ACameraInterpolationActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tInterpolationSpeed = 0.5f;\n}\n\nvoid ACameraInterpolationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCurrentLocation = StartLocation;\n}\n\nvoid ACameraInterpolationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!FMath::IsNearlyEqual((CurrentLocation - EndLocation).Size(), 0.0f, KINDA_SMALL_NUMBER))\n\t{\n\t\tCurrentLocation = FMath::VInterpTo(CurrentLocation, EndLocation, DeltaTime, InterpolationSpeed);\n\t\tSetActorLocation(CurrentLocation);\n\t}\n}\n```"}
{"requirement": "Implement a simple AI that stops moving when close to a specific target.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"AICharacter.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAICharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAICharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat StopDistance;\n\n\tUPROPERTY(EditAnywhere)\n\tAActor* TargetActor;\n};\n```", "cpp_code": "```cpp\n#include \"AICharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAAICharacter::AAICharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tStopDistance = 100.0f; // Distance at which the AI will stop\n\tTargetActor = nullptr; // This should be set in the editor or dynamically\n}\n\nvoid AAICharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Additional initialization if needed\n}\n\nvoid AAICharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tfloat DistanceToTarget = FVector::Dist(GetActorLocation(), TargetActor->GetActorLocation());\n\t\tif (DistanceToTarget > StopDistance)\n\t\t{\n\t\t\tFVector Direction = (TargetActor->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n\t\t\tAddMovementInput(Direction);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Bind a function to rotate the actor 90 degrees clockwise when 'R' is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotateActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotateActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotateActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Rotate function\n\tvoid RotateActorClockwise();\n\n\t// Setup player input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"RotateActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nARotateActor::ARotateActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ARotateActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotateActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Rotate 90 degrees clockwise\nvoid ARotateActor::RotateActorClockwise()\n{\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += 90.0f;\n\tSetActorRotation(NewRotation);\n}\n\n// Setup player input\nvoid ARotateActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the RotateActorClockwise function to the 'R' key\n\tPlayerInputComponent->BindAction(\"Rotate\", IE_Pressed, this, &ARotateActor::RotateActorClockwise);\n}\n```"}
{"requirement": "Create a component with a boolean property that toggles between two states on command.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UToggleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUToggleComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Toggles the boolean state\n\tUFUNCTION(BlueprintCallable, Category=\"Toggle\")\n\tvoid ToggleState();\n\n\t// Returns the current state\n\tUFUNCTION(BlueprintCallable, Category=\"Toggle\")\n\tbool GetState() const;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Toggle\")\n\tbool bIsToggled;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleComponent.h\"\n\n// Sets default values for this component's properties\nUToggleComponent::UToggleComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\tbIsToggled = false;\n}\n\n// Called when the game starts\nvoid UToggleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UToggleComponent::ToggleState()\n{\n\tbIsToggled = !bIsToggled;\n}\n\nbool UToggleComponent::GetState() const\n{\n\treturn bIsToggled;\n}\n```"}
{"requirement": "React to OnBeginOverlap by logging the time of collision to the console.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionLoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionLoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionLoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionLoggingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nACollisionLoggingActor::ACollisionLoggingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionLoggingActor::OnBeginOverlap);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionLoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionLoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionLoggingActor::OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif(GEngine)\n\t{\n\t\tFString CurrentTime = FDateTime::Now().ToString();\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Collision Time: %s\"), *CurrentTime));\n\t}\n}\n```"}
{"requirement": "Create an actor that changes its mesh color based on its speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAColorChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat SpeedThreshold;\n\n\tvoid UpdateMeshColor();\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAColorChangingActor::AColorChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tSpeedThreshold = 100.0f;\n}\n\nvoid AColorChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AColorChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tUpdateMeshColor();\n}\n\nvoid AColorChangingActor::UpdateMeshColor()\n{\n\tFVector Velocity = GetVelocity();\n\tfloat Speed = Velocity.Size();\n\n\tUMaterialInstanceDynamic* MaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\tif (MaterialInstance)\n\t{\n\t\tFLinearColor NewColor = (Speed > SpeedThreshold) ? FLinearColor::Red : FLinearColor::Blue;\n\t\tMaterialInstance->SetVectorParameterValue(\"BaseColor\", NewColor);\n\t}\n}\n```"}
{"requirement": "Implement a UMG widget with a progress bar that updates with actor's health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"HealthWidget.generated.h\"\n\nUCLASS()\nclass AYourGame_API UHealthWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Health\")\n\tvoid UpdateHealthBar(float HealthPercentage);\n\nprotected:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UProgressBar* HealthProgressBar;\n};\n```", "cpp_code": "```cpp\n#include \"HealthWidget.h\"\n#include \"Components/ProgressBar.h\"\n\nvoid UHealthWidget::UpdateHealthBar(float HealthPercentage)\n{\n\tif (HealthProgressBar)\n\t{\n\t\tHealthProgressBar->SetPercent(HealthPercentage);\n\t}\n}\n```"}
{"requirement": "Bind a function to play a sound when the 'S' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"ASoundPlayer.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayer : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundPlayer();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid PlaySound();\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundCue;\n};\n```", "cpp_code": "```cpp\n#include \"ASoundPlayer.h\"\n#include \"Components/InputComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundPlayer::ASoundPlayer()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASoundPlayer::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundPlayer::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"PlaySound\", IE_Pressed, this, &ASoundPlayer::PlaySound);\n}\n\nvoid ASoundPlayer::PlaySound()\n{\n\tif (SoundCue)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundCue, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component with a function callable from Blueprints to increase a score.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UScoreComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UScoreComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUScoreComponent();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid IncreaseScore(int32 Amount);\n\n\tUPROPERTY(BlueprintReadOnly, Category=\"Score\")\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"UScoreComponent.h\"\n\nUScoreComponent::UScoreComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tScore = 0;\n}\n\nvoid UScoreComponent::IncreaseScore(int32 Amount)\n{\n\tScore += Amount;\n}\n```"}
{"requirement": "Load a skeletal mesh using ConstructorHelpers and set it to an actor component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"ASkeletalMeshLoaderActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASkeletalMeshLoaderActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASkeletalMeshLoaderActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Mesh\")\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ASkeletalMeshLoaderActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nASkeletalMeshLoaderActor::ASkeletalMeshLoaderActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<USkeletalMesh> SkeletalMeshAsset(TEXT(\"/Game/YourPath/YourSkeletalMesh.YourSkeletalMesh\"));\n\tif (SkeletalMeshAsset.Succeeded())\n\t{\n\t\tSkeletalMeshComponent->SetSkeletalMesh(SkeletalMeshAsset.Object);\n\t}\n}\n```"}
{"requirement": "Create an actor that spawns another actor at its location when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpawnerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpawnerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpawnerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Function to spawn another actor\n\tUFUNCTION()\n\tvoid SpawnNewActor();\n\n\t// Class of the actor to spawn\n\tUPROPERTY(EditAnywhere, Category = \"Spawning\")\n\tTSubclassOf<AActor> ActorToSpawn;\n};\n```", "cpp_code": "```cpp\n#include \"SpawnerActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nASpawnerActor::ASpawnerActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASpawnerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpawnerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid ASpawnerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the SpawnNewActor function to a key press (e.g., the space bar)\n\tPlayerInputComponent->BindAction(\"SpawnActor\", IE_Pressed, this, &ASpawnerActor::SpawnNewActor);\n}\n\n// Function to spawn another actor\nvoid ASpawnerActor::SpawnNewActor()\n{\n\tif (ActorToSpawn)\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tSpawnParams.Owner = this;\n\t\tSpawnParams.Instigator = GetInstigator();\n\n\t\t// Get the current location and rotation\n\t\tFVector Location = GetActorLocation();\n\t\tFRotator Rotation = GetActorRotation();\n\n\t\t// Spawn the actor\n\t\tGetWorld()->SpawnActor<AActor>(ActorToSpawn, Location, Rotation, SpawnParams);\n\t}\n}\n```"}
{"requirement": "Implement a function in an actor to print its current velocity every Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintVelocityActor.generated.h\"\n\nUCLASS()\nclass APrintVelocityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPrintVelocityActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"PrintVelocityActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/MovementComponent.h\"\n#include \"Engine/World.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nAPrintVelocityActor::APrintVelocityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APrintVelocityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APrintVelocityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector Velocity = FVector::ZeroVector;\n\tUPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(GetRootComponent());\n\tif (PrimitiveComponent)\n\t{\n\t\tVelocity = PrimitiveComponent->GetComponentVelocity();\n\t}\n\n\tUE_LOG(LogTemp, Log, TEXT(\"Velocity: %s\"), *Velocity.ToString());\n}\n```"}
{"requirement": "Bind a function to toggle an actor's material between two states with the 'N' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* MaterialOne;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* MaterialTwo;\n\n\tbool bUseMaterialOne;\n\n\tvoid ToggleMaterial();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Components/InputComponent.h\"\n\nAToggleMaterialActor::AToggleMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tbUseMaterialOne = true;\n}\n\nvoid AToggleMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MaterialOne)\n\t{\n\t\tMeshComponent->SetMaterial(0, MaterialOne);\n\t}\n}\n\nvoid AToggleMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleMaterialActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleMaterial\", IE_Pressed, this, &AToggleMaterialActor::ToggleMaterial);\n}\n\nvoid AToggleMaterialActor::ToggleMaterial()\n{\n\tif (bUseMaterialOne && MaterialTwo)\n\t{\n\t\tMeshComponent->SetMaterial(0, MaterialTwo);\n\t}\n\telse if (!bUseMaterialOne && MaterialOne)\n\t{\n\t\tMeshComponent->SetMaterial(0, MaterialOne);\n\t}\n\tbUseMaterialOne = !bUseMaterialOne;\n}\n```"}
{"requirement": "Create a component with a UPROPERTY(EditAnywhere) to set the actor's maximum speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"MaximumSpeedComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UMaximumSpeedComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUMaximumSpeedComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MaxSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MaximumSpeedComponent.h\"\n\nUMaximumSpeedComponent::UMaximumSpeedComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tMaxSpeed = 600.0f; // Default maximum speed\n}\n\nvoid UMaximumSpeedComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Initialization logic if needed\n}\n```"}
{"requirement": "React to OnBeginOverlap by changing the actor's location to a specified point.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(EditAnywhere)\n\tFVector NewLocation;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nAOverlapActor::AOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tNewLocation = FVector(100.0f, 100.0f, 100.0f);\n}\n\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create an actor with a light component that changes intensity over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"LightIntensityChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALightIntensityChanger : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tALightIntensityChanger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUPointLightComponent* PointLight;\n\t\n\tUPROPERTY(EditAnywhere, Category=\"Light\")\n\tfloat IntensityChangeRate;\n\t\n\tfloat TimeElapsed;\n};\n```", "cpp_code": "```cpp\n#include \"LightIntensityChanger.h\"\n\n// Sets default values\nALightIntensityChanger::ALightIntensityChanger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create PointLight component and attach it to the root\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\t// Initial values\n\tIntensityChangeRate = 50.0f;\n\tTimeElapsed = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ALightIntensityChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALightIntensityChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update time elapsed\n\tTimeElapsed += DeltaTime;\n\n\t// Calculate new intensity\n\tfloat NewIntensity = FMath::Abs(FMath::Sin(TimeElapsed) * IntensityChangeRate);\n\n\t// Set the intensity of the light\n\tPointLight->SetIntensity(NewIntensity);\n}\n```"}
{"requirement": "Implement a simple AI controller that changes a property when an actor is detected.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ADetectingAIController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADetectingAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tADetectingAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat DetectionRadius;\n\n\tUPROPERTY(EditAnywhere)\n\tbool bIsActorDetected;\n\n\tvoid DetectActors();\n};\n```", "cpp_code": "```cpp\n#include \"ADetectingAIController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nADetectingAIController::ADetectingAIController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tDetectionRadius = 500.0f;\n\tbIsActorDetected = false;\n}\n\nvoid ADetectingAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADetectingAIController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tDetectActors();\n}\n\nvoid ADetectingAIController::DetectActors()\n{\n\tFVector MyLocation = GetPawn()->GetActorLocation();\n\tTArray<FOverlapResult> OverlapResults;\n\tFCollisionShape CollisionShape;\n\tCollisionShape.SetSphere(DetectionRadius);\n\n\tbool bHasOverlap = GetWorld()->OverlapMultiByChannel(\n\t\tOverlapResults,\n\t\tMyLocation,\n\t\tFQuat::Identity,\n\t\tECC_Pawn,\n\t\tCollisionShape\n\t);\n\n\tif (bHasOverlap)\n\t{\n\t\tbIsActorDetected = true;\n\t}\n\telse\n\t{\n\t\tbIsActorDetected = false;\n\t}\n\n\t// Debug\n\tDrawDebugSphere(GetWorld(), MyLocation, DetectionRadius, 24, FColor::Green, false, 1.0f);\n}\n```"}
{"requirement": "Bind a function to log the actor's name when the 'Name' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogActorName.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALogActorName : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALogActorName();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to log actor's name\n\tvoid LogName();\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"LogActorName.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nALogActorName::ALogActorName()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALogActorName::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALogActorName::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to log actor's name\nvoid ALogActorName::LogName()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor Name: %s\"), *GetName());\n}\n\n// Setup player input component\nvoid ALogActorName::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"Name\", IE_Pressed, this, &ALogActorName::LogName);\n}\n```"}
{"requirement": "Create a component with a BlueprintCallable function to reset the actor's health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UHealthResetComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UHealthResetComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUHealthResetComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category=\"Health\")\n\tvoid ResetHealth();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat DefaultHealth;\n\n\tUPROPERTY(VisibleAnywhere, Category=\"Health\")\n\tfloat CurrentHealth;\n};\n```", "cpp_code": "```cpp\n#include \"UHealthResetComponent.h\"\n\nUHealthResetComponent::UHealthResetComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\t// Initialize default health value\n\tDefaultHealth = 100.0f;\n\tCurrentHealth = DefaultHealth;\n}\n\nvoid UHealthResetComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Initial setup if needed\n\tCurrentHealth = DefaultHealth;\n}\n\nvoid UHealthResetComponent::ResetHealth()\n{\n\tCurrentHealth = DefaultHealth;\n}\n```"}
{"requirement": "Load a particle system using ConstructorHelpers and play it at the actor's location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"ParticleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AParticleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAParticleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Effects\")\n\tUParticleSystemComponent* ParticleSystemComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ParticleActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Particles/ParticleSystem.h\"\n\nAParticleActor::AParticleActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystemComponent\"));\n\tParticleSystemComponent->SetupAttachment(RootComponent);\n\n\tstatic ConstructorHelpers::FObjectFinder<UParticleSystem> ParticleAsset(TEXT(\"/Game/Path/To/Your/ParticleSystem.ParticleSystem\"));\n\tif (ParticleAsset.Succeeded())\n\t{\n\t\tParticleSystemComponent->SetTemplate(ParticleAsset.Object);\n\t}\n}\n\nvoid AParticleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (ParticleSystemComponent && ParticleSystemComponent->Template)\n\t{\n\t\tParticleSystemComponent->Activate();\n\t}\n}\n```"}
{"requirement": "Create an actor that rotates towards a player character smoothly using Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SmoothRotatingActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASmoothRotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASmoothRotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"SmoothRotatingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASmoothRotatingActor::ASmoothRotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 45.0f; // Default rotation speed in degrees per second\n}\n\nvoid ASmoothRotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Assume there is only one player controller\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tPlayerActor = PlayerController->GetPawn();\n\t}\n}\n\nvoid ASmoothRotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerActor)\n\t{\n\t\tFVector Direction = PlayerActor->GetActorLocation() - GetActorLocation();\n\t\tFRotator TargetRotation = Direction.Rotation();\n\t\tFRotator CurrentRotation = GetActorRotation();\n\t\tFRotator NewRotation = FMath::RInterpTo(CurrentRotation, TargetRotation, DeltaTime, RotationSpeed);\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Implement a UMG widget with a button that teleports the player when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"TeleportPlayerWidget.generated.h\"\n\nUCLASS()\nclass MYGAME_API UTeleportPlayerWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUTeleportPlayerWidget(const FObjectInitializer& ObjectInitializer);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Teleport\")\n\tvoid OnTeleportButtonClicked();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Teleport\")\n\tFVector TeleportLocation;\n};\n```", "cpp_code": "```cpp\n#include \"TeleportPlayerWidget.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\nUTeleportPlayerWidget::UTeleportPlayerWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n\t// Set a default teleport location\n\tTeleportLocation = FVector(1000.0f, 1000.0f, 300.0f);\n}\n\nvoid UTeleportPlayerWidget::OnTeleportButtonClicked()\n{\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tAPawn* PlayerPawn = PlayerController->GetPawn();\n\t\tif (PlayerPawn)\n\t\t{\n\t\t\tPlayerPawn->SetActorLocation(TeleportLocation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Bind a function to toggle an actor's visibility with the 'V' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleVisibilityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ToggleVisibility();\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerInput.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleVisibilityActor::ToggleVisibility);\n\t}\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tif (MeshComponent)\n\t{\n\t\tMeshComponent->SetVisibility(!MeshComponent->IsVisible());\n\t}\n}\n```"}
{"requirement": "Create a component with a float property exposed to Blueprints to control brightness.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UBrightnessComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UBrightnessComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUBrightnessComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Brightness\")\n\tfloat Brightness;\n};\n```", "cpp_code": "```cpp\n#include \"UBrightnessComponent.h\"\n\nUBrightnessComponent::UBrightnessComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\t// Initialize Brightness with a default value\n\tBrightness = 1.0f;\n}\n\nvoid UBrightnessComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Additional initialization if needed\n}\n```"}
{"requirement": "React to OnBeginOverlap by playing a random sound from an array.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"SoundOverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASoundOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUBoxComponent* BoxComponent;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUAudioComponent* AudioComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tTArray<USoundCue*> SoundArray;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"SoundOverlapActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundOverlapActor::ASoundOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tBoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tRootComponent = BoxComponent;\n\tBoxComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tBoxComponent->OnComponentBeginOverlap.AddDynamic(this, &ASoundOverlapActor::OnOverlapBegin);\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n\tAudioComponent->bAutoActivate = false;\n}\n\nvoid ASoundOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (SoundArray.Num() > 0)\n\t{\n\t\tint32 RandomIndex = FMath::RandRange(0, SoundArray.Num() - 1);\n\t\tUSoundCue* RandomSound = SoundArray[RandomIndex];\n\t\tif (RandomSound)\n\t\t{\n\t\t\tAudioComponent->SetSound(RandomSound);\n\t\t\tAudioComponent->Play();\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a skeletal mesh that plays an animation on key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"MySkeletalMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMySkeletalMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMySkeletalMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tUAnimSequence* AnimationToPlay;\n\n\tvoid PlayAnimation();\n};\n```", "cpp_code": "```cpp\n#include \"MySkeletalMeshActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAMySkeletalMeshActor::AMySkeletalMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AMySkeletalMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMySkeletalMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input\nvoid AMySkeletalMeshActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"PlayAnimation\", IE_Pressed, this, &AMySkeletalMeshActor::PlayAnimation);\n}\n\n// Play animation function\nvoid AMySkeletalMeshActor::PlayAnimation()\n{\n\tif (AnimationToPlay && SkeletalMeshComponent)\n\t{\n\t\tSkeletalMeshComponent->PlayAnimation(AnimationToPlay, false);\n\t}\n}\n```"}
{"requirement": "Implement a function to log the total distance an actor has moved every second.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADistanceLoggerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector LastLocation;\n\tfloat TotalDistanceMoved;\n\tfloat TimeAccumulator;\n\n\tvoid LogDistance();\n};\n```", "cpp_code": "```cpp\n#include \"DistanceLoggerActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nADistanceLoggerActor::ADistanceLoggerActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\tTotalDistanceMoved = 0.0f;\n\tTimeAccumulator = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ADistanceLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tLastLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid ADistanceLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentLocation = GetActorLocation();\n\tfloat DistanceMoved = FVector::Dist(LastLocation, CurrentLocation);\n\tTotalDistanceMoved += DistanceMoved;\n\tLastLocation = CurrentLocation;\n\n\tTimeAccumulator += DeltaTime;\n\tif (TimeAccumulator >= 1.0f)\n\t{\n\t\tLogDistance();\n\t\tTimeAccumulator -= 1.0f;\n\t}\n}\n\nvoid ADistanceLoggerActor::LogDistance()\n{\n\tUE_LOG(LogTemp, Log, TEXT(\"Total Distance Moved: %f\"), TotalDistanceMoved);\n}\n```"}
{"requirement": "Bind a function to change the actor's mesh when the 'M' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AChangeMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAChangeMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMesh* NewMesh;\n\n\tvoid ChangeMesh();\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAChangeMeshActor::AChangeMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> DefaultMesh(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (DefaultMesh.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(DefaultMesh.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> FoundNewMesh(TEXT(\"/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere\"));\n\tif (FoundNewMesh.Succeeded())\n\t{\n\t\tNewMesh = FoundNewMesh.Object;\n\t}\n}\n\nvoid AChangeMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AChangeMeshActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ChangeMesh\", IE_Pressed, this, &AChangeMeshActor::ChangeMesh);\n}\n\nvoid AChangeMeshActor::ChangeMesh()\n{\n\tif (NewMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(NewMesh);\n\t}\n}\n```"}
{"requirement": "Create a component with a BlueprintCallable function to decrement a counter.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UDecrementCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UDecrementCounterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUDecrementCounterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Counter\")\n\tint32 Counter;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Counter\")\n\tvoid DecrementCounter();\n};\n```", "cpp_code": "```cpp\n#include \"UDecrementCounterComponent.h\"\n\nUDecrementCounterComponent::UDecrementCounterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tCounter = 0;\n}\n\nvoid UDecrementCounterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UDecrementCounterComponent::DecrementCounter()\n{\n\t--Counter;\n}\n```"}
{"requirement": "Load a widget blueprint using ConstructorHelpers and display it on the screen.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"WidgetBlueprintLoaderActor.generated.h\"\n\nUCLASS()\nclass AWidgetBlueprintLoaderActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWidgetBlueprintLoaderActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"UI\")\n\tTSubclassOf<UUserWidget> WidgetClass;\n\n\tUUserWidget* WidgetInstance;\n};\n```", "cpp_code": "```cpp\n#include \"WidgetBlueprintLoaderActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Blueprint/UserWidget.h\"\n\nAWidgetBlueprintLoaderActor::AWidgetBlueprintLoaderActor()\n{\n\tstatic ConstructorHelpers::FClassFinder<UUserWidget> WidgetBPClass(TEXT(\"/Game/Path/To/YourWidgetBlueprint\"));\n\tif (WidgetBPClass.Succeeded())\n\t{\n\t\tWidgetClass = WidgetBPClass.Class;\n\t}\n}\n\nvoid AWidgetBlueprintLoaderActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (WidgetClass)\n\t{\n\t\tWidgetInstance = CreateWidget<UUserWidget>(GetWorld(), WidgetClass);\n\t\tif (WidgetInstance)\n\t\t{\n\t\t\tWidgetInstance->AddToViewport();\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that moves towards a target point when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid MoveTowardsTarget();\n\n\tUPROPERTY(EditAnywhere)\n\tFVector TargetLocation;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementSpeed = 100.0f;\n\tTargetLocation = FVector(0.0f, 0.0f, 0.0f);\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMovingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"MoveToTarget\", IE_Pressed, this, &AMovingActor::MoveTowardsTarget);\n}\n\nvoid AMovingActor::MoveTowardsTarget()\n{\n\tFVector CurrentLocation = GetActorLocation();\n\tFVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n\tFVector NewLocation = CurrentLocation + (Direction * MovementSpeed * GetWorld()->GetDeltaSeconds());\n\tSetActorLocation(NewLocation);\n}\n```"}
