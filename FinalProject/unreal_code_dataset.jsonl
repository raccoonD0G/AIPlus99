{"requirement": "Create an actor with a visible mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyVisibleMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyVisibleMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMyVisibleMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyVisibleMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAMyVisibleMeshActor::AMyVisibleMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component and set as root\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AMyVisibleMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyVisibleMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Add a jump function to a character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyCharacter();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\npublic:\n\tvoid Jump();\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n\nAMyCharacter::AMyCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, &AMyCharacter::Jump);\n}\n\nvoid AMyCharacter::Jump()\n{\n\tif (CanJump())\n\t{\n\t\tACharacter::Jump();\n\t}\n}\n```"}
{"requirement": "Create a rotating actor using a tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tFRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the rotation rate\n\tRotationRate = FRotator(0.f, 180.f, 0.f);\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Rotate the actor\n\tAddActorLocalRotation(RotationRate * DeltaTime);\n}\n```"}
{"requirement": "Implement a trigger volume that prints a message when an actor enters.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TriggerVolumeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATriggerVolumeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tATriggerVolumeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* TriggerVolume;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"TriggerVolumeActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nATriggerVolumeActor::ATriggerVolumeActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n\tRootComponent = TriggerVolume;\n\n\tTriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &ATriggerVolumeActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ATriggerVolumeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATriggerVolumeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATriggerVolumeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Actor has entered the trigger volume\"));\n\t}\n}\n```"}
{"requirement": "Add a health variable to a character using UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"YourCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AYourCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tAYourCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat Health;\n};\n```", "cpp_code": "```cpp\n#include \"YourCharacter.h\"\n\n// Sets default values\nAYourCharacter::AYourCharacter()\n{\n\t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tHealth = 100.0f; // Default health value\n}\n\n// Called when the game starts or when spawned\nvoid AYourCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AYourCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\n// Called to bind functionality to input\nvoid AYourCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n}\n```"}
{"requirement": "Create a simple pickup item that destroys itself when collected.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PickupItem.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API APickupItem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPickupItem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass USphereComponent* CollisionComponent;\n};\n```", "cpp_code": "```cpp\n#include \"PickupItem.h\"\n#include \"Components/SphereComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nAPickupItem::APickupItem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\tCollisionComponent->SetSphereRadius(50.0f);\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &APickupItem::OnOverlapBegin);\n}\n\nvoid APickupItem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APickupItem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APickupItem::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && OtherActor != this && OtherComp)\n\t{\n\t\tDestroy();\n\t}\n}\n```"}
{"requirement": "Implement a floating movement component for an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FloatingMovementComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatingMovementComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUFloatingMovementComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Floating\")\n\tfloat FloatSpeed = 20.0f;\n\n\tUPROPERTY(EditAnywhere, Category=\"Floating\")\n\tfloat Amplitude = 50.0f;\n\n\tFVector InitialLocation;\n};\n```", "cpp_code": "```cpp\n#include \"FloatingMovementComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUFloatingMovementComponent::UFloatingMovementComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UFloatingMovementComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Save the initial location of the actor\n\tInitialLocation = GetOwner()->GetActorLocation();\n}\n\nvoid UFloatingMovementComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (!GetOwner()) return;\n\n\t// Calculate new location\n\tFVector NewLocation = InitialLocation;\n\tNewLocation.Z += Amplitude * FMath::Sin(FloatSpeed * GetWorld()->GetTimeSeconds());\n\n\t// Update Actor's location\n\tGetOwner()->SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Add a function to change the material of a mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AYourActor();\n\n  UFUNCTION(BlueprintCallable, Category = \"Mesh\")\n  void ChangeMeshMaterial(UMeshComponent* MeshComponent, UMaterialInterface* NewMaterial);\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::ChangeMeshMaterial(UMeshComponent* MeshComponent, UMaterialInterface* NewMaterial)\n{\n  if (MeshComponent && NewMaterial)\n  {\n\tMeshComponent->SetMaterial(0, NewMaterial);\n  }\n}\n```"}
{"requirement": "Bind a key to print a message in the log.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"KeyBindingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AKeyBindingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AKeyBindingActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n  void PrintMessage();\n};\n```", "cpp_code": "```cpp\n#include \"KeyBindingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n\nAKeyBindingActor::AKeyBindingActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AKeyBindingActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AKeyBindingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n  Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n  PlayerInputComponent->BindAction(\"PrintMessage\", IE_Pressed, this, &AKeyBindingActor::PrintMessage);\n}\n\nvoid AKeyBindingActor::PrintMessage()\n{\n  if (GEngine)\n  {\n\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Key Pressed: Print Message\"));\n\tUE_LOG(LogTemp, Warning, TEXT(\"Key Pressed: Print Message\"));\n  }\n}\n```"}
{"requirement": "Create a door actor that opens and closes with a toggle function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DoorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADoorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADoorActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Door\")\n\tvoid ToggleDoor();\n\nprivate:\n\tbool bIsOpen;\n\n\tUPROPERTY(EditAnywhere)\n\tFRotator OpenRotation;\n\n\tUPROPERTY(EditAnywhere)\n\tFRotator ClosedRotation;\n\n\tvoid OpenDoor();\n\tvoid CloseDoor();\n};\n```", "cpp_code": "```cpp\n#include \"DoorActor.h\"\n\n// Sets default values\nADoorActor::ADoorActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tbIsOpen = false;\n\n\t// Define default rotations\n\tOpenRotation = FRotator(0.f, 90.f, 0.f);\n\tClosedRotation = FRotator(0.f, 0.f, 0.f);\n}\n\n// Called when the game starts or when spawned\nvoid ADoorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADoorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADoorActor::ToggleDoor()\n{\n\tif (bIsOpen)\n\t{\n\t\tCloseDoor();\n\t}\n\telse\n\t{\n\t\tOpenDoor();\n\t}\n}\n\nvoid ADoorActor::OpenDoor()\n{\n\tSetActorRotation(OpenRotation);\n\tbIsOpen = true;\n}\n\nvoid ADoorActor::CloseDoor()\n{\n\tSetActorRotation(ClosedRotation);\n\tbIsOpen = false;\n}\n```"}
{"requirement": "Implement a timer that prints a message every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerExample.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ATimerExample : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tATimerExample();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFTimerHandle TimerHandle;\n\tvoid PrintMessage();\n};\n```", "cpp_code": "```cpp\n#include \"TimerExample.h\"\n#include \"Engine/Engine.h\"\n\nATimerExample::ATimerExample()\n{\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ATimerExample::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tGetWorldTimerManager().SetTimer(TimerHandle, this, &ATimerExample::PrintMessage, 1.0f, true);\n}\n\nvoid ATimerExample::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATimerExample::PrintMessage()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Green, TEXT(\"Message printed every second\"));\n\t}\n}\n```"}
{"requirement": "Create a light actor that changes color over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingLight.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangingLight : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAColorChangingLight();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPointLightComponent* PointLight;\n\n\tFLinearColor CurrentColor;\n\tfloat TimeAccumulator;\n\tfloat ColorChangeRate;\n\n\tvoid UpdateLightColor(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingLight.h\"\n#include \"Components/PointLightComponent.h\"\n\nAColorChangingLight::AColorChangingLight()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\tCurrentColor = FLinearColor::Red;\n\tTimeAccumulator = 0.0f;\n\tColorChangeRate = 1.0f; // Change color every second\n}\n\nvoid AColorChangingLight::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AColorChangingLight::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateLightColor(DeltaTime);\n}\n\nvoid AColorChangingLight::UpdateLightColor(float DeltaTime)\n{\n\tTimeAccumulator += DeltaTime;\n\n\tif (TimeAccumulator >= ColorChangeRate)\n\t{\n\t\tTimeAccumulator = 0.0f;\n\n\t\t// Cycle through colors: Red -> Green -> Blue -> Red\n\t\tif (CurrentColor == FLinearColor::Red)\n\t\t{\n\t\t\tCurrentColor = FLinearColor::Green;\n\t\t}\n\t\telse if (CurrentColor == FLinearColor::Green)\n\t\t{\n\t\t\tCurrentColor = FLinearColor::Blue;\n\t\t}\n\t\telse if (CurrentColor == FLinearColor::Blue)\n\t\t{\n\t\t\tCurrentColor = FLinearColor::Red;\n\t\t}\n\t}\n\n\tPointLight->SetLightColor(CurrentColor);\n}\n```"}
{"requirement": "Add a function to increase a character's speed temporarily.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SpeedBoostCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API ASpeedBoostCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedBoostCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid IncreaseSpeedTemporarily(float SpeedMultiplier, float Duration);\n\nprivate:\n\tvoid ResetSpeed();\n\n\tFTimerHandle SpeedBoostTimerHandle;\n\tfloat OriginalSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedBoostCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"TimerManager.h\"\n\nASpeedBoostCharacter::ASpeedBoostCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASpeedBoostCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tOriginalSpeed = GetCharacterMovement()->MaxWalkSpeed;\n}\n\nvoid ASpeedBoostCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpeedBoostCharacter::IncreaseSpeedTemporarily(float SpeedMultiplier, float Duration)\n{\n\tGetCharacterMovement()->MaxWalkSpeed *= SpeedMultiplier;\n\tGetWorldTimerManager().SetTimer(SpeedBoostTimerHandle, this, &ASpeedBoostCharacter::ResetSpeed, Duration, false);\n}\n\nvoid ASpeedBoostCharacter::ResetSpeed()\n{\n\tGetCharacterMovement()->MaxWalkSpeed = OriginalSpeed;\n\tGetWorldTimerManager().ClearTimer(SpeedBoostTimerHandle);\n}\n```"}
{"requirement": "Create a simple camera shake effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Camera/CameraShakeBase.h\"\n#include \"SimpleCameraShake.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API USimpleCameraShake : public UCameraShakeBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tUSimpleCameraShake();\n};\n```", "cpp_code": "```cpp\n#include \"SimpleCameraShake.h\"\n\nUSimpleCameraShake::USimpleCameraShake()\n{\n\tOscillationDuration = 0.25f;\n\tOscillationBlendInTime = 0.05f;\n\tOscillationBlendOutTime = 0.05f;\n\n\tRotOscillation.Pitch.Amplitude = 10.0f;\n\tRotOscillation.Pitch.Frequency = 5.0f;\n\n\tRotOscillation.Yaw.Amplitude = 10.0f;\n\tRotOscillation.Yaw.Frequency = 5.0f;\n\n\tRotOscillation.Roll.Amplitude = 0.0f;\n\tRotOscillation.Roll.Frequency = 0.0f;\n}\n```"}
{"requirement": "Implement a HUD element that displays player health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/HUD.h\"\n#include \"PlayerHealthHUD.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APlayerHealthHUD : public AHUD\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPlayerHealthHUD();\n\nprotected:\n\tvirtual void DrawHUD() override;\n\nprivate:\n\tvoid DrawHealthBar();\n\n\t// Example health value, replace with actual player health retrieval\n\tfloat PlayerHealth;\n\tfloat MaxPlayerHealth;\n\n\t// Health bar properties\n\tFVector2D HealthBarPosition;\n\tFVector2D HealthBarSize;\n\tFLinearColor HealthBarColor;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerHealthHUD.h\"\n#include \"Engine/Canvas.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAPlayerHealthHUD::APlayerHealthHUD()\n{\n\t// Initialize default values\n\tPlayerHealth = 100.0f;\n\tMaxPlayerHealth = 100.0f;\n\tHealthBarPosition = FVector2D(50, 50);\n\tHealthBarSize = FVector2D(200, 25);\n\tHealthBarColor = FLinearColor::Green;\n}\n\nvoid APlayerHealthHUD::DrawHUD()\n{\n\tSuper::DrawHUD();\n\n\t// Update PlayerHealth here with actual data\n\n\tDrawHealthBar();\n}\n\nvoid APlayerHealthHUD::DrawHealthBar()\n{\n\t// Calculate the width of the health bar based on current health\n\tfloat HealthPercentage = PlayerHealth / MaxPlayerHealth;\n\tfloat HealthBarWidth = HealthBarSize.X * HealthPercentage;\n\n\t// Draw the health bar background\n\tFCanvasTileItem BackgroundTile(HealthBarPosition, HealthBarSize, FLinearColor::Black);\n\tBackgroundTile.BlendMode = SE_BLEND_Translucent;\n\tCanvas->DrawItem(BackgroundTile);\n\n\t// Draw the health bar\n\tFCanvasTileItem HealthTile(HealthBarPosition, FVector2D(HealthBarWidth, HealthBarSize.Y), HealthBarColor);\n\tHealthTile.BlendMode = SE_BLEND_Translucent;\n\tCanvas->DrawItem(HealthTile);\n}\n```"}
{"requirement": "Create a basic inventory system with an array of items.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InventorySystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FInventoryItem\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Inventory\")\n\tFString ItemName;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Inventory\")\n\tint32 Quantity;\n\n\tFInventoryItem() : ItemName(\"\"), Quantity(0) {}\n};\n\nUCLASS()\nclass AInventorySystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAInventorySystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Inventory\")\n\tTArray<FInventoryItem> Items;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tvoid AddItem(const FString& ItemName, int32 Quantity);\n};\n```", "cpp_code": "```cpp\n#include \"InventorySystem.h\"\n\nAInventorySystem::AInventorySystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AInventorySystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AInventorySystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AInventorySystem::AddItem(const FString& ItemName, int32 Quantity)\n{\n\tfor (FInventoryItem& Item : Items)\n\t{\n\t\tif (Item.ItemName == ItemName)\n\t\t{\n\t\t\tItem.Quantity += Quantity;\n\t\t\treturn;\n\t\t}\n\t}\n\tFInventoryItem NewItem;\n\tNewItem.ItemName = ItemName;\n\tNewItem.Quantity = Quantity;\n\tItems.Add(NewItem);\n}\n```"}
{"requirement": "Add a sound effect that plays when an actor is clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"ClickableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AClickableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAClickableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tUSoundBase* ClickSound;\n\n\tUFUNCTION()\n\tvoid OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n};\n```", "cpp_code": "```cpp\n#include \"ClickableActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\nAClickableActor::AClickableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tOnClicked.AddDynamic(this, &AClickableActor::OnClicked);\n}\n\nvoid AClickableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AClickableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AClickableActor::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tif (ClickSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, ClickSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Implement a simple save and load system for player score.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/SaveGame.h\"\n#include \"PlayerScoreSaveGame.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UPlayerScoreSaveGame : public USaveGame\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPlayerScoreSaveGame();\n\n\tUPROPERTY(VisibleAnywhere, Category = Basic)\n\tint32 PlayerScore;\n};\n\nUCLASS()\nclass YOURGAME_API AYourGameGameModeBase : public AGameModeBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tvoid SavePlayerScore(int32 Score);\n\tint32 LoadPlayerScore();\n};\n```", "cpp_code": "```cpp\n#include \"PlayerScoreSaveGame.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUPlayerScoreSaveGame::UPlayerScoreSaveGame()\n{\n\tPlayerScore = 0;\n}\n\nvoid AYourGameGameModeBase::SavePlayerScore(int32 Score)\n{\n\tUPlayerScoreSaveGame* SaveGameInstance = Cast<UPlayerScoreSaveGame>(UGameplayStatics::CreateSaveGameObject(UPlayerScoreSaveGame::StaticClass()));\n\tif (SaveGameInstance)\n\t{\n\t\tSaveGameInstance->PlayerScore = Score;\n\t\tUGameplayStatics::SaveGameToSlot(SaveGameInstance, TEXT(\"PlayerScoreSlot\"), 0);\n\t}\n}\n\nint32 AYourGameGameModeBase::LoadPlayerScore()\n{\n\tUPlayerScoreSaveGame* LoadGameInstance = Cast<UPlayerScoreSaveGame>(UGameplayStatics::LoadGameFromSlot(TEXT(\"PlayerScoreSlot\"), 0));\n\tif (LoadGameInstance)\n\t{\n\t\treturn LoadGameInstance->PlayerScore;\n\t}\n\treturn 0;\n}\n```"}
{"requirement": "Create a projectile that moves forward when spawned.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Projectile.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AProjectile : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AProjectile();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n  UStaticMeshComponent* ProjectileMesh;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Movement\")\n  float MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"Projectile.h\"\n#include \"GameFramework/ProjectileMovementComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nAProjectile::AProjectile()\n{\n  PrimaryActorTick.bCanEverTick = true;\n\n  ProjectileMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"ProjectileMesh\"));\n  RootComponent = ProjectileMesh;\n\n  MovementSpeed = 1000.0f;\n}\n\nvoid AProjectile::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AProjectile::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  FVector NewLocation = GetActorLocation() + GetActorForwardVector() * MovementSpeed * DeltaTime;\n  SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Add a function to check if a character is in the air.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Function to check if the character is in the air\n\tUFUNCTION(BlueprintCallable, Category=\"Character\")\n\tbool IsInAir() const;\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n\nbool AMyCharacter::IsInAir() const\n{\n\treturn GetCharacterMovement()->IsFalling();\n}\n```"}
{"requirement": "Implement a basic countdown timer on the HUD.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/HUD.h\"\n#include \"CountdownTimerHUD.generated.h\"\n\nUCLASS()\nclass MYGAME_API ACountdownTimerHUD : public AHUD\n{\n\tGENERATED_BODY()\n\npublic:\n\tACountdownTimerHUD();\n\n\tvirtual void DrawHUD() override;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tfloat CountdownTime;\n\tFText CountdownText;\n\tFTimerHandle CountdownTimerHandle;\n\n\tvoid UpdateCountdownDisplay();\n\tvoid CountdownHasFinished();\n};\n```", "cpp_code": "```cpp\n#include \"CountdownTimerHUD.h\"\n#include \"Engine/Canvas.h\"\n#include \"Engine/Font.h\"\n#include \"TimerManager.h\"\n\nACountdownTimerHUD::ACountdownTimerHUD()\n{\n\tCountdownTime = 60.0f; // Set initial countdown time in seconds\n}\n\nvoid ACountdownTimerHUD::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Start the countdown timer\n\tGetWorldTimerManager().SetTimer(CountdownTimerHandle, this, &ACountdownTimerHUD::UpdateCountdownDisplay, 1.0f, true);\n}\n\nvoid ACountdownTimerHUD::DrawHUD()\n{\n\tSuper::DrawHUD();\n\n\t// Draw the countdown timer text on the screen\n\tif (GEngine && GEngine->GetMediumFont())\n\t{\n\t\tFVector2D ScreenDimensions = FVector2D(Canvas->SizeX, Canvas->SizeY);\n\t\tFVector2D TextSize;\n\t\tGetTextSize(CountdownText.ToString(), TextSize.X, TextSize.Y, GEngine->GetMediumFont());\n\t\tFVector2D TextPosition = FVector2D(ScreenDimensions.X / 2.0f - TextSize.X / 2.0f, 50.0f);\n\t\tFCanvasTextItem TextItem(TextPosition, CountdownText, GEngine->GetMediumFont(), FLinearColor::White);\n\t\tCanvas->DrawItem(TextItem);\n\t}\n}\n\nvoid ACountdownTimerHUD::UpdateCountdownDisplay()\n{\n\tif (CountdownTime > 0)\n\t{\n\t\tCountdownTime--;\n\t\tCountdownText = FText::FromString(FString::Printf(TEXT(\"Time Remaining: %d\"), FMath::CeilToInt(CountdownTime)));\n\t}\n\telse\n\t{\n\t\tCountdownHasFinished();\n\t}\n}\n\nvoid ACountdownTimerHUD::CountdownHasFinished()\n{\n\tGetWorldTimerManager().ClearTimer(CountdownTimerHandle);\n\tCountdownText = FText::FromString(TEXT(\"Time's Up!\"));\n}\n```"}
{"requirement": "Create a character that can crouch with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"CrouchingCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ACrouchingCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tACrouchingCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid StartCrouch();\n\tvoid StopCrouch();\n};\n```", "cpp_code": "```cpp\n#include \"CrouchingCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nACrouchingCharacter::ACrouchingCharacter()\n{\n\t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ACrouchingCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACrouchingCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid ACrouchingCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"Crouch\", IE_Pressed, this, &ACrouchingCharacter::StartCrouch);\n\tPlayerInputComponent->BindAction(\"Crouch\", IE_Released, this, &ACrouchingCharacter::StopCrouch);\n}\n\nvoid ACrouchingCharacter::StartCrouch()\n{\n\tCrouch();\n}\n\nvoid ACrouchingCharacter::StopCrouch()\n{\n\tUnCrouch();\n}\n```"}
{"requirement": "Add a function to respawn a character at a specific location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyCharacter : public ACharacter\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this character's properties\n  AMyCharacter();\n\n  // Function to respawn the character at a specific location\n  UFUNCTION(BlueprintCallable, Category = \"Respawn\")\n  void RespawnAtLocation(const FVector& NewLocation);\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n\n// Sets default values\nAMyCharacter::AMyCharacter()\n{\n  // Set this character to call Tick() every frame.\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyCharacter::RespawnAtLocation(const FVector& NewLocation)\n{\n  // Set the new location for the character\n  SetActorLocation(NewLocation);\n\n  // Additional logic for respawning can be added here\n}\n```"}
{"requirement": "Implement a simple fade-in effect on level start.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FadeInEffect.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AFadeInEffect : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAFadeInEffect();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Fade\")\n\tfloat FadeDuration;\n\n\tUFUNCTION()\n\tvoid StartFadeIn();\n};\n```", "cpp_code": "```cpp\n#include \"FadeInEffect.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nAFadeInEffect::AFadeInEffect()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tFadeDuration = 2.0f; // Default fade duration\n}\n\nvoid AFadeInEffect::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartFadeIn();\n}\n\nvoid AFadeInEffect::StartFadeIn()\n{\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tPlayerController->PlayerCameraManager->StartCameraFade(1.0f, 0.0f, FadeDuration, FLinearColor::Black);\n\t}\n}\n```"}
{"requirement": "Create a basic day-night cycle with a directional light.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DayNightCycle.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADayNightCycle : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADayNightCycle();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"DayNight\")\n\tfloat DayLengthInSeconds;\n\n\tUPROPERTY(EditAnywhere, Category = \"DayNight\")\n\tADirectionalLight* DirectionalLight;\n\n\tfloat CurrentTimeOfDay;\n};\n```", "cpp_code": "```cpp\n#include \"DayNightCycle.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/DirectionalLight.h\"\n\nADayNightCycle::ADayNightCycle()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tDayLengthInSeconds = 120.0f; // 2 minutes for a full cycle\n\tCurrentTimeOfDay = 0.0f;\n}\n\nvoid ADayNightCycle::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (DirectionalLight == nullptr)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"DirectionalLight not set on DayNightCycle.\"));\n\t}\n}\n\nvoid ADayNightCycle::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DirectionalLight)\n\t{\n\t\tCurrentTimeOfDay += DeltaTime;\n\t\tif (CurrentTimeOfDay >= DayLengthInSeconds)\n\t\t{\n\t\t\tCurrentTimeOfDay = 0.0f;\n\t\t}\n\n\t\tfloat SunAngle = (CurrentTimeOfDay / DayLengthInSeconds) * 360.0f;\n\t\tFRotator NewRotation = FRotator(SunAngle, 0.0f, 0.0f);\n\t\tDirectionalLight->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Add a function to pause and resume the game.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"PauseGameMode.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APauseGameMode : public AGameModeBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPauseGameMode();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Game\")\n\tvoid PauseGame();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Game\")\n\tvoid ResumeGame();\n\nprivate:\n\tbool bIsGamePaused;\n};\n```", "cpp_code": "```cpp\n#include \"PauseGameMode.h\"\n\nAPauseGameMode::APauseGameMode()\n{\n\tbIsGamePaused = false;\n}\n\nvoid APauseGameMode::PauseGame()\n{\n\tif (!bIsGamePaused)\n\t{\n\t\tUGameplayStatics::SetGamePaused(GetWorld(), true);\n\t\tbIsGamePaused = true;\n\t}\n}\n\nvoid APauseGameMode::ResumeGame()\n{\n\tif (bIsGamePaused)\n\t{\n\t\tUGameplayStatics::SetGamePaused(GetWorld(), false);\n\t\tbIsGamePaused = false;\n\t}\n}\n```"}
{"requirement": "Implement a basic score system using integers.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScoreSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Score\")\n\tvoid AddScore(int32 Points);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Score\")\n\tint32 GetScore() const;\n\nprivate:\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreSystem.h\"\n\nAScoreSystem::AScoreSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScore = 0;\n}\n\nvoid AScoreSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScoreSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScoreSystem::AddScore(int32 Points)\n{\n\tScore += Points;\n}\n\nint32 AScoreSystem::GetScore() const\n{\n\treturn Score;\n}\n```"}
{"requirement": "Create a flashlight effect that toggles on and off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Flashlight.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFlashlight : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAFlashlight();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to toggle the flashlight\n\tUFUNCTION(BlueprintCallable, Category=\"Flashlight\")\n\tvoid ToggleFlashlight();\n\nprivate:\n\t// Point light component for the flashlight\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tclass UPointLightComponent* FlashlightLight;\n\n\t// Whether the flashlight is currently on\n\tbool bIsFlashlightOn;\n};\n```", "cpp_code": "```cpp\n#include \"Flashlight.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nAFlashlight::AFlashlight()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Point Light Component\n\tFlashlightLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"FlashlightLight\"));\n\tRootComponent = FlashlightLight;\n\n\t// Initialize the flashlight to be off\n\tbIsFlashlightOn = false;\n\tFlashlightLight->SetVisibility(bIsFlashlightOn);\n}\n\n// Called when the game starts or when spawned\nvoid AFlashlight::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AFlashlight::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Toggle the flashlight on and off\nvoid AFlashlight::ToggleFlashlight()\n{\n\tbIsFlashlightOn = !bIsFlashlightOn;\n\tFlashlightLight->SetVisibility(bIsFlashlightOn);\n}\n```"}
{"requirement": "Add a collision event that changes an actor's color.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionColorChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionColorChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionColorChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nACollisionColorChangeActor::ACollisionColorChangeActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetNotifyRigidBodyCollision(true);\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ACollisionColorChangeActor::OnHit);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionColorChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionColorChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionColorChangeActor::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", NewColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a basic sprint mechanic for a character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SprintCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASprintCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tASprintCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Sprint speed multiplier\n\tUPROPERTY(EditAnywhere, Category=\"Sprint\")\n\tfloat SprintMultiplier;\n\n\t// Default movement speed\n\tfloat DefaultWalkSpeed;\n\n\t// Function to start sprinting\n\tvoid StartSprinting();\n\n\t// Function to stop sprinting\n\tvoid StopSprinting();\n};\n```", "cpp_code": "```cpp\n#include \"SprintCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nASprintCharacter::ASprintCharacter()\n{\n\t// Set this character to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize sprint multiplier\n\tSprintMultiplier = 2.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASprintCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Save the default walk speed\n\tDefaultWalkSpeed = GetCharacterMovement()->MaxWalkSpeed;\n}\n\n// Called every frame\nvoid ASprintCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid ASprintCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind sprint actions\n\tPlayerInputComponent->BindAction(\"Sprint\", IE_Pressed, this, &ASprintCharacter::StartSprinting);\n\tPlayerInputComponent->BindAction(\"Sprint\", IE_Released, this, &ASprintCharacter::StopSprinting);\n}\n\nvoid ASprintCharacter::StartSprinting()\n{\n\t// Increase the character's speed\n\tGetCharacterMovement()->MaxWalkSpeed = DefaultWalkSpeed * SprintMultiplier;\n}\n\nvoid ASprintCharacter::StopSprinting()\n{\n\t// Reset the character's speed to default\n\tGetCharacterMovement()->MaxWalkSpeed = DefaultWalkSpeed;\n}\n```"}
{"requirement": "Create a simple health pickup that restores health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthPickup.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHealthPickup : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAHealthPickup();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat HealthAmount;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* CollisionComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tclass UStaticMeshComponent* PickupMesh;\n};\n```", "cpp_code": "```cpp\n#include \"HealthPickup.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourGameCharacter.h\"  // Replace with your character class\n\nAHealthPickup::AHealthPickup()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\tCollisionComponent->SetCollisionProfileName(TEXT(\"OverlapAll\"));\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AHealthPickup::OnOverlapBegin);\n\n\tPickupMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"PickupMesh\"));\n\tPickupMesh->SetupAttachment(RootComponent);\n\n\tHealthAmount = 50.0f;  // Default health amount\n}\n\nvoid AHealthPickup::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthPickup::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHealthPickup::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tAYourGameCharacter* Character = Cast<AYourGameCharacter>(OtherActor);  // Replace with your character class\n\t\tif (Character)\n\t\t{\n\t\t\tCharacter->ChangeHealth(HealthAmount);  // Assumes your character has a ChangeHealth function\n\t\t\tDestroy();  // Destroy the pickup after use\n\t\t}\n\t}\n}\n```"}
{"requirement": "Add a function to play an animation on an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Animation\")\n\tvoid PlayAnimation(UAnimSequence* AnimationToPlay);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyActor::PlayAnimation(UAnimSequence* AnimationToPlay)\n{\n\tif (SkeletalMeshComponent && AnimationToPlay)\n\t{\n\t\tSkeletalMeshComponent->PlayAnimation(AnimationToPlay, false);\n\t}\n}\n```"}
{"requirement": "Implement a basic zoom feature for the player camera.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ZoomCameraComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API UZoomCameraComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUZoomCameraComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Zoom\")\n\tfloat ZoomedFOV;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Zoom\")\n\tfloat ZoomInterpSpeed;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Zoom\")\n\tfloat DefaultFOV;\n\n\tvoid ZoomIn();\n\tvoid ZoomOut();\n\nprivate:\n\tbool bIsZoomedIn;\n\tclass UCameraComponent* CameraComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ZoomCameraComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Camera/CameraComponent.h\"\n\nUZoomCameraComponent::UZoomCameraComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tZoomedFOV = 65.0f;\n\tZoomInterpSpeed = 20.0f;\n\tDefaultFOV = 90.0f;\n\tbIsZoomedIn = false;\n}\n\nvoid UZoomCameraComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tCameraComponent = GetOwner()->FindComponentByClass<UCameraComponent>();\n\tif (CameraComponent)\n\t{\n\t\tDefaultFOV = CameraComponent->FieldOfView;\n\t}\n}\n\nvoid UZoomCameraComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (CameraComponent)\n\t{\n\t\tfloat TargetFOV = bIsZoomedIn ? ZoomedFOV : DefaultFOV;\n\t\tfloat CurrentFOV = CameraComponent->FieldOfView;\n\t\tCameraComponent->SetFieldOfView(FMath::FInterpTo(CurrentFOV, TargetFOV, DeltaTime, ZoomInterpSpeed));\n\t}\n}\n\nvoid UZoomCameraComponent::ZoomIn()\n{\n\tbIsZoomedIn = true;\n}\n\nvoid UZoomCameraComponent::ZoomOut()\n{\n\tbIsZoomedIn = false;\n}\n```"}
{"requirement": "Create a bounce effect when an actor hits the ground.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BouncingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ABouncingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tABouncingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Bounce\")\n\tfloat BounceFactor;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"BouncingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nABouncingActor::ABouncingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->SetNotifyRigidBodyCollision(true);\n\n\tBounceFactor = 1.0f;\n\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ABouncingActor::OnHit);\n}\n\nvoid ABouncingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ABouncingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ABouncingActor::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tFVector BounceVelocity = -NormalImpulse * BounceFactor;\n\t\tMeshComponent->AddImpulse(BounceVelocity, NAME_None, true);\n\t}\n}\n```"}
{"requirement": "Add a function to randomly change an actor's location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomLocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomLocationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARandomLocationActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"RandomLocation\")\n\tvoid ChangeLocationRandomly();\n\nprivate:\n\tFVector GetRandomLocationWithinBounds(const FVector& MinBounds, const FVector& MaxBounds) const;\n\n\tUPROPERTY(EditAnywhere, Category=\"RandomLocation\")\n\tFVector MinBounds;\n\n\tUPROPERTY(EditAnywhere, Category=\"RandomLocation\")\n\tFVector MaxBounds;\n};\n```", "cpp_code": "```cpp\n#include \"RandomLocationActor.h\"\n#include \"Engine/World.h\"\n#include \"Math/UnrealMathUtility.h\"\n\n// Sets default values\nARandomLocationActor::ARandomLocationActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Set default bounds\n\tMinBounds = FVector(-1000.0f, -1000.0f, 0.0f);\n\tMaxBounds = FVector(1000.0f, 1000.0f, 500.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ARandomLocationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARandomLocationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARandomLocationActor::ChangeLocationRandomly()\n{\n\tFVector NewLocation = GetRandomLocationWithinBounds(MinBounds, MaxBounds);\n\tSetActorLocation(NewLocation);\n}\n\nFVector ARandomLocationActor::GetRandomLocationWithinBounds(const FVector& MinBounds, const FVector& MaxBounds) const\n{\n\tfloat RandomX = FMath::FRandRange(MinBounds.X, MaxBounds.X);\n\tfloat RandomY = FMath::FRandRange(MinBounds.Y, MaxBounds.Y);\n\tfloat RandomZ = FMath::FRandRange(MinBounds.Z, MaxBounds.Z);\n\treturn FVector(RandomX, RandomY, RandomZ);\n}\n```"}
{"requirement": "Implement a simple fire rate control for a weapon.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Weapon.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AWeapon : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAWeapon();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to fire the weapon\n\tvoid Fire();\n\nprivate:\n\t// Fire rate in rounds per second\n\tUPROPERTY(EditAnywhere, Category = \"Weapon\")\n\tfloat FireRate;\n\n\t// Time since last fire\n\tfloat TimeSinceLastFire;\n};\n```", "cpp_code": "```cpp\n#include \"Weapon.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nAWeapon::AWeapon()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize fire rate and timer\n\tFireRate = 1.0f; // 1 round per second\n\tTimeSinceLastFire = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AWeapon::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AWeapon::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update time since last fire\n\tTimeSinceLastFire += DeltaTime;\n}\n\nvoid AWeapon::Fire()\n{\n\tif (TimeSinceLastFire >= 1.0f / FireRate)\n\t{\n\t\t// Fire the weapon\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Weapon Fired!\"));\n\n\t\t// Reset the timer\n\t\tTimeSinceLastFire = 0.0f;\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Weapon can't fire yet!\"));\n\t}\n}\n```"}
{"requirement": "Create a character that can swim when in water.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SwimmableCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASwimmableCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tASwimmableCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid StartSwimming();\n\n\tUFUNCTION()\n\tvoid StopSwimming();\n\nprivate:\n\tbool bIsInWater;\n\tvoid CheckIfInWater();\n};\n```", "cpp_code": "```cpp\n#include \"SwimmableCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nASwimmableCharacter::ASwimmableCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsInWater = false;\n}\n\nvoid ASwimmableCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASwimmableCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tCheckIfInWater();\n}\n\nvoid ASwimmableCharacter::StartSwimming()\n{\n\t// Logic to start swimming\n\t// E.g., change movement mode\n\tGetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_Swimming);\n}\n\nvoid ASwimmableCharacter::StopSwimming()\n{\n\t// Logic to stop swimming\n\t// E.g., revert movement mode\n\tGetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_Walking);\n}\n\nvoid ASwimmableCharacter::CheckIfInWater()\n{\n\t// Simple example of checking if character is in water\n\tif (GetActorLocation().Z < WaterLevel && !bIsInWater)\n\t{\n\t\tbIsInWater = true;\n\t\tStartSwimming();\n\t}\n\telse if (GetActorLocation().Z >= WaterLevel && bIsInWater)\n\t{\n\t\tbIsInWater = false;\n\t\tStopSwimming();\n\t}\n}\n```"}
{"requirement": "Add a function to log the player's current position.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PlayerPositionLogger.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APlayerPositionLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPlayerPositionLogger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Logs the player's current position\n\tUFUNCTION(BlueprintCallable, Category=\"Player\")\n\tvoid LogPlayerPosition();\n};\n```", "cpp_code": "```cpp\n#include \"PlayerPositionLogger.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAPlayerPositionLogger::APlayerPositionLogger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid APlayerPositionLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APlayerPositionLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APlayerPositionLogger::LogPlayerPosition()\n{\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tAPawn* PlayerPawn = PlayerController->GetPawn();\n\t\tif (PlayerPawn)\n\t\t{\n\t\t\tFVector PlayerLocation = PlayerPawn->GetActorLocation();\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Player Location: X=%f, Y=%f, Z=%f\"), PlayerLocation.X, PlayerLocation.Y, PlayerLocation.Z);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a simple gravity switch for an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GravitySwitchActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AGravitySwitchActor : public AActor\n{\n  GENERATED_BODY()\n\npublic: \n  AGravitySwitchActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic: \n  virtual void Tick(float DeltaTime) override;\n\n  UFUNCTION(BlueprintCallable, Category=\"Gravity\")\n  void ToggleGravity();\n\nprivate:\n  UPROPERTY(EditAnywhere, Category=\"Gravity\")\n  bool bIsGravityEnabled;\n};\n```", "cpp_code": "```cpp\n#include \"GravitySwitchActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nAGravitySwitchActor::AGravitySwitchActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n  bIsGravityEnabled = true;\n}\n\nvoid AGravitySwitchActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AGravitySwitchActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AGravitySwitchActor::ToggleGravity()\n{\n  bIsGravityEnabled = !bIsGravityEnabled;\n  TArray<UActorComponent*> Components = GetComponentsByClass(UPrimitiveComponent::StaticClass());\n  for (UActorComponent* Component : Components)\n  {\n\tif (UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(Component))\n\t{\n\t  PrimitiveComponent->SetEnableGravity(bIsGravityEnabled);\n\t}\n  }\n}\n```"}
{"requirement": "Create a console command that prints a custom message.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintMessageConsoleCommand.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APrintMessageConsoleCommand : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPrintMessageConsoleCommand();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid PrintCustomMessage();\n};\n```", "cpp_code": "```cpp\n#include \"PrintMessageConsoleCommand.h\"\n#include \"Engine/Engine.h\"\n\nAPrintMessageConsoleCommand::APrintMessageConsoleCommand()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APrintMessageConsoleCommand::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (GEngine)\n\t{\n\t\tGEngine->Exec(GetWorld(), TEXT(\"ce PrintCustomMessage\"));\n\t}\n}\n\nvoid APrintMessageConsoleCommand::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APrintMessageConsoleCommand::PrintCustomMessage()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"This is a custom message from the console command!\"));\n\t}\n}\n\nstatic FAutoConsoleCommand PrintCustomMessageCommand = FAutoConsoleCommand(\n\tTEXT(\"PrintCustomMessage\"),\n\tTEXT(\"Executes the PrintCustomMessage function.\"),\n\tFConsoleCommandDelegate::CreateStatic(&APrintMessageConsoleCommand::PrintCustomMessage)\n);\n```"}
{"requirement": "Add a function to toggle an actor's visibility.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleVisibilityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visibility\")\n\tvoid ToggleVisibility();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tSetActorHiddenInGame(!bHidden);\n\tSetActorEnableCollision(!bHidden);\n\tSetActorTickEnabled(!bHidden);\n}\n```"}
{"requirement": "Implement a basic health regeneration system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthRegenSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHealthRegenSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAHealthRegenSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat MaxHealth;\n\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat CurrentHealth;\n\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat RegenRate;\n\n\tvoid RegenerateHealth(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"HealthRegenSystem.h\"\n\nAHealthRegenSystem::AHealthRegenSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMaxHealth = 100.0f;\n\tCurrentHealth = 50.0f;\n\tRegenRate = 5.0f; // Health per second\n}\n\nvoid AHealthRegenSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthRegenSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tRegenerateHealth(DeltaTime);\n}\n\nvoid AHealthRegenSystem::RegenerateHealth(float DeltaTime)\n{\n\tif (CurrentHealth < MaxHealth)\n\t{\n\t\tCurrentHealth += RegenRate * DeltaTime;\n\t\tif (CurrentHealth > MaxHealth)\n\t\t{\n\t\t\tCurrentHealth = MaxHealth;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a simple checkpoint system for a player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CheckpointSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ACheckpointSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACheckpointSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to set a checkpoint\n\tUFUNCTION(BlueprintCallable, Category = \"Checkpoint\")\n\tvoid SetCheckpoint(FVector NewCheckpointLocation);\n\n\t// Function to get the last checkpoint location\n\tUFUNCTION(BlueprintCallable, Category = \"Checkpoint\")\n\tFVector GetCheckpoint() const;\n\nprivate:\n\t// Variable to store the last checkpoint location\n\tFVector CheckpointLocation;\n};\n```", "cpp_code": "```cpp\n#include \"CheckpointSystem.h\"\n\n// Sets default values\nACheckpointSystem::ACheckpointSystem()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ACheckpointSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Initialize the checkpoint location to a default value, e.g., the actor's starting location\n\tCheckpointLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid ACheckpointSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACheckpointSystem::SetCheckpoint(FVector NewCheckpointLocation)\n{\n\tCheckpointLocation = NewCheckpointLocation;\n}\n\nFVector ACheckpointSystem::GetCheckpoint() const\n{\n\treturn CheckpointLocation;\n}\n```"}
{"requirement": "Add a function to rotate an actor towards a point.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotatableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Rotation\")\n\tvoid RotateTowardsPoint(const FVector& TargetPoint);\n};\n```", "cpp_code": "```cpp\n#include \"RotatableActor.h\"\n#include \"GameFramework/Actor.h\"\n\nARotatableActor::ARotatableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARotatableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARotatableActor::RotateTowardsPoint(const FVector& TargetPoint)\n{\n\tFVector Direction = TargetPoint - GetActorLocation();\n\tDirection.Z = 0.0f; // Assuming you want to rotate only on the Z axis\n\tFRotator NewRotation = Direction.Rotation();\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a basic wall jump mechanic for a character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"WallJumpCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AWallJumpCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWallJumpCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tbool bIsWallJumping;\n\tFVector WallNormal;\n\n\tUFUNCTION()\n\tvoid OnWallJump();\n\n\tvoid CheckForWall();\n};\n```", "cpp_code": "```cpp\n#include \"WallJumpCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/InputComponent.h\"\n\nAWallJumpCharacter::AWallJumpCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsWallJumping = false;\n}\n\nvoid AWallJumpCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AWallJumpCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tCheckForWall();\n}\n\nvoid AWallJumpCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"WallJump\", IE_Pressed, this, &AWallJumpCharacter::OnWallJump);\n}\n\nvoid AWallJumpCharacter::OnWallJump()\n{\n\tif (bIsWallJumping)\n\t{\n\t\tFVector JumpDirection = FVector::UpVector + WallNormal * 0.5f;\n\t\tLaunchCharacter(JumpDirection * 600.0f, true, true);\n\t\tbIsWallJumping = false;\n\t}\n}\n\nvoid AWallJumpCharacter::CheckForWall()\n{\n\tFVector Start = GetActorLocation();\n\tFVector ForwardVector = GetActorForwardVector();\n\tFVector End = ((ForwardVector * 100.0f) + Start);\n\tFHitResult HitResult;\n\tFCollisionQueryParams CollisionParams;\n\n\tif (GetWorld()->LineTraceSingleByChannel(HitResult, Start, End, ECC_Visibility, CollisionParams))\n\t{\n\t\tif (HitResult.bBlockingHit)\n\t\t{\n\t\t\tWallNormal = HitResult.Normal;\n\t\t\tbIsWallJumping = true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tbIsWallJumping = false;\n\t}\n}\n```"}
{"requirement": "Create an actor that changes size over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SizeChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASizeChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASizeChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialScale;\n\tUPROPERTY(EditAnywhere, Category = \"Size\")\n\tfloat ScaleFactor;\n\tUPROPERTY(EditAnywhere, Category = \"Size\")\n\tfloat Speed;\n};\n```", "cpp_code": "```cpp\n#include \"SizeChangingActor.h\"\n\n// Sets default values\nASizeChangingActor::ASizeChangingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tInitialScale = FVector(1.0f);\n\tScaleFactor = 1.0f;\n\tSpeed = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASizeChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tInitialScale = GetActorScale3D();\n}\n\n// Called every frame\nvoid ASizeChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat NewScaleFactor = ScaleFactor + FMath::Sin(GetWorld()->TimeSeconds * Speed) * 0.5f;\n\tSetActorScale3D(InitialScale * NewScaleFactor);\n}\n```"}
{"requirement": "Add a function to check if an actor is in a trigger box.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyTriggerBox.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyTriggerBox : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyTriggerBox();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Trigger\")\n\tbool IsActorInTriggerBox(AActor* ActorToCheck) const;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* TriggerBoxComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyTriggerBox.h\"\n#include \"Components/BoxComponent.h\"\n\nAMyTriggerBox::AMyTriggerBox()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tTriggerBoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerBoxComponent\"));\n\tRootComponent = TriggerBoxComponent;\n}\n\nvoid AMyTriggerBox::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nbool AMyTriggerBox::IsActorInTriggerBox(AActor* ActorToCheck) const\n{\n\tif (!ActorToCheck || !TriggerBoxComponent)\n\t{\n\t\treturn false;\n\t}\n\n\treturn TriggerBoxComponent->IsOverlappingActor(ActorToCheck);\n}\n```"}
{"requirement": "Implement a basic energy system with a depletion rate.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EnergySystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AEnergySystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAEnergySystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Energy value\n\tUPROPERTY(EditAnywhere, Category = \"Energy\")\n\tfloat Energy;\n\n\t// Energy depletion rate per second\n\tUPROPERTY(EditAnywhere, Category = \"Energy\")\n\tfloat DepletionRate;\n\n\t// Function to deplete energy\n\tvoid DepleteEnergy(float DeltaTime);\n\n\t// Function to handle energy reaching zero\n\tvoid OnEnergyDepleted();\n};\n```", "cpp_code": "```cpp\n#include \"EnergySystem.h\"\n\n// Sets default values\nAEnergySystem::AEnergySystem()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize energy and depletion rate\n\tEnergy = 100.0f;\n\tDepletionRate = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AEnergySystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AEnergySystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Deplete energy based on the delta time\n\tDepleteEnergy(DeltaTime);\n}\n\nvoid AEnergySystem::DepleteEnergy(float DeltaTime)\n{\n\tEnergy -= DepletionRate * DeltaTime;\n\n\t// Clamp the energy to zero to prevent negative values\n\tif (Energy <= 0.0f)\n\t{\n\t\tEnergy = 0.0f;\n\t\tOnEnergyDepleted();\n\t}\n}\n\nvoid AEnergySystem::OnEnergyDepleted()\n{\n\t// Handle what happens when energy is depleted\n\tUE_LOG(LogTemp, Warning, TEXT(\"Energy Depleted!\"));\n\t// Additional logic for energy depletion can be added here\n}\n```"}
{"requirement": "Create a rain effect with a particle system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RainParticleSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARainParticleSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARainParticleSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The particle system component for rain\n\tUPROPERTY(VisibleAnywhere)\n\tclass UParticleSystemComponent* RainParticleSystemComponent;\n\n\t// Function to initialize the particle system\n\tvoid InitializeRainParticleSystem();\n};\n```", "cpp_code": "```cpp\n#include \"RainParticleSystem.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nARainParticleSystem::ARainParticleSystem()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the particle system component and attach it to the root\n\tRainParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"RainParticleSystem\"));\n\tRootComponent = RainParticleSystemComponent;\n\n\t// Load the rain particle system asset\n\tstatic ConstructorHelpers::FObjectFinder<UParticleSystem> ParticleSystemAsset(TEXT(\"/Game/PathToYourParticleSystem/PS_Rain\"));\n\tif (ParticleSystemAsset.Succeeded())\n\t{\n\t\tRainParticleSystemComponent->SetTemplate(ParticleSystemAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ARainParticleSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tInitializeRainParticleSystem();\n}\n\n// Called every frame\nvoid ARainParticleSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARainParticleSystem::InitializeRainParticleSystem()\n{\n\t// Additional setup for the particle system can be done here\n\tRainParticleSystemComponent->ActivateSystem();\n}\n```"}
{"requirement": "Add a function to explode an actor on key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ExplodingActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AExplodingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AExplodingActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:  \n  virtual void Tick(float DeltaTime) override;\n\n  UFUNCTION()\n  void Explode();\n\nprivate:\n  void SetupInputComponent();\n\n  UPROPERTY(EditAnywhere)\n  float ExplosionRadius;\n\n  UPROPERTY(EditAnywhere)\n  float ExplosionStrength;\n};\n```", "cpp_code": "```cpp\n#include \"ExplodingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAExplodingActor::AExplodingActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AExplodingActor::BeginPlay()\n{\n  Super::BeginPlay();\n  SetupInputComponent();\n}\n\nvoid AExplodingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AExplodingActor::Explode()\n{\n  UGameplayStatics::ApplyRadialDamage(\n\tthis,\n\tExplosionStrength,\n\tGetActorLocation(),\n\tExplosionRadius,\n\tnullptr,\n\tTArray<AActor*>(),\n\tthis,\n\tGetInstigatorController(),\n\ttrue\n  );\n  Destroy();\n}\n\nvoid AExplodingActor::SetupInputComponent()\n{\n  if (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n  {\n\tif (InputComponent == nullptr)\n\t{\n\t  InputComponent = NewObject<UInputComponent>(this);\n\t  InputComponent->RegisterComponent();\n\t}\n\tInputComponent->BindAction(\"Explode\", IE_Pressed, this, &AExplodingActor::Explode);\n\tPlayerController->PushInputComponent(InputComponent);\n  }\n}\n```"}
{"requirement": "Implement a simple flashlight with battery life.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Flashlight.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFlashlight : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFlashlight();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Flashlight\")\n\tbool bIsOn;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Flashlight\")\n\tfloat BatteryLife;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Flashlight\")\n\tfloat BatteryDrainRate;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Flashlight\")\n\tvoid ToggleFlashlight();\n\nprivate:\n\tvoid DrainBattery(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"Flashlight.h\"\n\nAFlashlight::AFlashlight()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsOn = false;\n\tBatteryLife = 100.0f;\n\tBatteryDrainRate = 1.0f;\n}\n\nvoid AFlashlight::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AFlashlight::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsOn)\n\t{\n\t\tDrainBattery(DeltaTime);\n\t}\n}\n\nvoid AFlashlight::ToggleFlashlight()\n{\n\tif (BatteryLife > 0.0f)\n\t{\n\t\tbIsOn = !bIsOn;\n\t}\n\telse\n\t{\n\t\tbIsOn = false;\n\t}\n}\n\nvoid AFlashlight::DrainBattery(float DeltaTime)\n{\n\tif (BatteryLife > 0.0f)\n\t{\n\t\tBatteryLife -= BatteryDrainRate * DeltaTime;\n\t\tif (BatteryLife <= 0.0f)\n\t\t{\n\t\t\tBatteryLife = 0.0f;\n\t\t\tbIsOn = false;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a character that can slide under obstacles.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SlidingCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASlidingCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tASlidingCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sliding\")\n\tfloat SlideSpeed;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sliding\")\n\tfloat SlideDuration;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Sliding\")\n\tvoid StartSlide();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Sliding\")\n\tvoid StopSlide();\n\nprivate:\n\tFTimerHandle SlideTimerHandle;\n\tbool bIsSliding;\n};\n```", "cpp_code": "```cpp\n#include \"SlidingCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"TimerManager.h\"\n\nASlidingCharacter::ASlidingCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSlideSpeed = 600.0f;\n\tSlideDuration = 1.0f;\n\tbIsSliding = false;\n}\n\nvoid ASlidingCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASlidingCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tif (bIsSliding)\n\t{\n\t\tFVector SlideDirection = GetActorForwardVector();\n\t\tAddMovementInput(SlideDirection, SlideSpeed * DeltaTime);\n\t}\n}\n\nvoid ASlidingCharacter::StartSlide()\n{\n\tif (!bIsSliding)\n\t{\n\t\tbIsSliding = true;\n\t\tGetCharacterMovement()->MaxWalkSpeed = SlideSpeed;\n\t\tGetWorldTimerManager().SetTimer(SlideTimerHandle, this, &ASlidingCharacter::StopSlide, SlideDuration, false);\n\t}\n}\n\nvoid ASlidingCharacter::StopSlide()\n{\n\tbIsSliding = false;\n\tGetCharacterMovement()->MaxWalkSpeed = 600.0f; // Reset to default walk speed\n\tGetWorldTimerManager().ClearTimer(SlideTimerHandle);\n}\n```"}
{"requirement": "Add a function to log the current level name.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LevelLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALevelLogger : public AActor\n{\n  GENERATED_BODY()\n\npublic:  \n  ALevelLogger();\n\n  UFUNCTION(BlueprintCallable, Category=\"Logging\")\n  void LogCurrentLevelName();\n};\n```", "cpp_code": "```cpp\n#include \"LevelLogger.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nALevelLogger::ALevelLogger()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ALevelLogger::LogCurrentLevelName()\n{\n  if (UWorld* World = GetWorld())\n  {\n\tFString LevelName = UGameplayStatics::GetCurrentLevelName(World);\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Level Name: %s\"), *LevelName);\n  }\n}\n```"}
{"requirement": "Implement a basic health bar with UMG.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"HealthBarWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API UHealthBarWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Health\")\n\tvoid SetHealthPercentage(float HealthPercentage);\n\nprotected:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UProgressBar* HealthProgressBar;\n};\n```", "cpp_code": "```cpp\n#include \"HealthBarWidget.h\"\n#include \"Components/ProgressBar.h\"\n\nvoid UHealthBarWidget::SetHealthPercentage(float HealthPercentage)\n{\n\tif (HealthProgressBar)\n\t{\n\t\tHealthProgressBar->SetPercent(HealthPercentage);\n\t}\n}\n```"}
{"requirement": "Create a simple wind effect that moves actors.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WindEffectActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWindEffectActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAWindEffectActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Wind\")\n\tFVector WindDirection;\n\n\tUPROPERTY(EditAnywhere, Category = \"Wind\")\n\tfloat WindStrength;\n};\n```", "cpp_code": "```cpp\n#include \"WindEffectActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAWindEffectActor::AWindEffectActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tWindDirection = FVector(1.0f, 0.0f, 0.0f);\n\tWindStrength = 100.0f;\n}\n\nvoid AWindEffectActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AWindEffectActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector Movement = WindDirection * WindStrength * DeltaTime;\n\tfor (TActorIterator<AActor> It(GetWorld()); It; ++It)\n\t{\n\t\tAActor* Actor = *It;\n\t\tif (Actor != this)\n\t\t{\n\t\t\tActor->AddActorWorldOffset(Movement);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Add a function to check the player's speed.", "header_code": "```cpp\nUCLASS()\nclass YOURGAME_API APlayerCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Function to get the player's current speed\n\tUFUNCTION(BlueprintCallable, Category=\"Player\")\n\tfloat GetPlayerSpeed() const;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerCharacter.h\"\n\nfloat APlayerCharacter::GetPlayerSpeed() const\n{\n\treturn GetVelocity().Size();\n}\n```"}
{"requirement": "Implement a basic wall running mechanic.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"WallRunningCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AWallRunningCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWallRunningCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid StartWallRun();\n\n\tUFUNCTION()\n\tvoid StopWallRun();\n\n\tUFUNCTION()\n\tbool CanWallRun() const;\n\n\tUFUNCTION()\n\tvoid PerformWallRun(float DeltaTime);\n\nprivate:\n\tbool bIsWallRunning;\n\tFVector WallRunDirection;\n\n\tUPROPERTY(EditAnywhere, Category=\"WallRun\")\n\tfloat WallRunSpeed;\n\n\tUPROPERTY(EditAnywhere, Category=\"WallRun\")\n\tfloat WallRunDuration;\n\n\tUPROPERTY(EditAnywhere, Category=\"WallRun\")\n\tfloat WallRunGravityScale;\n};\n```", "cpp_code": "```cpp\n#include \"WallRunningCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/InputComponent.h\"\n\nAWallRunningCharacter::AWallRunningCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsWallRunning = false;\n\tWallRunSpeed = 600.0f;\n\tWallRunDuration = 1.0f;\n\tWallRunGravityScale = 0.3f;\n}\n\nvoid AWallRunningCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AWallRunningCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsWallRunning)\n\t{\n\t\tPerformWallRun(DeltaTime);\n\t}\n}\n\nvoid AWallRunningCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"WallRun\", IE_Pressed, this, &AWallRunningCharacter::StartWallRun);\n\tPlayerInputComponent->BindAction(\"WallRun\", IE_Released, this, &AWallRunningCharacter::StopWallRun);\n}\n\nvoid AWallRunningCharacter::StartWallRun()\n{\n\tif (CanWallRun())\n\t{\n\t\tbIsWallRunning = true;\n\t\tGetCharacterMovement()->GravityScale = WallRunGravityScale;\n\t\tWallRunDirection = GetActorRightVector(); // Assume wall on the right for simplicity\n\t}\n}\n\nvoid AWallRunningCharacter::StopWallRun()\n{\n\tbIsWallRunning = false;\n\tGetCharacterMovement()->GravityScale = 1.0f;\n}\n\nbool AWallRunningCharacter::CanWallRun() const\n{\n\t// Add logic to check if wall run is possible (e.g., raycasting to check for nearby walls)\n\treturn true;\n}\n\nvoid AWallRunningCharacter::PerformWallRun(float DeltaTime)\n{\n\tif (!bIsWallRunning) return;\n\n\tFVector NewLocation = GetActorLocation() + WallRunDirection * WallRunSpeed * DeltaTime;\n\tSetActorLocation(NewLocation);\n\n\tWallRunDuration -= DeltaTime;\n\tif (WallRunDuration <= 0.0f)\n\t{\n\t\tStopWallRun();\n\t}\n}\n```"}
{"requirement": "Create a simple collectable coin system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Coin.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ACoin : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACoin();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle the collection of the coin\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprivate:\n\t// Sphere component to detect overlaps\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tclass USphereComponent* CollisionComponent;\n\n\t// Static mesh for the coin\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tclass UStaticMeshComponent* CoinMesh;\n\n\t// Coin value\n\tUPROPERTY(EditAnywhere, Category = \"Coin\")\n\tint32 CoinValue;\n};\n```", "cpp_code": "```cpp\n#include \"Coin.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nACoin::ACoin()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set up the sphere component\n\tCollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\tCollisionComponent->InitSphereRadius(50.0f);\n\tCollisionComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\n\t// Create and set up the static mesh component\n\tCoinMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"CoinMesh\"));\n\tCoinMesh->SetupAttachment(RootComponent);\n\n\t// Set default coin value\n\tCoinValue = 10;\n\n\t// Register the overlap event\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACoin::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ACoin::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACoin::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACoin::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor != nullptr && OtherActor != this && OtherComp != nullptr)\n\t{\n\t\t// Implement logic to add the coin value to the player's total\n\t\t// For example, cast to the player's character and increase the score\n\t\tDestroy(); // Destroy the coin after collection\n\t}\n}\n```"}
{"requirement": "Add a function to change the skybox during play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SkyboxChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASkyboxChanger : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tASkyboxChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Skybox\")\n\tvoid ChangeSkybox(UStaticMesh* NewSkybox);\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* SkyboxMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SkyboxChanger.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nASkyboxChanger::ASkyboxChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSkyboxMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"SkyboxMeshComponent\"));\n\tRootComponent = SkyboxMeshComponent;\n}\n\nvoid ASkyboxChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASkyboxChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASkyboxChanger::ChangeSkybox(UStaticMesh* NewSkybox)\n{\n\tif (SkyboxMeshComponent && NewSkybox)\n\t{\n\t\tSkyboxMeshComponent->SetStaticMesh(NewSkybox);\n\t}\n}\n```"}
{"requirement": "Implement a basic dual-wield weapon system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DualWieldWeaponSystem.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADualWieldWeaponSystem : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tADualWieldWeaponSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to equip weapons\n\tUFUNCTION(BlueprintCallable, Category=\"Weapon\")\n\tvoid EquipWeapons(AActor* LeftWeapon, AActor* RightWeapon);\n\n\t// Function to fire left weapon\n\tUFUNCTION(BlueprintCallable, Category=\"Weapon\")\n\tvoid FireLeftWeapon();\n\n\t// Function to fire right weapon\n\tUFUNCTION(BlueprintCallable, Category=\"Weapon\")\n\tvoid FireRightWeapon();\n\nprivate:\n\t// Pointers to the weapons\n\tUPROPERTY()\n\tAActor* LeftWeapon;\n\n\tUPROPERTY()\n\tAActor* RightWeapon;\n};\n```", "cpp_code": "```cpp\n#include \"DualWieldWeaponSystem.h\"\n\n// Sets default values\nADualWieldWeaponSystem::ADualWieldWeaponSystem()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tLeftWeapon = nullptr;\n\tRightWeapon = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid ADualWieldWeaponSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ADualWieldWeaponSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ADualWieldWeaponSystem::EquipWeapons(AActor* NewLeftWeapon, AActor* NewRightWeapon)\n{\n\tif (NewLeftWeapon)\n\t{\n\t\tLeftWeapon = NewLeftWeapon;\n\t\t// Additional logic for equipping left weapon can be added here\n\t}\n\tif (NewRightWeapon)\n\t{\n\t\tRightWeapon = NewRightWeapon;\n\t\t// Additional logic for equipping right weapon can be added here\n\t}\n}\n\nvoid ADualWieldWeaponSystem::FireLeftWeapon()\n{\n\tif (LeftWeapon)\n\t{\n\t\t// Logic to fire the left weapon\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Firing Left Weapon!\"));\n\t}\n}\n\nvoid ADualWieldWeaponSystem::FireRightWeapon()\n{\n\tif (RightWeapon)\n\t{\n\t\t// Logic to fire the right weapon\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Firing Right Weapon!\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that spins when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpinActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpinActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tASpinActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle click event\n\tUFUNCTION()\n\tvoid OnClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed);\n\nprivate:\n\t// Rotation speed\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed;\n\n\t// Flag to check if spinning\n\tbool bIsSpinning;\n\n\t// Root component\n\tUSceneComponent* RootComp;\n\n\t// Static Mesh\n\tUStaticMeshComponent* MeshComp;\n};\n```", "cpp_code": "```cpp\n#include \"SpinActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nASpinActor::ASpinActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create root component\n\tRootComp = CreateDefaultSubobject<USceneComponent>(TEXT(\"RootComponent\"));\n\tRootComponent = RootComp;\n\n\t// Create static mesh component\n\tMeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComp->SetupAttachment(RootComp);\n\n\t// Enable click events\n\tMeshComp->SetMobility(EComponentMobility::Movable);\n\tMeshComp->OnClicked.AddDynamic(this, &ASpinActor::OnClicked);\n\n\t// Initialize variables\n\tRotationSpeed = 180.0f;\n\tbIsSpinning = false;\n}\n\n// Called when the game starts or when spawned\nvoid ASpinActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpinActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsSpinning)\n\t{\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n\nvoid ASpinActor::OnClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed)\n{\n\tbIsSpinning = !bIsSpinning;\n}\n```"}
{"requirement": "Add a function to toggle slow motion.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SlowMotionToggle.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASlowMotionToggle : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASlowMotionToggle();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"TimeControl\")\n\tvoid ToggleSlowMotion();\n\nprivate:\n\tbool bIsSlowMotionActive;\n};\n```", "cpp_code": "```cpp\n#include \"SlowMotionToggle.h\"\n#include \"GameFramework/WorldSettings.h\"\n\nASlowMotionToggle::ASlowMotionToggle()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsSlowMotionActive = false;\n}\n\nvoid ASlowMotionToggle::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASlowMotionToggle::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASlowMotionToggle::ToggleSlowMotion()\n{\n\tif (GetWorld())\n\t{\n\t\tUWorld* World = GetWorld();\n\t\tAWorldSettings* WorldSettings = World->GetWorldSettings();\n\t\tif (bIsSlowMotionActive)\n\t\t{\n\t\t\tWorldSettings->SetTimeDilation(1.0f);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWorldSettings->SetTimeDilation(0.5f); // Adjust this value for desired slow motion effect\n\t\t}\n\t\tbIsSlowMotionActive = !bIsSlowMotionActive;\n\t}\n}\n```"}
{"requirement": "Implement a basic healing zone for the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealingZone.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHealingZone : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAHealingZone();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Healing\")\n\tfloat HealingRate;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass USphereComponent* CollisionComponent;\n\n\tUPROPERTY()\n\tTSet<AActor*> OverlappingPlayers;\n};\n```", "cpp_code": "```cpp\n#include \"HealingZone.h\"\n#include \"Components/SphereComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/Character.h\"\n#include \"TimerManager.h\"\n\nAHealingZone::AHealingZone()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"SphereComponent\"));\n\tCollisionComponent->InitSphereRadius(200.0f);\n\tCollisionComponent->SetCollisionProfileName(TEXT(\"Trigger\"));\n\tRootComponent = CollisionComponent;\n\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AHealingZone::OnOverlapBegin);\n\tCollisionComponent->OnComponentEndOverlap.AddDynamic(this, &AHealingZone::OnOverlapEnd);\n\n\tHealingRate = 5.0f;\n}\n\nvoid AHealingZone::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealingZone::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfor (AActor* Player : OverlappingPlayers)\n\t{\n\t\tif (ACharacter* Character = Cast<ACharacter>(Player))\n\t\t{\n\t\t\t// Assuming the character has a function to modify health\n\t\t\t// Character->ModifyHealth(HealingRate * DeltaTime);\n\t\t}\n\t}\n}\n\nvoid AHealingZone::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tOverlappingPlayers.Add(OtherActor);\n\t}\n}\n\nvoid AHealingZone::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tOverlappingPlayers.Remove(OtherActor);\n\t}\n}\n```"}
{"requirement": "Create a simple NPC that follows the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"NPCFollower.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ANPCFollower : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tANPCFollower();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAPawn* PlayerPawn;\n\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tfloat AcceptanceRadius = 200.0f;\n};\n```", "cpp_code": "```cpp\n#include \"NPCFollower.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"AIController.h\"\n\nANPCFollower::ANPCFollower()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ANPCFollower::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid ANPCFollower::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerPawn)\n\t{\n\t\tAAIController* AIController = Cast<AAIController>(GetController());\n\t\tif (AIController)\n\t\t{\n\t\t\tAIController->MoveToActor(PlayerPawn, AcceptanceRadius);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Add a function to spawn an actor at a random location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActorSpawner.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActorSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAYourActorSpawner();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Spawning\")\n\tvoid SpawnActorAtRandomLocation();\n\n\tUPROPERTY(EditAnywhere, Category = \"Spawning\")\n\tTSubclassOf<AActor> ActorToSpawn;\n\n\tUPROPERTY(EditAnywhere, Category = \"Spawning\")\n\tFVector SpawnAreaMin;\n\n\tUPROPERTY(EditAnywhere, Category = \"Spawning\")\n\tFVector SpawnAreaMax;\n};\n```", "cpp_code": "```cpp\n#include \"YourActorSpawner.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\n// Sets default values\nAYourActorSpawner::AYourActorSpawner()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AYourActorSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AYourActorSpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AYourActorSpawner::SpawnActorAtRandomLocation()\n{\n\tif (ActorToSpawn)\n\t{\n\t\tFVector RandomLocation = UKismetMathLibrary::RandomPointInBoundingBox(SpawnAreaMin, SpawnAreaMax - SpawnAreaMin);\n\t\tFActorSpawnParameters SpawnParams;\n\t\tGetWorld()->SpawnActor<AActor>(ActorToSpawn, RandomLocation, FRotator::ZeroRotator, SpawnParams);\n\t}\n}\n```"}
{"requirement": "Implement a simple music system with volume control.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimpleMusicSystem.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASimpleMusicSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASimpleMusicSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Music\")\n\tvoid PlayMusic();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Music\")\n\tvoid StopMusic();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Music\")\n\tvoid SetVolume(float Volume);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Music\")\n\tUSoundCue* MusicCue;\n\n\tUPROPERTY(EditAnywhere, Category=\"Music\")\n\tfloat Volume;\n\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SimpleMusicSystem.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n\nASimpleMusicSystem::ASimpleMusicSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->bAutoActivate = false;\n\tVolume = 1.0f;\n}\n\nvoid ASimpleMusicSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (MusicCue)\n\t{\n\t\tAudioComponent->SetSound(MusicCue);\n\t}\n}\n\nvoid ASimpleMusicSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASimpleMusicSystem::PlayMusic()\n{\n\tif (AudioComponent && MusicCue)\n\t{\n\t\tAudioComponent->Play();\n\t}\n}\n\nvoid ASimpleMusicSystem::StopMusic()\n{\n\tif (AudioComponent)\n\t{\n\t\tAudioComponent->Stop();\n\t}\n}\n\nvoid ASimpleMusicSystem::SetVolume(float NewVolume)\n{\n\tVolume = FMath::Clamp(NewVolume, 0.0f, 1.0f);\n\tif (AudioComponent)\n\t{\n\t\tAudioComponent->SetVolumeMultiplier(Volume);\n\t}\n}\n```"}
{"requirement": "Create a character that clings to surfaces.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"ClingingCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AClingingCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAClingingCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Cling\")\n\tbool bIsClinging;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Cling\")\n\tvoid StartClinging();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Cling\")\n\tvoid StopClinging();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Cling\")\n\tfloat ClingSpeed;\n\nprivate:\n\tvoid ClingToSurface(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"ClingingCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAClingingCharacter::AClingingCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsClinging = false;\n\tClingSpeed = 200.0f;\n}\n\nvoid AClingingCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AClingingCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsClinging)\n\t{\n\t\tClingToSurface(DeltaTime);\n\t}\n}\n\nvoid AClingingCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"Cling\", IE_Pressed, this, &AClingingCharacter::StartClinging);\n\tPlayerInputComponent->BindAction(\"Cling\", IE_Released, this, &AClingingCharacter::StopClinging);\n}\n\nvoid AClingingCharacter::StartClinging()\n{\n\tbIsClinging = true;\n\tGetCharacterMovement()->GravityScale = 0.0f;\n}\n\nvoid AClingingCharacter::StopClinging()\n{\n\tbIsClinging = false;\n\tGetCharacterMovement()->GravityScale = 1.0f;\n}\n\nvoid AClingingCharacter::ClingToSurface(float DeltaTime)\n{\n\tif (Controller)\n\t{\n\t\tFVector ForwardVector = Controller->GetControlRotation().Vector();\n\t\tAddMovementInput(ForwardVector, ClingSpeed * DeltaTime);\n\t}\n}\n```"}
{"requirement": "Add a function to print out available console commands.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ConsoleCommandPrinter.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AConsoleCommandPrinter : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic: \n\t// Sets default values for this actor's properties\n\tAConsoleCommandPrinter();\n\n\t// Function to print available console commands\n\tUFUNCTION(BlueprintCallable, Category=\"Console Commands\")\n\tvoid PrintAvailableConsoleCommands();\n};\n```", "cpp_code": "```cpp\n#include \"ConsoleCommandPrinter.h\"\n#include \"Engine/Engine.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Actor.h\"\n\nAConsoleCommandPrinter::AConsoleCommandPrinter()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AConsoleCommandPrinter::PrintAvailableConsoleCommands()\n{\n\tif (GEngine)\n\t{\n\t\tFString Output;\n\t\tfor (TObjectIterator<UConsole> It; It; ++It)\n\t\t{\n\t\t\tUConsole* Console = *It;\n\t\t\tif (Console)\n\t\t\t{\n\t\t\t\tOutput = Console->ConsoleCommandHistory;\n\t\t\t\tfor (const FString& Command : Console->AutoCompleteList)\n\t\t\t\t{\n\t\t\t\t\tOutput += Command + TEXT(\"\\n\");\n\t\t\t\t}\n\t\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, Output);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a basic color change on damage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangeOnDamage.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AColorChangeOnDamage : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorChangeOnDamage();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnTakeDamage();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Damage\")\n\tFLinearColor DamageColor;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Damage\")\n\tFLinearColor DefaultColor;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeOnDamage.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAColorChangeOnDamage::AColorChangeOnDamage()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tDefaultColor = FLinearColor::White;\n\tDamageColor = FLinearColor::Red;\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangeOnDamage::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"Color\"), DefaultColor);\n}\n\n// Called every frame\nvoid AColorChangeOnDamage::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AColorChangeOnDamage::OnTakeDamage()\n{\n\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"Color\"), DamageColor);\n}\n```"}
{"requirement": "Create a simple teleportation system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TeleportationSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATeleportationSystem : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tATeleportationSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Teleportation\")\n\tvoid TeleportActor(AActor* ActorToTeleport, const FVector& TargetLocation);\n};\n```", "cpp_code": "```cpp\n#include \"TeleportationSystem.h\"\n\nATeleportationSystem::ATeleportationSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ATeleportationSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATeleportationSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATeleportationSystem::TeleportActor(AActor* ActorToTeleport, const FVector& TargetLocation)\n{\n\tif (ActorToTeleport)\n\t{\n\t\tActorToTeleport->SetActorLocation(TargetLocation);\n\t}\n}\n```"}
{"requirement": "Add a function to toggle character invisibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visibility\")\n\tvoid ToggleInvisibility();\n\nprivate:\n\tbool bIsInvisible;\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n\nAMyCharacter::AMyCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsInvisible = false;\n}\n\nvoid AMyCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\nvoid AMyCharacter::ToggleInvisibility()\n{\n\tbIsInvisible = !bIsInvisible;\n\tSetActorHiddenInGame(bIsInvisible);\n\tSetActorEnableCollision(!bIsInvisible);\n}\n```"}
{"requirement": "Implement a basic sliding door mechanic.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SlidingDoor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASlidingDoor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tASlidingDoor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector OpenPosition;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector ClosedPosition;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat DoorSpeed;\n\n\tUFUNCTION(BlueprintCallable)\n\tvoid OpenDoor();\n\n\tUFUNCTION(BlueprintCallable)\n\tvoid CloseDoor();\n\nprivate:\n\tbool bIsOpening;\n\tbool bIsClosing;\n};\n```", "cpp_code": "```cpp\n#include \"SlidingDoor.h\"\n\nASlidingDoor::ASlidingDoor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tClosedPosition = GetActorLocation();\n\tOpenPosition = ClosedPosition + FVector(0, 200, 0); // Example offset for open position\n\tDoorSpeed = 100.0f;\n\tbIsOpening = false;\n\tbIsClosing = false;\n}\n\nvoid ASlidingDoor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASlidingDoor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsOpening)\n\t{\n\t\tFVector CurrentPosition = GetActorLocation();\n\t\tFVector NewPosition = FMath::VInterpConstantTo(CurrentPosition, OpenPosition, DeltaTime, DoorSpeed);\n\t\tSetActorLocation(NewPosition);\n\n\t\tif (CurrentPosition.Equals(OpenPosition, 1.0f))\n\t\t{\n\t\t\tbIsOpening = false;\n\t\t}\n\t}\n\telse if (bIsClosing)\n\t{\n\t\tFVector CurrentPosition = GetActorLocation();\n\t\tFVector NewPosition = FMath::VInterpConstantTo(CurrentPosition, ClosedPosition, DeltaTime, DoorSpeed);\n\t\tSetActorLocation(NewPosition);\n\n\t\tif (CurrentPosition.Equals(ClosedPosition, 1.0f))\n\t\t{\n\t\t\tbIsClosing = false;\n\t\t}\n\t}\n}\n\nvoid ASlidingDoor::OpenDoor()\n{\n\tbIsOpening = true;\n\tbIsClosing = false;\n}\n\nvoid ASlidingDoor::CloseDoor()\n{\n\tbIsClosing = true;\n\tbIsOpening = false;\n}\n```"}
{"requirement": "Create an actor that changes its mesh based on time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ADynamicMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADynamicMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ChangeMesh();\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Meshes\")\n\tTArray<UStaticMesh*> Meshes;\n\n\tfloat TimeAccumulator;\n\n\tUPROPERTY(EditAnywhere, Category=\"Time\")\n\tfloat ChangeInterval;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n\nADynamicMeshActor::ADynamicMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tTimeAccumulator = 0.0f;\n\tChangeInterval = 5.0f; // Change mesh every 5 seconds by default\n}\n\nvoid ADynamicMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADynamicMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeAccumulator += DeltaTime;\n\tif (TimeAccumulator >= ChangeInterval)\n\t{\n\t\tChangeMesh();\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n\nvoid ADynamicMeshActor::ChangeMesh()\n{\n\tif (Meshes.Num() > 0)\n\t{\n\t\tint32 MeshIndex = FMath::RandRange(0, Meshes.Num() - 1);\n\t\tMeshComponent->SetStaticMesh(Meshes[MeshIndex]);\n\t}\n}\n```"}
{"requirement": "Add a function to detect when the player is falling.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"FallingCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AFallingCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFallingCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Movement\")\n\tbool IsFalling() const;\n};\n```", "cpp_code": "```cpp\n#include \"FallingCharacter.h\"\n\nAFallingCharacter::AFallingCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AFallingCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AFallingCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nbool AFallingCharacter::IsFalling() const\n{\n\treturn GetCharacterMovement()->IsFalling();\n}\n```"}
{"requirement": "Implement a basic dynamic weather system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WeatherSystem.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AWeatherSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAWeatherSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Weather\")\n\tfloat WeatherChangeInterval;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Weather\")\n\tvoid ChangeWeather();\n\nprivate:\n\tvoid UpdateWeather();\n\n\tFTimerHandle WeatherChangeTimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"WeatherSystem.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAWeatherSystem::AWeatherSystem()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tWeatherChangeInterval = 60.0f; // Default to change weather every 60 seconds\n}\n\n// Called when the game starts or when spawned\nvoid AWeatherSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tGetWorldTimerManager().SetTimer(WeatherChangeTimerHandle, this, &AWeatherSystem::ChangeWeather, WeatherChangeInterval, true);\n}\n\n// Called every frame\nvoid AWeatherSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AWeatherSystem::ChangeWeather()\n{\n\tUpdateWeather();\n}\n\nvoid AWeatherSystem::UpdateWeather()\n{\n\t// Simple weather change logic\n\tint WeatherType = FMath::RandRange(0, 2);\n\tswitch (WeatherType)\n\t{\n\tcase 0:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Weather changed to Sunny\"));\n\t\tbreak;\n\tcase 1:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Weather changed to Rainy\"));\n\t\tbreak;\n\tcase 2:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Weather changed to Cloudy\"));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n```"}
{"requirement": "Create a destructible object that breaks on impact.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DestructibleComponent.h\"\n#include \"DestructibleObject.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADestructibleObject : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADestructibleObject();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Destructible\")\n\tUDestructibleComponent* DestructibleComponent;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"DestructibleObject.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nADestructibleObject::ADestructibleObject()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tDestructibleComponent = CreateDefaultSubobject<UDestructibleComponent>(TEXT(\"DestructibleComponent\"));\n\tRootComponent = DestructibleComponent;\n\n\tDestructibleComponent->OnComponentHit.AddDynamic(this, &ADestructibleObject::OnHit);\n}\n\nvoid ADestructibleObject::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADestructibleObject::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADestructibleObject::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (DestructibleComponent)\n\t{\n\t\tDestructibleComponent->ApplyDamage(10.0f, Hit.ImpactPoint, NormalImpulse, 1000.0f);\n\t}\n}\n```"}
{"requirement": "Add a function to control actor brightness.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BrightnessControlActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ABrightnessControlActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tABrightnessControlActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Brightness\")\n\tvoid SetBrightness(float NewBrightness);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Brightness\")\n\tfloat Brightness;\n};\n```", "cpp_code": "```cpp\n#include \"BrightnessControlActor.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nABrightnessControlActor::ABrightnessControlActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tBrightness = 1.0f;\n}\n\nvoid ABrightnessControlActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ABrightnessControlActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ABrightnessControlActor::SetBrightness(float NewBrightness)\n{\n\tBrightness = FMath::Clamp(NewBrightness, 0.0f, 1.0f);\n\n\tTArray<UPrimitiveComponent*> Components;\n\tGetComponents(Components);\n\n\tfor (UPrimitiveComponent* Component : Components)\n\t{\n\t\tif (Component)\n\t\t{\n\t\t\tComponent->SetScalarParameterValueOnMaterials(TEXT(\"Brightness\"), Brightness);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a basic inventory limit system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"InventorySystem.generated.h\"\n\nUCLASS(Blueprintable)\nclass YOURGAME_API UInventorySystem : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUInventorySystem();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tbool AddItem(FString ItemName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tbool RemoveItem(FString ItemName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tTArray<FString> GetInventoryItems() const;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Inventory\")\n\tint32 InventoryLimit;\n\n\tUPROPERTY()\n\tTArray<FString> Items;\n};\n```", "cpp_code": "```cpp\n#include \"InventorySystem.h\"\n\nUInventorySystem::UInventorySystem()\n{\n\tInventoryLimit = 10; // Default inventory limit\n}\n\nbool UInventorySystem::AddItem(FString ItemName)\n{\n\tif (Items.Num() < InventoryLimit)\n\t{\n\t\tItems.Add(ItemName);\n\t\treturn true;\n\t}\n\treturn false; // Inventory is full\n}\n\nbool UInventorySystem::RemoveItem(FString ItemName)\n{\n\treturn Items.Remove(ItemName) > 0;\n}\n\nTArray<FString> UInventorySystem::GetInventoryItems() const\n{\n\treturn Items;\n}\n```"}
{"requirement": "Create a simple starfield background.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"StarfieldBackground.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AStarfieldBackground : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAStarfieldBackground();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid GenerateStarfield();\n\n\tUPROPERTY(EditAnywhere, Category = \"Starfield\")\n\tint32 NumberOfStars;\n\n\tUPROPERTY(EditAnywhere, Category = \"Starfield\")\n\tfloat StarfieldRadius;\n\n\tUPROPERTY(EditDefaultsOnly, Category = \"Starfield\")\n\tUMaterial* StarMaterial;\n\n\tUPROPERTY()\n\tTArray<UStaticMeshComponent*> Stars;\n};\n```", "cpp_code": "```cpp\n#include \"StarfieldBackground.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAStarfieldBackground::AStarfieldBackground()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tNumberOfStars = 100;\n\tStarfieldRadius = 1000.0f;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> StarMesh(TEXT(\"/Engine/BasicShapes/Sphere.Sphere\"));\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> StarMat(TEXT(\"/Game/StarMaterial.StarMaterial\"));\n\n\tif (StarMesh.Succeeded() && StarMat.Succeeded())\n\t{\n\t\tStarMaterial = StarMat.Object;\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AStarfieldBackground::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGenerateStarfield();\n}\n\n// Called every frame\nvoid AStarfieldBackground::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AStarfieldBackground::GenerateStarfield()\n{\n\tfor (int32 i = 0; i < NumberOfStars; ++i)\n\t{\n\t\tUStaticMeshComponent* Star = NewObject<UStaticMeshComponent>(this);\n\t\tStar->SetStaticMesh(ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"/Engine/BasicShapes/Sphere.Sphere\")).Object);\n\t\tStar->SetMaterial(0, StarMaterial);\n\n\t\tFVector RandomLocation = FMath::VRand() * FMath::RandRange(0.0f, StarfieldRadius);\n\t\tStar->SetWorldLocation(RandomLocation);\n\t\tStar->SetWorldScale3D(FVector(0.1f));\n\t\tStar->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepWorldTransform);\n\t\tStar->RegisterComponent();\n\t\tStars.Add(Star);\n\t}\n}\n```"}
{"requirement": "Add a function to pause sound effects.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/AudioComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SoundEffectManager.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundEffectManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundEffectManager();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Audio\")\n\tvoid PauseSoundEffects();\n\nprivate:\n\tUPROPERTY()\n\tTArray<UAudioComponent*> AudioComponents;\n};\n```", "cpp_code": "```cpp\n#include \"SoundEffectManager.h\"\n#include \"Components/AudioComponent.h\"\n\nASoundEffectManager::ASoundEffectManager()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ASoundEffectManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Find all audio components in the scene\n\tTArray<UActorComponent*> Components;\n\tGetComponents(UAudioComponent::StaticClass(), Components);\n\n\tfor (UActorComponent* Component : Components)\n\t{\n\t\tUAudioComponent* AudioComponent = Cast<UAudioComponent>(Component);\n\t\tif (AudioComponent && AudioComponent->IsPlaying())\n\t\t{\n\t\t\tAudioComponents.Add(AudioComponent);\n\t\t}\n\t}\n}\n\nvoid ASoundEffectManager::PauseSoundEffects()\n{\n\tfor (UAudioComponent* AudioComponent : AudioComponents)\n\t{\n\t\tif (AudioComponent && AudioComponent->IsPlaying())\n\t\t{\n\t\t\tAudioComponent->SetPaused(true);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a basic on-screen key prompt.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"KeyPromptActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AKeyPromptActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAKeyPromptActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Prompt\")\n\tFString PromptMessage;\n\n\tUPROPERTY(EditAnywhere, Category=\"Prompt\")\n\tFKey PromptKey;\n\n\tvoid ShowPrompt();\n\n\tvoid HidePrompt();\n\n\tbool bIsPromptVisible;\n};\n```", "cpp_code": "```cpp\n#include \"KeyPromptActor.h\"\n#include \"Engine/Engine.h\"\n\nAKeyPromptActor::AKeyPromptActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsPromptVisible = false;\n}\n\nvoid AKeyPromptActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AKeyPromptActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!bIsPromptVisible && FInputKeyEventArgs::IsPressed(PromptKey))\n\t{\n\t\tShowPrompt();\n\t\tbIsPromptVisible = true;\n\t}\n\telse if (bIsPromptVisible && !FInputKeyEventArgs::IsPressed(PromptKey))\n\t{\n\t\tHidePrompt();\n\t\tbIsPromptVisible = false;\n\t}\n}\n\nvoid AKeyPromptActor::ShowPrompt()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, PromptMessage);\n\t}\n}\n\nvoid AKeyPromptActor::HidePrompt()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->ClearOnScreenDebugMessages();\n\t}\n}\n```"}
{"requirement": "Create a simple score multiplier system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreMultiplierSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AScoreMultiplierSystem : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAScoreMultiplierSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid AddScore(int32 BasePoints);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid SetMultiplier(float NewMultiplier);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tint32 GetTotalScore() const;\n\nprivate:\n\tint32 TotalScore;\n\tfloat Multiplier;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreMultiplierSystem.h\"\n\nAScoreMultiplierSystem::AScoreMultiplierSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTotalScore = 0;\n\tMultiplier = 1.0f;\n}\n\nvoid AScoreMultiplierSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScoreMultiplierSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScoreMultiplierSystem::AddScore(int32 BasePoints)\n{\n\tTotalScore += FMath::RoundToInt(BasePoints * Multiplier);\n}\n\nvoid AScoreMultiplierSystem::SetMultiplier(float NewMultiplier)\n{\n\tMultiplier = NewMultiplier;\n}\n\nint32 AScoreMultiplierSystem::GetTotalScore() const\n{\n\treturn TotalScore;\n}\n```"}
{"requirement": "Add a function to print the number of actors in a level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CountActors.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACountActors : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACountActors();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Level\")\n\tvoid PrintNumberOfActorsInLevel();\n};\n```", "cpp_code": "```cpp\n#include \"CountActors.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nACountActors::ACountActors()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ACountActors::PrintNumberOfActorsInLevel()\n{\n\tif (GetWorld())\n\t{\n\t\tint32 ActorCount = GetWorld()->GetActorCount();\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Number of actors in the level: %d\"), ActorCount);\n\t}\n}\n```"}
{"requirement": "Implement a simple health display using text.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthDisplay.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHealthDisplay : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAHealthDisplay();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tint32 Health;\n\n\tUFUNCTION()\n\tvoid DisplayHealth();\n};\n```", "cpp_code": "```cpp\n#include \"HealthDisplay.h\"\n#include \"Engine/Engine.h\"\n\nAHealthDisplay::AHealthDisplay()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHealth = 100; // Initialize health\n}\n\nvoid AHealthDisplay::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tDisplayHealth();\n}\n\nvoid AHealthDisplay::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHealthDisplay::DisplayHealth()\n{\n\tif (GEngine)\n\t{\n\t\tFString HealthString = FString::Printf(TEXT(\"Current Health: %d\"), Health);\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, HealthString);\n\t}\n}\n```"}
{"requirement": "Create a character that can wall slide.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"WallSlideCharacter.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWallSlideCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWallSlideCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid WallSlide();\n\n\tbool bIsSliding;\n\n\tUFUNCTION()\n\tvoid OnWallHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"WallSlideCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/CapsuleComponent.h\"\n\nAWallSlideCharacter::AWallSlideCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tGetCapsuleComponent()->OnComponentHit.AddDynamic(this, &AWallSlideCharacter::OnWallHit);\n\n\tbIsSliding = false;\n}\n\nvoid AWallSlideCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AWallSlideCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsSliding)\n\t{\n\t\tWallSlide();\n\t}\n}\n\nvoid AWallSlideCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\nvoid AWallSlideCharacter::WallSlide()\n{\n\t// Simple gravity reduction for wall sliding effect\n\tFVector NewVelocity = GetCharacterMovement()->Velocity;\n\tNewVelocity.Z = FMath::Clamp(NewVelocity.Z, -200.f, 0.f);\n\tGetCharacterMovement()->Velocity = NewVelocity;\n}\n\nvoid AWallSlideCharacter::OnWallHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\t// Check if the hit surface is a wall\n\tFVector Normal = Hit.Normal;\n\n\tif (FMath::Abs(Normal.Z) < KINDA_SMALL_NUMBER)\n\t{\n\t\tbIsSliding = true;\n\t}\n\telse\n\t{\n\t\tbIsSliding = false;\n\t}\n}\n```"}
{"requirement": "Add a function to detect actor overlap events.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* CollisionComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/BoxComponent.h\"\n\nAOverlapActor::AOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tRootComponent = CollisionComponent;\n\n\tCollisionComponent->SetGenerateOverlapEvents(true);\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n}\n\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlap Begin with: %s\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Implement a basic shooting mechanic.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyShootingActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyShootingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyShootingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Shooting\")\n\tvoid Shoot();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Shooting\")\n\tTSubclassOf<AActor> ProjectileClass;\n\n\tUPROPERTY(EditAnywhere, Category=\"Shooting\")\n\tFVector MuzzleOffset;\n};\n```", "cpp_code": "```cpp\n#include \"MyShootingActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nAMyShootingActor::AMyShootingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyShootingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyShootingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyShootingActor::Shoot()\n{\n\tif (ProjectileClass)\n\t{\n\t\tFVector MuzzleLocation = GetActorLocation() + FTransform(GetActorRotation()).TransformVector(MuzzleOffset);\n\t\tFRotator MuzzleRotation = GetActorRotation();\n\t\tUWorld* World = GetWorld();\n\t\tif (World)\n\t\t{\n\t\t\tWorld->SpawnActor<AActor>(ProjectileClass, MuzzleLocation, MuzzleRotation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a simple level transition system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LevelTransitionSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALevelTransitionSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALevelTransitionSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"LevelTransition\")\n\tvoid TransitionToLevel(FName LevelName);\n};\n```", "cpp_code": "```cpp\n#include \"LevelTransitionSystem.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nALevelTransitionSystem::ALevelTransitionSystem()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALevelTransitionSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALevelTransitionSystem::TransitionToLevel(FName LevelName)\n{\n\tif (!LevelName.IsNone())\n\t{\n\t\tUGameplayStatics::OpenLevel(this, LevelName);\n\t}\n}\n```"}
{"requirement": "Add a function to invert character controls.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"InvertControlsCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AInvertControlsCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tAInvertControlsCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Function to invert controls\n\tUFUNCTION(BlueprintCallable, Category=\"Character\")\n\tvoid InvertControls();\n\nprivate:\n\tbool bAreControlsInverted;\n\n\tvoid MoveForward(float Value);\n\tvoid MoveRight(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"InvertControlsCharacter.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/InputComponent.h\"\n\nAInvertControlsCharacter::AInvertControlsCharacter()\n{\n\t// Set default values\n\tbAreControlsInverted = false;\n}\n\nvoid AInvertControlsCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AInvertControlsCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AInvertControlsCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &AInvertControlsCharacter::MoveForward);\n\tPlayerInputComponent->BindAxis(\"MoveRight\", this, &AInvertControlsCharacter::MoveRight);\n}\n\nvoid AInvertControlsCharacter::MoveForward(float Value)\n{\n\tif (bAreControlsInverted)\n\t{\n\t\tValue = -Value;\n\t}\n\tAddMovementInput(GetActorForwardVector(), Value);\n}\n\nvoid AInvertControlsCharacter::MoveRight(float Value)\n{\n\tif (bAreControlsInverted)\n\t{\n\t\tValue = -Value;\n\t}\n\tAddMovementInput(GetActorRightVector(), Value);\n}\n\nvoid AInvertControlsCharacter::InvertControls()\n{\n\tbAreControlsInverted = !bAreControlsInverted;\n}\n```"}
{"requirement": "Implement a basic auto-save feature.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AutoSaveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAutoSaveActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAutoSaveActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid AutoSave();\n\n\tUPROPERTY(EditAnywhere, Category=\"AutoSave\")\n\tfloat SaveInterval;\n\n\tFTimerHandle AutoSaveTimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"AutoSaveActor.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n\nAAutoSaveActor::AAutoSaveActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSaveInterval = 300.0f; // default to 5 minutes\n}\n\nvoid AAutoSaveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorld()->GetTimerManager().SetTimer(AutoSaveTimerHandle, this, &AAutoSaveActor::AutoSave, SaveInterval, true);\n}\n\nvoid AAutoSaveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AAutoSaveActor::AutoSave()\n{\n\tUE_LOG(LogTemp, Log, TEXT(\"Auto-saving game state...\"));\n\t// Implement your save logic here\n}\n```"}
{"requirement": "Create an actor that emits light periodically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"PeriodicLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APeriodicLightActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAPeriodicLightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUPointLightComponent* PointLight;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat LightOnDuration;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat LightOffDuration;\n\n\tFTimerHandle LightTimerHandle;\n\n\tvoid ToggleLight();\n};\n```", "cpp_code": "```cpp\n#include \"PeriodicLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nAPeriodicLightActor::APeriodicLightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\tLightOnDuration = 1.0f;\n\tLightOffDuration = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid APeriodicLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tToggleLight();\n}\n\n// Called every frame\nvoid APeriodicLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APeriodicLightActor::ToggleLight()\n{\n\tPointLight->ToggleVisibility();\n\tfloat NextDuration = PointLight->IsVisible() ? LightOffDuration : LightOnDuration;\n\tGetWorldTimerManager().SetTimer(LightTimerHandle, this, &APeriodicLightActor::ToggleLight, NextDuration);\n}\n```"}
{"requirement": "Add a function to check the player's health status.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"PlayerCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API APlayerCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tAPlayerCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Function to check the player's health status\n\tUFUNCTION(BlueprintCallable, Category=\"Health\")\n\tFString CheckHealthStatus() const;\n\nprivate:\n\t// Player's health\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\", meta=(AllowPrivateAccess = \"true\"))\n\tfloat Health;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerCharacter.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAPlayerCharacter::APlayerCharacter()\n{\n\t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize health\n\tHealth = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid APlayerCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APlayerCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid APlayerCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\n// Function to check the player's health status\nFString APlayerCharacter::CheckHealthStatus() const\n{\n\tif (Health > 75.0f)\n\t{\n\t\treturn TEXT(\"Healthy\");\n\t}\n\telse if (Health > 50.0f)\n\t{\n\t\treturn TEXT(\"Injured\");\n\t}\n\telse if (Health > 25.0f)\n\t{\n\t\treturn TEXT(\"Critical\");\n\t}\n\telse\n\t{\n\t\treturn TEXT(\"Near Death\");\n\t}\n}\n```"}
{"requirement": "Implement a basic toggle for character abilities.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"AbilityToggleCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AAbilityToggleCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAbilityToggleCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Abilities\")\n\tvoid ToggleAbility();\n\nprivate:\n\tbool bIsAbilityActive;\n};\n```", "cpp_code": "```cpp\n#include \"AbilityToggleCharacter.h\"\n\nAAbilityToggleCharacter::AAbilityToggleCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsAbilityActive = false;\n}\n\nvoid AAbilityToggleCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAbilityToggleCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Example logic when ability is active\n\tif (bIsAbilityActive)\n\t{\n\t\t// Ability active logic here\n\t}\n}\n\nvoid AAbilityToggleCharacter::ToggleAbility()\n{\n\tbIsAbilityActive = !bIsAbilityActive;\n\tUE_LOG(LogTemp, Log, TEXT(\"Ability is now %s\"), bIsAbilityActive ? TEXT(\"Active\") : TEXT(\"Inactive\"));\n}\n```"}
{"requirement": "Create a simple interactive door system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InteractiveDoor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AInteractiveDoor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAInteractiveDoor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Door\")\n\tvoid OpenDoor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Door\")\n\tvoid CloseDoor();\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat OpenAngle;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat CloseAngle;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat DoorSpeed;\n\n\tUPROPERTY(VisibleAnywhere)\n\tbool bIsOpen;\n\n\tUPROPERTY(VisibleAnywhere)\n\tFRotator CurrentRotation;\n\n\tUPROPERTY(VisibleAnywhere)\n\tFRotator TargetRotation;\n\n\tvoid UpdateDoorRotation(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"InteractiveDoor.h\"\n#include \"GameFramework/Actor.h\"\n\nAInteractiveDoor::AInteractiveDoor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tOpenAngle = 90.0f;\n\tCloseAngle = 0.0f;\n\tDoorSpeed = 2.0f;\n\tbIsOpen = false;\n\tCurrentRotation = GetActorRotation();\n\tTargetRotation = CurrentRotation;\n}\n\nvoid AInteractiveDoor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AInteractiveDoor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateDoorRotation(DeltaTime);\n}\n\nvoid AInteractiveDoor::OpenDoor()\n{\n\tif (!bIsOpen)\n\t{\n\t\tTargetRotation = FRotator(CurrentRotation.Pitch, CurrentRotation.Yaw + OpenAngle, CurrentRotation.Roll);\n\t\tbIsOpen = true;\n\t}\n}\n\nvoid AInteractiveDoor::CloseDoor()\n{\n\tif (bIsOpen)\n\t{\n\t\tTargetRotation = FRotator(CurrentRotation.Pitch, CurrentRotation.Yaw + CloseAngle, CurrentRotation.Roll);\n\t\tbIsOpen = false;\n\t}\n}\n\nvoid AInteractiveDoor::UpdateDoorRotation(float DeltaTime)\n{\n\tif (CurrentRotation.Equals(TargetRotation, 1.0f))\n\t{\n\t\treturn;\n\t}\n\tCurrentRotation = FMath::RInterpConstantTo(CurrentRotation, TargetRotation, DeltaTime, DoorSpeed);\n\tSetActorRotation(CurrentRotation);\n}\n```"}
{"requirement": "Add a function to reset the player's position.", "header_code": "```cpp\nUCLASS()\nclass MYGAME_API AMyPlayerCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Function to reset the player's position\n\tUFUNCTION(BlueprintCallable, Category=\"Player\")\n\tvoid ResetPlayerPosition();\n\nprivate:\n\t// Default position to reset the player to\n\tFVector DefaultPosition;\n};\n```", "cpp_code": "```cpp\n#include \"MyPlayerCharacter.h\"\n#include \"GameFramework/Actor.h\"\n\nAMyPlayerCharacter::AMyPlayerCharacter()\n{\n\t// Initialize the default position (example position)\n\tDefaultPosition = FVector(0.0f, 0.0f, 0.0f);\n}\n\nvoid AMyPlayerCharacter::ResetPlayerPosition()\n{\n\tSetActorLocation(DefaultPosition);\n}\n```"}
{"requirement": "Implement a basic stealth mechanic.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"StealthCharacter.generated.h\"\n\nUCLASS()\nclass STEALTHGAME_API AStealthCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAStealthCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Stealth\")\n\tvoid EnterStealthMode();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Stealth\")\n\tvoid ExitStealthMode();\n\nprivate:\n\tbool bIsStealthed;\n\tUPROPERTY(EditAnywhere, Category = \"Stealth\")\n\tfloat StealthSpeedMultiplier;\n};\n```", "cpp_code": "```cpp\n#include \"StealthCharacter.h\"\n\nAStealthCharacter::AStealthCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsStealthed = false;\n\tStealthSpeedMultiplier = 0.5f; // Default to half speed\n}\n\nvoid AStealthCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AStealthCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsStealthed)\n\t{\n\t\t// Implement any logic that should occur while in stealth mode\n\t}\n}\n\nvoid AStealthCharacter::EnterStealthMode()\n{\n\tbIsStealthed = true;\n\tGetCharacterMovement()->MaxWalkSpeed *= StealthSpeedMultiplier;\n\t// Additional logic for entering stealth mode (e.g., change material)\n}\n\nvoid AStealthCharacter::ExitStealthMode()\n{\n\tbIsStealthed = false;\n\tGetCharacterMovement()->MaxWalkSpeed /= StealthSpeedMultiplier;\n\t// Additional logic for exiting stealth mode (e.g., revert material)\n}\n```"}
{"requirement": "Implement a C++ class for a day-night cycle system that dynamically changes the lighting based on the time of day.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DayNightCycle.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADayNightCycle : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tADayNightCycle();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid UpdateSunPosition();\n\n\tUPROPERTY(EditAnywhere, Category = \"DayNight\")\n\tfloat DayLengthInSeconds;\n\n\tUPROPERTY(VisibleAnywhere, Category = \"DayNight\")\n\tfloat CurrentTimeOfDay;\n\n\tUPROPERTY(EditAnywhere, Category = \"DayNight\")\n\tADirectionalLight* SunLight;\n};\n```", "cpp_code": "```cpp\n#include \"DayNightCycle.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/DirectionalLight.h\"\n\nADayNightCycle::ADayNightCycle()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tDayLengthInSeconds = 1200.0f; // 20 minutes\n\tCurrentTimeOfDay = 0.0f;\n}\n\nvoid ADayNightCycle::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADayNightCycle::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tCurrentTimeOfDay += DeltaTime;\n\tif (CurrentTimeOfDay >= DayLengthInSeconds)\n\t{\n\t\tCurrentTimeOfDay = 0.0f;\n\t}\n\tUpdateSunPosition();\n}\n\nvoid ADayNightCycle::UpdateSunPosition()\n{\n\tif (SunLight)\n\t{\n\t\tfloat SunAngle = (CurrentTimeOfDay / DayLengthInSeconds) * 360.0f;\n\t\tFRotator NewRotation = FRotator(SunAngle - 90.0f, -90.0f, 0.0f);\n\t\tSunLight->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an AI behavior tree for NPCs that allows them to patrol, chase players, and return to patrol if the player is lost.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"BehaviorTree/BTTaskNode.h\"\n#include \"AIController.h\"\n#include \"NPCBehaviorTree.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UBTTask_Patrol : public UBTTaskNode\n{\n\tGENERATED_BODY()\n\npublic:\n\tUBTTask_Patrol();\n\nprotected:\n\tvirtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;\n\nprivate:\n\tvoid Patrol();\n};\n\nUCLASS()\nclass YOURGAME_API UBTTask_ChasePlayer : public UBTTaskNode\n{\n\tGENERATED_BODY()\n\npublic:\n\tUBTTask_ChasePlayer();\n\nprotected:\n\tvirtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;\n\nprivate:\n\tvoid ChasePlayer();\n};\n\nUCLASS()\nclass YOURGAME_API UBTTask_ReturnToPatrol : public UBTTaskNode\n{\n\tGENERATED_BODY()\n\npublic:\n\tUBTTask_ReturnToPatrol();\n\nprotected:\n\tvirtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;\n\nprivate:\n\tvoid ReturnToPatrol();\n};\n```", "cpp_code": "```cpp\n#include \"NPCBehaviorTree.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BehaviorTree/BlackboardComponent.h\"\n\nUBTTask_Patrol::UBTTask_Patrol()\n{\n\tNodeName = TEXT(\"Patrol\");\n}\n\nEBTNodeResult::Type UBTTask_Patrol::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)\n{\n\tPatrol();\n\treturn EBTNodeResult::Succeeded;\n}\n\nvoid UBTTask_Patrol::Patrol()\n{\n\t// TODO: Implement patrol logic\n}\n\nUBTTask_ChasePlayer::UBTTask_ChasePlayer()\n{\n\tNodeName = TEXT(\"Chase Player\");\n}\n\nEBTNodeResult::Type UBTTask_ChasePlayer::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)\n{\n\tChasePlayer();\n\treturn EBTNodeResult::Succeeded;\n}\n\nvoid UBTTask_ChasePlayer::ChasePlayer()\n{\n\t// TODO: Implement chase player logic\n}\n\nUBTTask_ReturnToPatrol::UBTTask_ReturnToPatrol()\n{\n\tNodeName = TEXT(\"Return to Patrol\");\n}\n\nEBTNodeResult::Type UBTTask_ReturnToPatrol::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)\n{\n\tReturnToPatrol();\n\treturn EBTNodeResult::Succeeded;\n}\n\nvoid UBTTask_ReturnToPatrol::ReturnToPatrol()\n{\n\t// TODO: Implement return to patrol logic\n}\n```"}
{"requirement": "Develop a custom UMG widget for a health bar that changes color depending on the player's health state.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"HealthBarWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UHealthBarWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Health\")\n\tvoid UpdateHealthBar(float HealthPercentage);\n\nprotected:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UProgressBar* HealthBar;\n\nprivate:\n\tUFUNCTION()\n\tFLinearColor DetermineHealthBarColor(float HealthPercentage) const;\n};\n```", "cpp_code": "```cpp\n#include \"HealthBarWidget.h\"\n#include \"Components/ProgressBar.h\"\n\nvoid UHealthBarWidget::UpdateHealthBar(float HealthPercentage)\n{\n\tif (HealthBar)\n\t{\n\t\tHealthBar->SetPercent(HealthPercentage);\n\t\tHealthBar->SetFillColorAndOpacity(DetermineHealthBarColor(HealthPercentage));\n\t}\n}\n\nFLinearColor UHealthBarWidget::DetermineHealthBarColor(float HealthPercentage) const\n{\n\tif (HealthPercentage > 0.7f)\n\t{\n\t\treturn FLinearColor::Green;\n\t}\n\telse if (HealthPercentage > 0.3f)\n\t{\n\t\treturn FLinearColor::Yellow;\n\t}\n\telse\n\t{\n\t\treturn FLinearColor::Red;\n\t}\n}\n```"}
{"requirement": "Design a C++ component that manages player inventory with add, remove, and sort functionalities.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"InventoryComponent.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FInventoryItem\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString ItemName;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 Quantity;\n\n\tFInventoryItem()\n\t\t: ItemName(TEXT(\"\")), Quantity(0) {}\n\n\tFInventoryItem(FString Name, int32 Qty)\n\t\t: ItemName(Name), Quantity(Qty) {}\n};\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURGAME_API UInventoryComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUInventoryComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tbool AddItem(const FInventoryItem& Item);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tbool RemoveItem(const FString& ItemName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tvoid SortInventory();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Inventory\")\n\tTArray<FInventoryItem> Inventory;\n};\n```", "cpp_code": "```cpp\n#include \"InventoryComponent.h\"\n\nUInventoryComponent::UInventoryComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UInventoryComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nbool UInventoryComponent::AddItem(const FInventoryItem& Item)\n{\n\tfor (FInventoryItem& InvItem : Inventory)\n\t{\n\t\tif (InvItem.ItemName == Item.ItemName)\n\t\t{\n\t\t\tInvItem.Quantity += Item.Quantity;\n\t\t\treturn true;\n\t\t}\n\t}\n\tInventory.Add(Item);\n\treturn true;\n}\n\nbool UInventoryComponent::RemoveItem(const FString& ItemName)\n{\n\tfor (int32 i = 0; i < Inventory.Num(); i++)\n\t{\n\t\tif (Inventory[i].ItemName == ItemName)\n\t\t{\n\t\t\tInventory.RemoveAt(i);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid UInventoryComponent::SortInventory()\n{\n\tInventory.Sort([](const FInventoryItem& A, const FInventoryItem& B)\n\t{\n\t\treturn A.ItemName < B.ItemName;\n\t});\n}\n```"}
{"requirement": "Implement a networked multiplayer lobby system where players can join, leave, and ready up for matches.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"LobbyGameMode.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ALobbyGameMode : public AGameModeBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tALobbyGameMode();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Lobby\")\n\tvoid PlayerJoin(APlayerController* NewPlayer);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Lobby\")\n\tvoid PlayerLeave(APlayerController* ExitingPlayer);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Lobby\")\n\tvoid PlayerReady(APlayerController* ReadyPlayer);\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tTArray<APlayerController*> PlayersInLobby;\n\tTMap<APlayerController*, bool> PlayerReadyStatus;\n\n\tvoid CheckAllPlayersReady();\n};\n```", "cpp_code": "```cpp\n#include \"LobbyGameMode.h\"\n#include \"GameFramework/PlayerController.h\"\n\nALobbyGameMode::ALobbyGameMode()\n{\n\t// Set default class variables\n}\n\nvoid ALobbyGameMode::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Initialize lobby state\n}\n\nvoid ALobbyGameMode::PlayerJoin(APlayerController* NewPlayer)\n{\n\tif (NewPlayer && !PlayersInLobby.Contains(NewPlayer))\n\t{\n\t\tPlayersInLobby.Add(NewPlayer);\n\t\tPlayerReadyStatus.Add(NewPlayer, false);\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Player joined the lobby.\"));\n\t}\n}\n\nvoid ALobbyGameMode::PlayerLeave(APlayerController* ExitingPlayer)\n{\n\tif (ExitingPlayer && PlayersInLobby.Contains(ExitingPlayer))\n\t{\n\t\tPlayersInLobby.Remove(ExitingPlayer);\n\t\tPlayerReadyStatus.Remove(ExitingPlayer);\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Player left the lobby.\"));\n\t}\n}\n\nvoid ALobbyGameMode::PlayerReady(APlayerController* ReadyPlayer)\n{\n\tif (ReadyPlayer && PlayersInLobby.Contains(ReadyPlayer))\n\t{\n\t\tPlayerReadyStatus[ReadyPlayer] = true;\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Player is ready.\"));\n\t\tCheckAllPlayersReady();\n\t}\n}\n\nvoid ALobbyGameMode::CheckAllPlayersReady()\n{\n\tfor (const auto& PlayerStatus : PlayerReadyStatus)\n\t{\n\t\tif (!PlayerStatus.Value)\n\t\t{\n\t\t\treturn; // Not all players are ready\n\t\t}\n\t}\n\tUE_LOG(LogTemp, Log, TEXT(\"All players are ready. Starting match...\"));\n\t// Start the match\n}\n```"}
{"requirement": "Create a C++ class for a weapon system that supports switching between different weapon types and reloading.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WeaponSystem.generated.h\"\n\nUENUM(BlueprintType)\nenum class EWeaponType : uint8\n{\n\tPistol UMETA(DisplayName = \"Pistol\"),\n\tRifle UMETA(DisplayName = \"Rifle\"),\n\tShotgun UMETA(DisplayName = \"Shotgun\")\n};\n\nUCLASS()\nclass YOURGAME_API AWeaponSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAWeaponSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Weapons\")\n\tEWeaponType CurrentWeaponType;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Weapons\")\n\tint32 AmmoCount;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Weapons\")\n\tint32 MaxAmmo;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Weapons\")\n\tvoid SwitchWeapon(EWeaponType NewWeaponType);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Weapons\")\n\tvoid Reload();\n};\n```", "cpp_code": "```cpp\n#include \"WeaponSystem.h\"\n\n// Sets default values\nAWeaponSystem::AWeaponSystem()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\t// Initialize default values\n\tCurrentWeaponType = EWeaponType::Pistol;\n\tAmmoCount = 10;\n\tMaxAmmo = 30;\n}\n\n// Called when the game starts or when spawned\nvoid AWeaponSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AWeaponSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AWeaponSystem::SwitchWeapon(EWeaponType NewWeaponType)\n{\n\tif (CurrentWeaponType != NewWeaponType)\n\t{\n\t\tCurrentWeaponType = NewWeaponType;\n\t\t// Possibly reset ammo count or change max ammo based on weapon type\n\t\tswitch (CurrentWeaponType)\n\t\t{\n\t\tcase EWeaponType::Pistol:\n\t\t\tMaxAmmo = 15;\n\t\t\tbreak;\n\t\tcase EWeaponType::Rifle:\n\t\t\tMaxAmmo = 30;\n\t\t\tbreak;\n\t\tcase EWeaponType::Shotgun:\n\t\t\tMaxAmmo = 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t// Reset ammo count to max ammo when switching weapon\n\t\tAmmoCount = MaxAmmo;\n\t}\n}\n\nvoid AWeaponSystem::Reload()\n{\n\tAmmoCount = MaxAmmo;\n}\n```"}
{"requirement": "Develop a C++ component for an in-game map that updates in real-time as the player discovers new areas.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"GameMapComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API UGameMapComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUGameMapComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Map\")\n\tvoid DiscoverNewArea(FVector Location);\n\n\tUPROPERTY(BlueprintReadOnly, Category=\"Map\")\n\tTArray<FVector> DiscoveredAreas;\n};\n```", "cpp_code": "```cpp\n#include \"GameMapComponent.h\"\n\nUGameMapComponent::UGameMapComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UGameMapComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UGameMapComponent::DiscoverNewArea(FVector Location)\n{\n\tif (!DiscoveredAreas.Contains(Location))\n\t{\n\t\tDiscoveredAreas.Add(Location);\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"New area discovered at location: %s\"), *Location.ToString());\n\t\t// Additional logic to update the map UI can be added here\n\t}\n}\n```"}
{"requirement": "Implement a spline-based movement system for NPCs that allows them to follow predetermined paths smoothly.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SplineComponent.h\"\n#include \"NPCSplineMovement.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ANPCSplineMovement : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tANPCSplineMovement();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Spline\")\n\tUSplineComponent* SplineComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MovementSpeed;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat PathOffset;\n\nprivate:\n\tfloat DistanceAlongSpline;\n\n\tvoid MoveAlongSpline(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"NPCSplineMovement.h\"\n#include \"Components/SplineComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nANPCSplineMovement::ANPCSplineMovement()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSplineComponent = CreateDefaultSubobject<USplineComponent>(TEXT(\"SplineComponent\"));\n\tRootComponent = SplineComponent;\n\n\tMovementSpeed = 100.0f;\n\tPathOffset = 0.0f;\n\tDistanceAlongSpline = 0.0f;\n}\n\nvoid ANPCSplineMovement::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ANPCSplineMovement::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tMoveAlongSpline(DeltaTime);\n}\n\nvoid ANPCSplineMovement::MoveAlongSpline(float DeltaTime)\n{\n\tif (!SplineComponent)\n\t{\n\t\treturn;\n\t}\n\n\tconst float SplineLength = SplineComponent->GetSplineLength();\n\tDistanceAlongSpline += MovementSpeed * DeltaTime;\n\tif (DistanceAlongSpline > SplineLength)\n\t{\n\t\tDistanceAlongSpline = 0.0f;  // Loop back to start\n\t}\n\n\tFVector NewLocation = SplineComponent->GetLocationAtDistanceAlongSpline(DistanceAlongSpline, ESplineCoordinateSpace::World);\n\tFVector RightVector = SplineComponent->GetRightVectorAtDistanceAlongSpline(DistanceAlongSpline, ESplineCoordinateSpace::World);\n\tNewLocation += RightVector * PathOffset;\n\n\tSetActorLocation(NewLocation);\n\n\tFRotator NewRotation = SplineComponent->GetRotationAtDistanceAlongSpline(DistanceAlongSpline, ESplineCoordinateSpace::World);\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create a custom C++ animation blueprint for character locomotion that transitions between idle, walk, and run.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"CharacterAnimInstance.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UCharacterAnimInstance : public UAnimInstance\n{\n\tGENERATED_BODY()\n\npublic:\n\tUCharacterAnimInstance();\n\n\tvirtual void NativeInitializeAnimation() override;\n\tvirtual void NativeUpdateAnimation(float DeltaSeconds) override;\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Movement\")\n\tfloat Speed;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Movement\")\n\tbool bIsInAir;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Movement\")\n\tbool bIsAccelerating;\n\nprivate:\n\tAPawn* OwnerPawn;\n};\n```", "cpp_code": "```cpp\n#include \"CharacterAnimInstance.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameFramework/PawnMovementComponent.h\"\n\nUCharacterAnimInstance::UCharacterAnimInstance()\n\t: Speed(0.f), bIsInAir(false), bIsAccelerating(false), OwnerPawn(nullptr)\n{\n}\n\nvoid UCharacterAnimInstance::NativeInitializeAnimation()\n{\n\tSuper::NativeInitializeAnimation();\n\tOwnerPawn = TryGetPawnOwner();\n}\n\nvoid UCharacterAnimInstance::NativeUpdateAnimation(float DeltaSeconds)\n{\n\tSuper::NativeUpdateAnimation(DeltaSeconds);\n\n\tif (!OwnerPawn)\n\t{\n\t\tOwnerPawn = TryGetPawnOwner();\n\t}\n\n\tif (OwnerPawn)\n\t{\n\t\tSpeed = OwnerPawn->GetVelocity().Size();\n\t\tbIsInAir = OwnerPawn->GetMovementComponent()->IsFalling();\n\t\tbIsAccelerating = OwnerPawn->GetMovementComponent()->GetCurrentAcceleration().Size() > 0.f;\n\t}\n}\n```"}
{"requirement": "Develop a C++ class for a dialogue system that supports branching conversations and player choices.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"DialogueSystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FDialogueOption\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString OptionText;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 NextNodeId;\n};\n\nUSTRUCT(BlueprintType)\nstruct FDialogueNode\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 NodeId;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString DialogueText;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tTArray<FDialogueOption> Options;\n};\n\nUCLASS(Blueprintable)\nclass YOURPROJECT_API UDialogueSystem : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUDialogueSystem();\n\n\tUFUNCTION(BlueprintCallable)\n\tFString GetCurrentDialogueText() const;\n\n\tUFUNCTION(BlueprintCallable)\n\tTArray<FDialogueOption> GetCurrentOptions() const;\n\n\tUFUNCTION(BlueprintCallable)\n\tvoid SelectOption(int32 OptionIndex);\n\n\tUFUNCTION(BlueprintCallable)\n\tvoid StartDialogue(int32 StartNodeId);\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tTArray<FDialogueNode> DialogueNodes;\n\n\tint32 CurrentNodeId;\n};\n```", "cpp_code": "```cpp\n#include \"DialogueSystem.h\"\n\nUDialogueSystem::UDialogueSystem()\n\t: CurrentNodeId(-1)\n{\n\t// Initialize with some sample data if needed\n}\n\nFString UDialogueSystem::GetCurrentDialogueText() const\n{\n\tfor (const FDialogueNode& Node : DialogueNodes)\n\t{\n\t\tif (Node.NodeId == CurrentNodeId)\n\t\t{\n\t\t\treturn Node.DialogueText;\n\t\t}\n\t}\n\treturn FString();\n}\n\nTArray<FDialogueOption> UDialogueSystem::GetCurrentOptions() const\n{\n\tfor (const FDialogueNode& Node : DialogueNodes)\n\t{\n\t\tif (Node.NodeId == CurrentNodeId)\n\t\t{\n\t\t\treturn Node.Options;\n\t\t}\n\t}\n\treturn TArray<FDialogueOption>();\n}\n\nvoid UDialogueSystem::SelectOption(int32 OptionIndex)\n{\n\tfor (const FDialogueNode& Node : DialogueNodes)\n\t{\n\t\tif (Node.NodeId == CurrentNodeId)\n\t\t{\n\t\t\tif (Node.Options.IsValidIndex(OptionIndex))\n\t\t\t{\n\t\t\t\tCurrentNodeId = Node.Options[OptionIndex].NextNodeId;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid UDialogueSystem::StartDialogue(int32 StartNodeId)\n{\n\tCurrentNodeId = StartNodeId;\n}\n```"}
{"requirement": "Implement a procedural terrain generation system that creates varied landscapes based on seed values.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ProceduralTerrainGenerator.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AProceduralTerrainGenerator : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAProceduralTerrainGenerator();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Seed value for terrain generation\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Terrain\")\n\tint32 Seed;\n\n\t// Function to generate terrain\n\tUFUNCTION(BlueprintCallable, Category=\"Terrain\")\n\tvoid GenerateTerrain();\n\nprivate:\n\tvoid InitializeNoiseGenerator();\n\tfloat GetTerrainHeight(float X, float Y);\n\n\tclass FSimplexNoiseGenerator* NoiseGenerator;\n};\n```", "cpp_code": "```cpp\n#include \"ProceduralTerrainGenerator.h\"\n#include \"SimplexNoiseBPLibrary.h\"\n\n// Sets default values\nAProceduralTerrainGenerator::AProceduralTerrainGenerator()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tSeed = 12345;\n}\n\n// Called when the game starts or when spawned\nvoid AProceduralTerrainGenerator::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitializeNoiseGenerator();\n\tGenerateTerrain();\n}\n\n// Called every frame\nvoid AProceduralTerrainGenerator::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AProceduralTerrainGenerator::InitializeNoiseGenerator()\n{\n\tNoiseGenerator = new FSimplexNoiseGenerator();\n\tNoiseGenerator->SetSeed(Seed);\n}\n\nfloat AProceduralTerrainGenerator::GetTerrainHeight(float X, float Y)\n{\n\treturn NoiseGenerator->GetNoise2D(X, Y);\n}\n\nvoid AProceduralTerrainGenerator::GenerateTerrain()\n{\n\t// Example: Generate a grid of terrain heights\n\tconst int32 GridSize = 100;\n\tconst float Scale = 100.0f;\n\n\tfor (int32 X = 0; X < GridSize; ++X)\n\t{\n\t\tfor (int32 Y = 0; Y < GridSize; ++Y)\n\t\t{\n\t\t\tfloat Height = GetTerrainHeight(X * Scale, Y * Scale);\n\t\t\t// Use Height to create terrain mesh or modify landscape\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a physics-based destructible environment using C++ where objects break apart realistically on impact.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DestructibleEnvironment.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ADestructibleEnvironment : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tADestructibleEnvironment();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tclass UStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Destruction\")\n\tfloat ImpactThreshold;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\n\tvoid BreakApart();\n};\n```", "cpp_code": "```cpp\n#include \"DestructibleEnvironment.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nADestructibleEnvironment::ADestructibleEnvironment()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ADestructibleEnvironment::OnHit);\n\n\tImpactThreshold = 100.0f;\n}\n\nvoid ADestructibleEnvironment::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADestructibleEnvironment::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADestructibleEnvironment::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (NormalImpulse.Size() > ImpactThreshold)\n\t{\n\t\tBreakApart();\n\t}\n}\n\nvoid ADestructibleEnvironment::BreakApart()\n{\n\t// Logic to break apart the mesh into fragments, you can use the Apex Destruction plugin\n\t// or create a custom implementation for fragmenting mesh.\n\tUE_LOG(LogTemp, Warning, TEXT(\"Breaking apart the object!\"));\n\t// Example: Using the DestructibleMesh component to simulate\n\t// Replace this with actual destructible code or plugin usage\n\tMeshComponent->DestroyComponent();\n\t// Additional code to spawn debris or particles\n}\n```"}
{"requirement": "Develop a C++ component that handles player input and allows for remappable key bindings.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"InputAction.h\"\n#include \"PlayerInputComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API UPlayerInputComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUPlayerInputComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvoid BindAction(FName ActionName, FInputActionBinding::EInputEvent KeyEvent, FName FunctionName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvoid RebindAction(FName ActionName, FKey NewKey);\n\nprivate:\n\tUInputComponent* InputComponent;\n\tTMap<FName, FInputActionBinding> ActionBindings;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerInputComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nUPlayerInputComponent::UPlayerInputComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UPlayerInputComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tInputComponent = Owner->FindComponentByClass<UInputComponent>();\n\t\tif (!InputComponent && GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"InputComponent not found!\"));\n\t\t}\n\t}\n}\n\nvoid UPlayerInputComponent::BindAction(FName ActionName, FInputActionBinding::EInputEvent KeyEvent, FName FunctionName)\n{\n\tif (InputComponent)\n\t{\n\t\tFInputActionBinding Binding(ActionName, KeyEvent);\n\t\tBinding.ActionDelegate.GetDelegateForManualSet().BindUFunction(GetOwner(), FunctionName);\n\t\tInputComponent->AddActionBinding(Binding);\n\t\tActionBindings.Add(ActionName, Binding);\n\t}\n}\n\nvoid UPlayerInputComponent::RebindAction(FName ActionName, FKey NewKey)\n{\n\tif (InputComponent && ActionBindings.Contains(ActionName))\n\t{\n\t\tFInputActionBinding& Binding = ActionBindings[ActionName];\n\t\tBinding.bConsumeInput = false; // Remove old binding\n\t\tInputComponent->RemoveActionBinding(Binding);\n\n\t\tFInputActionKeyMapping NewMapping(ActionName, NewKey);\n\t\tBinding.KeyEvent = IE_Pressed; // Assuming default to Pressed, modify as needed\n\t\tInputComponent->AddActionMapping(NewMapping);\n\t\tInputComponent->AddActionBinding(Binding);\n\t}\n}\n```"}
{"requirement": "Implement a C++ system for dynamic weather effects, including rain, snow, and fog, influencing gameplay.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WeatherSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWeatherSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWeatherSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Weather\")\n\tvoid SetWeatherCondition(FString Condition);\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Weather\")\n\tfloat RainIntensity;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Weather\")\n\tfloat SnowIntensity;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Weather\")\n\tfloat FogDensity;\n\nprivate:\n\tvoid ApplyRainEffect();\n\tvoid ApplySnowEffect();\n\tvoid ApplyFogEffect();\n\n\tFString CurrentCondition;\n};\n```", "cpp_code": "```cpp\n#include \"WeatherSystem.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Actor.h\"\n\nAWeatherSystem::AWeatherSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRainIntensity = 0.0f;\n\tSnowIntensity = 0.0f;\n\tFogDensity = 0.0f;\n\tCurrentCondition = \"Clear\";\n}\n\nvoid AWeatherSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AWeatherSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (CurrentCondition == \"Rain\")\n\t{\n\t\tApplyRainEffect();\n\t}\n\telse if (CurrentCondition == \"Snow\")\n\t{\n\t\tApplySnowEffect();\n\t}\n\telse if (CurrentCondition == \"Fog\")\n\t{\n\t\tApplyFogEffect();\n\t}\n}\n\nvoid AWeatherSystem::SetWeatherCondition(FString Condition)\n{\n\tCurrentCondition = Condition;\n}\n\nvoid AWeatherSystem::ApplyRainEffect()\n{\n\tRainIntensity = FMath::Clamp(RainIntensity + 0.1f, 0.0f, 1.0f);\n\t// Implement rain effect logic, influencing gameplay, e.g., changing character movement speed\n}\n\nvoid AWeatherSystem::ApplySnowEffect()\n{\n\tSnowIntensity = FMath::Clamp(SnowIntensity + 0.1f, 0.0f, 1.0f);\n\t// Implement snow effect logic, influencing gameplay, e.g., reducing visibility\n}\n\nvoid AWeatherSystem::ApplyFogEffect()\n{\n\tFogDensity = FMath::Clamp(FogDensity + 0.01f, 0.0f, 1.0f);\n\t// Implement fog effect logic, influencing gameplay, e.g., affecting AI perception\n}\n```"}
{"requirement": "Create a C++ class for a save/load system that serializes and deserializes game data efficiently.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/SaveGame.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"MySaveGame.generated.h\"\n\nUCLASS()\nclass MYGAME_API UMySaveGame : public USaveGame\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMySaveGame();\n\n\tUPROPERTY(VisibleAnywhere, Category = Basic)\n\tFString PlayerName;\n\n\tUPROPERTY(VisibleAnywhere, Category = Basic)\n\tint32 PlayerScore;\n\n\tUPROPERTY(VisibleAnywhere, Category = Basic)\n\tTArray<FVector> PlayerLocations;\n\n\tbool SaveGameToSlot(const FString& SlotName, const int32 UserIndex);\n\tstatic UMySaveGame* LoadGameFromSlot(const FString& SlotName, const int32 UserIndex);\n};\n```", "cpp_code": "```cpp\n#include \"MySaveGame.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUMySaveGame::UMySaveGame()\n{\n\tPlayerName = TEXT(\"Default\");\n\tPlayerScore = 0;\n\tPlayerLocations = TArray<FVector>();\n}\n\nbool UMySaveGame::SaveGameToSlot(const FString& SlotName, const int32 UserIndex)\n{\n\treturn UGameplayStatics::SaveGameToSlot(this, SlotName, UserIndex);\n}\n\nUMySaveGame* UMySaveGame::LoadGameFromSlot(const FString& SlotName, const int32 UserIndex)\n{\n\tif (UGameplayStatics::DoesSaveGameExist(SlotName, UserIndex))\n\t{\n\t\treturn Cast<UMySaveGame>(UGameplayStatics::LoadGameFromSlot(SlotName, UserIndex));\n\t}\n\treturn nullptr;\n}\n```"}
{"requirement": "Develop a custom C++ shader that renders water with realistic reflections and refractions.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GlobalShader.h\"\n#include \"ShaderParameterUtils.h\"\n#include \"RHIStaticStates.h\"\n\nclass FWaterShader : public FGlobalShader\n{\n\tDECLARE_SHADER_TYPE(FWaterShader, Global);\n\npublic:\n\tFWaterShader() {}\n\tFWaterShader(const ShaderMetaType::CompiledShaderInitializerType& Initializer);\n\n\tstatic bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters);\n\tstatic void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment);\n\n\tvoid BindParameters(const FShaderParameterMap& ParameterMap);\n\tvoid SetParameters(FRHICommandList& RHICmdList, const FSceneView& View, FTextureRHIRef ReflectionTexture, FTextureRHIRef RefractionTexture);\n\nprivate:\n\tFShaderResourceParameter ReflectionTextureParameter;\n\tFShaderResourceParameter RefractionTextureParameter;\n};\n```", "cpp_code": "```cpp\n#include \"WaterShader.h\"\n#include \"ShaderParameterUtils.h\"\n#include \"RHIStaticStates.h\"\n\nIMPLEMENT_SHADER_TYPE(, FWaterShader, TEXT(\"WaterShader\"), TEXT(\"Main\"), SF_Pixel);\n\nFWaterShader::FWaterShader(const ShaderMetaType::CompiledShaderInitializerType& Initializer)\n\t: FGlobalShader(Initializer)\n{\n\tReflectionTextureParameter.Bind(Initializer.ParameterMap, TEXT(\"ReflectionTexture\"));\n\tRefractionTextureParameter.Bind(Initializer.ParameterMap, TEXT(\"RefractionTexture\"));\n}\n\nbool FWaterShader::ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)\n{\n\treturn true;\n}\n\nvoid FWaterShader::ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)\n{\n\tFGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);\n}\n\nvoid FWaterShader::BindParameters(const FShaderParameterMap& ParameterMap)\n{\n\tReflectionTextureParameter.Bind(ParameterMap, TEXT(\"ReflectionTexture\"));\n\tRefractionTextureParameter.Bind(ParameterMap, TEXT(\"RefractionTexture\"));\n}\n\nvoid FWaterShader::SetParameters(FRHICommandList& RHICmdList, const FSceneView& View, FTextureRHIRef ReflectionTexture, FTextureRHIRef RefractionTexture)\n{\n\tSetTextureParameter(RHICmdList, GetPixelShader(), ReflectionTextureParameter, ReflectionTexture);\n\tSetTextureParameter(RHICmdList, GetPixelShader(), RefractionTextureParameter, RefractionTexture);\n}\n```"}
{"requirement": "Implement a C++ class for a quest system that tracks objectives, rewards, and progress for players.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"QuestSystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FQuestObjective\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Quest\")\n\tFString Description;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Quest\")\n\tbool bIsCompleted;\n\n\tFQuestObjective()\n\t\t: Description(TEXT(\"\")), bIsCompleted(false)\n\t{}\n};\n\nUCLASS(Blueprintable)\nclass YOURGAME_API UQuestSystem : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUQuestSystem();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Quest\")\n\tvoid AddObjective(const FString& Description);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Quest\")\n\tvoid CompleteObjective(int32 ObjectiveIndex);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Quest\")\n\tbool IsQuestCompleted() const;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Quest\")\n\tTArray<FQuestObjective> GetObjectives() const;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Quest\")\n\tvoid SetReward(const FString& NewReward);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Quest\")\n\tFString GetReward() const;\n\nprivate:\n\tUPROPERTY()\n\tTArray<FQuestObjective> Objectives;\n\n\tUPROPERTY()\n\tFString Reward;\n};\n```", "cpp_code": "```cpp\n#include \"QuestSystem.h\"\n\nUQuestSystem::UQuestSystem()\n{\n\t// Initialize default values\n\tReward = TEXT(\"\");\n}\n\nvoid UQuestSystem::AddObjective(const FString& Description)\n{\n\tFQuestObjective NewObjective;\n\tNewObjective.Description = Description;\n\tObjectives.Add(NewObjective);\n}\n\nvoid UQuestSystem::CompleteObjective(int32 ObjectiveIndex)\n{\n\tif (Objectives.IsValidIndex(ObjectiveIndex))\n\t{\n\t\tObjectives[ObjectiveIndex].bIsCompleted = true;\n\t}\n}\n\nbool UQuestSystem::IsQuestCompleted() const\n{\n\tfor (const FQuestObjective& Objective : Objectives)\n\t{\n\t\tif (!Objective.bIsCompleted)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nTArray<FQuestObjective> UQuestSystem::GetObjectives() const\n{\n\treturn Objectives;\n}\n\nvoid UQuestSystem::SetReward(const FString& NewReward)\n{\n\tReward = NewReward;\n}\n\nFString UQuestSystem::GetReward() const\n{\n\treturn Reward;\n}\n```"}
{"requirement": "Create a custom C++ UI component for a minimap that shows player position and nearby points of interest.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"MinimapWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UMinimapWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMinimapWidget(const FObjectInitializer& ObjectInitializer);\n\n\tvirtual void NativeConstruct() override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Minimap\")\n\tvoid UpdatePlayerPosition(const FVector2D& PlayerPosition);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Minimap\")\n\tvoid UpdatePointsOfInterest(const TArray<FVector2D>& PointsOfInterest);\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (BindWidget), Category = \"Minimap\")\n\tclass UImage* MinimapImage;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (BindWidget), Category = \"Minimap\")\n\tclass UCanvasPanel* MinimapCanvas;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Minimap\")\n\tFVector2D PlayerPosition;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Minimap\")\n\tTArray<FVector2D> PointsOfInterest;\n};\n```", "cpp_code": "```cpp\n#include \"MinimapWidget.h\"\n#include \"Components/Image.h\"\n#include \"Components/CanvasPanel.h\"\n\nUMinimapWidget::UMinimapWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UMinimapWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n}\n\nvoid UMinimapWidget::UpdatePlayerPosition(const FVector2D& NewPlayerPosition)\n{\n\tPlayerPosition = NewPlayerPosition;\n\t// Here you would add logic to update the player's position on the minimap\n}\n\nvoid UMinimapWidget::UpdatePointsOfInterest(const TArray<FVector2D>& NewPointsOfInterest)\n{\n\tPointsOfInterest = NewPointsOfInterest;\n\t// Here you would add logic to update the points of interest on the minimap\n}\n```"}
{"requirement": "Develop a C++ component for a crafting system that combines resources to create new items.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CraftingComponent.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FResourceItem\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString ResourceName;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 Quantity;\n};\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API UCraftingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUCraftingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category=\"Crafting\")\n\tbool CraftItem(const TArray<FResourceItem>& Resources, const FString& ItemName);\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Crafting\")\n\tTMap<FString, TArray<FResourceItem>> CraftingRecipes;\n};\n```", "cpp_code": "```cpp\n#include \"CraftingComponent.h\"\n\nUCraftingComponent::UCraftingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UCraftingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nbool UCraftingComponent::CraftItem(const TArray<FResourceItem>& Resources, const FString& ItemName)\n{\n\tif (!CraftingRecipes.Contains(ItemName))\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Crafting recipe for %s not found.\"), *ItemName);\n\t\treturn false;\n\t}\n\n\tconst TArray<FResourceItem>& RequiredResources = CraftingRecipes[ItemName];\n\n\tfor (const FResourceItem& RequiredResource : RequiredResources)\n\t{\n\t\tbool bResourceFound = false;\n\t\tfor (const FResourceItem& AvailableResource : Resources)\n\t\t{\n\t\t\tif (AvailableResource.ResourceName == RequiredResource.ResourceName && \n\t\t\t\tAvailableResource.Quantity >= RequiredResource.Quantity)\n\t\t\t{\n\t\t\t\tbResourceFound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!bResourceFound)\n\t\t{\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Insufficient resources to craft %s.\"), *ItemName);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tUE_LOG(LogTemp, Log, TEXT(\"Crafted item: %s\"), *ItemName);\n\treturn true;\n}\n```"}
{"requirement": "Implement a C++ class for character customization, allowing players to change appearance and gear.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"CharacterCustomization.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACharacterCustomization : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tACharacterCustomization();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Change character's appearance\n\tUFUNCTION(BlueprintCallable, Category=\"Customization\")\n\tvoid ChangeAppearance(FString AppearanceID);\n\n\t// Change character's gear\n\tUFUNCTION(BlueprintCallable, Category=\"Customization\")\n\tvoid ChangeGear(FString GearID);\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Customization\", meta=(AllowPrivateAccess = \"true\"))\n\tFString CurrentAppearance;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Customization\", meta=(AllowPrivateAccess = \"true\"))\n\tFString CurrentGear;\n};\n```", "cpp_code": "```cpp\n#include \"CharacterCustomization.h\"\n\n// Sets default values\nACharacterCustomization::ACharacterCustomization()\n{\n\t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default appearance and gear\n\tCurrentAppearance = \"DefaultAppearance\";\n\tCurrentGear = \"DefaultGear\";\n}\n\n// Called when the game starts or when spawned\nvoid ACharacterCustomization::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Initialize additional setup if needed\n}\n\n// Called every frame\nvoid ACharacterCustomization::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid ACharacterCustomization::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\nvoid ACharacterCustomization::ChangeAppearance(FString AppearanceID)\n{\n\t// Logic to change the character's appearance based on AppearanceID\n\tCurrentAppearance = AppearanceID;\n\tUE_LOG(LogTemp, Log, TEXT(\"Appearance changed to: %s\"), *CurrentAppearance);\n}\n\nvoid ACharacterCustomization::ChangeGear(FString GearID)\n{\n\t// Logic to change the character's gear based on GearID\n\tCurrentGear = GearID;\n\tUE_LOG(LogTemp, Log, TEXT(\"Gear changed to: %s\"), *CurrentGear);\n}\n```"}
{"requirement": "Create AI pathfinding using A* algorithm in C++ for complex environments with obstacles.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AStarPathfinder.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FNode {\n\tGENERATED_BODY()\n\n\tFVector Position;\n\tfloat GCost;\n\tfloat HCost;\n\tfloat FCost() const { return GCost + HCost; }\n\tFNode* Parent;\n\n\tFNode() : Position(FVector::ZeroVector), GCost(0), HCost(0), Parent(nullptr) {}\n};\n\nUCLASS()\nclass YOURPROJECT_API AAStarPathfinder : public AActor {\n\tGENERATED_BODY()\n\npublic:\n\tAAStarPathfinder();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tTArray<FVector> FindPath(const FVector& Start, const FVector& End);\n\nprivate:\n\tTArray<FNode*> OpenSet;\n\tTArray<FNode*> ClosedSet;\n\n\tFNode* GetLowestFCostNode();\n\tTArray<FNode*> GetNeighboringNodes(FNode* CurrentNode);\n\tfloat CalculateHCost(const FVector& NodePosition, const FVector& EndPosition);\n\tbool IsPositionWalkable(const FVector& Position);\n};\n```", "cpp_code": "```cpp\n#include \"AStarPathfinder.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nAAStarPathfinder::AAStarPathfinder() {\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AAStarPathfinder::BeginPlay() {\n\tSuper::BeginPlay();\n}\n\nTArray<FVector> AAStarPathfinder::FindPath(const FVector& Start, const FVector& End) {\n\tTArray<FVector> Path;\n\tOpenSet.Empty();\n\tClosedSet.Empty();\n\n\tFNode* StartNode = new FNode();\n\tStartNode->Position = Start;\n\tStartNode->GCost = 0;\n\tStartNode->HCost = CalculateHCost(Start, End);\n\tStartNode->Parent = nullptr;\n\n\tOpenSet.Add(StartNode);\n\n\twhile (OpenSet.Num() > 0) {\n\t\tFNode* CurrentNode = GetLowestFCostNode();\n\n\t\tif (CurrentNode->Position.Equals(End, 1.0f)) {\n\t\t\tFNode* Node = CurrentNode;\n\t\t\twhile (Node != nullptr) {\n\t\t\t\tPath.Add(Node->Position);\n\t\t\t\tNode = Node->Parent;\n\t\t\t}\n\t\t\tAlgo::Reverse(Path);\n\t\t\tbreak;\n\t\t}\n\n\t\tOpenSet.Remove(CurrentNode);\n\t\tClosedSet.Add(CurrentNode);\n\n\t\tfor (FNode* Neighbor : GetNeighboringNodes(CurrentNode)) {\n\t\t\tif (ClosedSet.Contains(Neighbor) || !IsPositionWalkable(Neighbor->Position)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfloat NewGCost = CurrentNode->GCost + FVector::Dist(CurrentNode->Position, Neighbor->Position);\n\t\t\tif (NewGCost < Neighbor->GCost || !OpenSet.Contains(Neighbor)) {\n\t\t\t\tNeighbor->GCost = NewGCost;\n\t\t\t\tNeighbor->HCost = CalculateHCost(Neighbor->Position, End);\n\t\t\t\tNeighbor->Parent = CurrentNode;\n\n\t\t\t\tif (!OpenSet.Contains(Neighbor)) {\n\t\t\t\t\tOpenSet.Add(Neighbor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Path;\n}\n\nFNode* AAStarPathfinder::GetLowestFCostNode() {\n\tFNode* LowestFCostNode = OpenSet[0];\n\tfor (FNode* Node : OpenSet) {\n\t\tif (Node->FCost() < LowestFCostNode->FCost()) {\n\t\t\tLowestFCostNode = Node;\n\t\t}\n\t}\n\treturn LowestFCostNode;\n}\n\nTArray<FNode*> AAStarPathfinder::GetNeighboringNodes(FNode* CurrentNode) {\n\tTArray<FNode*> Neighbors;\n\tFVector Directions[4] = { FVector(1, 0, 0), FVector(-1, 0, 0), FVector(0, 1, 0), FVector(0, -1, 0) };\n\n\tfor (FVector Direction : Directions) {\n\t\tFVector NeighborPos = CurrentNode->Position + Direction * 100.0f; // Assuming a grid size of 100 units\n\t\tFNode* NeighborNode = new FNode();\n\t\tNeighborNode->Position = NeighborPos;\n\t\tNeighbors.Add(NeighborNode);\n\t}\n\n\treturn Neighbors;\n}\n\nfloat AAStarPathfinder::CalculateHCost(const FVector& NodePosition, const FVector& EndPosition) {\n\treturn FVector::Dist(NodePosition, EndPosition);\n}\n\nbool AAStarPathfinder::IsPositionWalkable(const FVector& Position) {\n\t// This should be replaced with actual walkability check logic\n\tFHitResult HitResult;\n\tFVector Start = Position;\n\tFVector End = Position + FVector(0, 0, -1);\n\treturn !GetWorld()->LineTraceSingleByChannel(HitResult, Start, End, ECC_Visibility);\n}\n```"}
{"requirement": "Develop a C++ component that manages in-game achievements and tracks player progress towards them.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"AchievementManagerComponent.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FAchievement\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Achievement\")\n\tFName Name;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Achievement\")\n\tFString Description;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Achievement\")\n\tint32 TargetValue;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Achievement\")\n\tint32 CurrentValue;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Achievement\")\n\tbool bIsUnlocked;\n\n\tFAchievement()\n\t\t: Name(NAME_None), Description(TEXT(\"\")), TargetValue(0), CurrentValue(0), bIsUnlocked(false) {}\n};\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API UAchievementManagerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUAchievementManagerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category = \"Achievement\")\n\tvoid AddProgress(FName AchievementName, int32 Progress);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Achievement\")\n\tvoid UnlockAchievement(FName AchievementName);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Achievement\")\n\tbool IsAchievementUnlocked(FName AchievementName) const;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Achievements\")\n\tTArray<FAchievement> Achievements;\n\nprivate:\n\tFAchievement* FindAchievementByName(FName AchievementName);\n};\n```", "cpp_code": "```cpp\n#include \"AchievementManagerComponent.h\"\n\nUAchievementManagerComponent::UAchievementManagerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UAchievementManagerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UAchievementManagerComponent::AddProgress(FName AchievementName, int32 Progress)\n{\n\tFAchievement* Achievement = FindAchievementByName(AchievementName);\n\tif (Achievement && !Achievement->bIsUnlocked)\n\t{\n\t\tAchievement->CurrentValue += Progress;\n\t\tif (Achievement->CurrentValue >= Achievement->TargetValue)\n\t\t{\n\t\t\tUnlockAchievement(AchievementName);\n\t\t}\n\t}\n}\n\nvoid UAchievementManagerComponent::UnlockAchievement(FName AchievementName)\n{\n\tFAchievement* Achievement = FindAchievementByName(AchievementName);\n\tif (Achievement && !Achievement->bIsUnlocked)\n\t{\n\t\tAchievement->bIsUnlocked = true;\n\t\t// Notify the game or player that an achievement has been unlocked, e.g., trigger an event\n\t}\n}\n\nbool UAchievementManagerComponent::IsAchievementUnlocked(FName AchievementName) const\n{\n\tconst FAchievement* Achievement = FindAchievementByName(AchievementName);\n\treturn Achievement ? Achievement->bIsUnlocked : false;\n}\n\nFAchievement* UAchievementManagerComponent::FindAchievementByName(FName AchievementName)\n{\n\tfor (FAchievement& Achievement : Achievements)\n\t{\n\t\tif (Achievement.Name == AchievementName)\n\t\t{\n\t\t\treturn &Achievement;\n\t\t}\n\t}\n\treturn nullptr;\n}\n```"}
{"requirement": "Implement a networked chat system in C++ that supports private and group messaging between players.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/PlayerState.h\"\n#include \"ChatSystem.generated.h\"\n\nUCLASS()\nclass AChatSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAChatSystem();\n\n\tUFUNCTION(Server, Reliable, WithValidation)\n\tvoid ServerSendPrivateMessage(APlayerState* Sender, APlayerState* Receiver, const FString& Message);\n\n\tUFUNCTION(Server, Reliable, WithValidation)\n\tvoid ServerSendGroupMessage(APlayerState* Sender, const TArray<APlayerState*>& Group, const FString& Message);\n\n\tUFUNCTION(Client, Reliable)\n\tvoid ClientReceiveMessage(APlayerState* Sender, const FString& Message);\n};\n```", "cpp_code": "```cpp\n#include \"ChatSystem.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"GameFramework/PlayerState.h\"\n\nAChatSystem::AChatSystem()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tbReplicates = true;\n}\n\nvoid AChatSystem::ServerSendPrivateMessage_Implementation(APlayerState* Sender, APlayerState* Receiver, const FString& Message)\n{\n\tif (Receiver)\n\t{\n\t\tReceiver->GetOwner()->ClientReceiveMessage(Sender, Message);\n\t}\n}\n\nbool AChatSystem::ServerSendPrivateMessage_Validate(APlayerState* Sender, APlayerState* Receiver, const FString& Message)\n{\n\treturn true;\n}\n\nvoid AChatSystem::ServerSendGroupMessage_Implementation(APlayerState* Sender, const TArray<APlayerState*>& Group, const FString& Message)\n{\n\tfor (APlayerState* Player : Group)\n\t{\n\t\tif (Player)\n\t\t{\n\t\t\tPlayer->GetOwner()->ClientReceiveMessage(Sender, Message);\n\t\t}\n\t}\n}\n\nbool AChatSystem::ServerSendGroupMessage_Validate(APlayerState* Sender, const TArray<APlayerState*>& Group, const FString& Message)\n{\n\treturn true;\n}\n\nvoid AChatSystem::ClientReceiveMessage_Implementation(APlayerState* Sender, const FString& Message)\n{\n\t// Client-side logic to display the message, such as updating the UI\n}\n```"}
{"requirement": "Create a C++ class for a dynamic soundtrack system that changes music based on game events.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicSoundtrackSystem.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADynamicSoundtrackSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADynamicSoundtrackSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Soundtrack\")\n\tTMap<FString, USoundCue*> Soundtracks;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Soundtrack\")\n\tUAudioComponent* AudioComponent;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Soundtrack\")\n\tvoid ChangeMusic(FString EventName);\n\nprivate:\n\tvoid PlaySoundtrack(USoundCue* SoundCue);\n};\n```", "cpp_code": "```cpp\n#include \"DynamicSoundtrackSystem.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n\nADynamicSoundtrackSystem::ADynamicSoundtrackSystem()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->bAutoActivate = false;\n\tRootComponent = AudioComponent;\n}\n\nvoid ADynamicSoundtrackSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADynamicSoundtrackSystem::ChangeMusic(FString EventName)\n{\n\tif (USoundCue** FoundCue = Soundtracks.Find(EventName))\n\t{\n\t\tPlaySoundtrack(*FoundCue);\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Soundtrack for event %s not found.\"), *EventName);\n\t}\n}\n\nvoid ADynamicSoundtrackSystem::PlaySoundtrack(USoundCue* SoundCue)\n{\n\tif (SoundCue)\n\t{\n\t\tAudioComponent->SetSound(SoundCue);\n\t\tAudioComponent->Play();\n\t}\n}\n```"}
{"requirement": "Develop a C++ component for real-time voice chat within multiplayer sessions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"OnlineSubsystem.h\"\n#include \"Interfaces/VoiceInterface.h\"\n#include \"VoiceChatComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API UVoiceChatComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUVoiceChatComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\tvoid StartVoiceChat();\n\tvoid StopVoiceChat();\n\nprivate:\n\tIOnlineVoicePtr VoiceInterface;\n\tvoid InitializeVoiceChat();\n\tvoid OnVoiceChatAvailable(bool bSuccess);\n};\n```", "cpp_code": "```cpp\n#include \"VoiceChatComponent.h\"\n#include \"OnlineSubsystemUtils.h\"\n\nUVoiceChatComponent::UVoiceChatComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UVoiceChatComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitializeVoiceChat();\n}\n\nvoid UVoiceChatComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tStopVoiceChat();\n\tSuper::EndPlay(EndPlayReason);\n}\n\nvoid UVoiceChatComponent::InitializeVoiceChat()\n{\n\tif (IOnlineSubsystem* OnlineSubsystem = IOnlineSubsystem::Get())\n\t{\n\t\tVoiceInterface = OnlineSubsystem->GetVoiceInterface();\n\t\tif (VoiceInterface.IsValid())\n\t\t{\n\t\t\tVoiceInterface->RegisterLocalTalker(0);\n\t\t}\n\t}\n}\n\nvoid UVoiceChatComponent::StartVoiceChat()\n{\n\tif (VoiceInterface.IsValid())\n\t{\n\t\tVoiceInterface->StartNetworkedVoice(0);\n\t}\n}\n\nvoid UVoiceChatComponent::StopVoiceChat()\n{\n\tif (VoiceInterface.IsValid())\n\t{\n\t\tVoiceInterface->StopNetworkedVoice(0);\n\t}\n}\n```"}
{"requirement": "Implement a custom C++ physics system for vehicle movement, including acceleration, braking, and drifting.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"CustomVehicle.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomVehicle : public APawn\n{\n\tGENERATED_BODY()\n\npublic:\n\tACustomVehicle();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid Accelerate(float Value);\n\tvoid Brake(float Value);\n\tvoid Drift(float Value);\n\nprivate:\n\tFVector CurrentVelocity;\n\tfloat Acceleration;\n\tfloat BrakeStrength;\n\tfloat DriftFactor;\n};\n```", "cpp_code": "```cpp\n#include \"CustomVehicle.h\"\n\nACustomVehicle::ACustomVehicle()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tAcceleration = 1000.0f;\n\tBrakeStrength = 500.0f;\n\tDriftFactor = 0.5f;\n\tCurrentVelocity = FVector::ZeroVector;\n}\n\nvoid ACustomVehicle::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACustomVehicle::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation() + CurrentVelocity * DeltaTime;\n\tSetActorLocation(NewLocation);\n}\n\nvoid ACustomVehicle::Accelerate(float Value)\n{\n\tCurrentVelocity += GetActorForwardVector() * Acceleration * Value;\n}\n\nvoid ACustomVehicle::Brake(float Value)\n{\n\tCurrentVelocity -= GetActorForwardVector() * BrakeStrength * Value;\n\tif (CurrentVelocity.SizeSquared() < KINDA_SMALL_NUMBER)\n\t{\n\t\tCurrentVelocity = FVector::ZeroVector;\n\t}\n}\n\nvoid ACustomVehicle::Drift(float Value)\n{\n\tFVector DriftDirection = FVector::CrossProduct(GetActorUpVector(), CurrentVelocity).GetSafeNormal();\n\tCurrentVelocity += DriftDirection * DriftFactor * Value;\n}\n```"}
{"requirement": "Create a C++ class for a skill tree system that allows players to unlock and upgrade abilities.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"SkillTreeSystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FSkill\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Skill\")\n\tFName SkillName;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Skill\")\n\tint32 Level;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Skill\")\n\tbool bUnlocked;\n\n\tFSkill()\n\t\t: SkillName(NAME_None), Level(0), bUnlocked(false)\n\t{}\n};\n\nUCLASS(Blueprintable)\nclass YOURGAME_API USkillTreeSystem : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUSkillTreeSystem();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Skill Tree\")\n\tTArray<FSkill> Skills;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Skill Tree\")\n\tbool UnlockSkill(FName SkillName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Skill Tree\")\n\tbool UpgradeSkill(FName SkillName);\n\nprotected:\n\tFSkill* FindSkillByName(FName SkillName);\n};\n```", "cpp_code": "```cpp\n#include \"SkillTreeSystem.h\"\n\nUSkillTreeSystem::USkillTreeSystem()\n{\n\t// Initialize with some skills for example purposes\n\tSkills.Add(FSkill{ FName(\"Fireball\"), 0, false });\n\tSkills.Add(FSkill{ FName(\"IceBlast\"), 0, false });\n\tSkills.Add(FSkill{ FName(\"LightningStrike\"), 0, false });\n}\n\nbool USkillTreeSystem::UnlockSkill(FName SkillName)\n{\n\tFSkill* Skill = FindSkillByName(SkillName);\n\tif (Skill && !Skill->bUnlocked)\n\t{\n\t\tSkill->bUnlocked = true;\n\t\tSkill->Level = 1;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool USkillTreeSystem::UpgradeSkill(FName SkillName)\n{\n\tFSkill* Skill = FindSkillByName(SkillName);\n\tif (Skill && Skill->bUnlocked)\n\t{\n\t\tSkill->Level++;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nFSkill* USkillTreeSystem::FindSkillByName(FName SkillName)\n{\n\tfor (FSkill& Skill : Skills)\n\t{\n\t\tif (Skill.SkillName == SkillName)\n\t\t{\n\t\t\treturn &Skill;\n\t\t}\n\t}\n\treturn nullptr;\n}\n```"}
{"requirement": "Develop a C++ component for a leaderboard system that tracks and displays player rankings.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LeaderboardComponent.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FPlayerScore\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category = \"Leaderboard\")\n\tFString PlayerName;\n\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category = \"Leaderboard\")\n\tint32 Score;\n\n\tFPlayerScore()\n\t\t: PlayerName(TEXT(\"\")), Score(0) {}\n\n\tFPlayerScore(FString Name, int32 InScore)\n\t\t: PlayerName(Name), Score(InScore) {}\n};\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API ULeaderboardComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tULeaderboardComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Leaderboard\")\n\tvoid AddPlayerScore(const FString& PlayerName, int32 Score);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Leaderboard\")\n\tTArray<FPlayerScore> GetTopPlayers(int32 TopCount = 10) const;\n\nprivate:\n\tUPROPERTY()\n\tTArray<FPlayerScore> PlayerScores;\n\n\tvoid SortLeaderboard();\n};\n```", "cpp_code": "```cpp\n#include \"LeaderboardComponent.h\"\n\nULeaderboardComponent::ULeaderboardComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid ULeaderboardComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ULeaderboardComponent::AddPlayerScore(const FString& PlayerName, int32 Score)\n{\n\tbool bFound = false;\n\tfor (FPlayerScore& PlayerScore : PlayerScores)\n\t{\n\t\tif (PlayerScore.PlayerName == PlayerName)\n\t\t{\n\t\t\tPlayerScore.Score = FMath::Max(PlayerScore.Score, Score);\n\t\t\tbFound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!bFound)\n\t{\n\t\tPlayerScores.Add(FPlayerScore(PlayerName, Score));\n\t}\n\n\tSortLeaderboard();\n}\n\nTArray<FPlayerScore> ULeaderboardComponent::GetTopPlayers(int32 TopCount) const\n{\n\treturn PlayerScores.Num() > TopCount ? PlayerScores.Left(TopCount) : PlayerScores;\n}\n\nvoid ULeaderboardComponent::SortLeaderboard()\n{\n\tPlayerScores.Sort([](const FPlayerScore& A, const FPlayerScore& B) {\n\t\treturn A.Score > B.Score;\n\t});\n}\n```"}
{"requirement": "Implement a C++ system for procedural building generation, creating varied structures with each playthrough.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ProceduralBuildingGenerator.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AProceduralBuildingGenerator : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAProceduralBuildingGenerator();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Building\")\n\tint32 NumberOfFloors;\n\n\tUPROPERTY(EditAnywhere, Category=\"Building\")\n\tfloat FloorHeight;\n\n\tUPROPERTY(EditAnywhere, Category=\"Building\")\n\tTSubclassOf<AActor> WallMesh;\n\n\tUPROPERTY(EditAnywhere, Category=\"Building\")\n\tTSubclassOf<AActor> RoofMesh;\n\n\tvoid GenerateBuilding();\n\nprivate:\n\tvoid GenerateFloor(int32 FloorIndex);\n\tvoid GenerateRoof();\n};\n```", "cpp_code": "```cpp\n#include \"ProceduralBuildingGenerator.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nAProceduralBuildingGenerator::AProceduralBuildingGenerator()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tNumberOfFloors = 5;\n\tFloorHeight = 400.0f;\n}\n\nvoid AProceduralBuildingGenerator::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGenerateBuilding();\n}\n\nvoid AProceduralBuildingGenerator::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AProceduralBuildingGenerator::GenerateBuilding()\n{\n\tfor (int32 i = 0; i < NumberOfFloors; ++i)\n\t{\n\t\tGenerateFloor(i);\n\t}\n\tGenerateRoof();\n}\n\nvoid AProceduralBuildingGenerator::GenerateFloor(int32 FloorIndex)\n{\n\tif (WallMesh)\n\t{\n\t\tFVector Location = GetActorLocation() + FVector(0, 0, FloorIndex * FloorHeight);\n\t\tFRotator Rotation = GetActorRotation();\n\t\tFActorSpawnParameters SpawnParams;\n\t\tGetWorld()->SpawnActor<AActor>(WallMesh, Location, Rotation, SpawnParams);\n\t}\n}\n\nvoid AProceduralBuildingGenerator::GenerateRoof()\n{\n\tif (RoofMesh)\n\t{\n\t\tFVector Location = GetActorLocation() + FVector(0, 0, NumberOfFloors * FloorHeight);\n\t\tFRotator Rotation = GetActorRotation();\n\t\tFActorSpawnParameters SpawnParams;\n\t\tGetWorld()->SpawnActor<AActor>(RoofMesh, Location, Rotation, SpawnParams);\n\t}\n}\n```"}
{"requirement": "Create a C++ class for a weather-based AI behavior system that changes NPC actions based on current weather.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WeatherAIBehavior.generated.h\"\n\nUENUM(BlueprintType)\nenum class EWeatherType : uint8\n{\n\tSunny UMETA(DisplayName = \"Sunny\"),\n\tRainy UMETA(DisplayName = \"Rainy\"),\n\tSnowy UMETA(DisplayName = \"Snowy\")\n};\n\nUCLASS()\nclass MYGAME_API AWeatherAIBehavior : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWeatherAIBehavior();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid SetWeather(EWeatherType NewWeather);\n\nprivate:\n\tEWeatherType CurrentWeather;\n\tvoid UpdateBehavior();\n};\n```", "cpp_code": "```cpp\n#include \"WeatherAIBehavior.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nAWeatherAIBehavior::AWeatherAIBehavior()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentWeather = EWeatherType::Sunny;\n}\n\nvoid AWeatherAIBehavior::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateBehavior();\n}\n\nvoid AWeatherAIBehavior::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AWeatherAIBehavior::SetWeather(EWeatherType NewWeather)\n{\n\tif (CurrentWeather != NewWeather)\n\t{\n\t\tCurrentWeather = NewWeather;\n\t\tUpdateBehavior();\n\t}\n}\n\nvoid AWeatherAIBehavior::UpdateBehavior()\n{\n\tswitch (CurrentWeather)\n\t{\n\tcase EWeatherType::Sunny:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Weather is Sunny. NPCs are active.\"));\n\t\t// Implement Sunny weather behavior\n\t\tbreak;\n\tcase EWeatherType::Rainy:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Weather is Rainy. NPCs seek shelter.\"));\n\t\t// Implement Rainy weather behavior\n\t\tbreak;\n\tcase EWeatherType::Snowy:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Weather is Snowy. NPCs move slowly.\"));\n\t\t// Implement Snowy weather behavior\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n```"}
{"requirement": "Develop a C++ component for a dynamic lighting system that adjusts to time of day and weather conditions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"DynamicLightingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UDynamicLightingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUDynamicLightingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tvoid AdjustLighting(float DeltaTime);\n\tfloat GetTimeOfDayFactor() const;\n\tfloat GetWeatherFactor() const;\n\n\tUPROPERTY(EditAnywhere, Category=\"Lighting\")\n\tfloat MaxIntensity;\n\n\tUPROPERTY(EditAnywhere, Category=\"Lighting\")\n\tfloat MinIntensity;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicLightingComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nUDynamicLightingComponent::UDynamicLightingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tMaxIntensity = 5000.0f;\n\tMinIntensity = 500.0f;\n}\n\nvoid UDynamicLightingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UDynamicLightingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tAdjustLighting(DeltaTime);\n}\n\nvoid UDynamicLightingComponent::AdjustLighting(float DeltaTime)\n{\n\tfloat TimeOfDayFactor = GetTimeOfDayFactor();\n\tfloat WeatherFactor = GetWeatherFactor();\n\tfloat TargetIntensity = FMath::Lerp(MinIntensity, MaxIntensity, TimeOfDayFactor * WeatherFactor);\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tULightComponent* LightComp = Owner->FindComponentByClass<ULightComponent>();\n\t\tif (LightComp)\n\t\t{\n\t\t\tLightComp->SetIntensity(TargetIntensity);\n\t\t}\n\t}\n}\n\nfloat UDynamicLightingComponent::GetTimeOfDayFactor() const\n{\n\tfloat Hour = FDateTime::Now().GetHour() + FDateTime::Now().GetMinute() / 60.0f;\n\tif (Hour >= 6 && Hour <= 18)\n\t{\n\t\treturn 1.0f - FMath::Abs(12.0f - Hour) / 6.0f;\n\t}\n\treturn 0.0f;\n}\n\nfloat UDynamicLightingComponent::GetWeatherFactor() const\n{\n\t// Placeholder for weather conditions factor\n\t// Ideally, this would interface with a weather system\n\treturn 1.0f;\n}\n```"}
{"requirement": "Implement a C++ class for a teleportation system allowing players to move instantly between locations.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TeleportationSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ATeleportationSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tATeleportationSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Teleportation\")\n\tvoid TeleportPlayer(AActor* Player, const FVector& TargetLocation);\n};\n```", "cpp_code": "```cpp\n#include \"TeleportationSystem.h\"\n#include \"GameFramework/Actor.h\"\n\nATeleportationSystem::ATeleportationSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ATeleportationSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATeleportationSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATeleportationSystem::TeleportPlayer(AActor* Player, const FVector& TargetLocation)\n{\n\tif (Player)\n\t{\n\t\tPlayer->SetActorLocation(TargetLocation);\n\t}\n}\n```"}
{"requirement": "Create a C++ component for a reputation system that tracks player actions and alters NPC interactions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ReputationSystemComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API UReputationSystemComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUReputationSystemComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Function to modify reputation\n\tUFUNCTION(BlueprintCallable, Category=\"Reputation\")\n\tvoid ModifyReputation(int32 Amount);\n\n\t// Function to get current reputation\n\tUFUNCTION(BlueprintCallable, Category=\"Reputation\")\n\tint32 GetReputation() const;\n\nprivate:\n\t// Current reputation of the player\n\tUPROPERTY(VisibleAnywhere, Category=\"Reputation\")\n\tint32 Reputation;\n};\n```", "cpp_code": "```cpp\n#include \"ReputationSystemComponent.h\"\n\n// Sets default values for this component's properties\nUReputationSystemComponent::UReputationSystemComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tReputation = 0; // Initialize default reputation\n}\n\n// Called when the game starts\nvoid UReputationSystemComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UReputationSystemComponent::ModifyReputation(int32 Amount)\n{\n\tReputation += Amount;\n\t// Clamp reputation value if necessary, for example between -100 and 100\n\tReputation = FMath::Clamp(Reputation, -100, 100);\n\t// Log or handle changes in reputation\n\tUE_LOG(LogTemp, Warning, TEXT(\"Reputation changed to: %d\"), Reputation);\n}\n\nint32 UReputationSystemComponent::GetReputation() const\n{\n\treturn Reputation;\n}\n```"}
{"requirement": "Develop a C++ system for a global event manager that triggers in-game events based on specific conditions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"EventManager.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FEventTriggeredDelegate, FName, EventName);\n\nUCLASS()\nclass YOURGAME_API UEventManager : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUEventManager();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Event Management\")\n\tvoid TriggerEvent(FName EventName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Event Management\")\n\tvoid RegisterEventCondition(FName EventName, TFunction<bool()> Condition);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Event Management\")\n\tvoid CheckEvents();\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Event Management\")\n\tFEventTriggeredDelegate OnEventTriggered;\n\nprivate:\n\tTMap<FName, TFunction<bool()>> EventConditions;\n};\n```", "cpp_code": "```cpp\n#include \"EventManager.h\"\n\nUEventManager::UEventManager()\n{\n}\n\nvoid UEventManager::TriggerEvent(FName EventName)\n{\n\tOnEventTriggered.Broadcast(EventName);\n}\n\nvoid UEventManager::RegisterEventCondition(FName EventName, TFunction<bool()> Condition)\n{\n\tEventConditions.Add(EventName, Condition);\n}\n\nvoid UEventManager::CheckEvents()\n{\n\tfor (const auto& EventPair : EventConditions)\n\t{\n\t\tif (EventPair.Value())\n\t\t{\n\t\t\tTriggerEvent(EventPair.Key);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a C++ class for a customizable HUD that players can adjust to fit their preferences.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/HUD.h\"\n#include \"CustomizableHUD.generated.h\"\n\nUCLASS()\nclass MYGAME_API ACustomizableHUD : public AHUD\n{\n\tGENERATED_BODY()\n\npublic:\n\tACustomizableHUD();\n\n\tvirtual void DrawHUD() override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"HUD\")\n\tvoid SetHUDVisibility(bool bIsVisible);\n\n\tUFUNCTION(BlueprintCallable, Category = \"HUD\")\n\tvoid SetHUDColor(const FLinearColor& NewColor);\n\nprivate:\n\tbool bHUDVisible;\n\tFLinearColor HUDColor;\n};\n```", "cpp_code": "```cpp\n#include \"CustomizableHUD.h\"\n\nACustomizableHUD::ACustomizableHUD()\n\t: bHUDVisible(true), HUDColor(FLinearColor::White)\n{\n}\n\nvoid ACustomizableHUD::DrawHUD()\n{\n\tSuper::DrawHUD();\n\n\tif (bHUDVisible)\n\t{\n\t\t// Your custom HUD drawing logic here, using HUDColor\n\t}\n}\n\nvoid ACustomizableHUD::SetHUDVisibility(bool bIsVisible)\n{\n\tbHUDVisible = bIsVisible;\n}\n\nvoid ACustomizableHUD::SetHUDColor(const FLinearColor& NewColor)\n{\n\tHUDColor = NewColor;\n}\n```"}
{"requirement": "Create a C++ component for a stamina system that affects player actions like sprinting and jumping.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"StaminaComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURGAME_API UStaminaComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUStaminaComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Stamina\")\n\tvoid StartSprinting();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Stamina\")\n\tvoid StopSprinting();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Stamina\")\n\tvoid Jump();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Stamina\")\n\tfloat GetStamina() const;\n\nprivate:\n\tvoid UpdateStamina(float DeltaTime);\n\n\tFTimerHandle StaminaUpdateHandle;\n\n\tUPROPERTY(EditDefaultsOnly, Category = \"Stamina\")\n\tfloat MaxStamina;\n\n\tUPROPERTY(EditDefaultsOnly, Category = \"Stamina\")\n\tfloat StaminaDrainRate;\n\n\tUPROPERTY(EditDefaultsOnly, Category = \"Stamina\")\n\tfloat StaminaRegenRate;\n\n\tUPROPERTY(EditDefaultsOnly, Category = \"Stamina\")\n\tfloat JumpStaminaCost;\n\n\tfloat CurrentStamina;\n\n\tbool bIsSprinting;\n};\n```", "cpp_code": "```cpp\n#include \"StaminaComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n\nUStaminaComponent::UStaminaComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tMaxStamina = 100.0f;\n\tStaminaDrainRate = 10.0f;\n\tStaminaRegenRate = 5.0f;\n\tJumpStaminaCost = 20.0f;\n\tCurrentStamina = MaxStamina;\n\tbIsSprinting = false;\n}\n\nvoid UStaminaComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorld()->GetTimerManager().SetTimer(StaminaUpdateHandle, this, &UStaminaComponent::UpdateStamina, 0.1f, true);\n}\n\nvoid UStaminaComponent::StartSprinting()\n{\n\tbIsSprinting = true;\n}\n\nvoid UStaminaComponent::StopSprinting()\n{\n\tbIsSprinting = false;\n}\n\nvoid UStaminaComponent::Jump()\n{\n\tif (CurrentStamina >= JumpStaminaCost)\n\t{\n\t\tCurrentStamina -= JumpStaminaCost;\n\t\t// Execute jump action (not implemented here)\n\t}\n}\n\nfloat UStaminaComponent::GetStamina() const\n{\n\treturn CurrentStamina;\n}\n\nvoid UStaminaComponent::UpdateStamina(float DeltaTime)\n{\n\tif (bIsSprinting)\n\t{\n\t\tCurrentStamina -= StaminaDrainRate * DeltaTime;\n\t}\n\telse\n\t{\n\t\tCurrentStamina += StaminaRegenRate * DeltaTime;\n\t}\n\n\tCurrentStamina = FMath::Clamp(CurrentStamina, 0.0f, MaxStamina);\n}\n```"}
{"requirement": "Develop a C++ class for a real-time strategy game unit selection and command system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RTSUnitSelectionSystem.generated.h\"\n\nUCLASS()\nclass MYRTSGAME_API ARTSUnitSelectionSystem : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tARTSUnitSelectionSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to select units within a specified area\n\tUFUNCTION(BlueprintCallable, Category=\"Unit Selection\")\n\tvoid SelectUnitsInArea(const FVector2D& SelectionStart, const FVector2D& SelectionEnd);\n\n\t// Command selected units to move to a location\n\tUFUNCTION(BlueprintCallable, Category=\"Unit Command\")\n\tvoid CommandMoveUnits(const FVector& TargetLocation);\n\nprivate:\n\t// Array to store selected units\n\tUPROPERTY()\n\tTArray<AActor*> SelectedUnits;\n\n\t// Helper function to find units within the selection area\n\tvoid FindUnitsInArea(const FVector2D& SelectionStart, const FVector2D& SelectionEnd);\n};\n```", "cpp_code": "```cpp\n#include \"RTSUnitSelectionSystem.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nARTSUnitSelectionSystem::ARTSUnitSelectionSystem()\n{\n\t // Set this actor to call Tick() every frame\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ARTSUnitSelectionSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARTSUnitSelectionSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARTSUnitSelectionSystem::SelectUnitsInArea(const FVector2D& SelectionStart, const FVector2D& SelectionEnd)\n{\n\tSelectedUnits.Empty();\n\tFindUnitsInArea(SelectionStart, SelectionEnd);\n}\n\nvoid ARTSUnitSelectionSystem::CommandMoveUnits(const FVector& TargetLocation)\n{\n\tfor (AActor* Unit : SelectedUnits)\n\t{\n\t\tif (Unit)\n\t\t{\n\t\t\t// Assuming units have a method to move to a location, e.g., Unit->MoveTo(TargetLocation);\n\t\t\tUGameplayStatics::SimpleMoveToLocation(Unit->GetController(), TargetLocation);\n\t\t}\n\t}\n}\n\nvoid ARTSUnitSelectionSystem::FindUnitsInArea(const FVector2D& SelectionStart, const FVector2D& SelectionEnd)\n{\n\tFVector WorldStart, WorldEnd;\n\tWorldStart.X = FMath::Min(SelectionStart.X, SelectionEnd.X);\n\tWorldStart.Y = FMath::Min(SelectionStart.Y, SelectionEnd.Y);\n\tWorldEnd.X = FMath::Max(SelectionStart.X, SelectionEnd.X);\n\tWorldEnd.Y = FMath::Max(SelectionStart.Y, SelectionEnd.Y);\n\n\tfor (TActorIterator<AActor> ActorItr(GetWorld()); ActorItr; ++ActorItr)\n\t{\n\t\tAActor* Actor = *ActorItr;\n\t\tFVector ActorLocation = Actor->GetActorLocation();\n\t\tif (ActorLocation.X >= WorldStart.X && ActorLocation.X <= WorldEnd.X &&\n\t\t\tActorLocation.Y >= WorldStart.Y && ActorLocation.Y <= WorldEnd.Y)\n\t\t{\n\t\t\tSelectedUnits.Add(Actor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a C++ system for underwater environments with realistic buoyancy and swimming mechanics.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UnderwaterSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AUnderwaterSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAUnderwaterSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Buoyancy\")\n\tfloat BuoyancyFactor;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Swimming\")\n\tfloat SwimmingSpeed;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Buoyancy\")\n\tvoid CalculateBuoyancy();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Swimming\")\n\tvoid SwimForward(float Value);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Swimming\")\n\tvoid SwimRight(float Value);\n\nprivate:\n\tFVector CurrentVelocity;\n};\n```", "cpp_code": "```cpp\n#include \"UnderwaterSystem.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/Character.h\"\n#include \"Engine/World.h\"\n\nAUnderwaterSystem::AUnderwaterSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tBuoyancyFactor = 1.0f;\n\tSwimmingSpeed = 200.0f;\n\tCurrentVelocity = FVector::ZeroVector;\n}\n\nvoid AUnderwaterSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AUnderwaterSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!CurrentVelocity.IsNearlyZero())\n\t{\n\t\tFVector NewLocation = GetActorLocation() + (CurrentVelocity * DeltaTime);\n\t\tSetActorLocation(NewLocation);\n\t}\n\n\tCalculateBuoyancy();\n}\n\nvoid AUnderwaterSystem::CalculateBuoyancy()\n{\n\tFVector ActorLocation = GetActorLocation();\n\tfloat Depth = ActorLocation.Z; // Assuming Z is the vertical axis\n\tfloat BuoyantForce = -Depth * BuoyancyFactor;\n\n\tif (BuoyantForce != 0.0f)\n\t{\n\t\tFVector Buoyancy = FVector(0.0f, 0.0f, BuoyantForce);\n\t\tAddActorWorldOffset(Buoyancy, true);\n\t}\n}\n\nvoid AUnderwaterSystem::SwimForward(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tCurrentVelocity.X = FMath::Clamp(Value, -1.0f, 1.0f) * SwimmingSpeed;\n\t}\n\telse\n\t{\n\t\tCurrentVelocity.X = 0.0f;\n\t}\n}\n\nvoid AUnderwaterSystem::SwimRight(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tCurrentVelocity.Y = FMath::Clamp(Value, -1.0f, 1.0f) * SwimmingSpeed;\n\t}\n\telse\n\t{\n\t\tCurrentVelocity.Y = 0.0f;\n\t}\n}\n```"}
{"requirement": "Create a C++ component for a skill cooldown system that visually shows when abilities are ready to use.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"SkillCooldownComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCooldownUpdated, float, CooldownRemaining);\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnCooldownReady);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API USkillCooldownComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUSkillCooldownComponent();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Cooldown\")\n\tfloat CooldownDuration;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Cooldown\")\n\tvoid StartCooldown();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Cooldown\")\n\tbool IsCooldownActive() const;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Cooldown\")\n\tFOnCooldownUpdated OnCooldownUpdated;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Cooldown\")\n\tFOnCooldownReady OnCooldownReady;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tFTimerHandle CooldownTimerHandle;\n\tfloat CooldownRemaining;\n\n\tvoid UpdateCooldown();\n};\n```", "cpp_code": "```cpp\n#include \"SkillCooldownComponent.h\"\n#include \"TimerManager.h\"\n\nUSkillCooldownComponent::USkillCooldownComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tCooldownDuration = 5.0f;\n\tCooldownRemaining = 0.0f;\n}\n\nvoid USkillCooldownComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid USkillCooldownComponent::StartCooldown()\n{\n\tif (!GetWorld() || CooldownDuration <= 0.0f)\n\t{\n\t\treturn;\n\t}\n\tCooldownRemaining = CooldownDuration;\n\tGetWorld()->GetTimerManager().SetTimer(CooldownTimerHandle, this, &USkillCooldownComponent::UpdateCooldown, 1.0f, true);\n}\n\nvoid USkillCooldownComponent::UpdateCooldown()\n{\n\tif (CooldownRemaining > 0.0f)\n\t{\n\t\tCooldownRemaining--;\n\t\tOnCooldownUpdated.Broadcast(CooldownRemaining);\n\t}\n\telse\n\t{\n\t\tGetWorld()->GetTimerManager().ClearTimer(CooldownTimerHandle);\n\t\tOnCooldownReady.Broadcast();\n\t}\n}\n\nbool USkillCooldownComponent::IsCooldownActive() const\n{\n\treturn CooldownRemaining > 0.0f;\n}\n```"}
{"requirement": "Develop a C++ class for a destructible cover system in a shooter game, allowing players to hide and destroy barriers.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DestructibleCover.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ADestructibleCover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADestructibleCover();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\n\t// Health of the cover\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Destructible\")\n\tfloat Health;\n\n\t// Mesh for the destructible cover\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Destructible\")\n\tUStaticMeshComponent* CoverMesh;\n\n\t// Function to handle damage\n\tUFUNCTION()\n\tvoid TakeDamage(float DamageAmount);\n\n\t// Function to handle destruction\n\tvoid DestroyCover();\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"DestructibleCover.h\"\n\n// Sets default values\nADestructibleCover::ADestructibleCover()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the cover mesh\n\tCoverMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"CoverMesh\"));\n\tRootComponent = CoverMesh;\n\n\t// Initialize health\n\tHealth = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ADestructibleCover::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADestructibleCover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADestructibleCover::TakeDamage(float DamageAmount)\n{\n\tHealth -= DamageAmount;\n\tif (Health <= 0.0f)\n\t{\n\t\tDestroyCover();\n\t}\n}\n\nvoid ADestructibleCover::DestroyCover()\n{\n\t// Destroy the cover actor\n\tDestroy();\n}\n```"}
{"requirement": "Implement a C++ system for voice recognition that executes commands based on player speech.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VoiceRecognitionSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVoiceRecognitionSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAVoiceRecognitionSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to initialize voice recognition\n\tUFUNCTION(BlueprintCallable, Category=\"Voice Recognition\")\n\tvoid InitializeVoiceRecognition();\n\n\t// Function to process recognized voice command\n\tUFUNCTION(BlueprintCallable, Category=\"Voice Recognition\")\n\tvoid ProcessVoiceCommand(const FString& Command);\n\nprivate:\n\t// Internal function to setup voice recognition\n\tvoid SetupVoiceRecognition();\n\n\t// Internal function to handle voice recognition callback\n\tvoid OnVoiceCommandRecognized(const FString& RecognizedCommand);\n};\n```", "cpp_code": "```cpp\n#include \"VoiceRecognitionSystem.h\"\n#include \"YourVoiceRecognitionLibrary.h\" // Hypothetical library\n\n// Sets default values\nAVoiceRecognitionSystem::AVoiceRecognitionSystem()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AVoiceRecognitionSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitializeVoiceRecognition();\n}\n\n// Called every frame\nvoid AVoiceRecognitionSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AVoiceRecognitionSystem::InitializeVoiceRecognition()\n{\n\tSetupVoiceRecognition();\n}\n\nvoid AVoiceRecognitionSystem::SetupVoiceRecognition()\n{\n\t// Initialize the voice recognition system\n\tYourVoiceRecognitionLibrary::Initialize();\n\n\t// Set up a callback for when a voice command is recognized\n\tYourVoiceRecognitionLibrary::OnCommandRecognized.BindUObject(this, &AVoiceRecognitionSystem::OnVoiceCommandRecognized);\n}\n\nvoid AVoiceRecognitionSystem::ProcessVoiceCommand(const FString& Command)\n{\n\tif (Command.Equals(\"Jump\", ESearchCase::IgnoreCase))\n\t{\n\t\t// Execute jump command\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Player Jump\"));\n\t\t// Trigger jump action here\n\t}\n\telse if (Command.Equals(\"Run\", ESearchCase::IgnoreCase))\n\t{\n\t\t// Execute run command\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Player Run\"));\n\t\t// Trigger run action here\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Unrecognized Command: %s\"), *Command);\n\t}\n}\n\nvoid AVoiceRecognitionSystem::OnVoiceCommandRecognized(const FString& RecognizedCommand)\n{\n\tUE_LOG(LogTemp, Log, TEXT(\"Recognized Command: %s\"), *RecognizedCommand);\n\tProcessVoiceCommand(RecognizedCommand);\n}\n```"}
{"requirement": "Create a C++ class for a dynamic camera system that adjusts angles based on player action and environment.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicCameraSystem.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADynamicCameraSystem : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tADynamicCameraSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Camera\")\n\tAActor* TargetActor;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Camera\")\n\tfloat CameraDistance;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Camera\")\n\tFRotator BaseRotation;\n\n\tvoid AdjustCameraAngle();\n};\n```", "cpp_code": "```cpp\n#include \"DynamicCameraSystem.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\nADynamicCameraSystem::ADynamicCameraSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTargetActor = nullptr;\n\tCameraDistance = 300.0f;\n\tBaseRotation = FRotator(-45.0f, 0.0f, 0.0f);\n}\n\nvoid ADynamicCameraSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADynamicCameraSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tAdjustCameraAngle();\n\t}\n}\n\nvoid ADynamicCameraSystem::AdjustCameraAngle()\n{\n\tFVector TargetLocation = TargetActor->GetActorLocation();\n\tFVector NewCameraLocation = TargetLocation - TargetActor->GetActorForwardVector() * CameraDistance;\n\tNewCameraLocation.Z += CameraDistance * 0.5f; // Adjust the height\n\n\tSetActorLocation(NewCameraLocation);\n\tFRotator NewRotation = BaseRotation;\n\tNewRotation.Yaw += TargetActor->GetActorRotation().Yaw;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Develop a C++ component for a loyalty system that rewards long-term player engagement with in-game bonuses.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LoyaltySystemComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API ULoyaltySystemComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tULoyaltySystemComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category=\"Loyalty\")\n\tvoid AddPlayTime(float DeltaTime);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Loyalty\")\n\tvoid RewardPlayer();\n\nprivate:\n\tfloat TotalPlayTime;\n\tfloat RewardThreshold;\n\n\tvoid CheckAndReward();\n};\n```", "cpp_code": "```cpp\n#include \"LoyaltySystemComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nULoyaltySystemComponent::ULoyaltySystemComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTotalPlayTime = 0.0f;\n\tRewardThreshold = 3600.0f; // Example threshold in seconds (1 hour)\n}\n\nvoid ULoyaltySystemComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ULoyaltySystemComponent::AddPlayTime(float DeltaTime)\n{\n\tTotalPlayTime += DeltaTime;\n\tCheckAndReward();\n}\n\nvoid ULoyaltySystemComponent::RewardPlayer()\n{\n\t// Implement the logic to reward the player here\n\tUE_LOG(LogTemp, Warning, TEXT(\"Player rewarded for loyalty!\"));\n}\n\nvoid ULoyaltySystemComponent::CheckAndReward()\n{\n\tif (TotalPlayTime >= RewardThreshold)\n\t{\n\t\tRewardPlayer();\n\t\tTotalPlayTime = 0.0f; // Reset the play time after rewarding\n\t}\n}\n```"}
{"requirement": "Implement a C++ class for a photo mode that allows players to capture and edit in-game screenshots.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PhotoModeActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API APhotoModeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPhotoModeActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"PhotoMode\")\n\tvoid CaptureScreenshot();\n\n\tUFUNCTION(BlueprintCallable, Category=\"PhotoMode\")\n\tvoid EditScreenshot();\n\nprivate:\n\tvoid SaveScreenshotToDisk(const FString& ScreenshotName);\n};\n```", "cpp_code": "```cpp\n#include \"PhotoModeActor.h\"\n#include \"Engine/Engine.h\"\n#include \"HighResScreenshot.h\"\n#include \"IImageWrapper.h\"\n#include \"IImageWrapperModule.h\"\n#include \"ImageUtils.h\"\n#include \"Paths.h\"\n#include \"FileHelper.h\"\n\nAPhotoModeActor::APhotoModeActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APhotoModeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APhotoModeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APhotoModeActor::CaptureScreenshot()\n{\n\tFScreenshotRequest::RequestScreenshot(false);\n\tSaveScreenshotToDisk(TEXT(\"Screenshot\"));\n}\n\nvoid APhotoModeActor::EditScreenshot()\n{\n\t// Placeholder for editing logic\n\tUE_LOG(LogTemp, Warning, TEXT(\"EditScreenshot called\"));\n\t// Implement editing functionality such as applying filters here\n}\n\nvoid APhotoModeActor::SaveScreenshotToDisk(const FString& ScreenshotName)\n{\n\tFHighResScreenshotConfig& HighResScreenshotConfig = GetHighResScreenshotConfig();\n\tHighResScreenshotConfig.FilenameOverride = ScreenshotName;\n\tGEngine->GameViewport->Viewport->TakeHighResScreenShot();\n}\n```"}
{"requirement": "Create a C++ component for customizable control schemes, supporting multiple input devices.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"InputMappingComponent.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FInputMapping\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Input\")\n\tFName ActionName;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Input\")\n\tFKey Key;\n};\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UInputMappingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUInputMappingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Input\")\n\tTArray<FInputMapping> InputMappings;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Input\")\n\tvoid BindInputMappings(UInputComponent* PlayerInputComponent);\n};\n```", "cpp_code": "```cpp\n#include \"InputMappingComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\nUInputMappingComponent::UInputMappingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UInputMappingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UInputMappingComponent::BindInputMappings(UInputComponent* PlayerInputComponent)\n{\n\tfor (const FInputMapping& Mapping : InputMappings)\n\t{\n\t\tif (Mapping.ActionName.IsNone() || !Mapping.Key.IsValid())\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tPlayerInputComponent->BindKey(Mapping.Key, IE_Pressed, this, &UInputMappingComponent::ExecuteAction, Mapping.ActionName);\n\t}\n}\n\nvoid UInputMappingComponent::ExecuteAction(FName ActionName)\n{\n\t// Implement the action execution logic here\n\tUE_LOG(LogTemp, Log, TEXT(\"Action Executed: %s\"), *ActionName.ToString());\n}\n```"}
{"requirement": "Develop a C++ system for a modular character equipment system that visually changes with gear.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EquipmentSystem.generated.h\"\n\nUENUM(BlueprintType)\nenum class EEquipmentSlot : uint8\n{\n\tHead,\n\tBody,\n\tLegs,\n\tFeet\n};\n\nUSTRUCT(BlueprintType)\nstruct FEquipmentItem\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tEEquipmentSlot Slot;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tUSkeletalMesh* Mesh;\n};\n\nUCLASS()\nclass MODULARCHAREQUIP_API AModularCharacter : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAModularCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Equipment\")\n\tvoid EquipItem(const FEquipmentItem& Item);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUSkeletalMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Equipment\")\n\tTMap<EEquipmentSlot, USkeletalMesh*> EquippedItems;\n\n\tvoid UpdateCharacterMesh();\n};\n```", "cpp_code": "```cpp\n#include \"EquipmentSystem.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n\nAModularCharacter::AModularCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"CharacterMesh\"));\n\tRootComponent = MeshComponent;\n}\n\nvoid AModularCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AModularCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AModularCharacter::EquipItem(const FEquipmentItem& Item)\n{\n\tif (EquippedItems.Contains(Item.Slot))\n\t{\n\t\tEquippedItems[Item.Slot] = Item.Mesh;\n\t}\n\telse\n\t{\n\t\tEquippedItems.Add(Item.Slot, Item.Mesh);\n\t}\n\tUpdateCharacterMesh();\n}\n\nvoid AModularCharacter::UpdateCharacterMesh()\n{\n\tfor (const auto& Item : EquippedItems)\n\t{\n\t\tswitch (Item.Key)\n\t\t{\n\t\tcase EEquipmentSlot::Head:\n\t\t\tMeshComponent->SetSkeletalMesh(Item.Value, false);\n\t\t\tbreak;\n\t\tcase EEquipmentSlot::Body:\n\t\t\tMeshComponent->SetSkeletalMesh(Item.Value, false);\n\t\t\tbreak;\n\t\tcase EEquipmentSlot::Legs:\n\t\t\tMeshComponent->SetSkeletalMesh(Item.Value, false);\n\t\t\tbreak;\n\t\tcase EEquipmentSlot::Feet:\n\t\t\tMeshComponent->SetSkeletalMesh(Item.Value, false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a C++ class for a matchmaking system that pairs players based on skill and region.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include <vector>\n#include <string>\n\nclass MatchmakingSystem\n{\npublic:\n\tMatchmakingSystem();\n\t~MatchmakingSystem();\n\n\tstruct Player\n\t{\n\t\tint PlayerID;\n\t\tint SkillLevel;\n\t\tstd::string Region;\n\t};\n\n\tvoid AddPlayer(int PlayerID, int SkillLevel, const std::string& Region);\n\tvoid RemovePlayer(int PlayerID);\n\tstd::vector<std::pair<int, int>> PairPlayers();\n\nprivate:\n\tstd::vector<Player> Players;\n\tstd::vector<std::pair<int, int>> FindMatches();\n};\n```", "cpp_code": "```cpp\n#include \"MatchmakingSystem.h\"\n\nMatchmakingSystem::MatchmakingSystem()\n{\n}\n\nMatchmakingSystem::~MatchmakingSystem()\n{\n}\n\nvoid MatchmakingSystem::AddPlayer(int PlayerID, int SkillLevel, const std::string& Region)\n{\n\tPlayers.push_back({ PlayerID, SkillLevel, Region });\n}\n\nvoid MatchmakingSystem::RemovePlayer(int PlayerID)\n{\n\tPlayers.erase(std::remove_if(Players.begin(), Players.end(), [PlayerID](const Player& p) {\n\t\treturn p.PlayerID == PlayerID;\n\t}), Players.end());\n}\n\nstd::vector<std::pair<int, int>> MatchmakingSystem::PairPlayers()\n{\n\treturn FindMatches();\n}\n\nstd::vector<std::pair<int, int>> MatchmakingSystem::FindMatches()\n{\n\tstd::vector<std::pair<int, int>> Matches;\n\n\tfor (size_t i = 0; i < Players.size(); ++i)\n\t{\n\t\tfor (size_t j = i + 1; j < Players.size(); ++j)\n\t\t{\n\t\t\tif (Players[i].Region == Players[j].Region && abs(Players[i].SkillLevel - Players[j].SkillLevel) <= 5)\n\t\t\t{\n\t\t\t\tMatches.push_back({ Players[i].PlayerID, Players[j].PlayerID });\n\t\t\t\tPlayers.erase(Players.begin() + j);\n\t\t\t\tPlayers.erase(Players.begin() + i);\n\t\t\t\t--i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Matches;\n}\n```"}
{"requirement": "Create a C++ component for a dynamic object spawning system based on player proximity and game state.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"DynamicSpawnerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API UDynamicSpawnerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUDynamicSpawnerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid CheckSpawnConditions();\n\n\tUFUNCTION()\n\tvoid SpawnDynamicObject();\n\n\tUPROPERTY(EditAnywhere)\n\tfloat SpawnRadius;\n\n\tUPROPERTY(EditAnywhere)\n\tTSubclassOf<AActor> ObjectToSpawn;\n\n\tUPROPERTY(EditAnywhere)\n\tAActor* PlayerActor;\n\n\tUPROPERTY(EditAnywhere)\n\tbool bShouldSpawn;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicSpawnerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUDynamicSpawnerComponent::UDynamicSpawnerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tSpawnRadius = 500.0f;\n\tbShouldSpawn = false;\n}\n\nvoid UDynamicSpawnerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Attempt to find the player actor if not set\n\tif (!PlayerActor)\n\t{\n\t\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n\t}\n}\n\nvoid UDynamicSpawnerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tCheckSpawnConditions();\n}\n\nvoid UDynamicSpawnerComponent::CheckSpawnConditions()\n{\n\tif (!PlayerActor || !bShouldSpawn)\n\t{\n\t\treturn;\n\t}\n\n\tfloat DistanceToPlayer = FVector::Dist(PlayerActor->GetActorLocation(), GetOwner()->GetActorLocation());\n\n\tif (DistanceToPlayer <= SpawnRadius)\n\t{\n\t\tSpawnDynamicObject();\n\t\tbShouldSpawn = false; // Prevent further spawning until conditions change\n\t}\n}\n\nvoid UDynamicSpawnerComponent::SpawnDynamicObject()\n{\n\tif (ObjectToSpawn)\n\t{\n\t\tFVector SpawnLocation = GetOwner()->GetActorLocation();\n\t\tFRotator SpawnRotation = FRotator::ZeroRotator;\n\n\t\tAActor* SpawnedActor = GetWorld()->SpawnActor<AActor>(ObjectToSpawn, SpawnLocation, SpawnRotation);\n\n\t\tif (SpawnedActor)\n\t\t{\n\t\t\t// Optionally initialize the spawned actor here\n\t\t}\n\t}\n}\n```"}
{"requirement": "Develop a C++ class for an environmental damage system that affects players based on conditions like fire or poison.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EnvironmentalDamageSystem.generated.h\"\n\nUENUM(BlueprintType)\nenum class EDamageType : uint8\n{\n\tFire UMETA(DisplayName = \"Fire\"),\n\tPoison UMETA(DisplayName = \"Poison\")\n};\n\nUCLASS()\nclass YOURGAME_API AEnvironmentalDamageSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAEnvironmentalDamageSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Damage\")\n\tfloat DamageAmount;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Damage\")\n\tEDamageType DamageType;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Damage\")\n\tvoid ApplyDamage(class APlayerCharacter* Player);\n};\n```", "cpp_code": "```cpp\n#include \"EnvironmentalDamageSystem.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n#include \"PlayerCharacter.h\"\n\nAEnvironmentalDamageSystem::AEnvironmentalDamageSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tDamageAmount = 10.0f;\n\tDamageType = EDamageType::Fire;\n}\n\nvoid AEnvironmentalDamageSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AEnvironmentalDamageSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AEnvironmentalDamageSystem::ApplyDamage(APlayerCharacter* Player)\n{\n\tif (Player)\n\t{\n\t\tswitch (DamageType)\n\t\t{\n\t\tcase EDamageType::Fire:\n\t\t\tPlayer->TakeDamage(DamageAmount, FDamageEvent(), nullptr, this);\n\t\t\tbreak;\n\t\tcase EDamageType::Poison:\n\t\t\tPlayer->TakeDamage(DamageAmount * 0.5f, FDamageEvent(), nullptr, this);\n\t\t\t// Example of poison effect - apply damage over time\n\t\t\tGetWorld()->GetTimerManager().SetTimerForNextTick(FTimerDelegate::CreateLambda([=]() {\n\t\t\t\tPlayer->TakeDamage(DamageAmount * 0.5f, FDamageEvent(), nullptr, this);\n\t\t\t}));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a C++ system for seamless world streaming, allowing large open-world environments without loading screens.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WorldStreamer.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWorldStreamer : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAWorldStreamer();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid StreamInLevel(const FString& LevelName);\n\tvoid StreamOutLevel(const FString& LevelName);\n\n\tUPROPERTY(EditAnywhere)\n\tTArray<FString> LevelsToStream;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat LoadDistance;\n\n\tUPROPERTY(EditAnywhere)\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"WorldStreamer.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAWorldStreamer::AWorldStreamer()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tLoadDistance = 10000.0f;\n\tPlayerActor = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid AWorldStreamer::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (!PlayerActor)\n\t{\n\t\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n\t}\n}\n\n// Called every frame\nvoid AWorldStreamer::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!PlayerActor)\n\t{\n\t\treturn;\n\t}\n\n\tFVector PlayerLocation = PlayerActor->GetActorLocation();\n\n\tfor (const FString& LevelName : LevelsToStream)\n\t{\n\t\tFVector LevelLocation;\n\t\tFTransform LevelTransform;\n\n\t\tif (UGameplayStatics::GetStreamingLevelTransform(GetWorld(), FName(*LevelName), LevelTransform))\n\t\t{\n\t\t\tLevelLocation = LevelTransform.GetLocation();\n\n\t\t\tfloat Distance = FVector::Dist(PlayerLocation, LevelLocation);\n\n\t\t\tif (Distance < LoadDistance && !UGameplayStatics::IsLevelLoaded(GetWorld(), FName(*LevelName)))\n\t\t\t{\n\t\t\t\tStreamInLevel(LevelName);\n\t\t\t}\n\t\t\telse if (Distance >= LoadDistance && UGameplayStatics::IsLevelLoaded(GetWorld(), FName(*LevelName)))\n\t\t\t{\n\t\t\t\tStreamOutLevel(LevelName);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid AWorldStreamer::StreamInLevel(const FString& LevelName)\n{\n\tif (!LevelName.IsEmpty())\n\t{\n\t\tUGameplayStatics::LoadStreamLevel(this, FName(*LevelName), true, true, FLatentActionInfo());\n\t}\n}\n\nvoid AWorldStreamer::StreamOutLevel(const FString& LevelName)\n{\n\tif (!LevelName.IsEmpty())\n\t{\n\t\tUGameplayStatics::UnloadStreamLevel(this, FName(*LevelName), FLatentActionInfo(), false);\n\t}\n}\n```"}
{"requirement": "Create a C++ component for a cinematic camera system that can be triggered for special events.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CinematicCameraComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCinematicCameraComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUCinematicCameraComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Function to trigger the cinematic camera\n\tUFUNCTION(BlueprintCallable, Category=\"Cinematic\")\n\tvoid TriggerCinematicCamera();\n\nprivate:\n\t// Internal function to handle camera activation\n\tvoid ActivateCinematicCamera();\n\n\t// Timer handle for cinematic duration\n\tFTimerHandle CinematicTimerHandle;\n\n\t// Duration of the cinematic in seconds\n\tUPROPERTY(EditAnywhere, Category=\"Cinematic\")\n\tfloat CinematicDuration;\n};\n```", "cpp_code": "```cpp\n#include \"CinematicCameraComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\n// Sets default values for this component's properties\nUCinematicCameraComponent::UCinematicCameraComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tCinematicDuration = 5.0f;  // Default duration\n}\n\n// Called when the game starts\nvoid UCinematicCameraComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCinematicCameraComponent::TriggerCinematicCamera()\n{\n\tActivateCinematicCamera();\n}\n\nvoid UCinematicCameraComponent::ActivateCinematicCamera()\n{\n\t// Logic to switch to the cinematic camera would be implemented here\n\tUE_LOG(LogTemp, Warning, TEXT(\"Cinematic camera activated\"));\n\n\t// Set a timer to deactivate the cinematic camera after the duration\n\tGetWorld()->GetTimerManager().SetTimer(CinematicTimerHandle, [this]() {\n\t\t// Logic to revert back to the normal camera would be implemented here\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Cinematic camera deactivated\"));\n\t}, CinematicDuration, false);\n}\n```"}
{"requirement": "Develop a C++ class for a time manipulation mechanic, allowing players to slow down or rewind gameplay events.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimeManipulationMechanic.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ATimeManipulationMechanic : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATimeManipulationMechanic();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Time Manipulation\")\n\tvoid SlowDownTime(float Factor);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Time Manipulation\")\n\tvoid RewindTime(float Seconds);\n\nprivate:\n\tvoid RestoreNormalTime();\n\n\tfloat OriginalTimeDilation;\n\tfloat TimeDilationFactor;\n\tbool bIsRewinding;\n\tTArray<FTransform> TransformHistory;\n\tfloat RewindDuration;\n\tfloat CurrentRewindTime;\n};\n```", "cpp_code": "```cpp\n#include \"TimeManipulationMechanic.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nATimeManipulationMechanic::ATimeManipulationMechanic()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tOriginalTimeDilation = 1.0f;\n\tTimeDilationFactor = 1.0f;\n\tbIsRewinding = false;\n\tRewindDuration = 0.0f;\n\tCurrentRewindTime = 0.0f;\n}\n\nvoid ATimeManipulationMechanic::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tOriginalTimeDilation = GetWorld()->GetWorldSettings()->TimeDilation;\n}\n\nvoid ATimeManipulationMechanic::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsRewinding)\n\t{\n\t\tCurrentRewindTime += DeltaTime * TimeDilationFactor;\n\n\t\tif (TransformHistory.Num() > 0)\n\t\t{\n\t\t\tint32 Index = FMath::Clamp(TransformHistory.Num() - 1 - FMath::RoundToInt(CurrentRewindTime / DeltaTime), 0, TransformHistory.Num() - 1);\n\t\t\tGetOwner()->SetActorTransform(TransformHistory[Index]);\n\t\t}\n\n\t\tif (CurrentRewindTime >= RewindDuration)\n\t\t{\n\t\t\tbIsRewinding = false;\n\t\t\tRestoreNormalTime();\n\t\t}\n\t}\n\telse\n\t{\n\t\tTransformHistory.Add(GetOwner()->GetActorTransform());\n\t}\n}\n\nvoid ATimeManipulationMechanic::SlowDownTime(float Factor)\n{\n\tTimeDilationFactor = Factor;\n\tGetWorld()->GetWorldSettings()->TimeDilation = OriginalTimeDilation * Factor;\n}\n\nvoid ATimeManipulationMechanic::RewindTime(float Seconds)\n{\n\tbIsRewinding = true;\n\tRewindDuration = Seconds;\n\tCurrentRewindTime = 0.0f;\n}\n\nvoid ATimeManipulationMechanic::RestoreNormalTime()\n{\n\tGetWorld()->GetWorldSettings()->TimeDilation = OriginalTimeDilation;\n\tTimeDilationFactor = 1.0f;\n}\n```"}
{"requirement": "Implement a C++ system for NPC dialogues with voice-over functionality and lip-syncing.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DialogueSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ADialogueSystem : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tADialogueSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to initiate dialogue\n\tUFUNCTION(BlueprintCallable, Category=\"Dialogue\")\n\tvoid StartDialogue(const FString& DialogueText, USoundBase* VoiceOver);\n\nprivate:\n\t// Function to handle lip-syncing\n\tvoid HandleLipSyncing();\n\n\t// Callback when voice-over finishes playing\n\tUFUNCTION()\n\tvoid OnVoiceOverFinished();\n\n\t// Audio component for voice over\n\tUPROPERTY(VisibleAnywhere, Category=\"Audio\")\n\tUAudioComponent* AudioComponent;\n\n\t// The text for the dialogue\n\tFString CurrentDialogueText;\n};\n```", "cpp_code": "```cpp\n#include \"DialogueSystem.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundBase.h\"\n\n// Sets default values\nADialogueSystem::ADialogueSystem()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the audio component\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n\tAudioComponent->bAutoActivate = false;\n\n\t// Bind the OnVoiceOverFinished function to when the sound finishes\n\tAudioComponent->OnAudioFinished.AddDynamic(this, &ADialogueSystem::OnVoiceOverFinished);\n}\n\n// Called when the game starts or when spawned\nvoid ADialogueSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ADialogueSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// If audio is playing, handle lip-syncing\n\tif(AudioComponent->IsPlaying())\n\t{\n\t\tHandleLipSyncing();\n\t}\n}\n\nvoid ADialogueSystem::StartDialogue(const FString& DialogueText, USoundBase* VoiceOver)\n{\n\t// Set the current dialogue text\n\tCurrentDialogueText = DialogueText;\n\n\t// Play the voice-over sound\n\tif(VoiceOver)\n\t{\n\t\tAudioComponent->SetSound(VoiceOver);\n\t\tAudioComponent->Play();\n\t}\n}\n\nvoid ADialogueSystem::HandleLipSyncing()\n{\n\t// Lip-sync logic here, potentially using phoneme analysis on VoiceOver or using blend shapes\n}\n\nvoid ADialogueSystem::OnVoiceOverFinished()\n{\n\t// Logic to handle end of dialogue, like triggering next dialogue or ending conversation\n}\n```"}
{"requirement": "Create a C++ component for a particle effect system that triggers based on player actions and events.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ParticleEffectComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API UParticleEffectComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUParticleEffectComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"ParticleEffects\")\n\tvoid TriggerParticleEffect(FName EventName);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"ParticleEffects\")\n\tTMap<FName, UParticleSystem*> ParticleEffectsMap;\n\n\tvoid InitializeParticleEffects();\n};\n```", "cpp_code": "```cpp\n#include \"ParticleEffectComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Particles/ParticleSystem.h\"\n\nUParticleEffectComponent::UParticleEffectComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UParticleEffectComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tInitializeParticleEffects();\n}\n\nvoid UParticleEffectComponent::TriggerParticleEffect(FName EventName)\n{\n\tif (UParticleSystem** ParticleSystem = ParticleEffectsMap.Find(EventName))\n\t{\n\t\tif (*ParticleSystem)\n\t\t{\n\t\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), *ParticleSystem, GetOwner()->GetActorLocation());\n\t\t}\n\t}\n}\n\nvoid UParticleEffectComponent::InitializeParticleEffects()\n{\n\t// Example of initializing the ParticleEffectsMap with some events and corresponding particle systems.\n\t// This should be customized based on actual game assets and events.\n\t// ParticleEffectsMap.Add(\"Jump\", LoadObject<UParticleSystem>(nullptr, TEXT(\"/Game/Particles/P_JumpEffect.P_JumpEffect\")));\n\t// ParticleEffectsMap.Add(\"Shoot\", LoadObject<UParticleSystem>(nullptr, TEXT(\"/Game/Particles/P_ShootEffect.P_ShootEffect\")));\n}\n```"}
{"requirement": "Develop a C++ class for a crowd simulation system that manages large numbers of AI characters efficiently.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CrowdSimulationManager.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACrowdSimulationManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACrowdSimulationManager();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"CrowdSimulation\")\n\tvoid InitializeCrowd(int32 NumberOfAgents);\n\n\tUFUNCTION(BlueprintCallable, Category = \"CrowdSimulation\")\n\tvoid UpdateCrowd(float DeltaTime);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"CrowdSimulation\")\n\tTArray<class AAICharacter*> AICharacters;\n\n\tvoid SpawnAgent(FVector Location);\n};\n```", "cpp_code": "```cpp\n#include \"CrowdSimulationManager.h\"\n#include \"AICharacter.h\"\n#include \"Engine/World.h\"\n\nACrowdSimulationManager::ACrowdSimulationManager()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ACrowdSimulationManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACrowdSimulationManager::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateCrowd(DeltaTime);\n}\n\nvoid ACrowdSimulationManager::InitializeCrowd(int32 NumberOfAgents)\n{\n\tfor (int32 i = 0; i < NumberOfAgents; ++i)\n\t{\n\t\tFVector SpawnLocation = FVector(i * 100.f, 0.f, 0.f); // Example placement logic\n\t\tSpawnAgent(SpawnLocation);\n\t}\n}\n\nvoid ACrowdSimulationManager::UpdateCrowd(float DeltaTime)\n{\n\tfor (AAICharacter* AICharacter : AICharacters)\n\t{\n\t\tif (AICharacter)\n\t\t{\n\t\t\tAICharacter->UpdateAI(DeltaTime); // Assumes AAICharacter has an UpdateAI method\n\t\t}\n\t}\n}\n\nvoid ACrowdSimulationManager::SpawnAgent(FVector Location)\n{\n\tif (UWorld* World = GetWorld())\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tAAICharacter* NewAgent = World->SpawnActor<AAICharacter>(AAICharacter::StaticClass(), Location, FRotator::ZeroRotator, SpawnParams);\n\t\tif (NewAgent)\n\t\t{\n\t\t\tAICharacters.Add(NewAgent);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a C++ system for a stealth mechanic, including AI detection and alertness levels.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AIController.h\"\n#include \"StealthMechanic.generated.h\"\n\nUCLASS()\nclass MYGAME_API AStealthMechanic : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAStealthMechanic();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Stealth\")\n\tfloat DetectionRadius;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Stealth\")\n\tfloat AlertnessLevel;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Stealth\")\n\tfloat AlertnessThreshold;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Stealth\")\n\tvoid DetectPlayer();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Stealth\")\n\tvoid IncreaseAlertness(float Amount);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Stealth\")\n\tvoid DecreaseAlertness(float Amount);\n\nprivate:\n\tAAIController* AIController;\n\tvoid UpdateAlertness();\n};\n```", "cpp_code": "```cpp\n#include \"StealthMechanic.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Character.h\"\n\nAStealthMechanic::AStealthMechanic()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tDetectionRadius = 500.0f;\n\tAlertnessLevel = 0.0f;\n\tAlertnessThreshold = 100.0f;\n}\n\nvoid AStealthMechanic::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tAIController = Cast<AAIController>(GetController());\n}\n\nvoid AStealthMechanic::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tDetectPlayer();\n\tUpdateAlertness();\n}\n\nvoid AStealthMechanic::DetectPlayer()\n{\n\tACharacter* PlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);\n\tif (PlayerCharacter)\n\t{\n\t\tfloat DistanceToPlayer = FVector::Dist(PlayerCharacter->GetActorLocation(), GetActorLocation());\n\t\tif (DistanceToPlayer <= DetectionRadius)\n\t\t{\n\t\t\tIncreaseAlertness(20.0f * GetWorld()->DeltaTimeSeconds);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDecreaseAlertness(10.0f * GetWorld()->DeltaTimeSeconds);\n\t\t}\n\t}\n}\n\nvoid AStealthMechanic::IncreaseAlertness(float Amount)\n{\n\tAlertnessLevel = FMath::Clamp(AlertnessLevel + Amount, 0.0f, AlertnessThreshold);\n}\n\nvoid AStealthMechanic::DecreaseAlertness(float Amount)\n{\n\tAlertnessLevel = FMath::Clamp(AlertnessLevel - Amount, 0.0f, AlertnessThreshold);\n}\n\nvoid AStealthMechanic::UpdateAlertness()\n{\n\tif (AlertnessLevel >= AlertnessThreshold && AIController)\n\t{\n\t\t// Code to execute when the AI is fully alert\n\t}\n}\n```"}
{"requirement": "Create a C++ component for a player progression system that tracks experience and level-ups.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"PlayerProgressionComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnLevelUp, int32, NewLevel, int32, ExperiencePoints);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UPlayerProgressionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUPlayerProgressionComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tint32 CurrentLevel;\n\tint32 CurrentExperience;\n\tint32 ExperienceToNextLevel;\n\n\tvoid LevelUp();\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Progression\")\n\tvoid AddExperience(int32 ExperiencePoints);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Progression\")\n\tint32 GetCurrentLevel() const { return CurrentLevel; }\n\n\tUFUNCTION(BlueprintCallable, Category=\"Progression\")\n\tint32 GetCurrentExperience() const { return CurrentExperience; }\n\n\tUFUNCTION(BlueprintCallable, Category=\"Progression\")\n\tint32 GetExperienceToNextLevel() const { return ExperienceToNextLevel; }\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Progression\")\n\tFOnLevelUp OnLevelUp;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerProgressionComponent.h\"\n\nUPlayerProgressionComponent::UPlayerProgressionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tCurrentLevel = 1;\n\tCurrentExperience = 0;\n\tExperienceToNextLevel = 100; // Example value\n}\n\nvoid UPlayerProgressionComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UPlayerProgressionComponent::AddExperience(int32 ExperiencePoints)\n{\n\tCurrentExperience += ExperiencePoints;\n\twhile (CurrentExperience >= ExperienceToNextLevel)\n\t{\n\t\tCurrentExperience -= ExperienceToNextLevel;\n\t\tLevelUp();\n\t}\n}\n\nvoid UPlayerProgressionComponent::LevelUp()\n{\n\tCurrentLevel++;\n\tExperienceToNextLevel = CurrentLevel * 100; // Increase the requirement for the next level\n\tOnLevelUp.Broadcast(CurrentLevel, CurrentExperience);\n}\n```"}
{"requirement": "Develop a C++ class for a cross-platform input handling system supporting PC, console, and mobile devices.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InputHandlingSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AInputHandlingSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAInputHandlingSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle input\n\tvoid HandleInput();\n\nprivate:\n\tvoid HandlePCInput();\n\tvoid HandleConsoleInput();\n\tvoid HandleMobileInput();\n};\n```", "cpp_code": "```cpp\n#include \"InputHandlingSystem.h\"\n#include \"Engine/Engine.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAInputHandlingSystem::AInputHandlingSystem()\n{\n\t // Set this actor to call Tick() every frame.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AInputHandlingSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AInputHandlingSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tHandleInput();\n}\n\nvoid AInputHandlingSystem::HandleInput()\n{\n\t#if PLATFORM_WINDOWS || PLATFORM_MAC || PLATFORM_LINUX\n\t\tHandlePCInput();\n\t#elif PLATFORM_PS4 || PLATFORM_XBOXONE || PLATFORM_SWITCH\n\t\tHandleConsoleInput();\n\t#elif PLATFORM_IOS || PLATFORM_ANDROID\n\t\tHandleMobileInput();\n\t#endif\n}\n\nvoid AInputHandlingSystem::HandlePCInput()\n{\n\tif (GEngine && GEngine->GameViewport)\n\t{\n\t\t// Example: Log mouse position\n\t\tFVector2D MousePosition;\n\t\tif (GEngine->GameViewport->GetMousePosition(MousePosition))\n\t\t{\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Mouse Position: %s\"), *MousePosition.ToString());\n\t\t}\n\t}\n}\n\nvoid AInputHandlingSystem::HandleConsoleInput()\n{\n\t// Example: Log console specific input handling\n\tUE_LOG(LogTemp, Warning, TEXT(\"Handling console input.\"));\n}\n\nvoid AInputHandlingSystem::HandleMobileInput()\n{\n\t// Example: Log mobile specific input handling\n\tUE_LOG(LogTemp, Warning, TEXT(\"Handling mobile input.\"));\n}\n```"}
{"requirement": "Implement a C++ system for a dynamic economy, adjusting prices based on supply and demand.", "header_code": "```cpp\nUCLASS()\nclass YOURPROJECT_API UEconomySystem : public UObject\n{\n\tGENERATED_BODY()\n\nprivate:\n\tUPROPERTY()\n\tTMap<FString, float> Supply;\n\n\tUPROPERTY()\n\tTMap<FString, float> Demand;\n\n\tUPROPERTY()\n\tTMap<FString, float> Prices;\n\npublic:\n\tUEconomySystem();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Economy\")\n\tvoid UpdateSupply(FString Item, float Amount);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Economy\")\n\tvoid UpdateDemand(FString Item, float Amount);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Economy\")\n\tfloat GetPrice(FString Item) const;\n\nprivate:\n\tvoid AdjustPrices();\n};\n```", "cpp_code": "```cpp\n#include \"EconomySystem.h\"\n\nUEconomySystem::UEconomySystem()\n{\n\t// Initialize with some default values or load from a data source.\n\tSupply.Add(\"ItemA\", 100.0f);\n\tDemand.Add(\"ItemA\", 100.0f);\n\tPrices.Add(\"ItemA\", 10.0f);\n}\n\nvoid UEconomySystem::UpdateSupply(FString Item, float Amount)\n{\n\tif (Supply.Contains(Item))\n\t{\n\t\tSupply[Item] = Amount;\n\t}\n\telse\n\t{\n\t\tSupply.Add(Item, Amount);\n\t}\n\tAdjustPrices();\n}\n\nvoid UEconomySystem::UpdateDemand(FString Item, float Amount)\n{\n\tif (Demand.Contains(Item))\n\t{\n\t\tDemand[Item] = Amount;\n\t}\n\telse\n\t{\n\t\tDemand.Add(Item, Amount);\n\t}\n\tAdjustPrices();\n}\n\nfloat UEconomySystem::GetPrice(FString Item) const\n{\n\tif (Prices.Contains(Item))\n\t{\n\t\treturn Prices[Item];\n\t}\n\treturn 0.0f; // Default price if item not found.\n}\n\nvoid UEconomySystem::AdjustPrices()\n{\n\tfor (const auto& Elem : Supply)\n\t{\n\t\tFString Item = Elem.Key;\n\t\tfloat SupplyValue = Elem.Value;\n\t\tfloat DemandValue = Demand.Contains(Item) ? Demand[Item] : 0.0f;\n\n\t\tif (DemandValue > 0)\n\t\t{\n\t\t\tPrices[Item] = (SupplyValue / DemandValue) * 10.0f; // Basic price adjustment formula\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPrices[Item] = 10.0f; // Default price if no demand\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a C++ component for a customizable emote system for player expression in multiplayer environments.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"EmoteSystemComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURGAME_API UEmoteSystemComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUEmoteSystemComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION(BlueprintCallable, Category=\"Emote\")\n\tvoid PlayEmote(FName EmoteName);\n\n\tUFUNCTION(Server, Reliable, WithValidation)\n\tvoid ServerPlayEmote(FName EmoteName);\n\n\tUFUNCTION(NetMulticast, Reliable)\n\tvoid MulticastPlayEmote(FName EmoteName);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Emote\")\n\tTMap<FName, UAnimMontage*> EmoteAnimations;\n};\n```", "cpp_code": "```cpp\n#include \"EmoteSystemComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Net/UnrealNetwork.h\"\n\nUEmoteSystemComponent::UEmoteSystemComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tSetIsReplicatedByDefault(true);\n}\n\nvoid UEmoteSystemComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UEmoteSystemComponent::PlayEmote(FName EmoteName)\n{\n\tif (GetOwnerRole() < ROLE_Authority)\n\t{\n\t\tServerPlayEmote(EmoteName);\n\t}\n\telse\n\t{\n\t\tMulticastPlayEmote(EmoteName);\n\t}\n}\n\nbool UEmoteSystemComponent::ServerPlayEmote_Validate(FName EmoteName)\n{\n\treturn true;\n}\n\nvoid UEmoteSystemComponent::ServerPlayEmote_Implementation(FName EmoteName)\n{\n\tMulticastPlayEmote(EmoteName);\n}\n\nvoid UEmoteSystemComponent::MulticastPlayEmote_Implementation(FName EmoteName)\n{\n\tif (UAnimMontage** EmoteAnim = EmoteAnimations.Find(EmoteName))\n\t{\n\t\tAActor* Owner = GetOwner();\n\t\tif (Owner)\n\t\t{\n\t\t\tUAnimInstance* AnimInstance = Owner->FindComponentByClass<USkeletalMeshComponent>()->GetAnimInstance();\n\t\t\tif (AnimInstance)\n\t\t\t{\n\t\t\t\tAnimInstance->Montage_Play(*EmoteAnim);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UEmoteSystemComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\tDOREPLIFETIME(UEmoteSystemComponent, EmoteAnimations);\n}\n```"}
{"requirement": "Develop a C++ class for an auto-scaling difficulty system that adapts to player performance.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AutoDifficultyScaler.generated.h\"\n\nUCLASS()\nclass MYGAME_API AAutoDifficultyScaler : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAutoDifficultyScaler();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tfloat PlayerPerformance;\n\tfloat CurrentDifficulty;\n\t\n\tUPROPERTY(EditAnywhere)\n\tfloat MaxDifficulty;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MinDifficulty;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat PerformanceThreshold;\n\n\tvoid AdjustDifficulty();\n\n\tfloat CalculatePlayerPerformance();\n};\n```", "cpp_code": "```cpp\n#include \"AutoDifficultyScaler.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Character.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAAutoDifficultyScaler::AAutoDifficultyScaler()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMaxDifficulty = 1.0f;\n\tMinDifficulty = 0.1f;\n\tPerformanceThreshold = 0.5f;\n\tCurrentDifficulty = 0.5f;\n}\n\nvoid AAutoDifficultyScaler::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAutoDifficultyScaler::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tPlayerPerformance = CalculatePlayerPerformance();\n\tAdjustDifficulty();\n}\n\nvoid AAutoDifficultyScaler::AdjustDifficulty()\n{\n\tif (PlayerPerformance > PerformanceThreshold)\n\t{\n\t\tCurrentDifficulty = FMath::Clamp(CurrentDifficulty + 0.01f, MinDifficulty, MaxDifficulty);\n\t}\n\telse\n\t{\n\t\tCurrentDifficulty = FMath::Clamp(CurrentDifficulty - 0.01f, MinDifficulty, MaxDifficulty);\n\t}\n\t// Apply the CurrentDifficulty to game parameters here\n}\n\nfloat AAutoDifficultyScaler::CalculatePlayerPerformance()\n{\n\t// Placeholder for actual performance calculation logic\n\t// This could be based on player score, health, etc.\n\treturn FMath::FRand(); // Random value for demonstration\n}\n```"}
{"requirement": "Implement a C++ system for a multi-language localization that supports text and audio in various languages.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Engine/DataTable.h\"\n#include \"LocalizationSystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FLocalizationEntry : public FTableRowBase\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString Language;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString Text;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tUSoundWave* Audio;\n};\n\nUCLASS()\nclass YOURPROJECT_API ULocalizationSystem : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tvoid Initialize(FString LanguageCode);\n\tFString GetLocalizedText(FName Key) const;\n\tUSoundWave* GetLocalizedAudio(FName Key) const;\n\nprivate:\n\tUPROPERTY()\n\tUDataTable* LocalizationDataTable;\n\n\tFString CurrentLanguage;\n};\n```", "cpp_code": "```cpp\n#include \"LocalizationSystem.h\"\n#include \"Engine/DataTable.h\"\n\nvoid ULocalizationSystem::Initialize(FString LanguageCode)\n{\n\tCurrentLanguage = LanguageCode;\n\n\tstatic ConstructorHelpers::FObjectFinder<UDataTable> DataTable(TEXT(\"DataTable'/Game/Localization/LocalizationData.LocalizationData'\"));\n\tif (DataTable.Succeeded())\n\t{\n\t\tLocalizationDataTable = DataTable.Object;\n\t}\n}\n\nFString ULocalizationSystem::GetLocalizedText(FName Key) const\n{\n\tif (!LocalizationDataTable)\n\t{\n\t\treturn FString(\"Localization data table not found.\");\n\t}\n\n\tstatic const FString ContextString(TEXT(\"GENERAL\"));\n\tFLocalizationEntry* Entry = LocalizationDataTable->FindRow<FLocalizationEntry>(Key, ContextString);\n\tif (Entry && Entry->Language == CurrentLanguage)\n\t{\n\t\treturn Entry->Text;\n\t}\n\n\treturn FString(\"Text not found.\");\n}\n\nUSoundWave* ULocalizationSystem::GetLocalizedAudio(FName Key) const\n{\n\tif (!LocalizationDataTable)\n\t{\n\t\treturn nullptr;\n\t}\n\n\tstatic const FString ContextString(TEXT(\"GENERAL\"));\n\tFLocalizationEntry* Entry = LocalizationDataTable->FindRow<FLocalizationEntry>(Key, ContextString);\n\tif (Entry && Entry->Language == CurrentLanguage)\n\t{\n\t\treturn Entry->Audio;\n\t}\n\n\treturn nullptr;\n}\n```"}
{"requirement": "Create a C++ component for a heatmap analytics system that tracks player movement and actions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"HeatmapAnalyticsComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECTNAME_API UHeatmapAnalyticsComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUHeatmapAnalyticsComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\t// Function to log player position\n\tvoid LogPlayerPosition();\n\n\t// Function to log player actions\n\tvoid LogPlayerAction(FString Action);\n\nprivate:\n\t// Store player positions\n\tTArray<FVector> PlayerPositions;\n\n\t// Store player actions\n\tTArray<FString> PlayerActions;\n};\n```", "cpp_code": "```cpp\n#include \"HeatmapAnalyticsComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\n// Sets default values for this component's properties\nUHeatmapAnalyticsComponent::UHeatmapAnalyticsComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\n// Called when the game starts\nvoid UHeatmapAnalyticsComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid UHeatmapAnalyticsComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tLogPlayerPosition();\n}\n\nvoid UHeatmapAnalyticsComponent::LogPlayerPosition()\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector CurrentPosition = Owner->GetActorLocation();\n\t\tPlayerPositions.Add(CurrentPosition);\n\t\t// Additional logic to store/log the position can be added here\n\t}\n}\n\nvoid UHeatmapAnalyticsComponent::LogPlayerAction(FString Action)\n{\n\tPlayerActions.Add(Action);\n\t// Additional logic to store/log the action can be added here\n}\n```"}
{"requirement": "Develop a C++ class for an end-game summary screen displaying player statistics and achievements.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"EndGameSummary.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UEndGameSummary : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"EndGame Summary\")\n\tvoid DisplaySummary(const TMap<FString, int32>& PlayerStatistics, const TArray<FString>& Achievements);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tvoid UpdatePlayerStatistics(const TMap<FString, int32>& PlayerStatistics);\n\tvoid UpdateAchievements(const TArray<FString>& Achievements);\n\n\tUPROPERTY(meta=(BindWidget))\n\tclass UTextBlock* PlayerStatisticsText;\n\n\tUPROPERTY(meta=(BindWidget))\n\tclass UTextBlock* AchievementsText;\n};\n```", "cpp_code": "```cpp\n#include \"EndGameSummary.h\"\n#include \"Components/TextBlock.h\"\n\nvoid UEndGameSummary::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\t// Initialize or bind any necessary events here\n}\n\nvoid UEndGameSummary::DisplaySummary(const TMap<FString, int32>& PlayerStatistics, const TArray<FString>& Achievements)\n{\n\tUpdatePlayerStatistics(PlayerStatistics);\n\tUpdateAchievements(Achievements);\n}\n\nvoid UEndGameSummary::UpdatePlayerStatistics(const TMap<FString, int32>& PlayerStatistics)\n{\n\tFString StatsText;\n\tfor (const auto& Stat : PlayerStatistics)\n\t{\n\t\tStatsText += FString::Printf(TEXT(\"%s: %d\\n\"), *Stat.Key, Stat.Value);\n\t}\n\tif (PlayerStatisticsText)\n\t{\n\t\tPlayerStatisticsText->SetText(FText::FromString(StatsText));\n\t}\n}\n\nvoid UEndGameSummary::UpdateAchievements(const TArray<FString>& Achievements)\n{\n\tFString AchievementsTextContent;\n\tfor (const FString& Achievement : Achievements)\n\t{\n\t\tAchievementsTextContent += Achievement + TEXT(\"\\n\");\n\t}\n\tif (AchievementsText)\n\t{\n\t\tAchievementsText->SetText(FText::FromString(AchievementsTextContent));\n\t}\n}\n```"}
{"requirement": "Implement a C++ system for a physics-based puzzle mechanic involving gravity and momentum.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GravityPuzzleActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AGravityPuzzleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAGravityPuzzleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to apply custom gravity\n\tvoid ApplyGravity();\n\n\t// Function to manage momentum\n\tvoid ManageMomentum();\n\nprivate:\n\t// The gravity force applied to the actor\n\tUPROPERTY(EditAnywhere)\n\tfloat GravityForce;\n\n\t// The momentum factor of the actor\n\tUPROPERTY(EditAnywhere)\n\tfloat MomentumFactor;\n\n\t// The current velocity of the actor\n\tFVector CurrentVelocity;\n};\n```", "cpp_code": "```cpp\n#include \"GravityPuzzleActor.h\"\n\n// Sets default values\nAGravityPuzzleActor::AGravityPuzzleActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default values\n\tGravityForce = -980.f; // Default gravity in Unreal Engine\n\tMomentumFactor = 1.5f;\n\tCurrentVelocity = FVector::ZeroVector;\n}\n\n// Called when the game starts or when spawned\nvoid AGravityPuzzleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AGravityPuzzleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tApplyGravity();\n\tManageMomentum();\n\n\t// Update actor location\n\tFVector NewLocation = GetActorLocation() + CurrentVelocity * DeltaTime;\n\tSetActorLocation(NewLocation);\n}\n\nvoid AGravityPuzzleActor::ApplyGravity()\n{\n\t// Apply gravity force to the current velocity\n\tCurrentVelocity.Z += GravityForce * GetWorld()->GetDeltaSeconds();\n}\n\nvoid AGravityPuzzleActor::ManageMomentum()\n{\n\t// Simple momentum management (for demonstration)\n\tCurrentVelocity *= MomentumFactor;\n}\n```"}
{"requirement": "Create a C++ component for a dynamic soundtrack system that changes based on player location and actions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"DynamicSoundtrackComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UDynamicSoundtrackComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUDynamicSoundtrackComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Soundtrack\")\n\tvoid UpdateSoundtrack();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Soundtrack\")\n\tUSoundCue* AmbientSoundCue;\n\n\tUPROPERTY(EditAnywhere, Category=\"Soundtrack\")\n\tUSoundCue* ActionSoundCue;\n\n\tUPROPERTY(EditAnywhere, Category=\"Soundtrack\")\n\tFVector PlayerLocation;\n\n\tUPROPERTY(EditAnywhere, Category=\"Soundtrack\")\n\tbool bIsInActionMode;\n\n\tvoid PlayAmbientSound();\n\tvoid PlayActionSound();\n};\n```", "cpp_code": "```cpp\n#include \"DynamicSoundtrackComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUDynamicSoundtrackComponent::UDynamicSoundtrackComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tAmbientSoundCue = nullptr;\n\tActionSoundCue = nullptr;\n\tbIsInActionMode = false;\n}\n\nvoid UDynamicSoundtrackComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UDynamicSoundtrackComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tUpdateSoundtrack();\n}\n\nvoid UDynamicSoundtrackComponent::UpdateSoundtrack()\n{\n\tAActor* Owner = GetOwner();\n\tif (!Owner) return;\n\n\tPlayerLocation = Owner->GetActorLocation();\n\n\t// Example logic to determine soundtrack\n\tif (bIsInActionMode)\n\t{\n\t\tPlayActionSound();\n\t}\n\telse\n\t{\n\t\tPlayAmbientSound();\n\t}\n}\n\nvoid UDynamicSoundtrackComponent::PlayAmbientSound()\n{\n\tif (AmbientSoundCue)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, AmbientSoundCue, PlayerLocation);\n\t}\n}\n\nvoid UDynamicSoundtrackComponent::PlayActionSound()\n{\n\tif (ActionSoundCue)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, ActionSoundCue, PlayerLocation);\n\t}\n}\n```"}
{"requirement": "Develop a C++ class for a visual scripting interface that allows designers to create logic without code.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/Object.h\"\n#include \"VisualScriptingInterface.generated.h\"\n\nUCLASS(BlueprintType)\nclass YOURPROJECT_API UVisualScriptingInterface : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUVisualScriptingInterface();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visual Scripting\")\n\tvoid AddNode(const FString& NodeName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visual Scripting\")\n\tvoid ConnectNodes(const FString& FromNode, const FString& ToNode);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visual Scripting\")\n\tvoid ExecuteGraph();\n\nprivate:\n\tTMap<FString, TArray<FString>> NodeConnections;\n};\n```", "cpp_code": "```cpp\n#include \"VisualScriptingInterface.h\"\n\nUVisualScriptingInterface::UVisualScriptingInterface()\n{\n\t// Constructor logic here\n}\n\nvoid UVisualScriptingInterface::AddNode(const FString& NodeName)\n{\n\tif (!NodeConnections.Contains(NodeName))\n\t{\n\t\tNodeConnections.Add(NodeName, TArray<FString>());\n\t}\n}\n\nvoid UVisualScriptingInterface::ConnectNodes(const FString& FromNode, const FString& ToNode)\n{\n\tif (NodeConnections.Contains(FromNode) && NodeConnections.Contains(ToNode))\n\t{\n\t\tNodeConnections[FromNode].Add(ToNode);\n\t}\n}\n\nvoid UVisualScriptingInterface::ExecuteGraph()\n{\n\t// Example execution logic\n\tfor (const auto& Node : NodeConnections)\n\t{\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Executing Node: %s\"), *Node.Key);\n\t\tfor (const auto& ConnectedNode : Node.Value)\n\t\t{\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"  Connected to: %s\"), *ConnectedNode);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a C++ system for a haptic feedback mechanism, enhancing player immersion through vibrations.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HapticFeedbackSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHapticFeedbackSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHapticFeedbackSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to trigger haptic feedback\n\tUFUNCTION(BlueprintCallable, Category = \"Haptic\")\n\tvoid TriggerHapticFeedback(APlayerController* PlayerController, float Intensity, float Duration);\n};\n```", "cpp_code": "```cpp\n#include \"HapticFeedbackSystem.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Haptics/HapticFeedbackEffect_Base.h\"\n\n// Sets default values\nAHapticFeedbackSystem::AHapticFeedbackSystem()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AHapticFeedbackSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AHapticFeedbackSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHapticFeedbackSystem::TriggerHapticFeedback(APlayerController* PlayerController, float Intensity, float Duration)\n{\n\tif (PlayerController && PlayerController->IsLocalController())\n\t{\n\t\tFActiveHapticFeedbackEffectHandle HapticHandle = PlayerController->PlayHapticEffect(/* Your HapticFeedbackEffect */, EControllerHand::Left, Intensity, false);\n\n\t\t// Optionally manage the duration if needed\n\t\t// You might need to create a timer to stop the feedback after the duration\n\t}\n}\n```"}
{"requirement": "Create a C++ component for a game replay system, allowing players to watch and analyze past matches.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ReplaySystemComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API UReplaySystemComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUReplaySystemComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void RecordReplay();\n\tvirtual void StopRecording();\n\tvirtual void PlayReplay();\n\tvirtual void StopReplay();\n\nprivate:\n\tbool bIsRecording;\n\tbool bIsPlaying;\n\tTArray<FTransform> RecordedTransforms;\n\tint32 CurrentReplayIndex;\n\n\tvoid CaptureFrame();\n};\n```", "cpp_code": "```cpp\n#include \"ReplaySystemComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nUReplaySystemComponent::UReplaySystemComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tbIsRecording = false;\n\tbIsPlaying = false;\n\tCurrentReplayIndex = 0;\n}\n\nvoid UReplaySystemComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UReplaySystemComponent::RecordReplay()\n{\n\tbIsRecording = true;\n\tRecordedTransforms.Empty();\n}\n\nvoid UReplaySystemComponent::StopRecording()\n{\n\tbIsRecording = false;\n}\n\nvoid UReplaySystemComponent::PlayReplay()\n{\n\tif (RecordedTransforms.Num() > 0)\n\t{\n\t\tbIsPlaying = true;\n\t\tCurrentReplayIndex = 0;\n\t}\n}\n\nvoid UReplaySystemComponent::StopReplay()\n{\n\tbIsPlaying = false;\n}\n\nvoid UReplaySystemComponent::CaptureFrame()\n{\n\tif (bIsRecording)\n\t{\n\t\tAActor* Owner = GetOwner();\n\t\tif (Owner)\n\t\t{\n\t\t\tRecordedTransforms.Add(Owner->GetActorTransform());\n\t\t}\n\t}\n\n\tif (bIsPlaying && RecordedTransforms.IsValidIndex(CurrentReplayIndex))\n\t{\n\t\tAActor* Owner = GetOwner();\n\t\tif (Owner)\n\t\t{\n\t\t\tOwner->SetActorTransform(RecordedTransforms[CurrentReplayIndex]);\n\t\t\tCurrentReplayIndex++;\n\t\t\tif (CurrentReplayIndex >= RecordedTransforms.Num())\n\t\t\t{\n\t\t\t\tStopReplay();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UReplaySystemComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tCaptureFrame();\n}\n```"}
{"requirement": "Develop a C++ class for a virtual reality control system, supporting motion controllers and head tracking.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VRControlSystem.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AVRControlSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAVRControlSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Motion Controller Components\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"VR\")\n\tclass UMotionControllerComponent* LeftController;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"VR\")\n\tclass UMotionControllerComponent* RightController;\n\n\t// Head Mounted Display Component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"VR\")\n\tclass UCameraComponent* HMD;\n\n\t// Function to Update Controller and Headset Tracking\n\tvoid UpdateVRTracking();\n};\n```", "cpp_code": "```cpp\n#include \"VRControlSystem.h\"\n#include \"Components/InputComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"MotionControllerComponent.h\"\n\n// Sets default values\nAVRControlSystem::AVRControlSystem()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the motion controller components\n\tLeftController = CreateDefaultSubobject<UMotionControllerComponent>(TEXT(\"LeftController\"));\n\tRightController = CreateDefaultSubobject<UMotionControllerComponent>(TEXT(\"RightController\"));\n\n\t// Assign the hand roles\n\tLeftController->MotionSource = FXRMotionControllerBase::LeftHandSourceId;\n\tRightController->MotionSource = FXRMotionControllerBase::RightHandSourceId;\n\n\t// Attach controllers to the root\n\tRootComponent = CreateDefaultSubobject<USceneComponent>(TEXT(\"RootComponent\"));\n\tLeftController->SetupAttachment(RootComponent);\n\tRightController->SetupAttachment(RootComponent);\n\n\t// Create the camera component for the HMD\n\tHMD = CreateDefaultSubobject<UCameraComponent>(TEXT(\"HMD\"));\n\tHMD->SetupAttachment(RootComponent);\n}\n\n// Called when the game starts or when spawned\nvoid AVRControlSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AVRControlSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateVRTracking();\n}\n\n// Function to Update Controller and Headset Tracking\nvoid AVRControlSystem::UpdateVRTracking()\n{\n\t// Here you can add code to update VR tracking, e.g., \n\t// logging positions or applying custom logic.\n\tFVector LeftControllerPos = LeftController->GetComponentLocation();\n\tFVector RightControllerPos = RightController->GetComponentLocation();\n\tFVector HMDPos = HMD->GetComponentLocation();\n\n\t// Example debug logs\n\tUE_LOG(LogTemp, Log, TEXT(\"Left Controller Position: %s\"), *LeftControllerPos.ToString());\n\tUE_LOG(LogTemp, Log, TEXT(\"Right Controller Position: %s\"), *RightControllerPos.ToString());\n\tUE_LOG(LogTemp, Log, TEXT(\"HMD Position: %s\"), *HMDPos.ToString());\n}\n```"}
{"requirement": "Implement a C++ system for a competitive ranking system with divisions and seasonal resets.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RankingSystem.generated.h\"\n\nUENUM(BlueprintType)\nenum class EDivision : uint8\n{\n\tBronze,\n\tSilver,\n\tGold,\n\tPlatinum,\n\tDiamond\n};\n\nUSTRUCT(BlueprintType)\nstruct FPlayerRank\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tEDivision Division;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 Points;\n\n\tFPlayerRank() : Division(EDivision::Bronze), Points(0) {}\n};\n\nUCLASS()\nclass YOURGAME_API ARankingSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARankingSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tint32 PointsPerWin;\n\n\tUPROPERTY(EditAnywhere)\n\tint32 PointsPerLoss;\n\n\tUPROPERTY(EditAnywhere)\n\tint32 PointsToAdvance;\n\n\tUPROPERTY(EditAnywhere)\n\tTArray<FPlayerRank> PlayerRanks;\n\n\tvoid ResetSeason();\n\tvoid UpdatePlayerRank(int32 PlayerIndex, bool bWin);\n};\n```", "cpp_code": "```cpp\n#include \"RankingSystem.h\"\n\nARankingSystem::ARankingSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPointsPerWin = 100;\n\tPointsPerLoss = 50;\n\tPointsToAdvance = 500;\n}\n\nvoid ARankingSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tResetSeason();\n}\n\nvoid ARankingSystem::ResetSeason()\n{\n\tfor (FPlayerRank& Rank : PlayerRanks)\n\t{\n\t\tRank.Division = EDivision::Bronze;\n\t\tRank.Points = 0;\n\t}\n}\n\nvoid ARankingSystem::UpdatePlayerRank(int32 PlayerIndex, bool bWin)\n{\n\tif (!PlayerRanks.IsValidIndex(PlayerIndex))\n\t{\n\t\treturn;\n\t}\n\n\tFPlayerRank& PlayerRank = PlayerRanks[PlayerIndex];\n\n\tif (bWin)\n\t{\n\t\tPlayerRank.Points += PointsPerWin;\n\t}\n\telse\n\t{\n\t\tPlayerRank.Points -= PointsPerLoss;\n\t}\n\n\tif (PlayerRank.Points >= PointsToAdvance)\n\t{\n\t\tPlayerRank.Points -= PointsToAdvance;\n\t\tPlayerRank.Division = static_cast<EDivision>(FMath::Min(static_cast<int32>(PlayerRank.Division) + 1, static_cast<int32>(EDivision::Diamond)));\n\t}\n\telse if (PlayerRank.Points < 0)\n\t{\n\t\tPlayerRank.Points = 0;\n\t\tPlayerRank.Division = static_cast<EDivision>(FMath::Max(static_cast<int32>(PlayerRank.Division) - 1, static_cast<int32>(EDivision::Bronze)));\n\t}\n}\n```"}
{"requirement": "Create a C++ component for a weather forecast system, providing in-game predictions based on time and location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"WeatherForecastComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UWeatherForecastComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUWeatherForecastComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Weather\")\n\tFString GetWeatherForecast(FDateTime Time, FVector Location);\n\nprivate:\n\tFString GenerateWeatherForecast(FDateTime Time, FVector Location);\n};\n```", "cpp_code": "```cpp\n#include \"WeatherForecastComponent.h\"\n\nUWeatherForecastComponent::UWeatherForecastComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UWeatherForecastComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nFString UWeatherForecastComponent::GetWeatherForecast(FDateTime Time, FVector Location)\n{\n\treturn GenerateWeatherForecast(Time, Location);\n}\n\nFString UWeatherForecastComponent::GenerateWeatherForecast(FDateTime Time, FVector Location)\n{\n\t// Example: Simple algorithm to determine weather based on time and location\n\t// In a real scenario, this could be a call to an external service or complex logic\n\tint32 Hour = Time.GetHour();\n\tFString WeatherType;\n\n\tif (Location.Z > 1000)\n\t{\n\t\tWeatherType = \"Snow\";\n\t}\n\telse if (Hour >= 6 && Hour < 18)\n\t{\n\t\tWeatherType = \"Sunny\";\n\t}\n\telse\n\t{\n\t\tWeatherType = \"Clear\";\n\t}\n\n\treturn WeatherType;\n}\n```"}
{"requirement": "Develop a C++ class for an interactive tutorial system guiding new players through gameplay mechanics.", "header_code": "```cpp\n/* InteractiveTutorialSystem.h */\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InteractiveTutorialSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AInteractiveTutorialSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAInteractiveTutorialSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Tutorial\")\n\tvoid StartTutorial();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Tutorial\")\n\tvoid AdvanceTutorialStep();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Tutorial\")\n\tvoid EndTutorial();\n\nprivate:\n\tint32 CurrentStep;\n\n\tvoid DisplayStepInstructions(int32 Step);\n};\n```", "cpp_code": "```cpp\n/* InteractiveTutorialSystem.cpp */\n#include \"InteractiveTutorialSystem.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAInteractiveTutorialSystem::AInteractiveTutorialSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentStep = 0;\n}\n\nvoid AInteractiveTutorialSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AInteractiveTutorialSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AInteractiveTutorialSystem::StartTutorial()\n{\n\tCurrentStep = 0;\n\tDisplayStepInstructions(CurrentStep);\n}\n\nvoid AInteractiveTutorialSystem::AdvanceTutorialStep()\n{\n\tCurrentStep++;\n\tDisplayStepInstructions(CurrentStep);\n}\n\nvoid AInteractiveTutorialSystem::EndTutorial()\n{\n\t// Logic to end the tutorial, such as hiding UI elements or stopping specific actions\n\tUE_LOG(LogTemp, Warning, TEXT(\"Tutorial Ended.\"));\n}\n\nvoid AInteractiveTutorialSystem::DisplayStepInstructions(int32 Step)\n{\n\t// Logic to display instructions for the current tutorial step\n\tswitch (Step)\n\t{\n\tcase 0:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Welcome to the game! Use WASD to move.\"));\n\t\tbreak;\n\tcase 1:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Great! Now try jumping with Spacebar.\"));\n\t\tbreak;\n\tcase 2:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Well done! That's the basics.\"));\n\t\tEndTutorial();\n\t\tbreak;\n\tdefault:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Unknown tutorial step.\"));\n\t\tbreak;\n\t}\n}\n```"}
{"requirement": "Implement a C++ system for a scalable server architecture that supports large-scale multiplayer battles.", "header_code": "```cpp\n/* ScalableBattleServer.h */\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"ScalableBattleServer.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AScalableBattleServer : public AGameModeBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScalableBattleServer();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tvoid InitializeServerNetworking();\n\tvoid HandlePlayerConnections();\n\tvoid BalanceLoadAcrossServers();\n\n\tint32 MaxPlayersPerServer;\n\tTArray<APlayerController*> ConnectedPlayers;\n};\n```", "cpp_code": "```cpp\n/* ScalableBattleServer.cpp */\n#include \"ScalableBattleServer.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Networking/Public/Networking.h\"\n\nAScalableBattleServer::AScalableBattleServer()\n{\n\tMaxPlayersPerServer = 100;\n}\n\nvoid AScalableBattleServer::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitializeServerNetworking();\n\tHandlePlayerConnections();\n}\n\nvoid AScalableBattleServer::InitializeServerNetworking()\n{\n\t// Initialize server socket and networking settings here\n\tUE_LOG(LogTemp, Warning, TEXT(\"Server networking initialized.\"));\n}\n\nvoid AScalableBattleServer::HandlePlayerConnections()\n{\n\t// Logic to accept and manage player connections\n\tUE_LOG(LogTemp, Warning, TEXT(\"Managing player connections.\"));\n}\n\nvoid AScalableBattleServer::BalanceLoadAcrossServers()\n{\n\t// Logic to balance the load among multiple servers\n\tif (ConnectedPlayers.Num() > MaxPlayersPerServer)\n\t{\n\t\t// Code for distributing players to another server\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Balancing load across servers.\"));\n\t}\n}\n```"}
{"requirement": "Create a C++ component for a character emotion system that changes facial expressions based on events.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CharacterEmotionComponent.generated.h\"\n\nUENUM(BlueprintType)\nenum class ECharacterEmotion : uint8\n{\n\tHappy\t UMETA(DisplayName = \"Happy\"),\n\tSad\t   UMETA(DisplayName = \"Sad\"),\n\tAngry\t UMETA(DisplayName = \"Angry\"),\n\tSurprised UMETA(DisplayName = \"Surprised\")\n};\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UCharacterEmotionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUCharacterEmotionComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category=\"Emotion\")\n\tvoid ChangeEmotion(ECharacterEmotion NewEmotion);\n\nprivate:\n\tvoid UpdateFacialExpression();\n\n\tUPROPERTY(EditAnywhere, Category=\"Emotion\")\n\tECharacterEmotion CurrentEmotion;\n};\n```", "cpp_code": "```cpp\n#include \"CharacterEmotionComponent.h\"\n\nUCharacterEmotionComponent::UCharacterEmotionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tCurrentEmotion = ECharacterEmotion::Happy;\n}\n\nvoid UCharacterEmotionComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateFacialExpression();\n}\n\nvoid UCharacterEmotionComponent::ChangeEmotion(ECharacterEmotion NewEmotion)\n{\n\tif (CurrentEmotion != NewEmotion)\n\t{\n\t\tCurrentEmotion = NewEmotion;\n\t\tUpdateFacialExpression();\n\t}\n}\n\nvoid UCharacterEmotionComponent::UpdateFacialExpression()\n{\n\t// Placeholder: Implement the logic to update the character's facial expression based on CurrentEmotion\n\tswitch (CurrentEmotion)\n\t{\n\t\tcase ECharacterEmotion::Happy:\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Character is now Happy\"));\n\t\t\tbreak;\n\t\tcase ECharacterEmotion::Sad:\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Character is now Sad\"));\n\t\t\tbreak;\n\t\tcase ECharacterEmotion::Angry:\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Character is now Angry\"));\n\t\t\tbreak;\n\t\tcase ECharacterEmotion::Surprised:\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Character is now Surprised\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n```"}
{"requirement": "Develop a C++ class for a debris simulation, creating realistic environmental destruction and particle effects.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DebrisSimulation.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADebrisSimulation : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADebrisSimulation();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Debris\")\n\tTArray<class UStaticMeshComponent*> DebrisComponents;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Debris\")\n\tclass UParticleSystem* DestructionParticleEffect;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Debris\")\n\tvoid SimulateDestruction();\n\nprivate:\n\tvoid InitializeDebris();\n\tvoid PlayDestructionEffects();\n};\n```", "cpp_code": "```cpp\n#include \"DebrisSimulation.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nADebrisSimulation::ADebrisSimulation()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ADebrisSimulation::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitializeDebris();\n}\n\n// Called every frame\nvoid ADebrisSimulation::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADebrisSimulation::InitializeDebris()\n{\n\t// Initialize debris components logic here\n}\n\nvoid ADebrisSimulation::SimulateDestruction()\n{\n\tPlayDestructionEffects();\n\t// Additional logic for handling the destruction simulation\n}\n\nvoid ADebrisSimulation::PlayDestructionEffects()\n{\n\tif (DestructionParticleEffect)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), DestructionParticleEffect, GetActorLocation(), FRotator::ZeroRotator);\n\t}\n\t// Additional effects like sound or camera shake can be added here\n}\n```"}
{"requirement": "Implement a C++ system for a shared world experience where player actions globally affect the environment.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SharedWorldManager.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASharedWorldManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASharedWorldManager();\n\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"SharedWorld\")\n\tvoid UpdateWorldState(FString PlayerAction);\n\n\tUFUNCTION(BlueprintCallable, Category=\"SharedWorld\")\n\tFString GetWorldState() const;\n\nprivate:\n\tFString CurrentWorldState;\n\n\tvoid ApplyPlayerActionToWorld(FString PlayerAction);\n};\n```", "cpp_code": "```cpp\n#include \"SharedWorldManager.h\"\n#include \"Net/UnrealNetwork.h\"\n\nASharedWorldManager::ASharedWorldManager()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentWorldState = TEXT(\"Initial State\");\n}\n\nvoid ASharedWorldManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASharedWorldManager::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASharedWorldManager::UpdateWorldState(FString PlayerAction)\n{\n\tApplyPlayerActionToWorld(PlayerAction);\n\tOnRep_WorldState();\n}\n\nFString ASharedWorldManager::GetWorldState() const\n{\n\treturn CurrentWorldState;\n}\n\nvoid ASharedWorldManager::ApplyPlayerActionToWorld(FString PlayerAction)\n{\n\t// Simple example logic to change world state based on player action\n\tif (PlayerAction == \"GrowTree\")\n\t{\n\t\tCurrentWorldState = TEXT(\"Tree Grown\");\n\t}\n\telse if (PlayerAction == \"BuildHouse\")\n\t{\n\t\tCurrentWorldState = TEXT(\"House Built\");\n\t}\n\t// Add more conditions as needed\n}\n\nvoid ASharedWorldManager::OnRep_WorldState()\n{\n\t// Logic to propagate changes in the world state to all clients\n\t// This function would be called on clients when the CurrentWorldState is replicated\n}\n\nvoid ASharedWorldManager::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(ASharedWorldManager, CurrentWorldState);\n}\n```"}
{"requirement": "Create a C++ component for a custom leaderboard that tracks specific player achievements and records.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LeaderboardComponent.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FPlayerAchievementRecord\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Leaderboard\")\n\tFString PlayerName;\n\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Leaderboard\")\n\tint32 AchievementPoints;\n\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Leaderboard\")\n\tFString AchievementName;\n\n\tFPlayerAchievementRecord()\n\t\t: PlayerName(TEXT(\"\")), AchievementPoints(0), AchievementName(TEXT(\"\")) {}\n};\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API ULeaderboardComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tULeaderboardComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Leaderboard\")\n\tTArray<FPlayerAchievementRecord> LeaderboardRecords;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Leaderboard\")\n\tvoid AddAchievementRecord(const FString& PlayerName, int32 AchievementPoints, const FString& AchievementName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Leaderboard\")\n\tTArray<FPlayerAchievementRecord> GetTopAchievements(int32 TopN) const;\n};\n```", "cpp_code": "```cpp\n#include \"LeaderboardComponent.h\"\n\nULeaderboardComponent::ULeaderboardComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid ULeaderboardComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ULeaderboardComponent::AddAchievementRecord(const FString& PlayerName, int32 AchievementPoints, const FString& AchievementName)\n{\n\tFPlayerAchievementRecord NewRecord;\n\tNewRecord.PlayerName = PlayerName;\n\tNewRecord.AchievementPoints = AchievementPoints;\n\tNewRecord.AchievementName = AchievementName;\n\tLeaderboardRecords.Add(NewRecord);\n\n\t// Sort the leaderboard by AchievementPoints descending\n\tLeaderboardRecords.Sort([](const FPlayerAchievementRecord& A, const FPlayerAchievementRecord& B) {\n\t\treturn A.AchievementPoints > B.AchievementPoints;\n\t});\n}\n\nTArray<FPlayerAchievementRecord> ULeaderboardComponent::GetTopAchievements(int32 TopN) const\n{\n\tTArray<FPlayerAchievementRecord> TopRecords;\n\tint32 Count = FMath::Min(TopN, LeaderboardRecords.Num());\n\tTopRecords.Append(LeaderboardRecords.GetData(), Count);\n\treturn TopRecords;\n}\n```"}
{"requirement": "Develop a C++ class for a real-time collaboration tool for developers to work concurrently on level design.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"CollaborationTool.generated.h\"\n\nUCLASS(Blueprintable)\nclass MYPROJECT_API UCollaborationTool : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUCollaborationTool();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Collaboration\")\n\tvoid ConnectToSession(const FString& SessionID);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Collaboration\")\n\tvoid ShareLevelChanges(const FString& ChangeDescription);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Collaboration\")\n\tvoid ReceiveLevelChanges();\n\nprivate:\n\tvoid HandleIncomingChanges(const FString& ChangeData);\n\n\tFString CurrentSessionID;\n};\n```", "cpp_code": "```cpp\n#include \"CollaborationTool.h\"\n#include \"Networking/Public/Networking.h\"\n#include \"Sockets.h\"\n#include \"SocketSubsystem.h\"\n\nUCollaborationTool::UCollaborationTool()\n{\n\t// Constructor logic here\n\tCurrentSessionID = TEXT(\"\");\n}\n\nvoid UCollaborationTool::ConnectToSession(const FString& SessionID)\n{\n\t// Logic to connect to a collaboration session using SessionID\n\tCurrentSessionID = SessionID;\n\tUE_LOG(LogTemp, Log, TEXT(\"Connected to session: %s\"), *SessionID);\n}\n\nvoid UCollaborationTool::ShareLevelChanges(const FString& ChangeDescription)\n{\n\t// Logic to send level changes to the server or other clients\n\tif (!CurrentSessionID.IsEmpty())\n\t{\n\t\t// Serialize and send ChangeDescription\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Sharing changes: %s\"), *ChangeDescription);\n\t}\n}\n\nvoid UCollaborationTool::ReceiveLevelChanges()\n{\n\t// Logic to receive level changes from the server or other clients\n\tFString IncomingChangeData;\n\t// Simulate receiving data\n\tIncomingChangeData = TEXT(\"Sample Change Data\");\n\tHandleIncomingChanges(IncomingChangeData);\n}\n\nvoid UCollaborationTool::HandleIncomingChanges(const FString& ChangeData)\n{\n\t// Handle the incoming change data\n\tUE_LOG(LogTemp, Log, TEXT(\"Received changes: %s\"), *ChangeData);\n}\n```"}
{"requirement": "Implement a C++ system for context-sensitive help, providing tips based on current player needs.", "header_code": "```cpp\nUCLASS()\nclass YOURGAME_API AContextSensitiveHelpSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAContextSensitiveHelpSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Method to provide context-sensitive help\n\tUFUNCTION(BlueprintCallable, Category=\"Help\")\n\tvoid ProvideHelp(EPlayerState CurrentPlayerState);\n\nprivate:\n\t// Internal method to determine help text\n\tFString DetermineHelpText(EPlayerState PlayerState);\n\n\t// Map to hold player state and corresponding help texts\n\tTMap<EPlayerState, FString> HelpTexts;\n};\n```", "cpp_code": "```cpp\n#include \"ContextSensitiveHelpSystem.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAContextSensitiveHelpSystem::AContextSensitiveHelpSystem()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t // Initialize help texts map\n\t HelpTexts.Add(EPlayerState::Idle, TEXT(\"You are idle. Consider exploring the area or checking your inventory.\"));\n\t HelpTexts.Add(EPlayerState::InCombat, TEXT(\"In combat! Use your skills wisely and keep an eye on your health.\"));\n\t HelpTexts.Add(EPlayerState::Exploring, TEXT(\"Exploring the world. Look for hidden items and secrets.\"));\n\t // Add more states and tips as needed\n}\n\n// Called when the game starts or when spawned\nvoid AContextSensitiveHelpSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AContextSensitiveHelpSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AContextSensitiveHelpSystem::ProvideHelp(EPlayerState CurrentPlayerState)\n{\n\tFString HelpText = DetermineHelpText(CurrentPlayerState);\n\t// Display help text to the player\n\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Yellow, HelpText);\n}\n\nFString AContextSensitiveHelpSystem::DetermineHelpText(EPlayerState PlayerState)\n{\n\tif (HelpTexts.Contains(PlayerState))\n\t{\n\t\treturn HelpTexts[PlayerState];\n\t}\n\treturn TEXT(\"No help available for the current state.\");\n}\n```"}
{"requirement": "Create a C++ component for a realistic aging system, altering character models and behaviors over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"AgingSystemComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UAgingSystemComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUAgingSystemComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tvoid UpdateAging(float DeltaTime);\n\n\tUPROPERTY(EditAnywhere, Category=\"Aging\")\n\tfloat AgingRate;\n\n\tUPROPERTY(EditAnywhere, Category=\"Aging\")\n\tfloat MaxAge;\n\n\tfloat CurrentAge;\n\n\tvoid UpdateCharacterModel();\n\tvoid UpdateCharacterBehavior();\n};\n```", "cpp_code": "```cpp\n#include \"AgingSystemComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUAgingSystemComponent::UAgingSystemComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tAgingRate = 1.0f;\n\tMaxAge = 100.0f;\n\tCurrentAge = 0.0f;\n}\n\nvoid UAgingSystemComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UAgingSystemComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tUpdateAging(DeltaTime);\n}\n\nvoid UAgingSystemComponent::UpdateAging(float DeltaTime)\n{\n\tCurrentAge += AgingRate * DeltaTime;\n\tif (CurrentAge > MaxAge)\n\t{\n\t\tCurrentAge = MaxAge;\n\t}\n\tUpdateCharacterModel();\n\tUpdateCharacterBehavior();\n}\n\nvoid UAgingSystemComponent::UpdateCharacterModel()\n{\n\t// TODO: Implement character model updates based on CurrentAge\n}\n\nvoid UAgingSystemComponent::UpdateCharacterBehavior()\n{\n\t// TODO: Implement character behavior updates based on CurrentAge\n}\n```"}
{"requirement": "Develop a C++ class for a multi-threaded AI system, optimizing performance for complex behaviors.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"HAL/Runnable.h\"\n#include \"HAL/RunnableThread.h\"\n#include \"AIThreadManager.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UAIThreadManager : public UObject, public FRunnable\n{\n\tGENERATED_BODY()\n\npublic:\n\tUAIThreadManager();\n\tvirtual ~UAIThreadManager();\n\n\tvoid StartAIThread();\n\tvoid StopAIThread();\n\nprotected:\n\tvirtual uint32 Run() override;\n\tvirtual void Stop() override;\n\nprivate:\n\tFRunnableThread* AIThread;\n\tFThreadSafeBool bStopThread;\n\n\tvoid ProcessAIBot(int32 BotID);\n};\n```", "cpp_code": "```cpp\n#include \"AIThreadManager.h\"\n#include \"HAL/PlatformProcess.h\"\n#include \"Misc/ScopeLock.h\"\n\nUAIThreadManager::UAIThreadManager()\n\t: AIThread(nullptr)\n\t, bStopThread(false)\n{\n}\n\nUAIThreadManager::~UAIThreadManager()\n{\n\tStopAIThread();\n}\n\nvoid UAIThreadManager::StartAIThread()\n{\n\tif (!AIThread)\n\t{\n\t\tbStopThread = false;\n\t\tAIThread = FRunnableThread::Create(this, TEXT(\"AIThread\"), 0, TPri_BelowNormal);\n\t}\n}\n\nvoid UAIThreadManager::StopAIThread()\n{\n\tbStopThread = true;\n\tif (AIThread)\n\t{\n\t\tAIThread->Kill(true);\n\t\tdelete AIThread;\n\t\tAIThread = nullptr;\n\t}\n}\n\nuint32 UAIThreadManager::Run()\n{\n\twhile (!bStopThread)\n\t{\n\t\tFPlatformProcess::Sleep(0.01f); // Adjust sleep time for performance\n\t\tfor (int32 BotID = 0; BotID < 10; ++BotID) // Example: Process 10 AI bots\n\t\t{\n\t\t\tProcessAIBot(BotID);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid UAIThreadManager::Stop()\n{\n\tbStopThread = true;\n}\n\nvoid UAIThreadManager::ProcessAIBot(int32 BotID)\n{\n\t// Implement complex AI behavior processing for each bot\n\t// This is where AI logic would be processed\n}\n```"}
{"requirement": "Implement a C++ system for a path tracing renderer, offering realistic lighting and shadows.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PathTracer.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APathTracer : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPathTracer();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid TracePath();\n\tFVector TraceRay(const FVector& Origin, const FVector& Direction, int Depth);\n\tFVector ComputeLighting(const FVector& Point, const FVector& Normal);\n\n\tUPROPERTY(EditAnywhere, Category = \"Path Tracing\")\n\tint MaxDepth;\n\n\tUPROPERTY(EditAnywhere, Category = \"Path Tracing\")\n\tint SamplesPerPixel;\n\n\tUPROPERTY(EditAnywhere, Category = \"Path Tracing\")\n\tFVector LightPosition;\n};\n```", "cpp_code": "```cpp\n#include \"PathTracer.h\"\n#include \"Engine/World.h\"\n\nAPathTracer::APathTracer()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMaxDepth = 5;\n\tSamplesPerPixel = 100;\n\tLightPosition = FVector(1000.0f, 1000.0f, 2000.0f);\n}\n\nvoid APathTracer::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APathTracer::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tTracePath();\n}\n\nvoid APathTracer::TracePath()\n{\n\t// Example of path tracing logic\n\tfor (int y = 0; y < 1080; ++y)\n\t{\n\t\tfor (int x = 0; x < 1920; ++x)\n\t\t{\n\t\t\tFVector Color(0, 0, 0);\n\t\t\tfor (int s = 0; s < SamplesPerPixel; ++s)\n\t\t\t{\n\t\t\t\tFVector Origin(0, 0, 0);\n\t\t\t\tFVector Direction = FVector(x, y, 1.0f).GetSafeNormal();\n\t\t\t\tColor += TraceRay(Origin, Direction, 0);\n\t\t\t}\n\t\t\tColor /= SamplesPerPixel;\n\t\t\t// Set pixel color in your render target\n\t\t}\n\t}\n}\n\nFVector APathTracer::TraceRay(const FVector& Origin, const FVector& Direction, int Depth)\n{\n\tif (Depth >= MaxDepth) return FVector(0, 0, 0);\n\n\tFHitResult Hit;\n\tFCollisionQueryParams Params;\n\tParams.AddIgnoredActor(this);\n\n\tif (GetWorld()->LineTraceSingleByChannel(Hit, Origin, Origin + Direction * 10000.0f, ECC_Visibility, Params))\n\t{\n\t\tFVector HitPoint = Hit.ImpactPoint;\n\t\tFVector Normal = Hit.ImpactNormal;\n\t\tFVector LightIntensity = ComputeLighting(HitPoint, Normal);\n\t\treturn LightIntensity;\n\t}\n\treturn FVector(0, 0, 0);\n}\n\nFVector APathTracer::ComputeLighting(const FVector& Point, const FVector& Normal)\n{\n\tFVector LightDir = (LightPosition - Point).GetSafeNormal();\n\tfloat Diffuse = FMath::Max(FVector::DotProduct(Normal, LightDir), 0.0f);\n\treturn FVector(1, 1, 1) * Diffuse;  // Simple diffuse lighting\n}\n```"}
{"requirement": "Create a C++ component for an in-game auction house where players can buy and sell items.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"AuctionHouseComponent.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FAuctionItem\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Auction\")\n\tFString ItemName;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Auction\")\n\tint32 ItemID;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Auction\")\n\tint32 StartingBid;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Auction\")\n\tint32 CurrentBid;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Auction\")\n\tFString HighestBidder;\n};\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURGAME_API UAuctionHouseComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUAuctionHouseComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category=\"Auction\")\n\tvoid ListAuctionItem(const FAuctionItem& NewItem);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Auction\")\n\tbool PlaceBid(int32 ItemID, int32 BidAmount, const FString& BidderName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Auction\")\n\tTArray<FAuctionItem> GetAuctionItems() const;\n\nprivate:\n\tUPROPERTY()\n\tTArray<FAuctionItem> AuctionItems;\n};\n```", "cpp_code": "```cpp\n#include \"AuctionHouseComponent.h\"\n\nUAuctionHouseComponent::UAuctionHouseComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UAuctionHouseComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UAuctionHouseComponent::ListAuctionItem(const FAuctionItem& NewItem)\n{\n\tAuctionItems.Add(NewItem);\n}\n\nbool UAuctionHouseComponent::PlaceBid(int32 ItemID, int32 BidAmount, const FString& BidderName)\n{\n\tfor (FAuctionItem& Item : AuctionItems)\n\t{\n\t\tif (Item.ItemID == ItemID)\n\t\t{\n\t\t\tif (BidAmount > Item.CurrentBid)\n\t\t\t{\n\t\t\t\tItem.CurrentBid = BidAmount;\n\t\t\t\tItem.HighestBidder = BidderName;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn false;\n}\n\nTArray<FAuctionItem> UAuctionHouseComponent::GetAuctionItems() const\n{\n\treturn AuctionItems;\n}\n```"}
{"requirement": "Develop a C++ class for a modular weapon attachment system, allowing players to customize gear.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WeaponAttachmentSystem.generated.h\"\n\nUENUM(BlueprintType)\nenum class EAttachmentType : uint8 {\n\tScope UMETA(DisplayName = \"Scope\"),\n\tSilencer UMETA(DisplayName = \"Silencer\"),\n\tGrip UMETA(DisplayName = \"Grip\"),\n\tMagazine UMETA(DisplayName = \"Magazine\")\n};\n\nUSTRUCT(BlueprintType)\nstruct FAttachment {\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Attachment\")\n\tEAttachmentType AttachmentType;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Attachment\")\n\tFString Name;\n};\n\nUCLASS()\nclass AWeaponAttachmentSystem : public AActor {\n\tGENERATED_BODY()\n\npublic:\n\tAWeaponAttachmentSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Weapon\")\n\tvoid AddAttachment(const FAttachment& NewAttachment);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Weapon\")\n\tvoid RemoveAttachment(EAttachmentType AttachmentType);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Weapon\")\n\tTArray<FAttachment> GetAttachments() const;\n\nprivate:\n\tTArray<FAttachment> Attachments;\n};\n```", "cpp_code": "```cpp\n#include \"WeaponAttachmentSystem.h\"\n\nAWeaponAttachmentSystem::AWeaponAttachmentSystem() {\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AWeaponAttachmentSystem::BeginPlay() {\n\tSuper::BeginPlay();\n}\n\nvoid AWeaponAttachmentSystem::Tick(float DeltaTime) {\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AWeaponAttachmentSystem::AddAttachment(const FAttachment& NewAttachment) {\n\tAttachments.Add(NewAttachment);\n}\n\nvoid AWeaponAttachmentSystem::RemoveAttachment(EAttachmentType AttachmentType) {\n\tAttachments.RemoveAll([&](const FAttachment& Attachment) {\n\t\treturn Attachment.AttachmentType == AttachmentType;\n\t});\n}\n\nTArray<FAttachment> AWeaponAttachmentSystem::GetAttachments() const {\n\treturn Attachments;\n}\n```"}
{"requirement": "Implement a C++ system for a dynamic quest generation, creating unique missions based on player actions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"DynamicQuestSystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FQuest\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Quest\")\n\tFString QuestName;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Quest\")\n\tFString Objective;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Quest\")\n\tint32 Reward;\n};\n\nUCLASS(Blueprintable)\nclass YOURGAME_API UDynamicQuestSystem : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUDynamicQuestSystem();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Quest\")\n\tFQuest GenerateQuest(const FString& PlayerAction);\n\nprivate:\n\tFString GenerateObjective(const FString& PlayerAction);\n\tint32 CalculateReward(const FString& PlayerAction);\n};\n```", "cpp_code": "```cpp\n#include \"DynamicQuestSystem.h\"\n\nUDynamicQuestSystem::UDynamicQuestSystem()\n{\n\t// Constructor logic if needed\n}\n\nFQuest UDynamicQuestSystem::GenerateQuest(const FString& PlayerAction)\n{\n\tFQuest NewQuest;\n\tNewQuest.QuestName = TEXT(\"Dynamic Quest\");\n\tNewQuest.Objective = GenerateObjective(PlayerAction);\n\tNewQuest.Reward = CalculateReward(PlayerAction);\n\n\treturn NewQuest;\n}\n\nFString UDynamicQuestSystem::GenerateObjective(const FString& PlayerAction)\n{\n\tif (PlayerAction == TEXT(\"Explore\"))\n\t{\n\t\treturn TEXT(\"Explore the mysterious cave\");\n\t}\n\telse if (PlayerAction == TEXT(\"Fight\"))\n\t{\n\t\treturn TEXT(\"Defeat the bandit leader\");\n\t}\n\telse if (PlayerAction == TEXT(\"Collect\"))\n\t{\n\t\treturn TEXT(\"Gather 10 rare herbs\");\n\t}\n\treturn TEXT(\"Unknown objective\");\n}\n\nint32 UDynamicQuestSystem::CalculateReward(const FString& PlayerAction)\n{\n\tif (PlayerAction == TEXT(\"Explore\"))\n\t{\n\t\treturn 100;\n\t}\n\telse if (PlayerAction == TEXT(\"Fight\"))\n\t{\n\t\treturn 200;\n\t}\n\telse if (PlayerAction == TEXT(\"Collect\"))\n\t{\n\t\treturn 150;\n\t}\n\treturn 50;\n}\n```"}
{"requirement": "Create a C++ component for a real-time translation system, facilitating communication between players speaking different languages.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TranslationComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTranslationReceived, const FString&, TranslatedText);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTranslationComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUTranslationComponent();\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Translation\")\n\tFOnTranslationReceived OnTranslationReceived;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Translation\")\n\tvoid RequestTranslation(const FString& OriginalText, const FString& SourceLanguage, const FString& TargetLanguage);\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tvoid HandleTranslationResponse(const FString& TranslatedText);\n\n\t// Mock function to simulate translation. Replace with actual API call.\n\tFString MockTranslate(const FString& Text, const FString& SourceLang, const FString& TargetLang);\n};\n```", "cpp_code": "```cpp\n#include \"TranslationComponent.h\"\n#include \"Engine/World.h\"\n\nUTranslationComponent::UTranslationComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UTranslationComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UTranslationComponent::RequestTranslation(const FString& OriginalText, const FString& SourceLanguage, const FString& TargetLanguage)\n{\n\t// Simulate an asynchronous API call with a delayed response\n\tFTimerHandle UnusedHandle;\n\tGetWorld()->GetTimerManager().SetTimer(UnusedHandle, [this, OriginalText, SourceLanguage, TargetLanguage]() {\n\t\tFString TranslatedText = MockTranslate(OriginalText, SourceLanguage, TargetLanguage);\n\t\tHandleTranslationResponse(TranslatedText);\n\t}, 1.0f, false);\n}\n\nvoid UTranslationComponent::HandleTranslationResponse(const FString& TranslatedText)\n{\n\tOnTranslationReceived.Broadcast(TranslatedText);\n}\n\nFString UTranslationComponent::MockTranslate(const FString& Text, const FString& SourceLang, const FString& TargetLang)\n{\n\t// This is a mock function. Replace with actual translation logic.\n\treturn FString::Printf(TEXT(\"%s (Translated from %s to %s)\"), *Text, *SourceLang, *TargetLang);\n}\n```"}
{"requirement": "Develop a C++ class for a predictive analytics system, forecasting player behavior and preferences.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PlayerAnalyticsSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APlayerAnalyticsSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAPlayerAnalyticsSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to collect player data\n\tUFUNCTION(BlueprintCallable, Category = \"Player Analytics\")\n\tvoid CollectPlayerData();\n\n\t// Function to forecast player behavior\n\tUFUNCTION(BlueprintCallable, Category = \"Player Analytics\")\n\tFString ForecastPlayerBehavior();\n\n\t// Function to predict player preferences\n\tUFUNCTION(BlueprintCallable, Category = \"Player Analytics\")\n\tFString PredictPlayerPreferences();\n\nprivate:\n\t// Example private data members, replace with actual data structure\n\tTArray<float> PlayerActions;\n\tTArray<float> PlayerPreferences;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerAnalyticsSystem.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAPlayerAnalyticsSystem::APlayerAnalyticsSystem()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid APlayerAnalyticsSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APlayerAnalyticsSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APlayerAnalyticsSystem::CollectPlayerData()\n{\n\t// TODO: Implement data collection logic\n}\n\nFString APlayerAnalyticsSystem::ForecastPlayerBehavior()\n{\n\t// TODO: Implement predictive analysis logic for player behavior\n\treturn FString(\"Predicted Behavior\");\n}\n\nFString APlayerAnalyticsSystem::PredictPlayerPreferences()\n{\n\t// TODO: Implement predictive analysis logic for player preferences\n\treturn FString(\"Predicted Preferences\");\n}\n```"}
{"requirement": "Implement a C++ system for a scalable AI population, maintaining performance with large NPC counts.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AISystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAISystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAAISystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to initialize AI population\n\tUFUNCTION(BlueprintCallable, Category = \"AI\")\n\tvoid InitializeAIPopulation(int32 NumberOfNPCs);\n\nprivate:\n\t// Function to spawn a single NPC\n\tvoid SpawnNPC();\n\n\t// Array to store spawned NPCs\n\tTArray<AActor*> NPCs;\n\n\t// NPC class to spawn\n\tUPROPERTY(EditDefaultsOnly, Category = \"AI\")\n\tTSubclassOf<AActor> NPCClass;\n\n\t// Maximum number of active NPCs\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tint32 MaxActiveNPCs;\n\n\t// Current number of active NPCs\n\tint32 CurrentActiveNPCs;\n};\n```", "cpp_code": "```cpp\n#include \"AISystem.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nAAISystem::AAISystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMaxActiveNPCs = 100;\n\tCurrentActiveNPCs = 0;\n}\n\nvoid AAISystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAISystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Logic for managing active NPCs\n\tif (CurrentActiveNPCs < MaxActiveNPCs)\n\t{\n\t\tSpawnNPC();\n\t}\n}\n\nvoid AAISystem::InitializeAIPopulation(int32 NumberOfNPCs)\n{\n\tfor (int32 i = 0; i < NumberOfNPCs; ++i)\n\t{\n\t\tSpawnNPC();\n\t}\n}\n\nvoid AAISystem::SpawnNPC()\n{\n\tif (NPCClass && GetWorld())\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tAActor* SpawnedNPC = GetWorld()->SpawnActor<AActor>(NPCClass, FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams);\n\t\tif (SpawnedNPC)\n\t\t{\n\t\t\tNPCs.Add(SpawnedNPC);\n\t\t\t++CurrentActiveNPCs;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a C++ component for a custom save state system, allowing players to bookmark progress at any time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"SaveStateComponent.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FSaveData\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY()\n\tFVector PlayerLocation;\n\n\tUPROPERTY()\n\tFRotator PlayerRotation;\n\n\t// Add more properties as needed\n};\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURGAME_API USaveStateComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUSaveStateComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category=\"SaveState\")\n\tvoid SaveGameState();\n\n\tUFUNCTION(BlueprintCallable, Category=\"SaveState\")\n\tvoid LoadGameState();\n\nprivate:\n\tFSaveData CurrentSaveData;\n};\n```", "cpp_code": "```cpp\n#include \"SaveStateComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUSaveStateComponent::USaveStateComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid USaveStateComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid USaveStateComponent::SaveGameState()\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tCurrentSaveData.PlayerLocation = Owner->GetActorLocation();\n\t\tCurrentSaveData.PlayerRotation = Owner->GetActorRotation();\n\t\t// Save additional data as needed\n\n\t\t// You can use UGameplayStatics::SaveGameToSlot here for persistent saving\n\t}\n}\n\nvoid USaveStateComponent::LoadGameState()\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->SetActorLocation(CurrentSaveData.PlayerLocation);\n\t\tOwner->SetActorRotation(CurrentSaveData.PlayerRotation);\n\t\t// Load additional data as needed\n\n\t\t// You can use UGameplayStatics::LoadGameFromSlot here for persistent loading\n\t}\n}\n```"}
{"requirement": "Develop a C++ class for a network latency compensation system, ensuring smooth gameplay across regions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LatencyCompensationSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALatencyCompensationSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALatencyCompensationSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Simulate latency compensation for a given player\n\tvoid CompensateForLatency(AActor* PlayerActor, float LatencyInSeconds);\n\nprivate:\n\t// Store previous states of actors to interpolate between them\n\tTMap<AActor*, TArray<FTransform>> ActorStateHistory;\n\n\t// The maximum history time we want to keep\n\tfloat MaxHistoryTime;\n\n\t// Helper function to interpolate between states\n\tFTransform InterpolateTransform(const FTransform& OlderTransform, const FTransform& NewerTransform, float InterpolationFactor);\n};\n```", "cpp_code": "```cpp\n#include \"LatencyCompensationSystem.h\"\n#include \"GameFramework/Actor.h\"\n\nALatencyCompensationSystem::ALatencyCompensationSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMaxHistoryTime = 1.0f; // Keep 1 second of history\n}\n\nvoid ALatencyCompensationSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALatencyCompensationSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfor (auto& Pair : ActorStateHistory)\n\t{\n\t\tAActor* Actor = Pair.Key;\n\t\tTArray<FTransform>& History = Pair.Value;\n\n\t\t// Remove older states if they exceed the max history time\n\t\twhile (History.Num() > 0 && GetWorld()->GetTimeSeconds() - History[0].GetRotation().W > MaxHistoryTime)\n\t\t{\n\t\t\tHistory.RemoveAt(0);\n\t\t}\n\n\t\t// Add current state\n\t\tFTransform CurrentTransform = Actor->GetTransform();\n\t\tCurrentTransform.SetRotation(FQuat(GetWorld()->GetTimeSeconds(), 0.0f, 0.0f, 0.0f));\n\t\tHistory.Add(CurrentTransform);\n\t}\n}\n\nvoid ALatencyCompensationSystem::CompensateForLatency(AActor* PlayerActor, float LatencyInSeconds)\n{\n\tif (!PlayerActor || !ActorStateHistory.Contains(PlayerActor))\n\t{\n\t\treturn;\n\t}\n\n\tTArray<FTransform>& History = ActorStateHistory[PlayerActor];\n\n\tif (History.Num() < 2)\n\t{\n\t\treturn; // Not enough data to interpolate\n\t}\n\n\t// Find two closest states\n\tfor (int i = 0; i < History.Num() - 1; ++i)\n\t{\n\t\tfloat Time1 = History[i].GetRotation().W;\n\t\tfloat Time2 = History[i + 1].GetRotation().W;\n\n\t\tif (Time1 <= GetWorld()->GetTimeSeconds() - LatencyInSeconds && Time2 >= GetWorld()->GetTimeSeconds() - LatencyInSeconds)\n\t\t{\n\t\t\tfloat InterpolationFactor = (GetWorld()->GetTimeSeconds() - LatencyInSeconds - Time1) / (Time2 - Time1);\n\t\t\tFTransform CompensatedTransform = InterpolateTransform(History[i], History[i + 1], InterpolationFactor);\n\t\t\tPlayerActor->SetActorTransform(CompensatedTransform);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nFTransform ALatencyCompensationSystem::InterpolateTransform(const FTransform& OlderTransform, const FTransform& NewerTransform, float InterpolationFactor)\n{\n\tFTransform Result;\n\tResult.SetLocation(FMath::Lerp(OlderTransform.GetLocation(), NewerTransform.GetLocation(), InterpolationFactor));\n\tResult.SetRotation(FQuat::Slerp(OlderTransform.GetRotation(), NewerTransform.GetRotation(), InterpolationFactor));\n\tResult.SetScale3D(FMath::Lerp(OlderTransform.GetScale3D(), NewerTransform.GetScale3D(), InterpolationFactor));\n\treturn Result;\n}\n```"}
{"requirement": "Implement a C++ system for a narrative branching tool, enabling complex story paths and endings.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"NarrativeBranchingSystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FStoryNode\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Narrative\")\n\tFString NodeID;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Narrative\")\n\tFString NarrativeText;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Narrative\")\n\tTArray<FString> Choices;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Narrative\")\n\tTArray<FString> NextNodeIDs;\n};\n\nUCLASS(Blueprintable)\nclass YOURPROJECT_API UNarrativeBranchingSystem : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUNarrativeBranchingSystem();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Narrative\")\n\tvoid AddStoryNode(const FStoryNode& NewNode);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Narrative\")\n\tFStoryNode GetCurrentNode() const;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Narrative\")\n\tbool MakeChoice(int32 ChoiceIndex);\n\nprivate:\n\tUPROPERTY()\n\tTMap<FString, FStoryNode> StoryNodes;\n\n\tUPROPERTY()\n\tFString CurrentNodeID;\n};\n```", "cpp_code": "```cpp\n#include \"NarrativeBranchingSystem.h\"\n\nUNarrativeBranchingSystem::UNarrativeBranchingSystem()\n{\n\tCurrentNodeID = TEXT(\"\");\n}\n\nvoid UNarrativeBranchingSystem::AddStoryNode(const FStoryNode& NewNode)\n{\n\tStoryNodes.Add(NewNode.NodeID, NewNode);\n}\n\nFStoryNode UNarrativeBranchingSystem::GetCurrentNode() const\n{\n\tconst FStoryNode* Node = StoryNodes.Find(CurrentNodeID);\n\tif (Node)\n\t{\n\t\treturn *Node;\n\t}\n\treturn FStoryNode(); // Return an empty node if not found\n}\n\nbool UNarrativeBranchingSystem::MakeChoice(int32 ChoiceIndex)\n{\n\tif (const FStoryNode* CurrentNode = StoryNodes.Find(CurrentNodeID))\n\t{\n\t\tif (ChoiceIndex >= 0 && ChoiceIndex < CurrentNode->NextNodeIDs.Num())\n\t\t{\n\t\t\tCurrentNodeID = CurrentNode->NextNodeIDs[ChoiceIndex];\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n```"}
{"requirement": "Create a C++ component for a user-generated content system, allowing player-created levels and assets.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UserGeneratedContentComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API UUserGeneratedContentComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUUserGeneratedContentComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Allow players to save their created levels\n\tUFUNCTION(BlueprintCallable, Category=\"UserContent\")\n\tvoid SaveLevel(const FString& LevelName);\n\n\t// Allow players to load their created levels\n\tUFUNCTION(BlueprintCallable, Category=\"UserContent\")\n\tvoid LoadLevel(const FString& LevelName);\n\n\t// Allow players to save their created assets\n\tUFUNCTION(BlueprintCallable, Category=\"UserContent\")\n\tvoid SaveAsset(const FString& AssetName);\n\n\t// Allow players to load their created assets\n\tUFUNCTION(BlueprintCallable, Category=\"UserContent\")\n\tvoid LoadAsset(const FString& AssetName);\n\nprivate:\n\t// Helper function to handle the saving process\n\tbool SaveToFile(const FString& FileName, const FString& Content);\n\n\t// Helper function to handle the loading process\n\tbool LoadFromFile(const FString& FileName, FString& OutContent);\n};\n```", "cpp_code": "```cpp\n#include \"UserGeneratedContentComponent.h\"\n#include \"Misc/FileHelper.h\"\n#include \"Misc/Paths.h\"\n\nUUserGeneratedContentComponent::UUserGeneratedContentComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UUserGeneratedContentComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UUserGeneratedContentComponent::SaveLevel(const FString& LevelName)\n{\n\tFString LevelData = \"Level data for \" + LevelName; // Placeholder for actual level data\n\tSaveToFile(LevelName + \".lvl\", LevelData);\n}\n\nvoid UUserGeneratedContentComponent::LoadLevel(const FString& LevelName)\n{\n\tFString LoadedData;\n\tif (LoadFromFile(LevelName + \".lvl\", LoadedData))\n\t{\n\t\t// Process loaded level data\n\t}\n}\n\nvoid UUserGeneratedContentComponent::SaveAsset(const FString& AssetName)\n{\n\tFString AssetData = \"Asset data for \" + AssetName; // Placeholder for actual asset data\n\tSaveToFile(AssetName + \".asset\", AssetData);\n}\n\nvoid UUserGeneratedContentComponent::LoadAsset(const FString& AssetName)\n{\n\tFString LoadedData;\n\tif (LoadFromFile(AssetName + \".asset\", LoadedData))\n\t{\n\t\t// Process loaded asset data\n\t}\n}\n\nbool UUserGeneratedContentComponent::SaveToFile(const FString& FileName, const FString& Content)\n{\n\tFString FullPath = FPaths::ProjectSavedDir() + FileName;\n\treturn FFileHelper::SaveStringToFile(Content, *FullPath);\n}\n\nbool UUserGeneratedContentComponent::LoadFromFile(const FString& FileName, FString& OutContent)\n{\n\tFString FullPath = FPaths::ProjectSavedDir() + FileName;\n\treturn FFileHelper::LoadFileToString(OutContent, *FullPath);\n}\n```"}
{"requirement": "Create an actor class with a static mesh component and set its mesh in the constructor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"StaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAStaticMeshActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"StaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAStaticMeshActor::AStaticMeshActor()\n{\n\t// Initialize the Static Mesh Component\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Set the static mesh for the component\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n```"}
{"requirement": "Implement an actor that moves forward constantly each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementSpeed = 100.0f; // default speed\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation() + (GetActorForwardVector() * MovementSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that rotates around its own axis on Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Rotation speed in degrees per second\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize rotation speed\n\tRotationSpeed = 45.0f; // default rotation speed in degrees per second\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate rotation for this frame\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\n\t// Apply rotation\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to allow the speed of an actor to be adjusted in the editor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedAdjustableActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASpeedAdjustableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedAdjustableActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat Speed;\n\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedAdjustableActor.h\"\n\nASpeedAdjustableActor::ASpeedAdjustableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSpeed = 100.0f; // Default speed value\n}\n\nvoid ASpeedAdjustableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpeedAdjustableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Example usage of Speed\n\tFVector NewLocation = GetActorLocation() + FVector(Speed * DeltaTime, 0, 0);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Bind the 'V' key to a function that prints 'Hello Unreal!' to the screen.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintHelloActor.generated.h\"\n\nUCLASS()\nclass APrintHelloActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPrintHelloActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid PrintHelloUnreal();\n};\n```", "cpp_code": "```cpp\n#include \"PrintHelloActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nAPrintHelloActor::APrintHelloActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APrintHelloActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APrintHelloActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APrintHelloActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"PrintHello\", IE_Pressed, this, &APrintHelloActor::PrintHelloUnreal);\n}\n\nvoid APrintHelloActor::PrintHelloUnreal()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Hello Unreal!\"));\n\t}\n}\n```"}
{"requirement": "Implement a component with a float property exposed to Blueprints called 'MovementSpeed'.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UMovementSpeedComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UMovementSpeedComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUMovementSpeedComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"UMovementSpeedComponent.h\"\n\nUMovementSpeedComponent::UMovementSpeedComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tMovementSpeed = 600.0f;  // Default value\n}\n\nvoid UMovementSpeedComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate that broadcasts when an actor is destroyed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ActorDestroyedNotifier.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnActorDestroyed);\n\nUCLASS()\nclass YOURPROJECT_API AActorDestroyedNotifier : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAActorDestroyedNotifier();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\npublic:\n\tUPROPERTY(BlueprintAssignable, Category = \"Events\")\n\tFOnActorDestroyed OnActorDestroyed;\n};\n```", "cpp_code": "```cpp\n#include \"ActorDestroyedNotifier.h\"\n\nAActorDestroyedNotifier::AActorDestroyedNotifier()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AActorDestroyedNotifier::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AActorDestroyedNotifier::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tif (EndPlayReason == EEndPlayReason::Destroyed)\n\t{\n\t\tOnActorDestroyed.Broadcast();\n\t}\n\tSuper::EndPlay(EndPlayReason);\n}\n```"}
{"requirement": "Load a static mesh asset using ConstructorHelpers in the constructor of an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAMyStaticMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Mesh\")\n\tUStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a StaticMeshComponent\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Load a static mesh asset\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/MeshAsset.MeshAsset\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyStaticMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a component that prints a log message when an actor overlaps with it using OnBeginOverlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"OverlapLoggerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UOverlapLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUOverlapLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION()\n\tvoid OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUOverlapLoggerComponent::UOverlapLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UOverlapLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->OnActorBeginOverlap.AddDynamic(this, &UOverlapLoggerComponent::OnBeginOverlap);\n\t}\n}\n\nvoid UOverlapLoggerComponent::OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && OtherActor != OverlappedActor)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s overlapped with %s\"), *OverlappedActor->GetName(), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Implement an actor that scales uniformly over time each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScalingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Scale factor per second\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tfloat ScaleFactorPerSecond;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n\n// Sets default values\nAScalingActor::AScalingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the scale factor\n\tScaleFactorPerSecond = 0.1f; // Example scale factor\n}\n\n// Called when the game starts or when spawned\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate new scale\n\tFVector NewScale = GetActorScale3D() * (1.0f + ScaleFactorPerSecond * DeltaTime);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Add a UPROPERTY with ClampMin metadata to limit a variable to positive values only.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PositiveValueActor.generated.h\"\n\nUCLASS()\nclass APositiveValueActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPositiveValueActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Positive Value\", meta=(ClampMin=\"0.0\"))\n\tfloat PositiveValue;\n};\n```", "cpp_code": "```cpp\n#include \"PositiveValueActor.h\"\n\nAPositiveValueActor::APositiveValueActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tPositiveValue = 1.0f; // Default positive value\n}\n```"}
{"requirement": "Bind the 'Space' key to toggle visibility of an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleVisibilityActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid ToggleVisibility();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/InputSettings.h\"\n\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleVisibilityActor::ToggleVisibility);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tif (MeshComponent)\n\t{\n\t\tbool bIsVisible = MeshComponent->IsVisible();\n\t\tMeshComponent->SetVisibility(!bIsVisible);\n\t}\n}\n```"}
{"requirement": "Create an actor with a collision component that reacts to OnBeginOverlap by changing color.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionColorChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionColorChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionColorChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\t\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* CollisionComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACollisionColorChangeActor::ACollisionColorChangeActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Create the collision component\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tCollisionComponent->SetupAttachment(RootComponent);\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionColorChangeActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionColorChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionColorChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionColorChangeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", FLinearColor::MakeRandomColor());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Expose a boolean UPROPERTY to Blueprints that controls whether an actor rotates on Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Rotation\")\n\tbool bShouldRotate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tbShouldRotate = true;\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bShouldRotate)\n\t{\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Yaw += DeltaTime * 45.0f; // Rotate 45 degrees per second\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Implement a component that triggers a sound when an actor overlaps with it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Sound/SoundBase.h\"\n#include \"UTriggerSoundComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UTriggerSoundComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUTriggerSoundComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called when an actor overlaps with the component\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);\n\n\t// Sound to play on overlap\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* OverlapSound;\n\n};\n```", "cpp_code": "```cpp\n#include \"UTriggerSoundComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUTriggerSoundComponent::UTriggerSoundComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UTriggerSoundComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->OnActorBeginOverlap.AddDynamic(this, &UTriggerSoundComponent::OnOverlapBegin);\n\t}\n}\n\nvoid UTriggerSoundComponent::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OverlapSound && OtherActor != GetOwner())\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, OverlapSound, GetOwner()->GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Bind the 'P' key to pause and resume Tick-based movement of an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PauseableActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API APauseableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPauseableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tbool bIsPaused;\n\n\tvoid TogglePause();\n};\n```", "cpp_code": "```cpp\n#include \"PauseableActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAPauseableActor::APauseableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsPaused = false;\n}\n\nvoid APauseableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APauseableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!bIsPaused)\n\t{\n\t\t// Place movement logic here\n\t}\n}\n\nvoid APauseableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"TogglePause\", IE_Pressed, this, &APauseableActor::TogglePause);\n}\n\nvoid APauseableActor::TogglePause()\n{\n\tbIsPaused = !bIsPaused;\n}\n```"}
{"requirement": "Create an actor that increases its size incrementally when the 'G' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"IncrementalSizeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AIncrementalSizeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAIncrementalSizeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to increase the size\n\tvoid IncreaseSize();\n\n\t// Static Mesh Component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Scale increment value\n\tUPROPERTY(EditAnywhere)\n\tFVector ScaleIncrement;\n};\n```", "cpp_code": "```cpp\n#include \"IncrementalSizeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAIncrementalSizeActor::AIncrementalSizeActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach the static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set default scale increment\n\tScaleIncrement = FVector(0.1f, 0.1f, 0.1f);\n}\n\n// Called when the game starts or when spawned\nvoid AIncrementalSizeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AIncrementalSizeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input\nvoid AIncrementalSizeActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the IncreaseSize function to the 'G' key\n\tPlayerInputComponent->BindAction(\"IncreaseSize\", IE_Pressed, this, &AIncrementalSizeActor::IncreaseSize);\n}\n\n// Function to increase the size\nvoid AIncrementalSizeActor::IncreaseSize()\n{\n\tFVector NewScale = GetActorScale3D() + ScaleIncrement;\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Implement an actor that changes its material when overlapping with another specific actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMaterialChangingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyMaterialChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyMaterialChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(EditAnywhere)\n\tTSubclassOf<AActor> SpecificActorClass;\n};\n```", "cpp_code": "```cpp\n#include \"MyMaterialChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyMaterialChangingActor::AMyMaterialChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyMaterialChangingActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AMyMaterialChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyMaterialChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyMaterialChangingActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor->IsA(SpecificActorClass))\n\t{\n\t\tif (NewMaterial)\n\t\t{\n\t\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up a UFUNCTION that prints the position of an actor each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PositionPrinterActor.generated.h\"\n\nUCLASS()\nclass APositionPrinterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPositionPrinterActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid PrintPosition();\n};\n```", "cpp_code": "```cpp\n#include \"PositionPrinterActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\nAPositionPrinterActor::APositionPrinterActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APositionPrinterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APositionPrinterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tPrintPosition();\n}\n\nvoid APositionPrinterActor::PrintPosition()\n{\n\tif (GEngine)\n\t{\n\t\tFVector ActorLocation = GetActorLocation();\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Actor Position: %s\"), *ActorLocation.ToString()));\n\t}\n}\n```"}
{"requirement": "Create a component with a UPROPERTY that can be edited in the Blueprint editor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UCustomComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUCustomComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Custom\")\n\tfloat CustomFloat;\n};\n```", "cpp_code": "```cpp\n#include \"UCustomComponent.h\"\n\n// Sets default values for this component's properties\nUCustomComponent::UCustomComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\t// Initialize default value\n\tCustomFloat = 0.0f;\n}\n\n// Called when the game starts\nvoid UCustomComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// ...\n}\n\n// Called every frame\nvoid UCustomComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// ...\n}\n```"}
{"requirement": "Bind a function to the 'R' key that resets an actor's position to a start location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetPositionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetPositionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResetPositionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tFVector StartLocation;\n\n\tvoid ResetPosition();\n};\n```", "cpp_code": "```cpp\n#include \"ResetPositionActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAResetPositionActor::AResetPositionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetPositionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartLocation = GetActorLocation();\n}\n\nvoid AResetPositionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetPositionActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetPosition\", IE_Pressed, this, &AResetPositionActor::ResetPosition);\n}\n\nvoid AResetPositionActor::ResetPosition()\n{\n\tSetActorLocation(StartLocation);\n}\n```"}
{"requirement": "Implement an actor that toggles between two materials each time it's clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAToggleMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Materials\")\n\tUMaterialInterface* MaterialOne;\n\n\tUPROPERTY(EditAnywhere, Category = \"Materials\")\n\tUMaterialInterface* MaterialTwo;\n\n\tUFUNCTION()\n\tvoid OnMeshClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed);\n\n\tbool bUseMaterialOne;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAToggleMaterialActor::AToggleMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnClicked.AddDynamic(this, &AToggleMaterialActor::OnMeshClicked);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/Path/To/Your/Mesh.YourMesh'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tbUseMaterialOne = true;\n}\n\nvoid AToggleMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MaterialOne && MaterialTwo)\n\t{\n\t\tMeshComponent->SetMaterial(0, MaterialOne);\n\t}\n}\n\nvoid AToggleMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleMaterialActor::OnMeshClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed)\n{\n\tif (MaterialOne && MaterialTwo)\n\t{\n\t\tbUseMaterialOne = !bUseMaterialOne;\n\t\tUMaterialInterface* CurrentMaterial = bUseMaterialOne ? MaterialOne : MaterialTwo;\n\t\tMeshComponent->SetMaterial(0, CurrentMaterial);\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere for a color property and change material color on Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAChangeColorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tFLinearColor Color;\n\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAChangeColorActor::AChangeColorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tColor = FLinearColor::White; // Default color\n}\n\nvoid AChangeColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* MaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (MaterialInstance)\n\t\t{\n\t\t\tMaterialInstance->SetVectorParameterValue(FName(\"BaseColor\"), Color);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a component that rotates the owner actor around a point set in UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"URotationAroundPointComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API URotationAroundPointComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tURotationAroundPointComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tFVector RotationPoint;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"URotationAroundPointComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nURotationAroundPointComponent::URotationAroundPointComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tRotationSpeed = 45.0f; // Default rotation speed in degrees per second\n}\n\nvoid URotationAroundPointComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotationAroundPointComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector OwnerLocation = Owner->GetActorLocation();\n\t\tFVector Direction = OwnerLocation - RotationPoint;\n\t\tDirection = Direction.RotateAngleAxis(RotationSpeed * DeltaTime, FVector::UpVector);\n\t\tFVector NewLocation = RotationPoint + Direction;\n\t\tOwner->SetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Load a texture using ConstructorHelpers and apply it to an actor's material in the constructor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UTextureLoaderActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AUTextureLoaderActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tAUTextureLoaderActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"UTextureLoaderActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/Texture2D.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nAUTextureLoaderActor::AUTextureLoaderActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UTexture2D> TextureAsset(TEXT(\"/Game/Path/To/Your/Texture.Texture\"));\n\tif (TextureAsset.Succeeded())\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tDynamicMaterial->SetTextureParameterValue(FName(\"YourTextureParameterName\"), TextureAsset.Object);\n\t\t\tMeshComponent->SetMaterial(0, DynamicMaterial);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that prints its current velocity to the screen each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VelocityPrinterActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVelocityPrinterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAVelocityPrinterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"VelocityPrinterActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAVelocityPrinterActor::AVelocityPrinterActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AVelocityPrinterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AVelocityPrinterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector Velocity = GetVelocity();\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Velocity: %s\"), *Velocity.ToString()));\n\t}\n}\n```"}
{"requirement": "Implement a component that doubles an actor's speed when a specific button is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"USpeedBoostComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API USpeedBoostComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUSpeedBoostComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvoid DoubleSpeed();\n\tvoid ResetSpeed();\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat SpeedMultiplier;\n\n\tUPROPERTY()\n\tbool bIsSpeedBoosted;\n\n\tUPROPERTY()\n\tfloat OriginalSpeed;\n\n\tUFUNCTION()\n\tvoid HandleSpeedBoostInput();\n};\n```", "cpp_code": "```cpp\n#include \"USpeedBoostComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nUSpeedBoostComponent::USpeedBoostComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tSpeedMultiplier = 2.0f;\n\tbIsSpeedBoosted = false;\n}\n\nvoid USpeedBoostComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUInputComponent* InputComponent = Owner->FindComponentByClass<UInputComponent>();\n\t\tif (InputComponent)\n\t\t{\n\t\t\tInputComponent->BindAction(\"SpeedBoost\", IE_Pressed, this, &USpeedBoostComponent::HandleSpeedBoostInput);\n\t\t}\n\t}\n}\n\nvoid USpeedBoostComponent::DoubleSpeed()\n{\n\tif (ACharacter* Character = Cast<ACharacter>(GetOwner()))\n\t{\n\t\tUCharacterMovementComponent* MovementComponent = Character->GetCharacterMovement();\n\t\tif (MovementComponent && !bIsSpeedBoosted)\n\t\t{\n\t\t\tOriginalSpeed = MovementComponent->MaxWalkSpeed;\n\t\t\tMovementComponent->MaxWalkSpeed *= SpeedMultiplier;\n\t\t\tbIsSpeedBoosted = true;\n\t\t}\n\t}\n}\n\nvoid USpeedBoostComponent::ResetSpeed()\n{\n\tif (ACharacter* Character = Cast<ACharacter>(GetOwner()))\n\t{\n\t\tUCharacterMovementComponent* MovementComponent = Character->GetCharacterMovement();\n\t\tif (MovementComponent && bIsSpeedBoosted)\n\t\t{\n\t\t\tMovementComponent->MaxWalkSpeed = OriginalSpeed;\n\t\t\tbIsSpeedBoosted = false;\n\t\t}\n\t}\n}\n\nvoid USpeedBoostComponent::HandleSpeedBoostInput()\n{\n\tif (bIsSpeedBoosted)\n\t{\n\t\tResetSpeed();\n\t}\n\telse\n\t{\n\t\tDoubleSpeed();\n\t}\n}\n```"}
{"requirement": "Bind the 'L' key to a function that logs all overlapping actors.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogOverlappingActors.generated.h\"\n\nUCLASS()\nclass ALogOverlappingActors : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALogOverlappingActors();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid LogOverlappingActors();\n};\n```", "cpp_code": "```cpp\n#include \"LogOverlappingActors.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nALogOverlappingActors::ALogOverlappingActors()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALogOverlappingActors::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALogOverlappingActors::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"LogOverlappingActors\", IE_Pressed, this, &ALogOverlappingActors::LogOverlappingActors);\n}\n\nvoid ALogOverlappingActors::LogOverlappingActors()\n{\n\tTArray<AActor*> OverlappingActors;\n\tGetOverlappingActors(OverlappingActors);\n\tfor (AActor* Actor : OverlappingActors)\n\t{\n\t\tif (Actor)\n\t\t{\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Overlapping Actor: %s\"), *Actor->GetName());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a particle system that activates on BeginPlay.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"MyParticleActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyParticleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyParticleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUParticleSystemComponent* ParticleSystemComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyParticleActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyParticleActor::AMyParticleActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystemComponent\"));\n\tRootComponent = ParticleSystemComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UParticleSystem> ParticleAsset(TEXT(\"/Game/Particles/MyParticleSystem.MyParticleSystem\"));\n\tif (ParticleAsset.Succeeded())\n\t{\n\t\tParticleSystemComponent->SetTemplate(ParticleAsset.Object);\n\t}\n}\n\nvoid AMyParticleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (ParticleSystemComponent)\n\t{\n\t\tParticleSystemComponent->Activate();\n\t}\n}\n```"}
{"requirement": "Implement an actor that changes its rotation direction when the 'F' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed;\n\n\tbool bRotateClockwise;\n\n\tvoid ToggleRotationDirection();\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"ConstructorHelpers.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/Path/To/Your/Mesh.Mesh'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRotationSpeed = 90.0f;\n\tbRotateClockwise = true;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat RotationDirection = bRotateClockwise ? 1.0f : -1.0f;\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * RotationDirection * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n\nvoid ARotatingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleRotation\", IE_Pressed, this, &ARotatingActor::ToggleRotationDirection);\n}\n\nvoid ARotatingActor::ToggleRotationDirection()\n{\n\tbRotateClockwise = !bRotateClockwise;\n}\n```"}
{"requirement": "Create a static mesh actor and set it to be hidden in game via a UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyStaticMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Mesh\")\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Visibility\")\n\tbool bHiddenInGame;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Set default visibility\n\tbHiddenInGame = true;\n\tStaticMeshComponent->SetHiddenInGame(bHiddenInGame);\n\n\t// Example of setting a static mesh (optional)\n\t// ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\t// if (MeshAsset.Succeeded())\n\t// {\n\t//\t StaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t// }\n}\n\n// Called when the game starts or when spawned\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tStaticMeshComponent->SetHiddenInGame(bHiddenInGame);\n}\n\n// Called every frame\nvoid AMyStaticMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a component that changes the scale of an actor over time based on a UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleChangerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UScaleChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUScaleChangerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Scale\")\n\tFVector TargetScale;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Scale\")\n\tfloat ScaleSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUScaleChangerComponent::UScaleChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTargetScale = FVector(1.0f, 1.0f, 1.0f);\n\tScaleSpeed = 1.0f;\n}\n\nvoid UScaleChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UScaleChangerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector CurrentScale = Owner->GetActorScale3D();\n\t\tFVector NewScale = FMath::VInterpTo(CurrentScale, TargetScale, DeltaTime, ScaleSpeed);\n\t\tOwner->SetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Bind the 'Q' key to a function that quits the game.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"UQuitGamePawn.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AUQuitGamePawn : public APawn\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this pawn's properties\n\tAUQuitGamePawn();\n\nprotected:\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to quit the game\n\tvoid QuitGame();\n};\n```", "cpp_code": "```cpp\n#include \"UQuitGamePawn.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAUQuitGamePawn::AUQuitGamePawn()\n{\n\t// Set this pawn to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AUQuitGamePawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the QuitGame function to the 'Q' key\n\tPlayerInputComponent->BindAction(\"QuitGame\", IE_Pressed, this, &AUQuitGamePawn::QuitGame);\n}\n\nvoid AUQuitGamePawn::QuitGame()\n{\n\tif (APlayerController* PC = UGameplayStatics::GetPlayerController(GetWorld(), 0))\n\t{\n\t\tPC->ConsoleCommand(\"quit\");\n\t}\n}\n```"}
{"requirement": "Implement an actor that plays a sound on BeginOverlap and stops it on EndOverlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"ASoundOverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUAudioComponent* AudioComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUSoundCue* OverlapSoundCue;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n};\n```", "cpp_code": "```cpp\n#include \"ASoundOverlapActor.h\"\n#include \"Components/BoxComponent.h\"\n\nASoundOverlapActor::ASoundOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tUBoxComponent* BoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tRootComponent = BoxComponent;\n\n\tBoxComponent->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tBoxComponent->SetCollisionResponseToAllChannels(ECR_Overlap);\n\n\tBoxComponent->OnComponentBeginOverlap.AddDynamic(this, &ASoundOverlapActor::OnOverlapBegin);\n\tBoxComponent->OnComponentEndOverlap.AddDynamic(this, &ASoundOverlapActor::OnOverlapEnd);\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n}\n\nvoid ASoundOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OverlapSoundCue && !AudioComponent->IsPlaying())\n\t{\n\t\tAudioComponent->SetSound(OverlapSoundCue);\n\t\tAudioComponent->Play();\n\t}\n}\n\nvoid ASoundOverlapActor::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (AudioComponent->IsPlaying())\n\t{\n\t\tAudioComponent->Stop();\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere for an integer variable and use it to limit movement speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourGameActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AYourGameActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAYourGameActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tint32 MaxMovementSpeed;\n\n\tvoid MoveForward(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"YourGameActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\nAYourGameActor::AYourGameActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMaxMovementSpeed = 600; // Default value\n}\n\nvoid AYourGameActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourGameActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AYourGameActor::MoveForward(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tFVector Direction = FVector::ForwardVector;\n\t\tFVector NewLocation = GetActorLocation() + Direction * FMath::Clamp(Value, -1.0f, 1.0f) * MaxMovementSpeed * GetWorld()->GetDeltaSeconds();\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n\nvoid AYourGameActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &AYourGameActor::MoveForward);\n}\n```"}
{"requirement": "Create an actor with a timer that prints a message every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"MessagePrinterActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMessagePrinterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMessagePrinterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\t// Timer handle for managing the timer\n\tFTimerHandle TimerHandle;\n\n\t// Function to be called every second by the timer\n\tvoid PrintMessage();\n};\n```", "cpp_code": "```cpp\n#include \"MessagePrinterActor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nAMessagePrinterActor::AMessagePrinterActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid AMessagePrinterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Set the timer to call PrintMessage every 1 second\n\tGetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &AMessagePrinterActor::PrintMessage, 1.0f, true);\n}\n\n// Function to print a message every second\nvoid AMessagePrinterActor::PrintMessage()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"This message is printed every second.\"));\n}\n```"}
{"requirement": "Bind the 'O' key to a function that toggles an actor's physics simulation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TogglePhysicsActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATogglePhysicsActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATogglePhysicsActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid TogglePhysics();\n};\n```", "cpp_code": "```cpp\n#include \"TogglePhysicsActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerInput.h\"\n\nATogglePhysicsActor::ATogglePhysicsActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetSimulatePhysics(false);\n}\n\nvoid ATogglePhysicsActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATogglePhysicsActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"TogglePhysics\", IE_Pressed, this, &ATogglePhysicsActor::TogglePhysics);\n\t}\n}\n\nvoid ATogglePhysicsActor::TogglePhysics()\n{\n\tif (MeshComponent)\n\t{\n\t\tbool bIsSimulating = MeshComponent->IsSimulatingPhysics();\n\t\tMeshComponent->SetSimulatePhysics(!bIsSimulating);\n\t}\n}\n```"}
{"requirement": "Implement a component that adds a force to an actor each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UForceAdderComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UForceAdderComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUForceAdderComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tFVector ForceToAdd;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"UForceAdderComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nUForceAdderComponent::UForceAdderComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tForceToAdd = FVector(1000.f, 0.f, 0.f); // Default force value\n}\n\nvoid UForceAdderComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tMeshComponent = GetOwner()->FindComponentByClass<UStaticMeshComponent>();\n\tif (!MeshComponent)\n\t{\n\t\tUE_LOG(LogTemp, Error, TEXT(\"No static mesh component found on %s\"), *GetOwner()->GetName());\n\t}\n}\n\nvoid UForceAdderComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (MeshComponent)\n\t{\n\t\tMeshComponent->AddForce(ForceToAdd);\n\t}\n}\n```"}
{"requirement": "Create an actor that changes its mesh when a specific UFUNCTION is called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MeshChangerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMeshChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMeshChangerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Mesh\")\n\tvoid ChangeMesh();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMesh* NewMesh;\n};\n```", "cpp_code": "```cpp\n#include \"MeshChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMeshChangerActor::AMeshChangerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Example of setting a default mesh, replace with your asset path\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> DefaultMesh(TEXT(\"/Game/Path/To/Your/DefaultMesh.DefaultMesh\"));\n\tif (DefaultMesh.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(DefaultMesh.Object);\n\t}\n}\n\nvoid AMeshChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMeshChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMeshChangerActor::ChangeMesh()\n{\n\tif (NewMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(NewMesh);\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with metadata to ensure a variable is only visible in Blueprint.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tUPROPERTY(BlueprintReadOnly, meta=(AllowPrivateAccess=\"true\"))\n\tint32 MyVariable;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\t// Initialize variable if needed\n\tMyVariable = 0;\n}\n```"}
{"requirement": "Implement an actor that spawns another actor when a specific key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpawnActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpawnActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpawnActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to spawn the actor\n\tvoid SpawnAnotherActor();\n\n\t// Setup player input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// The class of actor to spawn\n\tUPROPERTY(EditAnywhere, Category=\"Spawning\")\n\tTSubclassOf<AActor> ActorToSpawn;\n};\n```", "cpp_code": "```cpp\n#include \"SpawnActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASpawnActor::ASpawnActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASpawnActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpawnActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpawnActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the input action to spawn the actor when the \"SpawnKey\" is pressed\n\tPlayerInputComponent->BindAction(\"SpawnKey\", IE_Pressed, this, &ASpawnActor::SpawnAnotherActor);\n}\n\nvoid ASpawnActor::SpawnAnotherActor()\n{\n\tif (ActorToSpawn)\n\t{\n\t\tUWorld* World = GetWorld();\n\t\tif (World)\n\t\t{\n\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\tSpawnParams.Owner = this;\n\t\t\tSpawnParams.Instigator = GetInstigator();\n\n\t\t\t// Get the location and rotation of the current actor\n\t\t\tFVector SpawnLocation = GetActorLocation();\n\t\t\tFRotator SpawnRotation = GetActorRotation();\n\n\t\t\t// Spawn the actor\n\t\t\tWorld->SpawnActor<AActor>(ActorToSpawn, SpawnLocation, SpawnRotation, SpawnParams);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a light component that toggles on and off with the 'B' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"ToggleLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleLightActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AToggleLightActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\n  virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n  UPROPERTY(VisibleAnywhere, Category = \"Light\")\n  UPointLightComponent* PointLight;\n\n  void ToggleLight();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleLightActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAToggleLightActor::AToggleLightActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n\n  PointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n  RootComponent = PointLight;\n\n  PointLight->SetVisibility(false);\n}\n\nvoid AToggleLightActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AToggleLightActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AToggleLightActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n  Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n  if (PlayerInputComponent)\n  {\n\tPlayerInputComponent->BindAction(\"ToggleLight\", IE_Pressed, this, &AToggleLightActor::ToggleLight);\n  }\n}\n\nvoid AToggleLightActor::ToggleLight()\n{\n  if (PointLight)\n  {\n\tPointLight->ToggleVisibility();\n  }\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere for a timer duration and print a message when it expires.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"ATimerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATimerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATimerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Timer\")\n\tfloat TimerDuration;\n\n\tFTimerHandle TimerHandle;\n\n\tvoid OnTimerExpire();\n};\n```", "cpp_code": "```cpp\n#include \"ATimerActor.h\"\n#include \"Engine/World.h\"\n\nATimerActor::ATimerActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tTimerDuration = 5.0f; // Default value\n}\n\nvoid ATimerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &ATimerActor::OnTimerExpire, TimerDuration, false);\n}\n\nvoid ATimerActor::OnTimerExpire()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Timer expired!\"));\n}\n```"}
{"requirement": "Bind the 'M' key to a function that changes the material of an actor to a random color.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARandomColorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ChangeMaterialColor();\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"RandomColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Components/InputComponent.h\"\n\nARandomColorActor::ARandomColorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tDynamicMaterialInstance = nullptr;\n}\n\nvoid ARandomColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MeshComponent && MeshComponent->GetMaterial(0))\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\nvoid ARandomColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARandomColorActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ChangeColor\", IE_Pressed, this, &ARandomColorActor::ChangeMaterialColor);\n}\n\nvoid ARandomColorActor::ChangeMaterialColor()\n{\n\tif (DynamicMaterialInstance)\n\t{\n\t\tFLinearColor RandomColor = FLinearColor::MakeRandomColor();\n\t\tDynamicMaterialInstance->SetVectorParameterValue(\"BaseColor\", RandomColor);\n\t}\n}\n```"}
{"requirement": "Implement a component that prints a message each time an actor enters its collision box.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UCollisionMessageComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCollisionMessageComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUCollisionMessageComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUPROPERTY()\n\tclass UBoxComponent* CollisionBox;\n};\n```", "cpp_code": "```cpp\n#include \"UCollisionMessageComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUCollisionMessageComponent::UCollisionMessageComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\tCollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionBox\"));\n\tCollisionBox->SetupAttachment(this);\n\tCollisionBox->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tCollisionBox->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap);\n\tCollisionBox->OnComponentBeginOverlap.AddDynamic(this, &UCollisionMessageComponent::OnOverlapBegin);\n}\n\nvoid UCollisionMessageComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCollisionMessageComponent::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && OtherActor != GetOwner())\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Actor %s has entered the collision box.\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Load a sound asset using ConstructorHelpers and play it when a function is called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Sound/SoundWave.h\"\n#include \"ASoundPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tASoundPlayerActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Sound\")\n\tvoid PlaySound();\n\nprotected:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"ASoundPlayerActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"ConstructorHelpers.h\"\n\nASoundPlayerActor::ASoundPlayerActor()\n{\n\tstatic ConstructorHelpers::FObjectFinder<USoundBase> SoundAsset(TEXT(\"/Game/Audio/YourSoundCue.YourSoundCue\"));\n\tif (SoundAsset.Succeeded())\n\t{\n\t\tSoundToPlay = SoundAsset.Object;\n\t}\n\telse\n\t{\n\t\tSoundToPlay = nullptr;\n\t}\n}\n\nvoid ASoundPlayerActor::PlaySound()\n{\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create an actor that moves along a spline path each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SplineComponent.h\"\n#include \"SplinePathMover.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASplinePathMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASplinePathMover();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUSplineComponent* SplineComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat Speed;\n\n\tfloat DistanceTraveled;\n};\n```", "cpp_code": "```cpp\n#include \"SplinePathMover.h\"\n#include \"Components/SplineComponent.h\"\n\nASplinePathMover::ASplinePathMover()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSplineComponent = CreateDefaultSubobject<USplineComponent>(TEXT(\"SplineComponent\"));\n\tRootComponent = SplineComponent;\n\n\tSpeed = 100.0f;\n\tDistanceTraveled = 0.0f;\n}\n\nvoid ASplinePathMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASplinePathMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tDistanceTraveled += Speed * DeltaTime;\n\tfloat SplineLength = SplineComponent->GetSplineLength();\n\tFVector NewLocation = SplineComponent->GetLocationAtDistanceAlongSpline(fmod(DistanceTraveled, SplineLength), ESplineCoordinateSpace::World);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Add a UPROPERTY editable in Blueprint for a multiplier affecting an actor's rotation speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotationSpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotationSpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tARotationSpeedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Rotation\")\n\tfloat RotationSpeedMultiplier;\n};\n```", "cpp_code": "```cpp\n#include \"RotationSpeedActor.h\"\n\nARotationSpeedActor::ARotationSpeedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeedMultiplier = 1.0f; // Default value\n}\n\nvoid ARotationSpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotationSpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\t// Example usage: rotate actor based on multiplier\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeedMultiplier * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement an actor that rotates its mesh based on mouse movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseRotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMouseRotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMouseRotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// The static mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Mouse input functions\n\tvoid RotateMesh(float AxisValue);\n\n\t// Rotation speed\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MouseRotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAMouseRotatingActor::AMouseRotatingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Set default rotation speed\n\tRotationSpeed = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMouseRotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMouseRotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid AMouseRotatingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"Turn\", this, &AMouseRotatingActor::RotateMesh);\n}\n\n// Rotate the mesh based on mouse input\nvoid AMouseRotatingActor::RotateMesh(float AxisValue)\n{\n\tFRotator NewRotation = MeshComponent->GetComponentRotation();\n\tNewRotation.Yaw += AxisValue * RotationSpeed * GetWorld()->GetDeltaSeconds();\n\tMeshComponent->SetWorldRotation(NewRotation);\n}\n```"}
{"requirement": "Create a component that logs when an actor reaches a specific location in the world.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULocationLoggerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API ULocationLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tULocationLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFVector TargetLocation;\n\tfloat Tolerance;\n\n\tvoid CheckLocation();\n};\n```", "cpp_code": "```cpp\n#include \"ULocationLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nULocationLoggerComponent::ULocationLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tTargetLocation = FVector(0.0f, 0.0f, 0.0f);\n\tTolerance = 100.0f; // 100 units tolerance\n}\n\nvoid ULocationLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ULocationLoggerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tCheckLocation();\n}\n\nvoid ULocationLoggerComponent::CheckLocation()\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tFVector CurrentLocation = Owner->GetActorLocation();\n\t\tif (FVector::Dist(CurrentLocation, TargetLocation) <= Tolerance)\n\t\t{\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s has reached the target location!\"), *Owner->GetName());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Bind the 'I' key to a function that inverts the direction of an actor's movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InvertMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AInvertMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAInvertMovementActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid InvertMovementDirection();\n\n\tFVector MovementDirection;\n};\n```", "cpp_code": "```cpp\n#include \"InvertMovementActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAInvertMovementActor::AInvertMovementActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default movement direction\n\tMovementDirection = FVector(1.0f, 0.0f, 0.0f);\n}\n\nvoid AInvertMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AInvertMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Move the actor in the current movement direction\n\tAddActorWorldOffset(MovementDirection * DeltaTime);\n}\n\nvoid AInvertMovementActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the 'I' key to the InvertMovementDirection function\n\tPlayerInputComponent->BindAction(\"InvertDirection\", IE_Pressed, this, &AInvertMovementActor::InvertMovementDirection);\n}\n\nvoid AInvertMovementActor::InvertMovementDirection()\n{\n\tMovementDirection *= -1.0f;\n}\n```"}
{"requirement": "Create an actor with a UPROPERTY to toggle between two movement modes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovementModeActor.generated.h\"\n\nUENUM(BlueprintType)\nenum class EMovementMode : uint8 {\n\tWalking UMETA(DisplayName = \"Walking\"),\n\tRunning UMETA(DisplayName = \"Running\")\n};\n\nUCLASS()\nclass YOURPROJECT_API AMovementModeActor : public AActor {\n\tGENERATED_BODY()\n\npublic:\n\tAMovementModeActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Movement\")\n\tEMovementMode MovementMode;\n};\n```", "cpp_code": "```cpp\n#include \"MovementModeActor.h\"\n\nAMovementModeActor::AMovementModeActor() {\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementMode = EMovementMode::Walking;\n}\n\nvoid AMovementModeActor::BeginPlay() {\n\tSuper::BeginPlay();\n}\n\nvoid AMovementModeActor::Tick(float DeltaTime) {\n\tSuper::Tick(DeltaTime);\n\t\n\tswitch (MovementMode) {\n\t\tcase EMovementMode::Walking:\n\t\t\t// Implement walking behavior here\n\t\t\tbreak;\n\t\tcase EMovementMode::Running:\n\t\t\t// Implement running behavior here\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n```"}
{"requirement": "Implement a component that applies a rotational force to an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"URotationalForceComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API URotationalForceComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tURotationalForceComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Force\")\n\tvoid ApplyRotationalForce(float TorqueMagnitude);\n\nprivate:\n\t// The torque to apply each frame\n\tfloat CurrentTorque;\n};\n```", "cpp_code": "```cpp\n#include \"URotationalForceComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nURotationalForceComponent::URotationalForceComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCurrentTorque = 0.0f;\n}\n\nvoid URotationalForceComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotationalForceComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (CurrentTorque != 0.0f)\n\t{\n\t\tAActor* Owner = GetOwner();\n\t\tif (Owner)\n\t\t{\n\t\t\tUPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(Owner->GetRootComponent());\n\t\t\tif (PrimitiveComponent)\n\t\t\t{\n\t\t\t\tPrimitiveComponent->AddTorqueInRadians(FVector(0.0f, 0.0f, CurrentTorque));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid URotationalForceComponent::ApplyRotationalForce(float TorqueMagnitude)\n{\n\tCurrentTorque = TorqueMagnitude;\n}\n```"}
{"requirement": "Load a blueprint asset using ConstructorHelpers and spawn it at runtime.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditDefaultsOnly, Category=\"Spawning\")\n\tTSubclassOf<AActor> BlueprintActorToSpawn;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FClassFinder<AActor> BlueprintActor(TEXT(\"/Game/PathToYourBlueprintActor.YourBlueprintActor_C\"));\n\tif (BlueprintActor.Succeeded())\n\t{\n\t\tBlueprintActorToSpawn = BlueprintActor.Class;\n\t}\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (BlueprintActorToSpawn)\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tGetWorld()->SpawnActor<AActor>(BlueprintActorToSpawn, GetActorLocation() + FVector(200, 0, 0), FRotator::ZeroRotator, SpawnParams);\n\t}\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that prints the distance from another actor each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistancePrinterActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADistancePrinterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADistancePrinterActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Distance\")\n\tAActor* TargetActor;\n};\n```", "cpp_code": "```cpp\n#include \"DistancePrinterActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nADistancePrinterActor::ADistancePrinterActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ADistancePrinterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADistancePrinterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tfloat Distance = FVector::Dist(GetActorLocation(), TargetActor->GetActorLocation());\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Distance to Target: %f\"), Distance);\n\t}\n}\n```"}
{"requirement": "Bind the 'Z' key to toggle an actor's visibility and collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityAndCollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityAndCollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleVisibilityAndCollisionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tvoid ToggleVisibilityAndCollision();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityAndCollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"Components/InputComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAToggleVisibilityAndCollisionActor::AToggleVisibilityAndCollisionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Optionally set a default mesh\n\t// ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/Path/To/Your/Mesh.Mesh'\"));\n\t// if (MeshAsset.Succeeded())\n\t// {\n\t//\t StaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t// }\n}\n\nvoid AToggleVisibilityAndCollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleVisibilityAndCollisionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityAndCollisionActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleVisibilityAndCollision\", IE_Pressed, this, &AToggleVisibilityAndCollisionActor::ToggleVisibilityAndCollision);\n}\n\nvoid AToggleVisibilityAndCollisionActor::ToggleVisibilityAndCollision()\n{\n\tbool bNewVisibility = !StaticMeshComponent->IsVisible();\n\tStaticMeshComponent->SetVisibility(bNewVisibility);\n\tStaticMeshComponent->SetCollisionEnabled(bNewVisibility ? ECollisionEnabled::QueryAndPhysics : ECollisionEnabled::NoCollision);\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere for setting an actor's initial velocity.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector InitialVelocity;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Example usage of InitialVelocity\n\t// You might want to apply this velocity to a physics component\n\t// if you have one attached to this actor.\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\t// Example code to move actor according to InitialVelocity\n\tFVector NewLocation = GetActorLocation() + (InitialVelocity * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that scales up and down repeatedly each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* Mesh;\n\n\tfloat ScaleDirection;\n\tfloat ScaleSpeed;\n\tFVector InitialScale;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh\"));\n\tRootComponent = Mesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMesh->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tScaleDirection = 1.0f;\n\tScaleSpeed = 0.5f;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialScale = GetActorScale3D();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentScale = GetActorScale3D();\n\tCurrentScale += FVector(ScaleSpeed * ScaleDirection * DeltaTime);\n\n\tif (CurrentScale.X > 2.0f * InitialScale.X || CurrentScale.X < 0.5f * InitialScale.X)\n\t{\n\t\tScaleDirection *= -1.0f;\n\t}\n\n\tSetActorScale3D(CurrentScale);\n}\n```"}
{"requirement": "Implement a component that changes an actor's color when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ColorChangeComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UColorChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUColorChangeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\nprivate:\n\tUFUNCTION()\n\tvoid OnClicked();\n\n\tUPROPERTY()\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"ConstructorHelpers.h\"\n\nUColorChangeComponent::UColorChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComponent->OnClicked.AddDynamic(this, &UColorChangeComponent::OnClicked);\n}\n\nvoid UColorChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->AddInstanceComponent(MeshComponent);\n\t\tMeshComponent->RegisterComponent();\n\t}\n}\n\nvoid UColorChangeComponent::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tcheck(PlayerInputComponent);\n}\n\nvoid UColorChangeComponent::OnClicked()\n{\n\tif (MeshComponent)\n\t{\n\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"BaseColor\"), FVector(NewColor));\n\t}\n}\n```"}
{"requirement": "Create an actor with a UPROPERTY to control the amount of time it takes to rotate 360 degrees.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationTime;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationTime = 5.0f; // Default to 5 seconds for a full rotation\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (RotationTime > 0)\n\t{\n\t\tfloat RotationSpeed = 360.0f / RotationTime;\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Bind the 'X' key to a function that resets an actor's scale to default.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetScaleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResetScaleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid ResetScale();\n\n\tFVector DefaultScale;\n};\n```", "cpp_code": "```cpp\n#include \"ResetScaleActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nAResetScaleActor::AResetScaleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tDefaultScale = FVector(1.0f, 1.0f, 1.0f);\n}\n\nvoid AResetScaleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AResetScaleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetScaleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetScale\", IE_Pressed, this, &AResetScaleActor::ResetScale);\n}\n\nvoid AResetScaleActor::ResetScale()\n{\n\tSetActorScale3D(DefaultScale);\n}\n```"}
{"requirement": "Implement a component that plays a sound and logs a message when an actor enters its volume.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"UTriggerVolumeComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTriggerVolumeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUTriggerVolumeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* EnterSound;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);\n};\n```", "cpp_code": "```cpp\n#include \"UTriggerVolumeComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUTriggerVolumeComponent::UTriggerVolumeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UTriggerVolumeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUBoxComponent* BoxComponent = Owner->FindComponentByClass<UBoxComponent>();\n\t\tif (BoxComponent)\n\t\t{\n\t\t\tBoxComponent->OnComponentBeginOverlap.AddDynamic(this, &UTriggerVolumeComponent::OnOverlapBegin);\n\t\t}\n\t}\n}\n\nvoid UTriggerVolumeComponent::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && OtherActor != OverlappedActor)\n\t{\n\t\tif (EnterSound)\n\t\t{\n\t\t\tUGameplayStatics::PlaySoundAtLocation(this, EnterSound, GetOwner()->GetActorLocation());\n\t\t}\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s has entered the trigger volume.\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Create an actor with a collision component that changes its speed based on overlaps.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"SpeedChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedChangeActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUBoxComponent* CollisionComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat NormalSpeed;\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat OverlappedSpeed;\n\n\tfloat CurrentSpeed;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n};\n```", "cpp_code": "```cpp\n#include \"SpeedChangeActor.h\"\n#include \"Components/BoxComponent.h\"\n\nASpeedChangeActor::ASpeedChangeActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ASpeedChangeActor::OnOverlapBegin);\n\tCollisionComponent->OnComponentEndOverlap.AddDynamic(this, &ASpeedChangeActor::OnOverlapEnd);\n\n\tNormalSpeed = 600.0f;\n\tOverlappedSpeed = 300.0f;\n\tCurrentSpeed = NormalSpeed;\n}\n\nvoid ASpeedChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpeedChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation() + (GetActorForwardVector() * CurrentSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n\nvoid ASpeedChangeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tCurrentSpeed = OverlappedSpeed;\n\t}\n}\n\nvoid ASpeedChangeActor::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tCurrentSpeed = NormalSpeed;\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to determine the maximum size an actor can grow.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GrowableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AGrowableActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAGrowableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Growth\")\n\tfloat MaxGrowthSize;\n};\n```", "cpp_code": "```cpp\n#include \"GrowableActor.h\"\n\nAGrowableActor::AGrowableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMaxGrowthSize = 100.0f; // Default value\n}\n\nvoid AGrowableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AGrowableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that logs the number of frames passed each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FrameCounterActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFrameCounterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAFrameCounterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tint32 FrameCount;\n};\n```", "cpp_code": "```cpp\n#include \"FrameCounterActor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAFrameCounterActor::AFrameCounterActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tFrameCount = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AFrameCounterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tFrameCount = 0;\n}\n\n// Called every frame\nvoid AFrameCounterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFrameCount++;\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Frames passed: %d\"), FrameCount));\n\t}\n}\n```"}
{"requirement": "Implement a component that applies a gradual slowdown to an actor's movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"USlowdownComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API USlowdownComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUSlowdownComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Slowdown\")\n\tfloat SlowdownRate;\n\n\tUPROPERTY(EditAnywhere, Category = \"Slowdown\")\n\tfloat MinimumSpeed;\n\n\tFVector CurrentVelocity;\n\n\tvoid ApplySlowdown(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"USlowdownComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUSlowdownComponent::USlowdownComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tSlowdownRate = 100.0f;\n\tMinimumSpeed = 10.0f;\n}\n\nvoid USlowdownComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tCurrentVelocity = Owner->GetVelocity();\n\t}\n}\n\nvoid USlowdownComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tApplySlowdown(DeltaTime);\n}\n\nvoid USlowdownComponent::ApplySlowdown(float DeltaTime)\n{\n\tAActor* Owner = GetOwner();\n\tif (!Owner)\n\t{\n\t\treturn;\n\t}\n\n\tfloat Speed = CurrentVelocity.Size();\n\tif (Speed > MinimumSpeed)\n\t{\n\t\tfloat NewSpeed = FMath::Max(Speed - SlowdownRate * DeltaTime, MinimumSpeed);\n\t\tCurrentVelocity = CurrentVelocity.GetSafeNormal() * NewSpeed;\n\t\tOwner->SetActorLocation(Owner->GetActorLocation() + CurrentVelocity * DeltaTime);\n\t}\n}\n```"}
{"requirement": "Bind the 'C' key to a function that changes an actor's mesh to a second predefined mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAChangeMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ChangeMesh();\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMesh* SecondMesh;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nAChangeMeshActor::AChangeMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Assume the first mesh is already set in the editor or elsewhere\n\t// Load the second mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tSecondMesh = MeshAsset.Object;\n\t}\n}\n\nvoid AChangeMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMeshActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ChangeMesh\", IE_Pressed, this, &AChangeMeshActor::ChangeMesh);\n}\n\nvoid AChangeMeshActor::ChangeMesh()\n{\n\tif (MeshComponent && SecondMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(SecondMesh);\n\t}\n}\n```"}
{"requirement": "Create a static mesh actor that automatically rotates to face the player each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AutoRotateActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAutoRotateActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAutoRotateActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"AutoRotateActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAAutoRotateActor::AAutoRotateActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AAutoRotateActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(this, 0);\n}\n\nvoid AAutoRotateActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerActor)\n\t{\n\t\tFVector Direction = PlayerActor->GetActorLocation() - GetActorLocation();\n\t\tFRotator NewRotation = FRotationMatrix::MakeFromX(Direction).Rotator();\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to control the frequency of a looping sound.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SoundFrequencyController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundFrequencyController : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundFrequencyController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tfloat Frequency;\n};\n```", "cpp_code": "```cpp\n#include \"SoundFrequencyController.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundBase.h\"\n\nASoundFrequencyController::ASoundFrequencyController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tFrequency = 440.0f; // Default frequency value\n}\n\nvoid ASoundFrequencyController::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundFrequencyController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Here you would typically adjust the frequency of a sound component\n\t// if you had one attached to this actor.\n}\n```"}
{"requirement": "Implement an actor that reverses movement direction when it reaches a boundary.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReversingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AReversingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAReversingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tFVector MovementDirection;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat Speed;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector BoundaryMin;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector BoundaryMax;\n\n\tvoid CheckBoundary();\n};\n```", "cpp_code": "```cpp\n#include \"ReversingActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAReversingActor::AReversingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementDirection = FVector(1.0f, 0.0f, 0.0f);\n\tSpeed = 100.0f;\n\tBoundaryMin = FVector(-500.0f, -500.0f, -500.0f);\n\tBoundaryMax = FVector(500.0f, 500.0f, 500.0f);\n}\n\nvoid AReversingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AReversingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tFVector NewLocation = GetActorLocation() + (MovementDirection * Speed * DeltaTime);\n\tSetActorLocation(NewLocation);\n\n\tCheckBoundary();\n}\n\nvoid AReversingActor::CheckBoundary()\n{\n\tFVector Location = GetActorLocation();\n\tbool bReversed = false;\n\n\tif (Location.X < BoundaryMin.X || Location.X > BoundaryMax.X)\n\t{\n\t\tMovementDirection.X *= -1;\n\t\tbReversed = true;\n\t}\n\tif (Location.Y < BoundaryMin.Y || Location.Y > BoundaryMax.Y)\n\t{\n\t\tMovementDirection.Y *= -1;\n\t\tbReversed = true;\n\t}\n\tif (Location.Z < BoundaryMin.Z || Location.Z > BoundaryMax.Z)\n\t{\n\t\tMovementDirection.Z *= -1;\n\t\tbReversed = true;\n\t}\n\n\tif (bReversed)\n\t{\n\t\tSetActorLocation(Location - (MovementDirection * Speed * GetWorld()->GetDeltaSeconds()));\n\t}\n}\n```"}
{"requirement": "Create a component that prints a warning when an actor's health drops below a threshold.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"HealthWarningComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UHealthWarningComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUHealthWarningComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION()\n\tvoid CheckHealth(float CurrentHealth);\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Health\")\n\tfloat HealthThreshold;\n};\n```", "cpp_code": "```cpp\n#include \"HealthWarningComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nUHealthWarningComponent::UHealthWarningComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tHealthThreshold = 50.0f; // Default threshold value\n}\n\nvoid UHealthWarningComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Additional initialization if needed\n}\n\nvoid UHealthWarningComponent::CheckHealth(float CurrentHealth)\n{\n\tif (CurrentHealth < HealthThreshold)\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tFString ActorName = GetOwner()->GetName();\n\t\t\tFString WarningMessage = FString::Printf(TEXT(\"Warning: %s's health is below the threshold!\"), *ActorName);\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, WarningMessage);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Bind the 'D' key to a function that deletes an actor from the scene.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ADeletableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADeletableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADeletableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid DeleteActor();\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ADeletableActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nADeletableActor::ADeletableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ADeletableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADeletableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADeletableActor::DeleteActor()\n{\n\tDestroy();\n}\n\nvoid ADeletableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"DeleteActor\", IE_Pressed, this, &ADeletableActor::DeleteActor);\n}\n```"}
{"requirement": "Create an actor with a UPROPERTY to control its starting scale in all directions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Scale\")\n\tFVector StartingScale;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Set default starting scale\n\tStartingScale = FVector(1.0f, 1.0f, 1.0f);\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Apply the starting scale to the actor\n\tSetActorScale3D(StartingScale);\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Implement a component that alters gravity's effect on an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"GravityModifierComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UGravityModifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUGravityModifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION(BlueprintCallable, Category=\"Gravity\")\n\tvoid SetGravityScale(float NewScale);\n\nprivate:\n\tfloat GravityScale;\n};\n```", "cpp_code": "```cpp\n#include \"GravityModifierComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUGravityModifierComponent::UGravityModifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tGravityScale = 1.0f; // Default gravity scale\n}\n\nvoid UGravityModifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UGravityModifierComponent::SetGravityScale(float NewScale)\n{\n\tGravityScale = NewScale;\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->GetWorld()->GetGravityZ() * GravityScale;\n\t}\n}\n```"}
{"requirement": "Load a skeletal mesh asset using ConstructorHelpers and apply it to an actor in the constructor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ASkeletalMeshActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AASkeletalMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAASkeletalMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ASkeletalMeshActor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAASkeletalMeshActor::AASkeletalMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<USkeletalMesh> SkeletalMeshAsset(TEXT(\"/Game/Path/To/Your/SkeletalMesh.SkeletalMesh\"));\n\tif (SkeletalMeshAsset.Succeeded())\n\t{\n\t\tSkeletalMeshComponent->SetSkeletalMesh(SkeletalMeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AASkeletalMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AASkeletalMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Create an actor that changes its position based on a sine wave function each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SineWaveMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASineWaveMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASineWaveMover();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialPosition;\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Amplitude;\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Frequency;\n};\n```", "cpp_code": "```cpp\n#include \"SineWaveMover.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nASineWaveMover::ASineWaveMover()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAmplitude = 100.0f;\n\tFrequency = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASineWaveMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialPosition = GetActorLocation();\n}\n\n// Called every frame\nvoid ASineWaveMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat Time = GetWorld()->GetTimeSeconds();\n\tfloat SineValue = FMath::Sin(Frequency * Time);\n\tFVector NewPosition = InitialPosition;\n\tNewPosition.Z += Amplitude * SineValue;\n\n\tSetActorLocation(NewPosition);\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to define a delay before an actor becomes active.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Activation\")\n\tfloat ActivationDelay;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tActivationDelay = 5.0f; // Default Delay\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Logic to handle the delay before activation can be added here\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t// Actor tick logic\n}\n```"}
{"requirement": "Implement an actor that plays a particle effect when its health reaches zero.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"HealthBasedParticleActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AHealthBasedParticleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAHealthBasedParticleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Health\")\n\tfloat Health;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Effects\")\n\tUParticleSystem* DeathParticleEffect;\n\n\tUFUNCTION()\n\tvoid OnHealthChanged();\n};\n```", "cpp_code": "```cpp\n#include \"HealthBasedParticleActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAHealthBasedParticleActor::AHealthBasedParticleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHealth = 100.0f; // Default health value\n}\n\nvoid AHealthBasedParticleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthBasedParticleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tOnHealthChanged();\n}\n\nvoid AHealthBasedParticleActor::OnHealthChanged()\n{\n\tif (Health <= 0.0f && DeathParticleEffect)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), DeathParticleEffect, GetActorLocation(), FRotator::ZeroRotator, true);\n\t\t// Optionally destroy the actor if needed\n\t\t// Destroy();\n\t}\n}\n```"}
{"requirement": "Create a component that logs the time every time an actor is clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UTimeLoggerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTimeLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUTimeLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION()\n\tvoid OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n};\n```", "cpp_code": "```cpp\n#include \"UTimeLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Public/TimerManager.h\"\n#include \"GameFramework/PlayerController.h\"\n\nUTimeLoggerComponent::UTimeLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UTimeLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->OnClicked.AddDynamic(this, &UTimeLoggerComponent::OnClicked);\n\t}\n}\n\nvoid UTimeLoggerComponent::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tFDateTime CurrentTime = FDateTime::Now();\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor clicked at: %s\"), *CurrentTime.ToString());\n}\n```"}
{"requirement": "Bind the 'U' key to a function that unlocks additional speed for an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UnlockSpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AUnlockSpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAUnlockSpeedActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to unlock additional speed\n\tUFUNCTION()\n\tvoid UnlockSpeed();\n\n\t// Speed variables\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Speed\")\n\tfloat NormalSpeed;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Speed\")\n\tfloat UnlockedSpeed;\n\nprivate:\n\t// Input binding\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n};\n```", "cpp_code": "```cpp\n#include \"UnlockSpeedActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAUnlockSpeedActor::AUnlockSpeedActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize speed variables\n\tNormalSpeed = 600.0f;\n\tUnlockedSpeed = 1200.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AUnlockSpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AUnlockSpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to unlock additional speed\nvoid AUnlockSpeedActor::UnlockSpeed()\n{\n\t// Logic to unlock speed\n\t// This can be setting a speed variable or modifying a character movement component's speed\n\tUE_LOG(LogTemp, Warning, TEXT(\"Speed Unlocked!\"));\n\t// Example: CharacterMovement->MaxWalkSpeed = UnlockedSpeed;\n}\n\n// Setup input bindings\nvoid AUnlockSpeedActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"UnlockSpeed\", IE_Pressed, this, &AUnlockSpeedActor::UnlockSpeed);\n\t}\n}\n```"}
{"requirement": "Create an actor with a collision component that prints its bounds size on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"CollisionBoundsActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionBoundsActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionBoundsActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* CollisionComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionBoundsActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nACollisionBoundsActor::ACollisionBoundsActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach the collision component\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\t// Register the overlap event\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionBoundsActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionBoundsActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionBoundsActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionBoundsActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (GEngine)\n\t{\n\t\t// Get the bounds of the collision component\n\t\tFVector BoundsExtent = CollisionComponent->Bounds.BoxExtent;\n\t\tFString BoundsSize = FString::Printf(TEXT(\"Bounds Size: X=%.2f, Y=%.2f, Z=%.2f\"), BoundsExtent.X, BoundsExtent.Y, BoundsExtent.Z);\n\n\t\t// Print the bounds size to the screen\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, BoundsSize);\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY editable in Blueprint to control an actor's jump strength.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyJumpingActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyJumpingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyJumpingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Jump\")\n\tfloat JumpStrength;\n};\n```", "cpp_code": "```cpp\n#include \"MyJumpingActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAMyJumpingActor::AMyJumpingActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tJumpStrength = 600.0f; // Default jump strength\n}\n\n// Called when the game starts or when spawned\nvoid AMyJumpingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyJumpingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Implement an actor that scales down when it overlaps a specific type of actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass ASimpleScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASimpleScalingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tfloat ScaleFactor;\n\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tTSubclassOf<AActor> SpecificActorClass;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASimpleScalingActor::ASimpleScalingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ASimpleScalingActor::OnOverlapBegin);\n\n\tScaleFactor = 0.5f; // Example scale factor\n}\n\n// Called when the game starts or when spawned\nvoid ASimpleScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASimpleScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASimpleScalingActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && OtherActor->IsA(SpecificActorClass))\n\t{\n\t\tFVector NewScale = GetActorScale3D() * ScaleFactor;\n\t\tSetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Create a component that changes the owner's rotation to face another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFaceActorComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UFaceActorComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUFaceActorComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void FaceActor(AActor* TargetActor);\n};\n```", "cpp_code": "```cpp\n#include \"UFaceActorComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUFaceActorComponent::UFaceActorComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UFaceActorComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFaceActorComponent::FaceActor(AActor* TargetActor)\n{\n\tif (TargetActor && GetOwner())\n\t{\n\t\tFVector TargetLocation = TargetActor->GetActorLocation();\n\t\tFVector OwnerLocation = GetOwner()->GetActorLocation();\n\t\tFRotator NewRotation = (TargetLocation - OwnerLocation).Rotation();\n\t\tGetOwner()->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Bind the 'Y' key to a function that toggles a Boolean property in the actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ToggleBoolean();\n\n\tUPROPERTY()\n\tbool bIsToggled;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleActor.h\"\n#include \"Components/InputComponent.h\"\n\nAToggleActor::AToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsToggled = false;\n}\n\nvoid AToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ToggleBoolean\", IE_Pressed, this, &AToggleActor::ToggleBoolean);\n}\n\nvoid AToggleActor::ToggleBoolean()\n{\n\tbIsToggled = !bIsToggled;\n}\n```"}
{"requirement": "Create an actor that moves randomly within a defined area each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARandomMover();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector GetRandomLocation() const;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tFVector MovementArea;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RandomMover.h\"\n#include \"Engine/World.h\"\n#include \"Math/UnrealMathUtility.h\"\n\n// Sets default values\nARandomMover::ARandomMover()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementArea = FVector(1000.0f, 1000.0f, 1000.0f);\n\tMovementSpeed = 200.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ARandomMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARandomMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetRandomLocation();\n\tFVector CurrentLocation = GetActorLocation();\n\tFVector Direction = (NewLocation - CurrentLocation).GetSafeNormal();\n\n\tSetActorLocation(CurrentLocation + Direction * MovementSpeed * DeltaTime);\n}\n\nFVector ARandomMover::GetRandomLocation() const\n{\n\tfloat RandomX = FMath::FRandRange(-MovementArea.X, MovementArea.X);\n\tfloat RandomY = FMath::FRandRange(-MovementArea.Y, MovementArea.Y);\n\tfloat RandomZ = FMath::FRandRange(-MovementArea.Z, MovementArea.Z);\n\n\treturn FVector(RandomX, RandomY, RandomZ);\n}\n```"}
{"requirement": "Add a UPROPERTY with metadata to specify units for a numeric value in Blueprint.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UnitSpecifierActor.generated.h\"\n\nUCLASS()\nclass AUnitSpecifierActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAUnitSpecifierActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (Units = \"cm\"))\n\tfloat DistanceInCentimeters;\n};\n```", "cpp_code": "```cpp\n#include \"UnitSpecifierActor.h\"\n\n// Sets default values\nAUnitSpecifierActor::AUnitSpecifierActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tDistanceInCentimeters = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AUnitSpecifierActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AUnitSpecifierActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Implement a component that logs which actor overlapped with it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULoggingOverlapComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULoggingOverlapComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tULoggingOverlapComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION()\n\tvoid OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor);\n};\n```", "cpp_code": "```cpp\n#include \"ULoggingOverlapComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nULoggingOverlapComponent::ULoggingOverlapComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid ULoggingOverlapComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->OnActorBeginOverlap.AddDynamic(this, &ULoggingOverlapComponent::OnOverlapBegin);\n\t}\n}\n\nvoid ULoggingOverlapComponent::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && OtherActor != GetOwner())\n\t{\n\t\tUE_LOG(LogTemp, Log, TEXT(\"%s overlapped with %s\"), *GetOwner()->GetName(), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Create an actor with a UPROPERTY to set a color that changes on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAColorChangeActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tFLinearColor Color;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nAColorChangeActor::AColorChangeActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tUBoxComponent* BoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tBoxComponent->SetupAttachment(RootComponent);\n\tBoxComponent->SetBoxExtent(FVector(50.f));\n\tBoxComponent->OnComponentBeginOverlap.AddDynamic(this, &AColorChangeActor::OnOverlapBegin);\n\n\tColor = FLinearColor::Red;\n}\n\nvoid AColorChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AColorChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AColorChangeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tColor = FLinearColor::MakeRandomColor();\n\t\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"BaseColor\"), FVector(Color));\n\t}\n}\n```"}
{"requirement": "Bind the 'K' key to a function that halves an actor's current health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HalveHealthActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHalveHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAHalveHealthActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid HalveHealth();\n\n\tUPROPERTY(EditAnywhere)\n\tfloat CurrentHealth;\n};\n```", "cpp_code": "```cpp\n#include \"HalveHealthActor.h\"\n#include \"Components/InputComponent.h\"\n\nAHalveHealthActor::AHalveHealthActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentHealth = 100.0f; // Default health value\n}\n\nvoid AHalveHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHalveHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHalveHealthActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"HalveHealth\", IE_Pressed, this, &AHalveHealthActor::HalveHealth);\n}\n\nvoid AHalveHealthActor::HalveHealth()\n{\n\tCurrentHealth *= 0.5f;\n\tUE_LOG(LogTemp, Warning, TEXT(\"New Health: %f\"), CurrentHealth);\n}\n```"}
{"requirement": "Create a component that prints the angle between its owner and another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UAnglePrinterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UAnglePrinterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUAnglePrinterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void PrintAngleWithActor(AActor* OtherActor);\n};\n```", "cpp_code": "```cpp\n#include \"UAnglePrinterComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nUAnglePrinterComponent::UAnglePrinterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UAnglePrinterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UAnglePrinterComponent::PrintAngleWithActor(AActor* OtherActor)\n{\n\tif (!OtherActor)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"OtherActor is null\"));\n\t\treturn;\n\t}\n\n\tAActor* Owner = GetOwner();\n\tif (!Owner)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Owner is null\"));\n\t\treturn;\n\t}\n\n\tFVector OwnerLocation = Owner->GetActorLocation();\n\tFVector OtherActorLocation = OtherActor->GetActorLocation();\n\n\tFVector DirectionToOther = (OtherActorLocation - OwnerLocation).GetSafeNormal();\n\tFVector ForwardVector = Owner->GetActorForwardVector();\n\n\tfloat DotProduct = FVector::DotProduct(ForwardVector, DirectionToOther);\n\tfloat AngleInRadians = FMath::Acos(DotProduct);\n\tfloat AngleInDegrees = FMath::RadiansToDegrees(AngleInRadians);\n\n\tUE_LOG(LogTemp, Log, TEXT(\"Angle between %s and %s: %f degrees\"), *Owner->GetName(), *OtherActor->GetName(), AngleInDegrees);\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to control an actor's rotation speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotationSpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotationSpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotationSpeedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotationSpeedActor.h\"\n\nARotationSpeedActor::ARotationSpeedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 45.0f; // Default rotation speed\n}\n\nvoid ARotationSpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotationSpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement an actor that changes its Z position to simulate jumping each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"JumpingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AJumpingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAJumpingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The speed of the jump\n\tUPROPERTY(EditAnywhere)\n\tfloat JumpSpeed;\n\n\t// The maximum height of the jump\n\tUPROPERTY(EditAnywhere)\n\tfloat MaxJumpHeight;\n\n\t// Original Z position\n\tfloat OriginalZ;\n\n\t// Direction of movement (1 for up, -1 for down)\n\tint32 Direction;\n};\n```", "cpp_code": "```cpp\n#include \"JumpingActor.h\"\n\n// Sets default values\nAJumpingActor::AJumpingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tJumpSpeed = 100.0f;\n\tMaxJumpHeight = 300.0f;\n\tDirection = 1;\n}\n\n// Called when the game starts or when spawned\nvoid AJumpingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tOriginalZ = GetActorLocation().Z;\n}\n\n// Called every frame\nvoid AJumpingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation();\n\tNewLocation.Z += JumpSpeed * DeltaTime * Direction;\n\n\t// Check if we've reached the max height or returned to the original position\n\tif (Direction == 1 && NewLocation.Z >= OriginalZ + MaxJumpHeight)\n\t{\n\t\tDirection = -1;\n\t}\n\telse if (Direction == -1 && NewLocation.Z <= OriginalZ)\n\t{\n\t\tDirection = 1;\n\t\tNewLocation.Z = OriginalZ; // Reset to original Z to avoid floating point precision issues\n\t}\n\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that plays a different sound based on which key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASoundPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundPlayerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundCueA;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundCueB;\n\n\tUFUNCTION()\n\tvoid PlaySoundA();\n\n\tUFUNCTION()\n\tvoid PlaySoundB();\n};\n```", "cpp_code": "```cpp\n#include \"SoundPlayerActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundPlayerActor::ASoundPlayerActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ASoundPlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundPlayerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"PlaySoundA\", IE_Pressed, this, &ASoundPlayerActor::PlaySoundA);\n\tPlayerInputComponent->BindAction(\"PlaySoundB\", IE_Pressed, this, &ASoundPlayerActor::PlaySoundB);\n}\n\nvoid ASoundPlayerActor::PlaySoundA()\n{\n\tif (SoundCueA)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundCueA, GetActorLocation());\n\t}\n}\n\nvoid ASoundPlayerActor::PlaySoundB()\n{\n\tif (SoundCueB)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundCueB, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Bind the 'H' key to a function that hides and unhides all actors in a scene.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HideActorsManager.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHideActorsManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHideActorsManager();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to toggle visibility of all actors\n\tvoid ToggleActorsVisibility();\n\n\t// Bind input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\nprivate:\n\tbool bAreActorsHidden;\n};\n```", "cpp_code": "```cpp\n#include \"HideActorsManager.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAHideActorsManager::AHideActorsManager()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tbAreActorsHidden = false;\n}\n\n// Called when the game starts or when spawned\nvoid AHideActorsManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AHideActorsManager::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHideActorsManager::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AHideActorsManager::ToggleActorsVisibility);\n}\n\nvoid AHideActorsManager::ToggleActorsVisibility()\n{\n\tUWorld* World = GetWorld();\n\tif (World)\n\t{\n\t\tfor (TActorIterator<AActor> ActorItr(World); ActorItr; ++ActorItr)\n\t\t{\n\t\t\tAActor* Actor = *ActorItr;\n\t\t\tif (Actor && Actor != this) // Ensure we don't hide ourselves\n\t\t\t{\n\t\t\t\tActor->SetActorHiddenInGame(!bAreActorsHidden);\n\t\t\t}\n\t\t}\n\t\tbAreActorsHidden = !bAreActorsHidden;\n\t}\n}\n```"}
{"requirement": "Create a component that applies a random rotation to an actor on BeginPlay.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"URandomRotationComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API URandomRotationComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tURandomRotationComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"URandomRotationComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nURandomRotationComponent::URandomRotationComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid URandomRotationComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tFRotator RandomRotation = FRotator(FMath::FRand() * 360.0f, FMath::FRand() * 360.0f, FMath::FRand() * 360.0f);\n\tGetOwner()->SetActorRotation(RandomRotation);\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to set an actor's maximum health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat MaxHealth;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMaxHealth = 100.0f; // Default max health value\n}\n```"}
{"requirement": "Implement an actor that resets its location to a random point when the 'N' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomLocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomLocationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARandomLocationActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to reset location\n\tvoid ResetLocation();\n\n\t// Setup player input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tFVector MinBounds;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector MaxBounds;\n};\n```", "cpp_code": "```cpp\n#include \"RandomLocationActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nARandomLocationActor::ARandomLocationActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMinBounds = FVector(-1000.0f, -1000.0f, 0.0f);\n\tMaxBounds = FVector(1000.0f, 1000.0f, 1000.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ARandomLocationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARandomLocationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Reset location to a random point\nvoid ARandomLocationActor::ResetLocation()\n{\n\tFVector NewLocation;\n\tNewLocation.X = FMath::FRandRange(MinBounds.X, MaxBounds.X);\n\tNewLocation.Y = FMath::FRandRange(MinBounds.Y, MaxBounds.Y);\n\tNewLocation.Z = FMath::FRandRange(MinBounds.Z, MaxBounds.Z);\n\tSetActorLocation(NewLocation);\n}\n\n// Setup player input\nvoid ARandomLocationActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetLocation\", IE_Pressed, this, &ARandomLocationActor::ResetLocation);\n}\n\n// In your project settings, make sure to map the \"ResetLocation\" action to the 'N' key.\n```"}
{"requirement": "Create a static mesh actor with a UPROPERTY to swap between two meshes dynamically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SwapMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASwapMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASwapMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category = \"Mesh\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Mesh\")\n\tUStaticMesh* Mesh1;\n\n\tUPROPERTY(EditAnywhere, Category = \"Mesh\")\n\tUStaticMesh* Mesh2;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Mesh\")\n\tvoid SwapMesh();\n};\n```", "cpp_code": "```cpp\n#include \"SwapMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASwapMeshActor::ASwapMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Assuming you have two meshes in your project at the specified paths\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> Mesh1Asset(TEXT(\"/Game/Path/To/Your/Mesh1.Mesh1\"));\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> Mesh2Asset(TEXT(\"/Game/Path/To/Your/Mesh2.Mesh2\"));\n\n\tif (Mesh1Asset.Succeeded())\n\t{\n\t\tMesh1 = Mesh1Asset.Object;\n\t}\n\n\tif (Mesh2Asset.Succeeded())\n\t{\n\t\tMesh2 = Mesh2Asset.Object;\n\t}\n\n\t// Set the initial mesh\n\tif (Mesh1)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh1);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ASwapMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASwapMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASwapMeshActor::SwapMesh()\n{\n\tif (MeshComponent->GetStaticMesh() == Mesh1)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh2);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh1);\n\t}\n}\n```"}
{"requirement": "Bind the 'E' key to increase an actor's movement speed temporarily.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedBoostActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASpeedBoostActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpeedBoostActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Function to handle speed boost\n\tvoid BoostSpeed();\n\n\t// Timer handle for resetting speed\n\tFTimerHandle SpeedBoostTimerHandle;\n\n\t// Function to reset speed\n\tvoid ResetSpeed();\n\n\t// Movement speed\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MovementSpeed;\n\n\t// Boosted speed\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat BoostedSpeed;\n\n\t// Duration of the speed boost\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat BoostDuration;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedBoostActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nASpeedBoostActor::ASpeedBoostActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementSpeed = 600.0f;\n\tBoostedSpeed = 1200.0f;\n\tBoostDuration = 5.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASpeedBoostActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpeedBoostActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid ASpeedBoostActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"BoostSpeed\", IE_Pressed, this, &ASpeedBoostActor::BoostSpeed);\n}\n\n// Handle speed boost\nvoid ASpeedBoostActor::BoostSpeed()\n{\n\tGetCharacterMovement()->MaxWalkSpeed = BoostedSpeed;\n\tGetWorld()->GetTimerManager().SetTimer(SpeedBoostTimerHandle, this, &ASpeedBoostActor::ResetSpeed, BoostDuration, false);\n}\n\n// Reset speed to normal\nvoid ASpeedBoostActor::ResetSpeed()\n{\n\tGetCharacterMovement()->MaxWalkSpeed = MovementSpeed;\n}\n```"}
{"requirement": "Create an actor with a collision component that changes its material on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"CollisionChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* CollisionComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* InitialMaterial;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* OverlapMaterial;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionChangeActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACollisionChangeActor::ACollisionChangeActor()\n{\n\t// Initialize the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Find and set a default mesh (assuming a cube is in the engine content)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh>MeshAsset(TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Initialize the collision component\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tCollisionComponent->SetupAttachment(RootComponent);\n\tCollisionComponent->SetBoxExtent(FVector(50.f, 50.f, 50.f));\n\tCollisionComponent->SetCollisionProfileName(\"Trigger\");\n\n\t// Bind the overlap event\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionChangeActor::OnOverlapBegin);\n\n\t// Set default materials\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> InitialMat(TEXT(\"/Game/Materials/InitialMaterial.InitialMaterial\"));\n\tif (InitialMat.Succeeded())\n\t{\n\t\tInitialMaterial = InitialMat.Object;\n\t\tMeshComponent->SetMaterial(0, InitialMaterial);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> OverlapMat(TEXT(\"/Game/Materials/OverlapMaterial.OverlapMaterial\"));\n\tif (OverlapMat.Succeeded())\n\t{\n\t\tOverlapMaterial = OverlapMat.Object;\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionChangeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OverlapMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, OverlapMaterial);\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to adjust an actor's health regeneration rate.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat HealthRegenRate;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\t// Set default health regeneration rate\n\tHealthRegenRate = 1.0f;\n}\n```"}
{"requirement": "Implement a component that logs every time an actor receives damage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UDamageLoggerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UDamageLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUDamageLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION()\n\tvoid OnTakeAnyDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy, AActor* DamageCauser);\n};\n```", "cpp_code": "```cpp\n#include \"UDamageLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUDamageLoggerComponent::UDamageLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UDamageLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->OnTakeAnyDamage.AddDynamic(this, &UDamageLoggerComponent::OnTakeAnyDamage);\n\t}\n}\n\nvoid UDamageLoggerComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy, AActor* DamageCauser)\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"%s received %f damage from %s\"), *DamagedActor->GetName(), Damage, *DamageCauser->GetName());\n}\n```"}
{"requirement": "Create a static mesh actor that follows another actor each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"StaticMeshActorFollower.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AStaticMeshActorFollower : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAStaticMeshActorFollower();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Static Mesh Component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Actor to follow\n\tUPROPERTY(EditAnywhere)\n\tAActor* ActorToFollow;\n};\n```", "cpp_code": "```cpp\n#include \"StaticMeshActorFollower.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAStaticMeshActorFollower::AStaticMeshActorFollower()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Mesh Component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set static mesh (assuming the mesh is located in the StarterContent package)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AStaticMeshActorFollower::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AStaticMeshActorFollower::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (ActorToFollow)\n\t{\n\t\tFVector TargetLocation = ActorToFollow->GetActorLocation();\n\t\tSetActorLocation(TargetLocation);\n\t}\n}\n```"}
{"requirement": "Bind the 'W' key to a function that spawns a projectile at an actor's location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/ProjectileMovementComponent.h\"\n#include \"ProjectileSpawner.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AProjectileSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAProjectileSpawner();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid SpawnProjectile();\n\n\tUPROPERTY(EditAnywhere)\n\tTSubclassOf<AActor> ProjectileClass;\n};\n```", "cpp_code": "```cpp\n#include \"ProjectileSpawner.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAProjectileSpawner::AProjectileSpawner()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AProjectileSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AProjectileSpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AProjectileSpawner::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"SpawnProjectile\", IE_Pressed, this, &AProjectileSpawner::SpawnProjectile);\n}\n\nvoid AProjectileSpawner::SpawnProjectile()\n{\n\tif (ProjectileClass)\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tSpawnParams.Owner = this;\n\t\tSpawnParams.Instigator = GetInstigator();\n\n\t\tFVector Location = GetActorLocation();\n\t\tFRotator Rotation = GetActorRotation();\n\n\t\tGetWorld()->SpawnActor<AActor>(ProjectileClass, Location, Rotation, SpawnParams);\n\t}\n}\n```"}
{"requirement": "Create an actor with a UPROPERTY to toggle between two movement states.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleMovementActor.generated.h\"\n\nUENUM(BlueprintType)\nenum class EMovementState : uint8\n{\n\tWalking UMETA(DisplayName = \"Walking\"),\n\tRunning UMETA(DisplayName = \"Running\")\n};\n\nUCLASS()\nclass YOURPROJECT_API AToggleMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAToggleMovementActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Movement\")\n\tEMovementState MovementState;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleMovementActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAToggleMovementActor::AToggleMovementActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementState = EMovementState::Walking;\n}\n\nvoid AToggleMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tswitch (MovementState)\n\t{\n\tcase EMovementState::Walking:\n\t\t// Handle Walking state\n\t\tbreak;\n\tcase EMovementState::Running:\n\t\t// Handle Running state\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to determine how often an actor should change direction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat DirectionChangeInterval;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tDirectionChangeInterval = 5.0f; // Default interval in seconds\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t// Add logic for changing direction based on DirectionChangeInterval\n}\n```"}
{"requirement": "Implement an actor that changes its material when the 'T' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialChangerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMaterialChangerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ChangeMaterial();\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* Material1;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* Material2;\n\n\tbool bUsingMaterial1;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAMaterialChangerActor::AMaterialChangerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tbUsingMaterial1 = true;\n}\n\nvoid AMaterialChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Material1)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n}\n\nvoid AMaterialChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMaterialChangerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AMaterialChangerActor::ChangeMaterial);\n}\n\nvoid AMaterialChangerActor::ChangeMaterial()\n{\n\tif (bUsingMaterial1 && Material2)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material2);\n\t}\n\telse if (!bUsingMaterial1 && Material1)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n\tbUsingMaterial1 = !bUsingMaterial1;\n}\n```"}
{"requirement": "Create a component that applies a linear impulse to an actor on BeginPlay.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UImpulseComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UImpulseComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUImpulseComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Impulse\")\n\tFVector Impulse;\n};\n```", "cpp_code": "```cpp\n#include \"UImpulseComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nUImpulseComponent::UImpulseComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tImpulse = FVector(1000.0f, 0.0f, 0.0f);  // Default impulse\n}\n\nvoid UImpulseComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(Owner->GetRootComponent());\n\t\tif (PrimitiveComponent && PrimitiveComponent->IsSimulatingPhysics())\n\t\t{\n\t\t\tPrimitiveComponent->AddImpulse(Impulse);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Bind the 'S' key to a function that stops all actor movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"StopMovementPawn.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AStopMovementPawn : public APawn\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this pawn's properties\n\tAStopMovementPawn();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Function to stop all actor movement\n\tvoid StopAllMovement();\n};\n```", "cpp_code": "```cpp\n#include \"StopMovementPawn.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAStopMovementPawn::AStopMovementPawn()\n{\n\t// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AStopMovementPawn::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called to bind functionality to input\nvoid AStopMovementPawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the StopAllMovement function to the 'S' key\n\tPlayerInputComponent->BindAction(\"StopMovement\", IE_Pressed, this, &AStopMovementPawn::StopAllMovement);\n}\n\n// Function to stop all actor movement\nvoid AStopMovementPawn::StopAllMovement()\n{\n\tTArray<AActor*> AllActors;\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), AActor::StaticClass(), AllActors);\n\n\tfor (AActor* Actor : AllActors)\n\t{\n\t\tif (Actor)\n\t\t{\n\t\t\tActor->SetActorLocation(Actor->GetActorLocation());\n\t\t\tActor->GetRootComponent()->ComponentVelocity = FVector::ZeroVector;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that rotates twice as fast when overlapping another specific actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed;\n\n\tUPROPERTY(EditAnywhere)\n\tAActor* SpecificActor;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor);\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(AActor* OverlappedActor, AActor* OtherActor);\n\n\tUPROPERTY()\n\tbool bIsOverlapping;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tclass USphereComponent* OverlapComponent;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/SphereComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tOverlapComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"OverlapComponent\"));\n\tOverlapComponent->SetupAttachment(RootComponent);\n\tOverlapComponent->SetSphereRadius(100.0f);\n\tOverlapComponent->OnComponentBeginOverlap.AddDynamic(this, &ARotatingActor::OnOverlapBegin);\n\tOverlapComponent->OnComponentEndOverlap.AddDynamic(this, &ARotatingActor::OnOverlapEnd);\n\n\tRotationSpeed = 45.0f;\n\tbIsOverlapping = false;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat CurrentRotationSpeed = bIsOverlapping ? RotationSpeed * 2 : RotationSpeed;\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += CurrentRotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n\nvoid ARotatingActor::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor == SpecificActor)\n\t{\n\t\tbIsOverlapping = true;\n\t}\n}\n\nvoid ARotatingActor::OnOverlapEnd(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor == SpecificActor)\n\t{\n\t\tbIsOverlapping = false;\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with metadata to describe a float value as a percentage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PercentageActor.generated.h\"\n\nUCLASS()\nclass APercentageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPercentageActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = \"0.0\", ClampMax = \"100.0\", UIMin = \"0.0\", UIMax = \"100.0\", ToolTip = \"Value represented as a percentage\"))\n\tfloat PercentageValue;\n};\n```", "cpp_code": "```cpp\n#include \"PercentageActor.h\"\n\nAPercentageActor::APercentageActor()\n{\n\tPercentageValue = 0.0f;\n}\n```"}
{"requirement": "Implement a component that prints a log message when an actor is destroyed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UDestructionLoggerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UDestructionLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUDestructionLoggerComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called when the component is destroyed\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n};\n```", "cpp_code": "```cpp\n#include \"UDestructionLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nUDestructionLoggerComponent::UDestructionLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UDestructionLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UDestructionLoggerComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\tif (EndPlayReason == EEndPlayReason::Destroyed)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Actor %s has been destroyed.\"), *GetOwner()->GetName());\n\t}\n}\n```"}
{"requirement": "Create an actor that shrinks and disappears when it reaches a certain scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ShrinkingActor.generated.h\"\n\nUCLASS()\nclass AShrinkingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAShrinkingActor();\n\nprotected:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat ShrinkRate;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MinScaleBeforeDisappear;\n};\n```", "cpp_code": "```cpp\n#include \"ShrinkingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAShrinkingActor::AShrinkingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tShrinkRate = 0.1f;\n\tMinScaleBeforeDisappear = 0.1f;\n}\n\nvoid AShrinkingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentScale = GetActorScale3D();\n\tCurrentScale -= FVector(ShrinkRate * DeltaTime);\n\n\tif (CurrentScale.X <= MinScaleBeforeDisappear || CurrentScale.Y <= MinScaleBeforeDisappear || CurrentScale.Z <= MinScaleBeforeDisappear)\n\t{\n\t\tDestroy();\n\t}\n\telse\n\t{\n\t\tSetActorScale3D(CurrentScale);\n\t}\n}\n```"}
{"requirement": "Bind the 'G' key to a function that grows an actor's mesh by a set factor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GrowMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AGrowMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAGrowMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid GrowMesh();\n\n\tUPROPERTY(EditAnywhere, Category = \"Growth\")\n\tfloat GrowthFactor;\n};\n```", "cpp_code": "```cpp\n#include \"GrowMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"Components/InputComponent.h\"\n\nAGrowMeshActor::AGrowMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tGrowthFactor = 1.1f; // Default growth factor\n}\n\nvoid AGrowMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AGrowMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AGrowMeshActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"GrowMesh\", IE_Pressed, this, &AGrowMeshActor::GrowMesh);\n}\n\nvoid AGrowMeshActor::GrowMesh()\n{\n\tFVector NewScale = MeshComponent->GetComponentScale() * GrowthFactor;\n\tMeshComponent->SetWorldScale3D(NewScale);\n}\n```"}
{"requirement": "Create an actor with a collision component that plays a sound when an overlap ends.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Components/BoxComponent.h\"\n#include \"CollisionSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACollisionSoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUBoxComponent* CollisionComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* OverlapEndSound;\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nACollisionSoundActor::ACollisionSoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\tCollisionComponent->SetCollisionProfileName(TEXT(\"Trigger\"));\n\tCollisionComponent->OnComponentEndOverlap.AddDynamic(this, &ACollisionSoundActor::OnOverlapEnd);\n}\n\nvoid ACollisionSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionSoundActor::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (OverlapEndSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, OverlapEndSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to set a delay before an actor's action executes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Action\")\n\tfloat ActionDelay;\n\n\tUFUNCTION()\n\tvoid ExecuteAction();\n\nprivate:\n\tFTimerHandle ActionTimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"TimerManager.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tActionDelay = 0.0f;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGetWorldTimerManager().SetTimer(ActionTimerHandle, this, &AMyActor::ExecuteAction, ActionDelay, false);\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyActor::ExecuteAction()\n{\n\t// Action logic here\n}\n```"}
{"requirement": "Implement a component that adjusts an actor's scale based on time of day.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TimeOfDayScaleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTimeOfDayScaleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUTimeOfDayScaleComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tvoid AdjustScaleBasedOnTimeOfDay();\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector MorningScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector NoonScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector EveningScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector NightScale;\n};\n```", "cpp_code": "```cpp\n#include \"TimeOfDayScaleComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\nUTimeOfDayScaleComponent::UTimeOfDayScaleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\t\n\tMorningScale = FVector(1.0f, 1.0f, 1.0f);\n\tNoonScale = FVector(1.5f, 1.5f, 1.5f);\n\tEveningScale = FVector(1.2f, 1.2f, 1.2f);\n\tNightScale = FVector(0.8f, 0.8f, 0.8f);\n}\n\nvoid UTimeOfDayScaleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tAdjustScaleBasedOnTimeOfDay();\n}\n\nvoid UTimeOfDayScaleComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tAdjustScaleBasedOnTimeOfDay();\n}\n\nvoid UTimeOfDayScaleComponent::AdjustScaleBasedOnTimeOfDay()\n{\n\tif (!GetOwner())\n\t{\n\t\treturn;\n\t}\n\n\tFDateTime CurrentTime = FDateTime::Now();\n\tint32 Hour = CurrentTime.GetHour();\n\n\tFVector NewScale;\n\n\tif (Hour >= 6 && Hour < 12)\n\t{\n\t\tNewScale = MorningScale;\n\t}\n\telse if (Hour >= 12 && Hour < 18)\n\t{\n\t\tNewScale = NoonScale;\n\t}\n\telse if (Hour >= 18 && Hour < 21)\n\t{\n\t\tNewScale = EveningScale;\n\t}\n\telse\n\t{\n\t\tNewScale = NightScale;\n\t}\n\n\tGetOwner()->SetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create an actor that duplicates itself when the 'V' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SelfDuplicatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASelfDuplicatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASelfDuplicatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid DuplicateActor();\n};\n```", "cpp_code": "```cpp\n#include \"SelfDuplicatingActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nASelfDuplicatingActor::ASelfDuplicatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASelfDuplicatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASelfDuplicatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASelfDuplicatingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"Duplicate\", IE_Pressed, this, &ASelfDuplicatingActor::DuplicateActor);\n}\n\nvoid ASelfDuplicatingActor::DuplicateActor()\n{\n\tif (GetWorld())\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tGetWorld()->SpawnActor<ASelfDuplicatingActor>(GetClass(), GetActorLocation() + FVector(100, 0, 0), GetActorRotation(), SpawnParams);\n\t}\n}\n```"}
{"requirement": "Bind the 'J' key to a function that resets the game level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Character.h\"\n#include \"ResetLevelActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetLevelActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResetLevelActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid SetupPlayerInputComponent(UInputComponent* PlayerInputComponent);\n\n\tUFUNCTION()\n\tvoid ResetLevel();\n};\n```", "cpp_code": "```cpp\n#include \"ResetLevelActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAResetLevelActor::AResetLevelActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetLevelActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AResetLevelActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetLevelActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetLevel\", IE_Pressed, this, &AResetLevelActor::ResetLevel);\n}\n\nvoid AResetLevelActor::ResetLevel()\n{\n\tUWorld* World = GetWorld();\n\tif (World)\n\t{\n\t\tFName CurrentLevelName = *UGameplayStatics::GetCurrentLevelName(World);\n\t\tUGameplayStatics::OpenLevel(World, CurrentLevelName);\n\t}\n}\n```"}
{"requirement": "Create a static mesh actor with a UPROPERTY to toggle physics on BeginPlay.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PhysicsToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APhysicsToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPhysicsToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Physics\")\n\tbool bTogglePhysics;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"PhysicsToggleActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAPhysicsToggleActor::APhysicsToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tbTogglePhysics = false;\n}\n\nvoid APhysicsToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tMeshComponent->SetSimulatePhysics(bTogglePhysics);\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere for a damage multiplier affecting actor interactions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DamageMultiplierActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADamageMultiplierActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADamageMultiplierActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Damage\")\n\tfloat DamageMultiplier;\n};\n```", "cpp_code": "```cpp\n#include \"DamageMultiplierActor.h\"\n\n// Sets default values\nADamageMultiplierActor::ADamageMultiplierActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t // Initialize default damage multiplier\n\t DamageMultiplier = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ADamageMultiplierActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ADamageMultiplierActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Implement a component that logs the total number of overlaps with an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"OverlapLoggerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UOverlapLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUOverlapLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor);\n\n\tint32 OverlapCount;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUOverlapLoggerComponent::UOverlapLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tOverlapCount = 0;\n}\n\nvoid UOverlapLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->OnActorBeginOverlap.AddDynamic(this, &UOverlapLoggerComponent::OnOverlapBegin);\n\t}\n}\n\nvoid UOverlapLoggerComponent::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OverlappedActor && OtherActor && OverlappedActor != OtherActor)\n\t{\n\t\tOverlapCount++;\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Total overlaps with %s: %d\"), *OverlappedActor->GetName(), OverlapCount);\n\t}\n}\n```"}
{"requirement": "Create an actor that moves in a circular path each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CircularMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACircularMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACircularMovementActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Radius of the circular path\n\tUPROPERTY(EditAnywhere, Category=\"Circular Movement\")\n\tfloat Radius;\n\n\t// Speed of movement along the circular path\n\tUPROPERTY(EditAnywhere, Category=\"Circular Movement\")\n\tfloat Speed;\n\n\t// Internal angle used for circular movement calculation\n\tfloat CurrentAngle;\n};\n```", "cpp_code": "```cpp\n#include \"CircularMovementActor.h\"\n\n// Sets default values\nACircularMovementActor::ACircularMovementActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default values\n\tRadius = 100.0f;\n\tSpeed = 50.0f;\n\tCurrentAngle = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ACircularMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACircularMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate new position\n\tCurrentAngle += Speed * DeltaTime;\n\tif (CurrentAngle >= 360.0f)\n\t{\n\t\tCurrentAngle -= 360.0f;\n\t}\n\n\tFVector NewLocation;\n\tNewLocation.X = FMath::Cos(FMath::DegreesToRadians(CurrentAngle)) * Radius;\n\tNewLocation.Y = FMath::Sin(FMath::DegreesToRadians(CurrentAngle)) * Radius;\n\tNewLocation.Z = GetActorLocation().Z;\n\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Bind the 'B' key to a function that changes all actors' materials to the same one.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Materials/Material.h\"\n#include \"AChangeMaterialActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AChangeMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAChangeMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ChangeAllActorsMaterial();\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"AChangeMaterialActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/StaticMeshActor.h\"\n\nAChangeMaterialActor::AChangeMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tNewMaterial = nullptr;\n}\n\nvoid AChangeMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AChangeMaterialActor::ChangeAllActorsMaterial);\n}\n\nvoid AChangeMaterialActor::ChangeAllActorsMaterial()\n{\n\tif (NewMaterial == nullptr) return;\n\n\tfor (TActorIterator<AStaticMeshActor> ActorItr(GetWorld()); ActorItr; ++ActorItr)\n\t{\n\t\tAStaticMeshActor* StaticMeshActor = *ActorItr;\n\t\tif (StaticMeshActor && StaticMeshActor->GetStaticMeshComponent())\n\t\t{\n\t\t\tStaticMeshActor->GetStaticMeshComponent()->SetMaterial(0, NewMaterial);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that changes direction when it collides with a wall.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeDirectionActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AChangeDirectionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAChangeDirectionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called when the actor hits something\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector MoveDirection;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MoveSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeDirectionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAChangeDirectionActor::AChangeDirectionActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set a default mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Set initial move direction and speed\n\tMoveDirection = FVector(1.0f, 0.0f, 0.0f);\n\tMoveSpeed = 100.0f;\n\n\t// Bind the OnHit function\n\tMeshComponent->OnComponentHit.AddDynamic(this, &AChangeDirectionActor::OnHit);\n}\n\n// Called when the game starts or when spawned\nvoid AChangeDirectionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AChangeDirectionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Move the actor in the current direction\n\tFVector NewLocation = GetActorLocation() + (MoveDirection * MoveSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n\n// Called when the actor hits something\nvoid AChangeDirectionActor::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\t// Reverse direction on hit\n\tMoveDirection *= -1.0f;\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to adjust the intensity of an actor's light component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"LightActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ALightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALightActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Light\")\n\tfloat LightIntensity;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUPointLightComponent* LightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"LightActor.h\"\n\nALightActor::ALightActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tLightComponent = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLightComponent\"));\n\tRootComponent = LightComponent;\n\n\tLightIntensity = 3000.0f;\n\tLightComponent->Intensity = LightIntensity;\n}\n\nvoid ALightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tLightComponent->SetIntensity(LightIntensity);\n}\n```"}
{"requirement": "Implement a component that logs the distance traveled by an actor each second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULogDistanceTraveledComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULogDistanceTraveledComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tULogDistanceTraveledComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFVector LastLocation;\n\tfloat TotalDistanceTraveled;\n};\n```", "cpp_code": "```cpp\n#include \"ULogDistanceTraveledComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nULogDistanceTraveledComponent::ULogDistanceTraveledComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTotalDistanceTraveled = 0.0f;\n}\n\nvoid ULogDistanceTraveledComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (GetOwner())\n\t{\n\t\tLastLocation = GetOwner()->GetActorLocation();\n\t}\n\n\tGetWorld()->GetTimerManager().SetTimerForNextTick(this, &ULogDistanceTraveledComponent::TickComponent, 1.0f, true);\n}\n\nvoid ULogDistanceTraveledComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (GetOwner())\n\t{\n\t\tFVector CurrentLocation = GetOwner()->GetActorLocation();\n\t\tfloat DistanceTraveled = FVector::Dist(LastLocation, CurrentLocation);\n\n\t\tTotalDistanceTraveled += DistanceTraveled;\n\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Distance traveled this second: %f. Total distance: %f\"), DistanceTraveled, TotalDistanceTraveled);\n\n\t\tLastLocation = CurrentLocation;\n\t}\n}\n```"}
{"requirement": "Create an actor with a UPROPERTY to define a specific target actor it should follow.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FollowTargetActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFollowTargetActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAFollowTargetActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Follow\")\n\tAActor* TargetActor;\n};\n```", "cpp_code": "```cpp\n#include \"FollowTargetActor.h\"\n\n// Sets default values\nAFollowTargetActor::AFollowTargetActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AFollowTargetActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AFollowTargetActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tFVector TargetLocation = TargetActor->GetActorLocation();\n\t\t// Logic to move this actor towards the TargetActor can be added here\n\t}\n}\n```"}
{"requirement": "Bind the 'F' key to a function that toggles full-screen mode in the game.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleFullscreenActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AToggleFullscreenActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleFullscreenActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid ToggleFullscreen();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleFullscreenActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n\nAToggleFullscreenActor::AToggleFullscreenActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AToggleFullscreenActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleFullscreenActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleFullscreenActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ToggleFullscreen\", IE_Pressed, this, &AToggleFullscreenActor::ToggleFullscreen);\n}\n\nvoid AToggleFullscreenActor::ToggleFullscreen()\n{\n\tif (GEngine && GEngine->GameViewport)\n\t{\n\t\tGEngine->GameViewport->Exec(GetWorld(), TEXT(\"fullscreen\"));\n\t}\n}\n```"}
{"requirement": "Create a component that plays a random sound from an array each time it's activated.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"USoundRandomizerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API USoundRandomizerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUSoundRandomizerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION(BlueprintCallable, Category=\"Sound\")\n\tvoid ActivateComponent();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Sound\")\n\tTArray<USoundCue*> SoundCues;\n\n\tvoid PlayRandomSound();\n};\n```", "cpp_code": "```cpp\n#include \"USoundRandomizerComponent.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUSoundRandomizerComponent::USoundRandomizerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid USoundRandomizerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid USoundRandomizerComponent::ActivateComponent()\n{\n\tSuper::Activate(true);\n\tPlayRandomSound();\n}\n\nvoid USoundRandomizerComponent::PlayRandomSound()\n{\n\tif (SoundCues.Num() > 0)\n\t{\n\t\tint32 RandomIndex = FMath::RandRange(0, SoundCues.Num() - 1);\n\t\tUSoundCue* SelectedSound = SoundCues[RandomIndex];\n\t\tif (SelectedSound)\n\t\t{\n\t\t\tUGameplayStatics::PlaySoundAtLocation(this, SelectedSound, GetOwner()->GetActorLocation());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to control the length of time before an actor respawns.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RespawnableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARespawnableActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic: \n\tARespawnableActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Respawn\")\n\tfloat RespawnTime;\n};\n```", "cpp_code": "```cpp\n#include \"RespawnableActor.h\"\n\nARespawnableActor::ARespawnableActor()\n{\n\t// Set default respawn time\n\tRespawnTime = 5.0f;\n}\n```"}
{"requirement": "Implement an actor that prints a message when it gets too close to another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ProximityActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AProximityActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAProximityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Proximity\")\n\tfloat ProximityThreshold;\n\n\tvoid CheckProximity();\n};\n```", "cpp_code": "```cpp\n#include \"ProximityActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAProximityActor::AProximityActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tProximityThreshold = 100.0f; // Default proximity threshold\n}\n\n// Called when the game starts or when spawned\nvoid AProximityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AProximityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tCheckProximity();\n}\n\nvoid AProximityActor::CheckProximity()\n{\n\tTArray<AActor*> OverlappingActors;\n\tGetOverlappingActors(OverlappingActors);\n\n\tfor (AActor* Actor : OverlappingActors)\n\t{\n\t\tif (Actor != this && FVector::Dist(this->GetActorLocation(), Actor->GetActorLocation()) < ProximityThreshold)\n\t\t{\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Actor %s is too close to %s\"), *Actor->GetName(), *GetName());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a visible mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VisibleMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVisibleMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAVisibleMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"VisibleMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAVisibleMeshActor::AVisibleMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AVisibleMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AVisibleMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a rotating actor that spins continuously.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Rotation speed in degrees per second\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize rotation speed\n\tRotationSpeed = FRotator(0.0f, 180.0f, 0.0f);  // Yaw rotation at 180 degrees per second\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Add rotation\n\tAddActorLocalRotation(RotationSpeed * DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY integer variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:  \n  // Sets default values for this actor's properties\n  AMyActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:  \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"My Variables\")\n  int32 MyInteger;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  MyInteger = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n  Super::BeginPlay();\n\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create an actor that changes color over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\tfloat TimeAccumulator;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nAColorChangingActor::AColorChangingActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize variables\n\tTimeAccumulator = 0.0f;\n\n\t// Create and attach a static mesh component\n\tUStaticMeshComponent* MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Create a dynamic material instance\n\tUStaticMeshComponent* MeshComponent = Cast<UStaticMeshComponent>(RootComponent);\n\tif (MeshComponent && MeshComponent->GetMaterial(0))\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\n// Called every frame\nvoid AColorChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterialInstance)\n\t{\n\t\t// Accumulate time\n\t\tTimeAccumulator += DeltaTime;\n\n\t\t// Change color over time\n\t\tFLinearColor NewColor = FLinearColor::MakeFromHSV8((uint8)(TimeAccumulator * 10) % 256, 255, 255);\n\t\tDynamicMaterialInstance->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t}\n}\n```"}
{"requirement": "Bind a key input to print a message to the screen.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintMessageActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API APrintMessageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPrintMessageActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tvoid PrintMessage();\n};\n```", "cpp_code": "```cpp\n#include \"PrintMessageActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n\nAPrintMessageActor::APrintMessageActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid APrintMessageActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APrintMessageActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"PrintMessage\", IE_Pressed, this, &APrintMessageActor::PrintMessage);\n\t}\n}\n\nvoid APrintMessageActor::PrintMessage()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Hello, Unreal Engine!\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that moves upwards every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat UpwardSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tUpwardSpeed = 100.0f; // Default speed value\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation();\n\tNewLocation.Z += UpwardSpeed * DeltaTime; // Move upwards\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that scales up over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic: \n  // Sets default values for this actor's properties\n  AScalingActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic: \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  // The rate at which the actor scales up\n  UPROPERTY(EditAnywhere, Category = \"Scaling\")\n  float ScaleRate;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n\n// Sets default values\nAScalingActor::AScalingActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Initialize the scale rate\n  ScaleRate = 0.1f;\n}\n\n// Called when the game starts or when spawned\nvoid AScalingActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid AScalingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  // Get current scale\n  FVector CurrentScale = GetActorScale3D();\n\n  // Increase scale over time\n  FVector NewScale = CurrentScale + FVector(ScaleRate * DeltaTime);\n\n  // Set the new scale\n  SetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a UPROPERTY boolean variable in a component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"MyComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass MYPROJECT_API UMyComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMyComponent();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MyCategory\")\n\tbool bMyBoolean;\n};\n```", "cpp_code": "```cpp\n#include \"MyComponent.h\"\n\nUMyComponent::UMyComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tbMyBoolean = false;\n}\n```"}
{"requirement": "Create a simple sphere actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimpleSphereActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimpleSphereActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tASimpleSphereActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* SphereMesh;\n};\n```", "cpp_code": "```cpp\n#include \"SimpleSphereActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASimpleSphereActor::ASimpleSphereActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a sphere mesh component\n\tSphereMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"SphereMesh\"));\n\tRootComponent = SphereMesh;\n\n\t// Find and set the static mesh of the sphere\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> SphereAsset(TEXT(\"/Engine/BasicShapes/Sphere.Sphere\"));\n\tif (SphereAsset.Succeeded())\n\t{\n\t\tSphereMesh->SetStaticMesh(SphereAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ASimpleSphereActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ASimpleSphereActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that logs a message on begin play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyLoggingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyLoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyLoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"MyLoggingActor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAMyLoggingActor::AMyLoggingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid AMyLoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Begin Play: Logging Actor\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that moves forward every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMovingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat Speed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n\n// Sets default values\nAMovingActor::AMovingActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSpeed = 100.0f; // Default speed value\n}\n\n// Called when the game starts or when spawned\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Move the actor forward every tick\n\tFVector NewLocation = GetActorLocation() + (GetActorForwardVector() * Speed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a component that changes its color based on a UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ColorChangingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UColorChangingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUColorChangingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void OnRegister() override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Color\")\n\tFLinearColor ComponentColor;\n\nprivate:\n\tvoid UpdateColor();\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nUColorChangingComponent::UColorChangingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tComponentColor = FLinearColor::Red; // Default Color\n}\n\nvoid UColorChangingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateColor();\n}\n\nvoid UColorChangingComponent::OnRegister()\n{\n\tSuper::OnRegister();\n\tUpdateColor();\n}\n\nvoid UColorChangingComponent::UpdateColor()\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tTArray<UStaticMeshComponent*> MeshComponents;\n\t\tOwner->GetComponents<UStaticMeshComponent>(MeshComponents);\n\t\tfor (UStaticMeshComponent* MeshComponent : MeshComponents)\n\t\t{\n\t\t\tif (MeshComponent)\n\t\t\t{\n\t\t\t\tfor (int32 i = 0; i < MeshComponent->GetNumMaterials(); ++i)\n\t\t\t\t{\n\t\t\t\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(i);\n\t\t\t\t\tif (DynamicMaterial)\n\t\t\t\t\t{\n\t\t\t\t\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", ComponentColor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a class with a custom constructor.", "header_code": "```cpp\nclass MYPROJECT_API ACustomActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Custom constructor\n\tACustomActor(float InitialValue);\n\n\t// Example property\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Custom\")\n\tfloat CustomValue;\n};\n```", "cpp_code": "```cpp\n#include \"CustomActor.h\"\n\nACustomActor::ACustomActor(float InitialValue)\n{\n\t// Initialize the custom value with the provided initial value\n\tCustomValue = InitialValue;\n}\n```"}
{"requirement": "Create a UPROPERTY float variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MyCategory\")\n\tfloat MyFloatVariable;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMyFloatVariable = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that disappears after 5 seconds.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DisappearingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ADisappearingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADisappearingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tFTimerHandle TimerHandle;\n\tvoid Disappear();\n};\n```", "cpp_code": "```cpp\n#include \"DisappearingActor.h\"\n#include \"TimerManager.h\"\n\nADisappearingActor::ADisappearingActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ADisappearingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorldTimerManager().SetTimer(TimerHandle, this, &ADisappearingActor::Disappear, 5.0f, false);\n}\n\nvoid ADisappearingActor::Disappear()\n{\n\tDestroy();\n}\n```"}
{"requirement": "Bind a key input to toggle visibility of an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAToggleVisibilityActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid ToggleVisibility();\n\nprivate:\n\tvoid SetupInputComponent();\n\n\tUPROPERTY()\n\tUInputComponent* InputComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/InputComponent.h\"\n\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetupInputComponent();\n}\n\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tSetActorHiddenInGame(!bHidden);\n}\n\nvoid AToggleVisibilityActor::SetupInputComponent()\n{\n\tif (InputComponent == nullptr)\n\t{\n\t\tInputComponent = NewObject<UInputComponent>(this);\n\t\tInputComponent->RegisterComponent();\n\t}\n\n\tif (InputComponent)\n\t{\n\t\tInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleVisibilityActor::ToggleVisibility);\n\t\tEnableInput(GetWorld()->GetFirstPlayerController());\n\t}\n}\n```"}
{"requirement": "Create an actor with a collision box.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionBoxActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ACollisionBoxActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionBoxActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Collision\")\n\tclass UBoxComponent* CollisionBox;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionBoxActor.h\"\n#include \"Components/BoxComponent.h\"\n\n// Sets default values\nACollisionBoxActor::ACollisionBoxActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the collision box and set it as the root component\n\tCollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionBox\"));\n\tRootComponent = CollisionBox;\n\n\t// Set the collision profile\n\tCollisionBox->SetCollisionProfileName(TEXT(\"BlockAllDynamic\"));\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionBoxActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACollisionBoxActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Create a simple cube actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CubeActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACubeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACubeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* CubeMesh;\n};\n```", "cpp_code": "```cpp\n#include \"CubeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACubeActor::ACubeActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the static mesh component\n\tCubeMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"CubeMesh\"));\n\tRootComponent = CubeMesh;\n\n\t// Find and set the cube static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> CubeAsset(TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n\tif (CubeAsset.Succeeded())\n\t{\n\t\tCubeMesh->SetStaticMesh(CubeAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ACubeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACubeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a component with a tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TickComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UTickComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUTickComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n};\n```", "cpp_code": "```cpp\n#include \"TickComponent.h\"\n\n// Sets default values for this component's properties\nUTickComponent::UTickComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\n// Called when the game starts\nvoid UTickComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid UTickComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Add your tick code here\n}\n```"}
{"requirement": "Create a UPROPERTY vector variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  AMyActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Vector\")\n  FVector MyVector;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n  // Set this actor to call Tick() every frame.\n  PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that rotates based on a UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:  \n  // Sets default values for this actor's properties\n  ARotatingActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:  \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n  FRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  RotationRate = FRotator(0.f, 0.f, 0.f);\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  FRotator NewRotation = GetActorRotation() + (RotationRate * DeltaTime);\n  SetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an actor that bounces on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BouncingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ABouncingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tABouncingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat BounceStrength;\n};\n```", "cpp_code": "```cpp\n#include \"BouncingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nABouncingActor::ABouncingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->SetNotifyRigidBodyCollision(true);\n\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ABouncingActor::OnHit);\n\n\tBounceStrength = 500.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ABouncingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n}\n\n// Called every frame\nvoid ABouncingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ABouncingActor::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tFVector Bounce = -NormalImpulse.GetSafeNormal() * BounceStrength;\n\t\tMeshComponent->AddImpulse(Bounce, NAME_None, true);\n\t}\n}\n```"}
{"requirement": "Create a UFUNCTION to reset an actor's position.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetPositionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetPositionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAResetPositionActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Position\")\n\tvoid ResetActorPosition();\n\nprivate:\n\tFVector InitialPosition;\n};\n```", "cpp_code": "```cpp\n#include \"ResetPositionActor.h\"\n\n// Sets default values\nAResetPositionActor::AResetPositionActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Store the initial position of the actor\n\tInitialPosition = GetActorLocation();\n}\n\nvoid AResetPositionActor::ResetActorPosition()\n{\n\tSetActorLocation(InitialPosition);\n}\n```"}
{"requirement": "Create a class that changes scale based on time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleChanger : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAScaleChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat ScaleFactor;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat TimeScaleMultiplier;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChanger.h\"\n\nAScaleChanger::AScaleChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScaleFactor = 1.0f;\n\tTimeScaleMultiplier = 1.0f;\n}\n\nvoid AScaleChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialScale = GetActorScale3D();\n}\n\nvoid AScaleChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat Time = GetWorld()->GetTimeSeconds();\n\tfloat ScaleChange = FMath::Sin(Time * TimeScaleMultiplier) * ScaleFactor;\n\tFVector NewScale = InitialScale + FVector(ScaleChange, ScaleChange, ScaleChange);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Bind a key input to change an actor's scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeScaleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeScaleActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AChangeScaleActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\n  void ChangeScale();\n\nprivate:\n  void SetupInputComponent();\n\nprivate:\n  UPROPERTY(EditAnywhere)\n  FVector NewScale;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeScaleActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\nAChangeScaleActor::AChangeScaleActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n  NewScale = FVector(2.0f, 2.0f, 2.0f);\n}\n\nvoid AChangeScaleActor::BeginPlay()\n{\n  Super::BeginPlay();\n  SetupInputComponent();\n}\n\nvoid AChangeScaleActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AChangeScaleActor::ChangeScale()\n{\n  SetActorScale3D(NewScale);\n}\n\nvoid AChangeScaleActor::SetupInputComponent()\n{\n  if (InputComponent == nullptr)\n  {\n\tInputComponent = NewObject<UInputComponent>(this);\n\tInputComponent->RegisterComponent();\n\tInputComponent->BindAction(\"ChangeScale\", IE_Pressed, this, &AChangeScaleActor::ChangeScale);\n  }\n}\n```"}
{"requirement": "Create an actor with a light component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Light component\n\tUPROPERTY(VisibleAnywhere, Category = \"Light\")\n\tclass UPointLightComponent* PointLight;\n};\n```", "cpp_code": "```cpp\n#include \"LightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nALightActor::ALightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a point light component\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n}\n\n// Called when the game starts or when spawned\nvoid ALightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a simple plane actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimplePlaneActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimplePlaneActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASimplePlaneActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* PlaneMesh;\n};\n```", "cpp_code": "```cpp\n#include \"SimplePlaneActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nASimplePlaneActor::ASimplePlaneActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create plane mesh component\n\tPlaneMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"PlaneMesh\"));\n\tRootComponent = PlaneMesh;\n\n\t// Optionally set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> PlaneMeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Plane.Shape_Plane\"));\n\tif (PlaneMeshAsset.Succeeded())\n\t{\n\t\tPlaneMesh->SetStaticMesh(PlaneMeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ASimplePlaneActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASimplePlaneActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY string variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  AMyActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Custom\")\n  FString MyString;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that shrinks over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ShrinkingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AShrinkingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAShrinkingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Shrinking\")\n\tfloat ShrinkRate;\n};\n```", "cpp_code": "```cpp\n#include \"ShrinkingActor.h\"\n\nAShrinkingActor::AShrinkingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tShrinkRate = 0.1f; // Default shrink rate\n}\n\nvoid AShrinkingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AShrinkingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tFVector NewScale = GetActorScale3D();\n\tNewScale -= FVector(ShrinkRate * DeltaTime);\n\tNewScale = NewScale.GetClampedToMin(FVector(0.1f, 0.1f, 0.1f)); // Prevent scaling below a certain size\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a component that logs a message every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LoggingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULoggingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tULoggingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nULoggingComponent::ULoggingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid ULoggingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ULoggingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tUE_LOG(LogTemp, Warning, TEXT(\"LoggingComponent is ticking on actor: %s\"), *GetOwner()->GetName());\n}\n```"}
{"requirement": "Create an actor with a sound component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Components/AudioComponent.h\"\n#include \"SoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tASoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Audio\")\n\tUAudioComponent* AudioComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Audio\")\n\tUSoundBase* Sound;\n};\n```", "cpp_code": "```cpp\n#include \"SoundActor.h\"\n\nASoundActor::ASoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n}\n\nvoid ASoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (Sound)\n\t{\n\t\tAudioComponent->SetSound(Sound);\n\t\tAudioComponent->Play();\n\t}\n}\n\nvoid ASoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its material on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAChangeMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Materials\")\n\tUMaterialInterface* Material1;\n\n\tUPROPERTY(EditAnywhere, Category=\"Materials\")\n\tUMaterialInterface* Material2;\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n\tbool bUseMaterial1;\n\n\tvoid ChangeMaterial();\n\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerInput.h\"\n#include \"Engine/Engine.h\"\n\nAChangeMaterialActor::AChangeMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tbUseMaterial1 = true;\n}\n\nvoid AChangeMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Material1 && Material2)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n}\n\nvoid AChangeMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tInputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AChangeMaterialActor::ChangeMaterial);\n}\n\nvoid AChangeMaterialActor::ChangeMaterial()\n{\n\tif (bUseMaterial1)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material2);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n\tbUseMaterial1 = !bUseMaterial1;\n}\n```"}
{"requirement": "Create a class that sets its location on begin play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SetLocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASetLocationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tASetLocationActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Location to set on Begin Play\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Location\")\n\tFVector InitialLocation;\n};\n```", "cpp_code": "```cpp\n#include \"SetLocationActor.h\"\n\n// Sets default values\nASetLocationActor::ASetLocationActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t // Initialize default location\n\t InitialLocation = FVector(0.0f, 0.0f, 0.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ASetLocationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Set the actor's location\n\tSetActorLocation(InitialLocation);\n}\n```"}
{"requirement": "Create an actor that moves in a circle every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CircularMovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ACircularMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACircularMovingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector Center;\n\tfloat Radius;\n\tfloat AngularSpeed;\n\tfloat CurrentAngle;\n};\n```", "cpp_code": "```cpp\n#include \"CircularMovingActor.h\"\n\n// Sets default values\nACircularMovingActor::ACircularMovingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCenter = FVector(0.0f, 0.0f, 0.0f);\n\tRadius = 100.0f;\n\tAngularSpeed = 1.0f; // Radians per second\n\tCurrentAngle = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ACircularMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Optionally set the center to the actor's initial location\n\tCenter = GetActorLocation();\n}\n\n// Called every frame\nvoid ACircularMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tCurrentAngle += AngularSpeed * DeltaTime;\n\tfloat X = Center.X + Radius * FMath::Cos(CurrentAngle);\n\tfloat Y = Center.Y + Radius * FMath::Sin(CurrentAngle);\n\tfloat Z = Center.Z;\n\n\tSetActorLocation(FVector(X, Y, Z));\n}\n```"}
{"requirement": "Create a UFUNCTION to change an actor's color.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Color\")\n\tvoid ChangeColor(FLinearColor NewColor);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAColorChangeActor::AColorChangeActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AColorChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AColorChangeActor::ChangeColor(FLinearColor NewColor)\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that looks at the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LookAtPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALookAtPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tALookAtPlayerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"LookAtPlayerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nALookAtPlayerActor::ALookAtPlayerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ALookAtPlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid ALookAtPlayerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tif (PlayerActor)\n\t{\n\t\tFVector PlayerLocation = PlayerActor->GetActorLocation();\n\t\tFVector ActorLocation = GetActorLocation();\n\t\tFRotator LookAtRotation = FRotationMatrix::MakeFromX(PlayerLocation - ActorLocation).Rotator();\n\t\tSetActorRotation(LookAtRotation);\n\t}\n}\n```"}
{"requirement": "Create a simple cone actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimpleConeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimpleConeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASimpleConeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* ConeMesh;\n};\n```", "cpp_code": "```cpp\n#include \"SimpleConeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASimpleConeActor::ASimpleConeActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a StaticMeshComponent\n\tConeMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"ConeMesh\"));\n\tRootComponent = ConeMesh;\n\n\t// Set the cone mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> ConeMeshAsset(TEXT(\"/Engine/BasicShapes/Cone.Cone\"));\n\tif (ConeMeshAsset.Succeeded())\n\t{\n\t\tConeMesh->SetStaticMesh(ConeMeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ASimpleConeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASimpleConeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY array variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MyCategory\")\n\tTArray<int32> MyIntArray;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that plays a sound on begin play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"SoundActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundActor::ASoundActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that changes color when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ColorChangeComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UColorChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUColorChangeComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\t// Handle mouse click event\n\tUFUNCTION()\n\tvoid OnMouseClicked();\n\n\t// Change color function\n\tvoid ChangeColor();\n\n\t// Current color of the component\n\tFLinearColor CurrentColor;\n\n\t// Mesh component to change color\n\tUMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values for this component's properties\nUColorChangeComponent::UColorChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCurrentColor = FLinearColor::White;\n}\n\n// Called when the game starts\nvoid UColorChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tMeshComponent = Cast<UMeshComponent>(Owner->GetComponentByClass(UMeshComponent::StaticClass()));\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tMeshComponent->OnClicked.AddDynamic(this, &UColorChangeComponent::OnMouseClicked);\n\t\t}\n\t}\n}\n\n// Called every frame\nvoid UColorChangeComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UColorChangeComponent::OnMouseClicked()\n{\n\tChangeColor();\n}\n\nvoid UColorChangeComponent::ChangeColor()\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* MaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (MaterialInstance)\n\t\t{\n\t\t\tCurrentColor = FLinearColor(FMath::FRand(), FMath::FRand(), FMath::FRand(), 1.0f);\n\t\t\tMaterialInstance->SetVectorParameterValue(\"BaseColor\", CurrentColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a camera component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"MyCameraActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyCameraActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyCameraActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Camera component\n\tUPROPERTY(VisibleAnywhere)\n\tUCameraComponent* CameraComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyCameraActor.h\"\n\n// Sets default values\nAMyCameraActor::AMyCameraActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a CameraComponent and attach it to the root component\n\tCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"CameraComponent\"));\n\tRootComponent = CameraComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AMyCameraActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyCameraActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that logs its position every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ALoggingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  ALoggingActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic: \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingActor::ALoggingActor()\n{\n  // Set this actor to call Tick() every frame\n  PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  FVector Position = GetActorLocation();\n  UE_LOG(LogTemp, Log, TEXT(\"Actor Position: %s\"), *Position.ToString());\n}\n```"}
{"requirement": "Bind a key input to change an actor's material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AChangeMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAChangeMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n\n\tvoid ChangeMaterial();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInterface.h\"\n\nAChangeMaterialActor::AChangeMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AChangeMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AChangeMaterialActor::ChangeMaterial);\n}\n\nvoid AChangeMaterialActor::ChangeMaterial()\n{\n\tif (NewMaterial)\n\t{\n\t\tUStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that orbits around a point.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OrbitingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOrbitingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAOrbitingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Orbit\")\n\tFVector OrbitCenter;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Orbit\")\n\tfloat OrbitRadius;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Orbit\")\n\tfloat OrbitSpeed;\n\nprivate:\n\tfloat CurrentAngle;\n};\n```", "cpp_code": "```cpp\n#include \"OrbitingActor.h\"\n\nAOrbitingActor::AOrbitingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tOrbitCenter = FVector::ZeroVector;\n\tOrbitRadius = 300.0f;\n\tOrbitSpeed = 50.0f;\n\tCurrentAngle = 0.0f;\n}\n\nvoid AOrbitingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOrbitingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tCurrentAngle += OrbitSpeed * DeltaTime;\n\tif (CurrentAngle >= 360.0f)\n\t{\n\t\tCurrentAngle -= 360.0f;\n\t}\n\n\tfloat RadAngle = FMath::DegreesToRadians(CurrentAngle);\n\tFVector NewLocation;\n\tNewLocation.X = OrbitCenter.X + OrbitRadius * FMath::Cos(RadAngle);\n\tNewLocation.Y = OrbitCenter.Y + OrbitRadius * FMath::Sin(RadAngle);\n\tNewLocation.Z = OrbitCenter.Z; // Assuming orbit in XY plane only\n\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a simple cylinder actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CylinderActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ACylinderActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tACylinderActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* CylinderMesh;\n};\n```", "cpp_code": "```cpp\n#include \"CylinderActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACylinderActor::ACylinderActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create cylinder mesh component\n\tCylinderMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"CylinderMesh\"));\n\tRootComponent = CylinderMesh;\n\n\t// Set mesh to a cylinder\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> CylinderAsset(TEXT(\"/Engine/BasicShapes/Cylinder.Cylinder\"));\n\tif (CylinderAsset.Succeeded())\n\t{\n\t\tCylinderMesh->SetStaticMesh(CylinderAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ACylinderActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACylinderActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Create a UPROPERTY map variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMapActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAMapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Map\")\n\tTMap<FString, int32> StringToIntMap;\n};\n```", "cpp_code": "```cpp\n#include \"MapActor.h\"\n\n// Sets default values\nAMapActor::AMapActor()\n{\n\t // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that spawns another actor on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpawnActorOnKeyPress.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpawnActorOnKeyPress : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASpawnActorOnKeyPress();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere)\n\tTSubclassOf<AActor> ActorToSpawn;\n\n\tUPROPERTY(EditAnywhere)\n\tFKey SpawnKey;\n\nprivate:\n\tvoid HandleKeyPress();\n};\n```", "cpp_code": "```cpp\n#include \"SpawnActorOnKeyPress.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nASpawnActorOnKeyPress::ASpawnActorOnKeyPress()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASpawnActorOnKeyPress::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpawnActorOnKeyPress::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tHandleKeyPress();\n}\n\nvoid ASpawnActorOnKeyPress::HandleKeyPress()\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController && PlayerController->WasInputKeyJustPressed(SpawnKey))\n\t{\n\t\tif (ActorToSpawn)\n\t\t{\n\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\tGetWorld()->SpawnActor<AActor>(ActorToSpawn, GetActorLocation(), GetActorRotation(), SpawnParams);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a component that rotates around its parent.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"RotatingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API URotatingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tURotatingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingComponent.h\"\n\nURotatingComponent::URotatingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tRotationRate = FRotator(0.f, 45.f, 0.f); // Default rotation rate\n}\n\nvoid URotatingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotatingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFRotator NewRotation = Owner->GetActorRotation() + (RotationRate * DeltaTime);\n\t\tOwner->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY transform variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Transform\")\n\tFTransform MyTransform;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class with a custom tick interval.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomTickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomTickActor : public AActor\n{\n  GENERATED_BODY()\n  \npublic:  \n  ACustomTickActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:  \n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  float CustomTickInterval;\n  float TimeSinceLastTick;\n};\n```", "cpp_code": "```cpp\n#include \"CustomTickActor.h\"\n\nACustomTickActor::ACustomTickActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n  CustomTickInterval = 1.0f; // Set your desired tick interval here\n  TimeSinceLastTick = 0.0f;\n}\n\nvoid ACustomTickActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid ACustomTickActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  TimeSinceLastTick += DeltaTime;\n  if (TimeSinceLastTick >= CustomTickInterval)\n  {\n\tTimeSinceLastTick -= CustomTickInterval;\n\t// Place your custom tick logic here\n  }\n}\n```"}
{"requirement": "Create an actor that scales down to a minimum size.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat MinScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat ScalingSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMinScale = 0.1f;\n\tScalingSpeed = 0.1f;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentScale = GetActorScale3D();\n\n\tif (CurrentScale.GetMin() > MinScale)\n\t{\n\t\tFVector NewScale = CurrentScale - FVector(ScalingSpeed * DeltaTime);\n\t\tNewScale.X = FMath::Max(NewScale.X, MinScale);\n\t\tNewScale.Y = FMath::Max(NewScale.Y, MinScale);\n\t\tNewScale.Z = FMath::Max(NewScale.Z, MinScale);\n\n\t\tSetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Create a UFUNCTION to destroy an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DestroyActorFunction.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADestroyActorFunction : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Actor\")\n\tvoid DestroyActor();\n};\n```", "cpp_code": "```cpp\n#include \"DestroyActorFunction.h\"\n\nvoid ADestroyActorFunction::DestroyActor()\n{\n\tif (IsValid(this))\n\t{\n\t\tDestroy();\n\t}\n}\n```"}
{"requirement": "Create an actor that moves towards the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MoveToPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMoveToPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMoveToPlayerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MoveSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MoveToPlayerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Character.h\"\n\nAMoveToPlayerActor::AMoveToPlayerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMoveSpeed = 300.0f; // Default move speed\n}\n\nvoid AMoveToPlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMoveToPlayerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tACharacter* PlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);\n\tif (PlayerCharacter)\n\t{\n\t\tFVector Direction = (PlayerCharacter->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n\t\tFVector NewLocation = GetActorLocation() + (Direction * MoveSpeed * DeltaTime);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create a simple capsule actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimpleCapsuleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimpleCapsuleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASimpleCapsuleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUCapsuleComponent* CapsuleComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SimpleCapsuleActor.h\"\n#include \"Components/CapsuleComponent.h\"\n\n// Sets default values\nASimpleCapsuleActor::ASimpleCapsuleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create capsule component and attach it to the root\n\tCapsuleComponent = CreateDefaultSubobject<UCapsuleComponent>(TEXT(\"CapsuleComponent\"));\n\tRootComponent = CapsuleComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ASimpleCapsuleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASimpleCapsuleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY enum variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUENUM(BlueprintType)\nenum class EMyEnum : uint8\n{\n\tOption1 UMETA(DisplayName = \"Option 1\"),\n\tOption2 UMETA(DisplayName = \"Option 2\"),\n\tOption3 UMETA(DisplayName = \"Option 3\")\n};\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"MyEnum\")\n\tEMyEnum MyEnumVariable;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes mesh on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ChangeMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAChangeMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Mesh components\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Meshes to switch between\n\tUPROPERTY(EditAnywhere)\n\tUStaticMesh* Mesh1;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMesh* Mesh2;\n\n\t// Function to change the mesh\n\tvoid ChangeMesh();\n\nprivate:\n\t// Boolean to track the current mesh\n\tbool bUsingMesh1;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMeshActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAChangeMeshActor::AChangeMeshActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tbUsingMesh1 = true;\n}\n\n// Called when the game starts or when spawned\nvoid AChangeMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (InputComponent)\n\t{\n\t\tInputComponent->BindAction(\"ChangeMesh\", IE_Pressed, this, &AChangeMeshActor::ChangeMesh);\n\t}\n\n\tif (Mesh1)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh1);\n\t}\n}\n\n// Called every frame\nvoid AChangeMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to change the mesh\nvoid AChangeMeshActor::ChangeMesh()\n{\n\tif (bUsingMesh1 && Mesh2)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh2);\n\t\tbUsingMesh1 = false;\n\t}\n\telse if (Mesh1)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh1);\n\t\tbUsingMesh1 = true;\n\t}\n}\n```"}
{"requirement": "Create a component that changes scale when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleOnClickComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECTNAME_API UScaleOnClickComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUScaleOnClickComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFVector OriginalScale;\n\tFVector TargetScale;\n\tbool bIsScaled;\n\n\tUFUNCTION()\n\tvoid OnMouseClicked(AActor* TouchedActor, FKey ButtonPressed);\n\n\tvoid ToggleScale();\n};\n```", "cpp_code": "```cpp\n#include \"ScaleOnClickComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values for this component's properties\nUScaleOnClickComponent::UScaleOnClickComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tbIsScaled = false;\n\tTargetScale = FVector(2.0f, 2.0f, 2.0f);\n}\n\n// Called when the game starts\nvoid UScaleOnClickComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOriginalScale = Owner->GetActorScale3D();\n\n\t\tOwner->OnClicked.AddDynamic(this, &UScaleOnClickComponent::OnMouseClicked);\n\t}\n}\n\n// Called every frame\nvoid UScaleOnClickComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UScaleOnClickComponent::OnMouseClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tToggleScale();\n}\n\nvoid UScaleOnClickComponent::ToggleScale()\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tif (bIsScaled)\n\t\t{\n\t\t\tOwner->SetActorScale3D(OriginalScale);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOwner->SetActorScale3D(TargetScale);\n\t\t}\n\t\tbIsScaled = !bIsScaled;\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store another actor reference.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAYourActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"References\")\n\tAActor* OtherActorReference;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\n// Sets default values\nAYourActor::AYourActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create an actor with an audio component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"MyAudioActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyAudioActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMyAudioActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Audio\")\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyAudioActor.h\"\n\n// Sets default values\nAMyAudioActor::AMyAudioActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach an audio component\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n}\n\n// Called when the game starts or when spawned\nvoid AMyAudioActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyAudioActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that reverses movement on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReversibleMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AReversibleMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAReversibleMovementActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tFVector MovementDirection;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MovementSpeed;\n\n\tUFUNCTION()\n\tvoid OnCollision(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"ReversibleMovementActor.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nAReversibleMovementActor::AReversibleMovementActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementDirection = FVector(1.0f, 0.0f, 0.0f);\n\tMovementSpeed = 100.0f;\n\n\tUPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(RootComponent);\n\tif (PrimitiveComponent)\n\t{\n\t\tPrimitiveComponent->OnComponentHit.AddDynamic(this, &AReversibleMovementActor::OnCollision);\n\t}\n}\n\nvoid AReversibleMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AReversibleMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation() + (MovementDirection * MovementSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n\nvoid AReversibleMovementActor::OnCollision(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tMovementDirection = -MovementDirection;\n}\n```"}
{"requirement": "Create an actor that toggles visibility every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAToggleVisibilityActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ToggleVisibility();\n\tFTimerHandle VisibilityToggleTimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"TimerManager.h\"\n\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorld()->GetTimerManager().SetTimer(VisibilityToggleTimerHandle, this, &AToggleVisibilityActor::ToggleVisibility, 1.0f, true);\n}\n\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tSetActorHiddenInGame(!bHidden);\n}\n```"}
{"requirement": "Bind a key input to play a sound.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundPlayer.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayer : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundPlayer();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere)\n\tUSoundCue* SoundToPlay;\n\n\tvoid PlaySound();\n};\n```", "cpp_code": "```cpp\n#include \"SoundPlayer.h\"\n#include \"Components/InputComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundPlayer::ASoundPlayer()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASoundPlayer::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (InputComponent)\n\t{\n\t\tInputComponent->BindAction(\"PlaySound\", IE_Pressed, this, &ASoundPlayer::PlaySound);\n\t}\n}\n\nvoid ASoundPlayer::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundPlayer::PlaySound()\n{\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create an actor with a spotlight component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpotlightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpotlightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpotlightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUSpotLightComponent* SpotlightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SpotlightActor.h\"\n#include \"Components/SpotLightComponent.h\"\n\n// Sets default values\nASpotlightActor::ASpotlightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the spotlight component and attach it to the root\n\tSpotlightComponent = CreateDefaultSubobject<USpotLightComponent>(TEXT(\"SpotlightComponent\"));\n\tRootComponent = SpotlightComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ASpotlightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ASpotlightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a mesh component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAYourActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAYourActor::AYourActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that respawns at a location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RespawnActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARespawnActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARespawnActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Respawn location\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Respawn\")\n\tFVector RespawnLocation;\n\n\t// Respawn the actor at the specified location\n\tUFUNCTION(BlueprintCallable, Category=\"Respawn\")\n\tvoid Respawn();\n};\n```", "cpp_code": "```cpp\n#include \"RespawnActor.h\"\n\n// Sets default values\nARespawnActor::ARespawnActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ARespawnActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARespawnActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARespawnActor::Respawn()\n{\n\tSetActorLocation(RespawnLocation);\n}\n```"}
{"requirement": "Create a component with a boolean flag to toggle behavior.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleBehaviorComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UToggleBehaviorComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUToggleBehaviorComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\t// Boolean flag to toggle behavior\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Toggle\")\n\tbool bToggleBehavior;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleBehaviorComponent.h\"\n\n// Sets default values for this component's properties\nUToggleBehaviorComponent::UToggleBehaviorComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\t// Initialize the toggle flag\n\tbToggleBehavior = false;\n}\n\n// Called when the game starts\nvoid UToggleBehaviorComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Custom initialization can be added here\n}\n\n// Called every frame\nvoid UToggleBehaviorComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Toggle behavior based on the flag\n\tif (bToggleBehavior)\n\t{\n\t\t// Add code for the behavior when the flag is true\n\t}\n\telse\n\t{\n\t\t// Add code for the behavior when the flag is false\n\t}\n}\n```"}
{"requirement": "Create an actor that moves randomly every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARandomMover();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFTimerHandle MovementTimerHandle;\n\n\tvoid MoveRandomly();\n};\n```", "cpp_code": "```cpp\n#include \"RandomMover.h\"\n#include \"TimerManager.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\n// Sets default values\nARandomMover::ARandomMover()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ARandomMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Set timer to call MoveRandomly every second\n\tGetWorldTimerManager().SetTimer(MovementTimerHandle, this, &ARandomMover::MoveRandomly, 1.0f, true);\n}\n\n// Called every frame\nvoid ARandomMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Move the actor to a random location\nvoid ARandomMover::MoveRandomly()\n{\n\tFVector NewLocation = UKismetMathLibrary::RandomUnitVector() * 100.0f + GetActorLocation();\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a dynamic material instance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Materials\")\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nAYourActor::AYourActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Example of initializing the dynamic material instance\n\tUMaterialInterface* Material = LoadObject<UMaterialInterface>(nullptr, TEXT(\"/Game/YourMaterialPath.YourMaterialName\"));\n\tif (Material)\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(Material, this);\n\t}\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that reports its scale every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleReporter.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleReporter : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAScaleReporter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ReportScale() const;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleReporter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n\n// Sets default values\nAScaleReporter::AScaleReporter()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AScaleReporter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScaleReporter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tReportScale();\n}\n\nvoid AScaleReporter::ReportScale() const\n{\n\tFVector Scale = GetActorScale3D();\n\tUE_LOG(LogTemp, Log, TEXT(\"Scale: X=%f, Y=%f, Z=%f\"), Scale.X, Scale.Y, Scale.Z);\n}\n```"}
{"requirement": "Create an actor that changes light intensity over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightIntensityChanger.generated.h\"\n\nUCLASS()\nclass ALightIntensityChanger : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  ALightIntensityChanger();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Light\")\n  class UPointLightComponent* PointLight;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Light\")\n  float IntensityChangeRate;\n};\n```", "cpp_code": "```cpp\n#include \"LightIntensityChanger.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nALightIntensityChanger::ALightIntensityChanger()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  PointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n  RootComponent = PointLight;\n\n  IntensityChangeRate = 50.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ALightIntensityChanger::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid ALightIntensityChanger::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  if (PointLight)\n  {\n\tfloat NewIntensity = PointLight->Intensity + (IntensityChangeRate * DeltaTime);\n\tPointLight->SetIntensity(NewIntensity);\n  }\n}\n```"}
{"requirement": "Create a simple torus actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TorusActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATorusActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATorusActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Torus mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* TorusMesh;\n};\n```", "cpp_code": "```cpp\n#include \"TorusActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nATorusActor::ATorusActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set the static mesh component\n\tTorusMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"TorusMesh\"));\n\tRootComponent = TorusMesh;\n\n\t// Find the torus mesh asset\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> TorusAsset(TEXT(\"/Engine/BasicShapes/Torus.Torus\"));\n\tif (TorusAsset.Succeeded())\n\t{\n\t\tTorusMesh->SetStaticMesh(TorusAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ATorusActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATorusActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY FText variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"My Category\")\n\tFText MyTextVariable;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes location with a timeline.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"LocationTimelineActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALocationTimelineActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALocationTimelineActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFTimeline LocationTimeline;\n\n\tUFUNCTION()\n\tvoid HandleProgress(float Value);\n\n\tUPROPERTY(EditAnywhere, Category = \"Timeline\")\n\tUCurveFloat* LocationCurve;\n\n\tFVector StartLocation;\n\tFVector EndLocation;\n};\n```", "cpp_code": "```cpp\n#include \"LocationTimelineActor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nALocationTimelineActor::ALocationTimelineActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALocationTimelineActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (LocationCurve)\n\t{\n\t\tFOnTimelineFloat ProgressFunction;\n\t\tProgressFunction.BindUFunction(this, FName(\"HandleProgress\"));\n\n\t\tLocationTimeline.AddInterpFloat(LocationCurve, ProgressFunction);\n\t\tLocationTimeline.SetLooping(false);\n\n\t\tStartLocation = GetActorLocation();\n\t\tEndLocation = StartLocation + FVector(100.0f, 0.0f, 0.0f); // Example end location\n\n\t\tLocationTimeline.PlayFromStart();\n\t}\n}\n\n// Called every frame\nvoid ALocationTimelineActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tLocationTimeline.TickTimeline(DeltaTime);\n}\n\nvoid ALocationTimelineActor::HandleProgress(float Value)\n{\n\tFVector NewLocation = FMath::Lerp(StartLocation, EndLocation, Value);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a component that logs its parent actor's name.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LogParentActorComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API ULogParentActorComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tULogParentActorComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"LogParentActorComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values for this component's properties\nULogParentActorComponent::ULogParentActorComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid ULogParentActorComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Parent Actor Name: %s\"), *Owner->GetName());\n\t}\n}\n```"}
{"requirement": "Create an actor that plays an animation on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"AnimationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAnimationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAAnimationActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Animation\")\n\tUAnimSequence* AnimationToPlay;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Animation\")\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n\n\tvoid PlayAnimation();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n};\n```", "cpp_code": "```cpp\n#include \"AnimationActor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/InputSettings.h\"\n\nAAnimationActor::AAnimationActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n}\n\nvoid AAnimationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tEnableInput(PlayerController);\n\t\tSetupPlayerInputComponent(InputComponent);\n\t}\n}\n\nvoid AAnimationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AAnimationActor::PlayAnimation()\n{\n\tif (SkeletalMeshComponent && AnimationToPlay)\n\t{\n\t\tSkeletalMeshComponent->PlayAnimation(AnimationToPlay, false);\n\t}\n}\n\nvoid AAnimationActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"PlayAnimation\", IE_Pressed, this, &AAnimationActor::PlayAnimation);\n\t}\n}\n```"}
{"requirement": "Create a class that rotates to face a specified direction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Rotation\")\n\tvoid RotateToFaceDirection(const FVector& TargetDirection);\n\nprivate:\n\tFVector CurrentDirection;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCurrentDirection = GetActorForwardVector();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARotatingActor::RotateToFaceDirection(const FVector& TargetDirection)\n{\n\tif (!TargetDirection.IsNearlyZero())\n\t{\n\t\tFRotator TargetRotation = UKismetMathLibrary::MakeRotFromX(TargetDirection);\n\t\tSetActorRotation(TargetRotation);\n\t\tCurrentDirection = TargetDirection;\n\t}\n}\n```"}
{"requirement": "Create an actor that orbits another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OrbitingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOrbitingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOrbitingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAActor* TargetActor;\n\tfloat OrbitRadius;\n\tfloat OrbitSpeed;\n\tfloat CurrentAngle;\n\npublic:\n\tvoid SetTargetActor(AActor* NewTarget);\n\tvoid SetOrbitRadius(float NewRadius);\n\tvoid SetOrbitSpeed(float NewSpeed);\n};\n```", "cpp_code": "```cpp\n#include \"OrbitingActor.h\"\n\nAOrbitingActor::AOrbitingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTargetActor = nullptr;\n\tOrbitRadius = 300.0f;\n\tOrbitSpeed = 50.0f;\n\tCurrentAngle = 0.0f;\n}\n\nvoid AOrbitingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOrbitingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tCurrentAngle += OrbitSpeed * DeltaTime;\n\t\tif (CurrentAngle >= 360.0f)\n\t\t{\n\t\t\tCurrentAngle -= 360.0f;\n\t\t}\n\n\t\tfloat RadAngle = FMath::DegreesToRadians(CurrentAngle);\n\t\tFVector NewLocation = TargetActor->GetActorLocation();\n\t\tNewLocation.X += OrbitRadius * FMath::Cos(RadAngle);\n\t\tNewLocation.Y += OrbitRadius * FMath::Sin(RadAngle);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n\nvoid AOrbitingActor::SetTargetActor(AActor* NewTarget)\n{\n\tTargetActor = NewTarget;\n}\n\nvoid AOrbitingActor::SetOrbitRadius(float NewRadius)\n{\n\tOrbitRadius = NewRadius;\n}\n\nvoid AOrbitingActor::SetOrbitSpeed(float NewSpeed)\n{\n\tOrbitSpeed = NewSpeed;\n}\n```"}
{"requirement": "Create an actor that moves in a zig-zag pattern.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ZigZagActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AZigZagActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAZigZagActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector StartLocation;\n\tfloat MoveSpeed;\n\tfloat ZigZagAmplitude;\n\tfloat ZigZagFrequency;\n\tfloat RunningTime;\n};\n```", "cpp_code": "```cpp\n#include \"ZigZagActor.h\"\n\nAZigZagActor::AZigZagActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMoveSpeed = 100.0f;\n\tZigZagAmplitude = 100.0f;\n\tZigZagFrequency = 1.0f;\n\tRunningTime = 0.0f;\n}\n\nvoid AZigZagActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartLocation = GetActorLocation();\n}\n\nvoid AZigZagActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tRunningTime += DeltaTime;\n\tFVector NewLocation = StartLocation;\n\tNewLocation.X += MoveSpeed * RunningTime;\n\tNewLocation.Y += ZigZagAmplitude * FMath::Sin(ZigZagFrequency * RunningTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a simple tetrahedron actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TetrahedronActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ATetrahedronActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATetrahedronActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUProceduralMeshComponent* Mesh;\n\n\tvoid CreateTetrahedron();\n};\n```", "cpp_code": "```cpp\n#include \"TetrahedronActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\n// Sets default values\nATetrahedronActor::ATetrahedronActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"TetrahedronMesh\"));\n\tRootComponent = Mesh;\n\n\tCreateTetrahedron();\n}\n\n// Called when the game starts or when spawned\nvoid ATetrahedronActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATetrahedronActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATetrahedronActor::CreateTetrahedron()\n{\n\tTArray<FVector> Vertices;\n\tTArray<int32> Triangles;\n\n\t// Define vertices for a tetrahedron\n\tVertices.Add(FVector(0, 0, 0));  // Vertex 0\n\tVertices.Add(FVector(100, 0, 0));  // Vertex 1\n\tVertices.Add(FVector(50, 87, 0));  // Vertex 2\n\tVertices.Add(FVector(50, 29, 80));  // Vertex 3\n\n\t// Define triangles\n\tTriangles.Add(0);\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\n\tTriangles.Add(0);\n\tTriangles.Add(1);\n\tTriangles.Add(3);\n\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\tTriangles.Add(3);\n\n\tTriangles.Add(2);\n\tTriangles.Add(0);\n\tTriangles.Add(3);\n\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\tTArray<FProcMeshTangent> Tangents;\n\tTArray<FColor> VertexColors;\n\n\tMesh->CreateMeshSection_LinearColor(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a pointer to a player controller.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY()\n\tAPlayerController* PlayerController;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that creates a light beam.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightBeamActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALightBeamActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALightBeamActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* BeamMesh;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUSpotLightComponent* LightBeam;\n};\n```", "cpp_code": "```cpp\n#include \"LightBeamActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/SpotLightComponent.h\"\n\n// Sets default values\nALightBeamActor::ALightBeamActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component\n\tBeamMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"BeamMesh\"));\n\tRootComponent = BeamMesh;\n\n\t// Create light component\n\tLightBeam = CreateDefaultSubobject<USpotLightComponent>(TEXT(\"LightBeam\"));\n\tLightBeam->SetupAttachment(RootComponent);\n\tLightBeam->Intensity = 5000.0f;\n\tLightBeam->AttenuationRadius = 1000.0f;\n\tLightBeam->OuterConeAngle = 25.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ALightBeamActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALightBeamActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a component that checks for overlaps.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"OverlapCheckerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UOverlapCheckerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUOverlapCheckerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n\nprivate:\n\tUPROPERTY()\n\tUPrimitiveComponent* OwnerPrimitive;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapCheckerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUOverlapCheckerComponent::UOverlapCheckerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UOverlapCheckerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwnerPrimitive = Owner->FindComponentByClass<UPrimitiveComponent>();\n\t\tif (OwnerPrimitive)\n\t\t{\n\t\t\tOwnerPrimitive->OnComponentBeginOverlap.AddDynamic(this, &UOverlapCheckerComponent::OnOverlapBegin);\n\t\t\tOwnerPrimitive->OnComponentEndOverlap.AddDynamic(this, &UOverlapCheckerComponent::OnOverlapEnd);\n\t\t}\n\t}\n}\n\nvoid UOverlapCheckerComponent::OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != GetOwner()))\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlap Begin with %s\"), *OtherActor->GetName());\n\t}\n}\n\nvoid UOverlapCheckerComponent::OnOverlapEnd(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (OtherActor && (OtherActor != GetOwner()))\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlap End with %s\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Create a class with a custom destructor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n\nclass FMyCustomClass\n{\npublic:\n\tFMyCustomClass();\n\t~FMyCustomClass();\n};\n```", "cpp_code": "```cpp\n#include \"MyCustomClass.h\"\n\nFMyCustomClass::FMyCustomClass()\n{\n\t// Constructor logic\n}\n\nFMyCustomClass::~FMyCustomClass()\n{\n\t// Custom destructor logic\n}\n```"}
{"requirement": "Create an actor that stops moving after a collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionStopActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionStopActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tACollisionStopActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called when the actor hits something\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector MovementVelocity;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionStopActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nACollisionStopActor::ACollisionStopActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ACollisionStopActor::OnHit);\n\n\tMovementVelocity = FVector(100.0f, 0.0f, 0.0f); // Example initial velocity\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionStopActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionStopActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!MovementVelocity.IsZero())\n\t{\n\t\tFVector NewLocation = GetActorLocation() + (MovementVelocity * DeltaTime);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n\nvoid ACollisionStopActor::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\t// Stop movement upon collision\n\tMovementVelocity = FVector::ZeroVector;\n}\n```"}
{"requirement": "Create a UPROPERTY FColor variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Color\")\n\tFColor MyColor;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\t// Set default values\n\tMyColor = FColor::White;\n}\n```"}
{"requirement": "Create an actor that changes mesh every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MeshChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMeshChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMeshChangeActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tTArray<UStaticMesh*> Meshes;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tint32 CurrentMeshIndex;\n\tfloat TimeSinceLastChange;\n};\n```", "cpp_code": "```cpp\n#include \"MeshChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nAMeshChangeActor::AMeshChangeActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tCurrentMeshIndex = 0;\n\tTimeSinceLastChange = 0.0f;\n}\n\nvoid AMeshChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Meshes.Num() > 0)\n\t{\n\t\tMeshComponent->SetStaticMesh(Meshes[CurrentMeshIndex]);\n\t}\n}\n\nvoid AMeshChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (Meshes.Num() > 0)\n\t{\n\t\tTimeSinceLastChange += DeltaTime;\n\t\tif (TimeSinceLastChange >= 1.0f)\n\t\t{\n\t\t\tTimeSinceLastChange = 0.0f;\n\t\t\tCurrentMeshIndex = (CurrentMeshIndex + 1) % Meshes.Num();\n\t\t\tMeshComponent->SetStaticMesh(Meshes[CurrentMeshIndex]);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a component that can be toggled on/off with a key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleableComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UToggleableComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUToggleableComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void SetupInputComponent();\n\n\tUFUNCTION()\n\tvoid ToggleActive();\n\nprivate:\n\tbool bIsActive;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleableComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nUToggleableComponent::UToggleableComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbIsActive = true;\n}\n\nvoid UToggleableComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetupInputComponent();\n}\n\nvoid UToggleableComponent::SetupInputComponent()\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tInputComponent = NewObject<UInputComponent>(this);\n\t\tInputComponent->RegisterComponent();\n\t\tInputComponent->BindAction(\"ToggleComponent\", IE_Pressed, this, &UToggleableComponent::ToggleActive);\n\t\tPlayerController->PushInputComponent(InputComponent);\n\t}\n}\n\nvoid UToggleableComponent::ToggleActive()\n{\n\tbIsActive = !bIsActive;\n\tSetComponentTickEnabled(bIsActive);\n\tUE_LOG(LogTemp, Warning, TEXT(\"Component is now %s\"), bIsActive ? TEXT(\"Active\") : TEXT(\"Inactive\"));\n}\n```"}
{"requirement": "Create a UFUNCTION to set an actor's scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScaleActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"ActorScale\")\n\tvoid SetActorScale(FVector NewScale);\n};\n```", "cpp_code": "```cpp\n#include \"ScaleActor.h\"\n\nAScaleActor::AScaleActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AScaleActor::SetActorScale(FVector NewScale)\n{\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create an actor that follows a spline path.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SplineComponent.h\"\n#include \"SplineFollowerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ASplineFollowerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tASplineFollowerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUSplineComponent* SplineComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Spline\")\n\tfloat Speed = 100.0f;\n\n\tfloat DistanceAlongSpline;\n};\n```", "cpp_code": "```cpp\n#include \"SplineFollowerActor.h\"\n#include \"Components/SplineComponent.h\"\n\nASplineFollowerActor::ASplineFollowerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSplineComponent = CreateDefaultSubobject<USplineComponent>(TEXT(\"SplineComponent\"));\n\tRootComponent = SplineComponent;\n\n\tDistanceAlongSpline = 0.0f;\n}\n\nvoid ASplineFollowerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASplineFollowerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (SplineComponent)\n\t{\n\t\tDistanceAlongSpline += Speed * DeltaTime;\n\t\tconst float SplineLength = SplineComponent->GetSplineLength();\n\t\tif (DistanceAlongSpline > SplineLength)\n\t\t{\n\t\t\tDistanceAlongSpline = 0.0f;\n\t\t}\n\n\t\tconst FVector NewLocation = SplineComponent->GetLocationAtDistanceAlongSpline(DistanceAlongSpline, ESplineCoordinateSpace::World);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create a simple icosahedron actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"IcosahedronActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AIcosahedronActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAIcosahedronActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* IcosahedronMesh;\n};\n```", "cpp_code": "```cpp\n#include \"IcosahedronActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAIcosahedronActor::AIcosahedronActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tIcosahedronMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"IcosahedronMesh\"));\n\tRootComponent = IcosahedronMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> IcosahedronAsset(TEXT(\"/Engine/BasicShapes/Icosahedron.Icosahedron\"));\n\tif (IcosahedronAsset.Succeeded())\n\t{\n\t\tIcosahedronMesh->SetStaticMesh(IcosahedronAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AIcosahedronActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AIcosahedronActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a sound cue.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"MySoundActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMySoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMySoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundCue* SoundCueReference;\n};\n```", "cpp_code": "```cpp\n#include \"MySoundActor.h\"\n\n// Sets default values\nAMySoundActor::AMySoundActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMySoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMySoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create an actor that changes its material every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUMaterialInterface* CurrentMaterial;\n\tTArray<UMaterialInterface*> MaterialList;\n\tint32 MaterialIndex;\n\n\tvoid InitializeMaterials();\n};\n```", "cpp_code": "```cpp\n#include \"MaterialChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMaterialChangingActor::AMaterialChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMaterialIndex = 0;\n\n\tInitializeMaterials();\n}\n\nvoid AMaterialChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMaterialChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (MaterialList.Num() > 0)\n\t{\n\t\tMaterialIndex = (MaterialIndex + 1) % MaterialList.Num();\n\t\tCurrentMaterial = MaterialList[MaterialIndex];\n\n\t\tUStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tMeshComponent->SetMaterial(0, CurrentMaterial);\n\t\t}\n\t}\n}\n\nvoid AMaterialChangingActor::InitializeMaterials()\n{\n\t// Example of adding materials. Replace with your actual materials.\n\tConstructorHelpers::FObjectFinder<UMaterialInterface> Material1(TEXT(\"/Game/Materials/Material1.Material1\"));\n\tConstructorHelpers::FObjectFinder<UMaterialInterface> Material2(TEXT(\"/Game/Materials/Material2.Material2\"));\n\n\tif (Material1.Succeeded())\n\t{\n\t\tMaterialList.Add(Material1.Object);\n\t}\n\n\tif (Material2.Succeeded())\n\t{\n\t\tMaterialList.Add(Material2.Object);\n\t}\n}\n```"}
{"requirement": "Create a component that changes mesh based on UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"MeshChangerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UMeshChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUMeshChangerComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\t// UPROPERTY to change the mesh\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mesh\")\n\tUStaticMesh* NewMesh;\n\n\t// Function to change the mesh\n\tUFUNCTION(BlueprintCallable, Category = \"Mesh\")\n\tvoid ChangeMesh();\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MeshChangerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values for this component's properties\nUMeshChangerComponent::UMeshChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\n// Called when the game starts\nvoid UMeshChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tMeshComponent = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t}\n}\n\n// Called every frame\nvoid UMeshChangerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UMeshChangerComponent::ChangeMesh()\n{\n\tif (MeshComponent && NewMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(NewMesh);\n\t}\n}\n```"}
{"requirement": "Create an actor with a visual effect component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VisualEffectActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVisualEffectActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAVisualEffectActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Visual effect component\n\tUParticleSystemComponent* VisualEffectComponent;\n};\n```", "cpp_code": "```cpp\n#include \"VisualEffectActor.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n\n// Sets default values\nAVisualEffectActor::AVisualEffectActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach the visual effect component\n\tVisualEffectComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"VisualEffectComponent\"));\n\tRootComponent = VisualEffectComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AVisualEffectActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AVisualEffectActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that adjusts its transparency over time.", "header_code": "```cpp\nUCLASS()\nclass YOURPROJECT_API ATransparencyAdjuster : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATransparencyAdjuster();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat TransparencyChangeRate;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\n\tfloat CurrentOpacity;\n};\n```", "cpp_code": "```cpp\n#include \"TransparencyAdjuster.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nATransparencyAdjuster::ATransparencyAdjuster()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTransparencyChangeRate = 0.1f;\n\tCurrentOpacity = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ATransparencyAdjuster::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tUStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInterface* Material = MeshComponent->GetMaterial(0);\n\t\tif (Material)\n\t\t{\n\t\t\tDynamicMaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamicFromMaterial(0, Material);\n\t\t}\n\t}\n}\n\n// Called every frame\nvoid ATransparencyAdjuster::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterialInstance)\n\t{\n\t\tCurrentOpacity -= TransparencyChangeRate * DeltaTime;\n\t\tif (CurrentOpacity < 0.0f)\n\t\t{\n\t\t\tCurrentOpacity = 0.0f;\n\t\t}\n\t\tDynamicMaterialInstance->SetScalarParameterValue(TEXT(\"Opacity\"), CurrentOpacity);\n\t}\n}\n```"}
{"requirement": "Create an actor that can be picked up on click.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PickupActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APickupActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPickupActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"PickupActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nAPickupActor::APickupActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->OnClicked.AddDynamic(this, &APickupActor::OnClicked);\n}\n\nvoid APickupActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APickupActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APickupActor::OnClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed)\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tFVector Location;\n\t\tFRotator Rotation;\n\t\tPlayerController->GetPlayerViewPoint(Location, Rotation);\n\n\t\tFVector ForwardVector = Rotation.Vector();\n\t\tFVector PickupLocation = Location + ForwardVector * 200.f;\n\n\t\tMeshComponent->SetWorldLocation(PickupLocation);\n\t}\n}\n```"}
{"requirement": "Create an actor that moves with a sine wave pattern.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SineWaveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASineWaveActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tASineWaveActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialLocation;\n\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Amplitude;\n\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Frequency;\n\n\tfloat RunningTime;\n};\n```", "cpp_code": "```cpp\n#include \"SineWaveActor.h\"\n\nASineWaveActor::ASineWaveActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tAmplitude = 100.0f;\n\tFrequency = 1.0f;\n\tRunningTime = 0.0f;\n}\n\nvoid ASineWaveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialLocation = GetActorLocation();\n}\n\nvoid ASineWaveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRunningTime += DeltaTime;\n\tfloat DeltaHeight = Amplitude * FMath::Sin(Frequency * RunningTime);\n\tFVector NewLocation = InitialLocation;\n\tNewLocation.Z += DeltaHeight;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a simple dodecahedron actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DodecahedronActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADodecahedronActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tADodecahedronActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* DodecahedronMesh;\n};\n```", "cpp_code": "```cpp\n#include \"DodecahedronActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nADodecahedronActor::ADodecahedronActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tDodecahedronMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"DodecahedronMesh\"));\n\tRootComponent = DodecahedronMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Engine/BasicShapes/Dodecahedron.Dodecahedron'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tDodecahedronMesh->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ADodecahedronActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADodecahedronActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a light component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Components/LightComponent.h\"\n#include \"MyLightComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass MYPROJECT_API UMyLightComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMyLightComponent();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light\")\n\tULightComponent* LightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyLightComponent.h\"\n\nUMyLightComponent::UMyLightComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n```"}
{"requirement": "Create an actor that changes its shape with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ShapeShifter.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AShapeShifter : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAShapeShifter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ChangeShape();\n\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMesh* CubeMesh;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMesh* SphereMesh;\n\n\tbool bIsCube;\n\n\tvoid SetupInputComponent();\n\n};\n```", "cpp_code": "```cpp\n#include \"ShapeShifter.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAShapeShifter::AShapeShifter()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> CubeMeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> SphereMeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere\"));\n\n\tif (CubeMeshAsset.Succeeded())\n\t{\n\t\tCubeMesh = CubeMeshAsset.Object;\n\t}\n\n\tif (SphereMeshAsset.Succeeded())\n\t{\n\t\tSphereMesh = SphereMeshAsset.Object;\n\t}\n\n\tbIsCube = true;\n\tMeshComponent->SetStaticMesh(CubeMesh);\n}\n\n// Called when the game starts or when spawned\nvoid AShapeShifter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tSetupInputComponent();\n}\n\nvoid AShapeShifter::SetupInputComponent()\n{\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tEnableInput(PlayerController);\n\t\tInputComponent->BindAction(\"ChangeShape\", IE_Pressed, this, &AShapeShifter::ChangeShape);\n\t}\n}\n\n// Called every frame\nvoid AShapeShifter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AShapeShifter::ChangeShape()\n{\n\tbIsCube = !bIsCube;\n\n\tif (bIsCube)\n\t{\n\t\tMeshComponent->SetStaticMesh(CubeMesh);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetStaticMesh(SphereMesh);\n\t}\n}\n```"}
{"requirement": "Create a component that emits particles on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"ParticleEmitterComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UParticleEmitterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUParticleEmitterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void OnComponentHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\n\tUPROPERTY(EditAnywhere, Category=\"Effects\")\n\tUParticleSystem* ParticleEffect;\n};\n```", "cpp_code": "```cpp\n#include \"ParticleEmitterComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nUParticleEmitterComponent::UParticleEmitterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UParticleEmitterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif(AActor* Owner = GetOwner())\n\t{\n\t\tif(UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(Owner->GetComponentByClass(UPrimitiveComponent::StaticClass())))\n\t\t{\n\t\t\tPrimitiveComponent->OnComponentHit.AddDynamic(this, &UParticleEmitterComponent::OnComponentHit);\n\t\t}\n\t}\n}\n\nvoid UParticleEmitterComponent::OnComponentHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif(ParticleEffect)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ParticleEffect, Hit.ImpactPoint, FRotator::ZeroRotator);\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a particle system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"MyParticleActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyParticleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyParticleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Particles\")\n\tUParticleSystem* ParticleSystemReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyParticleActor.h\"\n\n// Sets default values\nAMyParticleActor::AMyParticleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyParticleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyParticleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create an actor that deactivates on a specific key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DeactivatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ADeactivatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADeactivatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Function to handle deactivation\n\tvoid DeactivateActor();\n};\n```", "cpp_code": "```cpp\n#include \"DeactivatingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nADeactivatingActor::ADeactivatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ADeactivatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind the input action\n\tif (APlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0))\n\t{\n\t\tInputComponent = NewObject<UInputComponent>(this);\n\t\tInputComponent->RegisterComponent();\n\t\tInputComponent->BindAction(\"Deactivate\", IE_Pressed, this, &ADeactivatingActor::DeactivateActor);\n\t\tPlayerController->PushInputComponent(InputComponent);\n\t}\n}\n\n// Called every frame\nvoid ADeactivatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle deactivation\nvoid ADeactivatingActor::DeactivateActor()\n{\n\tSetActorTickEnabled(false);\n\tSetActorHiddenInGame(true);\n\tSetActorEnableCollision(false);\n}\n```"}
{"requirement": "Create a class that changes location based on keyboard input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMovableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyMovableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyMovableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Input functions\n\tvoid MoveForward(float Value);\n\tvoid MoveRight(float Value);\n\n\t// Movement speed\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MovementSpeed;\n\nprivate:\n\t// Input component\n\tUInputComponent* InputComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyMovableActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAMyMovableActor::AMyMovableActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize movement speed\n\tMovementSpeed = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMyMovableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind input functions\n\tInputComponent = NewObject<UInputComponent>(this);\n\tInputComponent->BindAxis(\"MoveForward\", this, &AMyMovableActor::MoveForward);\n\tInputComponent->BindAxis(\"MoveRight\", this, &AMyMovableActor::MoveRight);\n\tInputComponent->RegisterComponent();\n}\n\n// Called every frame\nvoid AMyMovableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Add any custom tick logic here\n}\n\nvoid AMyMovableActor::MoveForward(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tFVector Direction = FVector::ForwardVector;\n\t\tAddActorLocalOffset(Direction * Value * MovementSpeed * GetWorld()->GetDeltaSeconds(), true);\n\t}\n}\n\nvoid AMyMovableActor::MoveRight(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tFVector Direction = FVector::RightVector;\n\t\tAddActorLocalOffset(Direction * Value * MovementSpeed * GetWorld()->GetDeltaSeconds(), true);\n\t}\n}\n```"}
{"requirement": "Create an actor with a mesh that fades over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FadingMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFadingMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFadingMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Fading\")\n\tfloat FadeDuration;\n\n\tfloat CurrentFadeTime;\n};\n```", "cpp_code": "```cpp\n#include \"FadingMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nAFadingMeshActor::AFadingMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tFadeDuration = 5.0f;\n\tCurrentFadeTime = 0.0f;\n}\n\nvoid AFadingMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AFadingMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (CurrentFadeTime < FadeDuration)\n\t{\n\t\tCurrentFadeTime += DeltaTime;\n\t\tfloat Alpha = 1.0f - (CurrentFadeTime / FadeDuration);\n\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\t\tif (DynamicMaterial)\n\t\t\t{\n\t\t\t\tDynamicMaterial->SetScalarParameterValue(\"Opacity\", Alpha);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a simple helix actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HelixActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AHelixActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAHelixActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Helix\")\n\tfloat Radius = 100.0f;\n\n\tUPROPERTY(EditAnywhere, Category=\"Helix\")\n\tfloat Height = 200.0f;\n\n\tUPROPERTY(EditAnywhere, Category=\"Helix\")\n\tint32 NumPoints = 100;\n\n\tUPROPERTY(EditAnywhere, Category=\"Helix\")\n\tUStaticMeshComponent* HelixMesh;\n};\n```", "cpp_code": "```cpp\n#include \"HelixActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nAHelixActor::AHelixActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHelixMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"HelixMesh\"));\n\tRootComponent = HelixMesh;\n}\n\nvoid AHelixActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tTArray<FVector> HelixPoints;\n\tfor (int32 i = 0; i < NumPoints; ++i)\n\t{\n\t\tfloat Angle = i * 2 * PI / NumPoints;\n\t\tfloat X = Radius * FMath::Cos(Angle);\n\t\tfloat Y = Radius * FMath::Sin(Angle);\n\t\tfloat Z = (Height / NumPoints) * i;\n\t\tHelixPoints.Add(FVector(X, Y, Z));\n\t}\n\n\t// Logic to use HelixPoints to create a visual helix can be added here\n}\n\nvoid AHelixActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Any dynamic updates to the helix can be added here\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a blueprint class.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"BlueprintClass\")\n\tTSubclassOf<AActor> BlueprintClassReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes sound pitch over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"SoundPitchChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPitchChanger : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tASoundPitchChanger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUAudioComponent* AudioComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Pitch\")\n\tfloat PitchChangeRate;\n};\n```", "cpp_code": "```cpp\n#include \"SoundPitchChanger.h\"\n\n// Sets default values\nASoundPitchChanger::ASoundPitchChanger()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tRootComponent = AudioComponent;\n\n\tPitchChangeRate = 0.1f; // default pitch change rate\n}\n\n// Called when the game starts or when spawned\nvoid ASoundPitchChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AudioComponent->Sound)\n\t{\n\t\tAudioComponent->Play();\n\t}\n}\n\n// Called every frame\nvoid ASoundPitchChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (AudioComponent->IsPlaying())\n\t{\n\t\tfloat NewPitch = AudioComponent->PitchMultiplier + PitchChangeRate * DeltaTime;\n\t\tAudioComponent->SetPitchMultiplier(NewPitch);\n\t}\n}\n```"}
{"requirement": "Create a component that can be activated with a trigger.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TriggerActivatableComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTriggerActivatableComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUTriggerActivatableComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category=\"Activation\")\n\tvoid ActivateComponent();\n\n\tUFUNCTION()\n\tvoid OnTriggerEnter();\n\nprivate:\n\tbool bIsActive;\n};\n```", "cpp_code": "```cpp\n#include \"TriggerActivatableComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUTriggerActivatableComponent::UTriggerActivatableComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbIsActive = false;\n}\n\nvoid UTriggerActivatableComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Assuming a trigger event is set up in the game environment\n\t// OnTriggerEnter would be bound to the actual event\n}\n\nvoid UTriggerActivatableComponent::ActivateComponent()\n{\n\tif (!bIsActive)\n\t{\n\t\tbIsActive = true;\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Component Activated\"));\n\t}\n}\n\nvoid UTriggerActivatableComponent::OnTriggerEnter()\n{\n\tActivateComponent();\n}\n```"}
{"requirement": "Create an actor with a looping sound effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"LoopingSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoopingSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoopingSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundCue;\n\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"LoopingSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n\n// Sets default values\nALoopingSoundActor::ALoopingSoundActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->bAutoActivate = false; // Prevent it from starting automatically\n\tRootComponent = AudioComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ALoopingSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (SoundCue)\n\t{\n\t\tAudioComponent->SetSound(SoundCue);\n\t\tAudioComponent->Play();\n\t\tAudioComponent->bIsUISound = false;\n\t\tAudioComponent->bLooping = true; // Set looping to true\n\t}\n}\n\n// Called every frame\nvoid ALoopingSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that toggles between two meshes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Mesh\")\n\tvoid ToggleMesh();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMesh* Mesh1;\n\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMesh* Mesh2;\n\n\tbool bIsMesh1Active;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleMeshActor.h\"\n\n// Sets default values\nAToggleMeshActor::AToggleMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tbIsMesh1Active = true;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Mesh1)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh1);\n\t}\n}\n\n// Called every frame\nvoid AToggleMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleMeshActor::ToggleMesh()\n{\n\tif (bIsMesh1Active && Mesh2)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh2);\n\t\tbIsMesh1Active = false;\n\t}\n\telse if (!bIsMesh1Active && Mesh1)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh1);\n\t\tbIsMesh1Active = true;\n\t}\n}\n```"}
{"requirement": "Create an actor that slides on a surface.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SlidingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASlidingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASlidingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat SlideSpeed;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector SlideDirection;\n\n\tvoid Slide(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"SlidingActor.h\"\n\n// Sets default values\nASlidingActor::ASlidingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSlideSpeed = 200.0f;\n\tSlideDirection = FVector(1.0f, 0.0f, 0.0f); // Slide along the X-axis by default\n}\n\n// Called when the game starts or when spawned\nvoid ASlidingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASlidingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tSlide(DeltaTime);\n}\n\nvoid ASlidingActor::Slide(float DeltaTime)\n{\n\tFVector NewLocation = GetActorLocation() + (SlideDirection * SlideSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a simple knot actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"KnotActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AKnotActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAKnotActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* KnotMesh;\n};\n```", "cpp_code": "```cpp\n#include \"KnotActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAKnotActor::AKnotActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the static mesh component\n\tKnotMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"KnotMesh\"));\n\tRootComponent = KnotMesh;\n\n\t// Load a simple knot mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> KnotMeshAsset(TEXT(\"StaticMesh'/Game/Geometry/Meshes/SimpleKnot.SimpleKnot'\"));\n\tif (KnotMeshAsset.Succeeded())\n\t{\n\t\tKnotMesh->SetStaticMesh(KnotMeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AKnotActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AKnotActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a camera actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Camera\")\n\tACameraActor* CameraActor;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its location with a timer.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"LocationChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALocationChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALocationChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFTimerHandle LocationChangeTimerHandle;\n\n\tvoid ChangeLocation();\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tFVector LocationOffset;\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat TimerInterval;\n};\n```", "cpp_code": "```cpp\n#include \"LocationChangingActor.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nALocationChangingActor::ALocationChangingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tLocationOffset = FVector(100.f, 0.f, 0.f);\n\tTimerInterval = 1.0f; // Default to change location every second\n}\n\n// Called when the game starts or when spawned\nvoid ALocationChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGetWorldTimerManager().SetTimer(LocationChangeTimerHandle, this, &ALocationChangingActor::ChangeLocation, TimerInterval, true);\n}\n\n// Called every frame\nvoid ALocationChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ALocationChangingActor::ChangeLocation()\n{\n\tFVector NewLocation = GetActorLocation() + LocationOffset;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a component that changes light color on activation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LightColorChangerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API ULightColorChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tULightColorChangerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION(BlueprintCallable, Category=\"Light\")\n\tvoid ChangeLightColor();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Light\")\n\tFLinearColor NewLightColor;\n};\n```", "cpp_code": "```cpp\n#include \"LightColorChangerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PointLightComponent.h\"\n\nULightColorChangerComponent::ULightColorChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid ULightColorChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ULightColorChangerComponent::ChangeLightColor()\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUPointLightComponent* LightComponent = Owner->FindComponentByClass<UPointLightComponent>();\n\t\tif (LightComponent)\n\t\t{\n\t\t\tLightComponent->SetLightColor(NewLightColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomMaterialActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Customizable material property\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Custom\")\n\tUMaterialInterface* CustomMaterial;\n\nprivate:\n\t// Static mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CustomMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nACustomMaterialActor::ACustomMaterialActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set up the static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Allow the material to be customized\n\tCustomMaterial = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Apply the custom material if it's set\n\tif (CustomMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, CustomMaterial);\n\t}\n}\n\n// Called every frame\nvoid ACustomMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that changes its dimension over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResizableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResizableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAResizableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialScale;\n\tfloat TimeElapsed;\n\n\tUPROPERTY(EditAnywhere, Category=\"Resize\")\n\tfloat ResizeSpeed = 1.0f;\n\n\tUPROPERTY(EditAnywhere, Category=\"Resize\")\n\tfloat MaxScaleMultiplier = 2.0f;\n};\n```", "cpp_code": "```cpp\n#include \"ResizableActor.h\"\n\n// Sets default values\nAResizableActor::AResizableActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tInitialScale = FVector(1.0f, 1.0f, 1.0f);\n\tTimeElapsed = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AResizableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tInitialScale = GetActorScale3D();\n}\n\n// Called every frame\nvoid AResizableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeElapsed += DeltaTime;\n\n\tfloat ScaleFactor = FMath::Sin(ResizeSpeed * TimeElapsed) * 0.5f + 0.5f; // Generates a value between 0 and 1\n\tFVector NewScale = InitialScale * FMath::Lerp(1.0f, MaxScaleMultiplier, ScaleFactor);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create an actor that toggles between two colors.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAColorToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tFLinearColor Color1;\n\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tFLinearColor Color2;\n\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tfloat ToggleInterval;\n\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\tfloat TimeSinceLastToggle;\n\tbool bUseColor1;\n\n\tvoid ToggleColor();\n};\n```", "cpp_code": "```cpp\n#include \"ColorToggleActor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nAColorToggleActor::AColorToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tColor1 = FLinearColor::Red;\n\tColor2 = FLinearColor::Blue;\n\tToggleInterval = 1.0f;\n\tTimeSinceLastToggle = 0.0f;\n\tbUseColor1 = true;\n\n\tUStaticMeshComponent* MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tDynamicMaterial = UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this);\n\tMeshComponent->SetMaterial(0, DynamicMaterial);\n}\n\nvoid AColorToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tToggleColor();\n}\n\nvoid AColorToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeSinceLastToggle += DeltaTime;\n\tif (TimeSinceLastToggle >= ToggleInterval)\n\t{\n\t\tToggleColor();\n\t\tTimeSinceLastToggle = 0.0f;\n\t}\n}\n\nvoid AColorToggleActor::ToggleColor()\n{\n\tif (DynamicMaterial)\n\t{\n\t\tFLinearColor CurrentColor = bUseColor1 ? Color1 : Color2;\n\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), CurrentColor);\n\t\tbUseColor1 = !bUseColor1;\n\t}\n}\n```"}
{"requirement": "Create an actor that follows a player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FollowerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFollowerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFollowerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAActor* PlayerActor;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat FollowSpeed = 300.0f;\n};\n```", "cpp_code": "```cpp\n#include \"FollowerActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAFollowerActor::AFollowerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AFollowerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tPlayerActor = PlayerController->GetPawn();\n\t}\n}\n\nvoid AFollowerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerActor)\n\t{\n\t\tFVector Direction = PlayerActor->GetActorLocation() - GetActorLocation();\n\t\tDirection.Normalize();\n\t\tFVector NewLocation = GetActorLocation() + Direction * FollowSpeed * DeltaTime;\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create a simple grid actor.", "header_code": "```cpp\nUCLASS()\nclass YOURPROJECT_API AGridActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAGridActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tint32 Rows;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tint32 Columns;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tfloat CellSize;\n};\n```", "cpp_code": "```cpp\n#include \"GridActor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nAGridActor::AGridActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tRows = 10;\n\tColumns = 10;\n\tCellSize = 100.0f;\n}\n\nvoid AGridActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tfor (int32 i = 0; i <= Rows; ++i)\n\t{\n\t\tfor (int32 j = 0; j <= Columns; ++j)\n\t\t{\n\t\t\tFVector Start = GetActorLocation() + FVector(i * CellSize, j * CellSize, 0);\n\t\t\tFVector End = Start + FVector(0, 0, 10);\n\t\t\tDrawDebugLine(GetWorld(), Start, End, FColor::Red, true, -1, 0, 5);\n\t\t}\n\t}\n}\n\nvoid AGridActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a texture.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"MyTextureObject.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API UMyTextureObject : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Texture\")\n\tUTexture2D* MyTexture;\n};\n```", "cpp_code": "```cpp\n#include \"MyTextureObject.h\"\n\n// No additional implementation needed at this time\n```"}
{"requirement": "Create an actor that spawns another actor with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpawnActorExample.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpawnActorExample : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpawnActorExample();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// The actor to spawn\n\tUPROPERTY(EditAnywhere, Category = \"Spawning\")\n\tTSubclassOf<AActor> ActorToSpawn;\n\nprivate:\n\t// Function to handle spawning\n\tvoid SpawnActor();\n};\n```", "cpp_code": "```cpp\n#include \"SpawnActorExample.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASpawnActorExample::ASpawnActorExample()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASpawnActorExample::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind the input\n\tif (APlayerController* PC = UGameplayStatics::GetPlayerController(this, 0))\n\t{\n\t\tPC->InputComponent->BindAction(\"SpawnActor\", IE_Pressed, this, &ASpawnActorExample::SpawnActor);\n\t}\n}\n\nvoid ASpawnActorExample::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpawnActorExample::SpawnActor()\n{\n\tif (ActorToSpawn)\n\t{\n\t\tFVector Location = GetActorLocation();\n\t\tFRotator Rotation = GetActorRotation();\n\t\tGetWorld()->SpawnActor<AActor>(ActorToSpawn, Location, Rotation);\n\t}\n}\n```"}
{"requirement": "Create a component with a custom constructor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUCustomComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Custom constructor with parameters\n\tUCustomComponent(float InCustomValue);\n\nprivate:\n\tfloat CustomValue;\n};\n```", "cpp_code": "```cpp\n#include \"CustomComponent.h\"\n\nUCustomComponent::UCustomComponent()\n\t: CustomValue(0.0f) // Initialize default value\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nUCustomComponent::UCustomComponent(float InCustomValue)\n\t: CustomValue(InCustomValue)\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UCustomComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Additional initialization\n}\n```"}
{"requirement": "Create an actor with a spotlight that follows the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpotlightFollower.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpotlightFollower : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpotlightFollower();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Spotlight component\n\tUPROPERTY(VisibleAnywhere)\n\tUSpotLightComponent* Spotlight;\n\n\t// Player reference\n\tAPawn* PlayerPawn;\n};\n```", "cpp_code": "```cpp\n#include \"SpotlightFollower.h\"\n#include \"Components/SpotLightComponent.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASpotlightFollower::ASpotlightFollower()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach spotlight component\n\tSpotlight = CreateDefaultSubobject<USpotLightComponent>(TEXT(\"Spotlight\"));\n\tRootComponent = Spotlight;\n}\n\n// Called when the game starts or when spawned\nvoid ASpotlightFollower::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Get the player pawn\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\n// Called every frame\nvoid ASpotlightFollower::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerPawn)\n\t{\n\t\t// Update spotlight's location to follow the player\n\t\tFVector PlayerLocation = PlayerPawn->GetActorLocation();\n\t\tSetActorLocation(PlayerLocation + FVector(0.0f, 0.0f, 500.0f));\n\t}\n}\n```"}
{"requirement": "Create a class that logs when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ClickableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AClickableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAClickableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called when the actor is clicked\n\tUFUNCTION()\n\tvoid OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n};\n```", "cpp_code": "```cpp\n#include \"ClickableActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAClickableActor::AClickableActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Enable click events\n\tbEnableClickEvents = true;\n}\n\n// Called when the game starts or when spawned\nvoid AClickableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind the OnClicked function to the OnClicked event\n\tOnClicked.AddDynamic(this, &AClickableActor::OnClicked);\n}\n\n// Called every frame\nvoid AClickableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AClickableActor::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tif (GEngine)\n\t{\n\t\t// Log a message when the actor is clicked\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Actor Clicked\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that moves in the direction of the camera.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"CameraMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACameraMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tACameraMovementActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUCameraComponent* CameraComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"CameraMovementActor.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nACameraMovementActor::ACameraMovementActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"CameraComponent\"));\n\tCameraComponent->SetupAttachment(RootComponent);\n\n\tMovementSpeed = 100.0f;\n}\n\nvoid ACameraMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACameraMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (CameraComponent)\n\t{\n\t\tFVector ForwardVector = CameraComponent->GetForwardVector();\n\t\tFVector NewLocation = GetActorLocation() + (ForwardVector * MovementSpeed * DeltaTime);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create a simple fractal actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FractalActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFractalActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAFractalActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to draw the fractal\n\tvoid DrawFractal(int32 Depth, FVector Location, float Size);\n\n\t// Recursive function to create the fractal\n\tvoid CreateFractal(int32 CurrentDepth, FVector Location, float Size);\n\n\t// Maximum depth of the fractal\n\tUPROPERTY(EditAnywhere, Category = \"Fractal\")\n\tint32 MaxDepth;\n\n\t// Initial size of the fractal\n\tUPROPERTY(EditAnywhere, Category = \"Fractal\")\n\tfloat InitialSize;\n};\n```", "cpp_code": "```cpp\n#include \"FractalActor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\n// Sets default values\nAFractalActor::AFractalActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMaxDepth = 3;\n\tInitialSize = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AFractalActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tDrawFractal(MaxDepth, GetActorLocation(), InitialSize);\n}\n\n// Called every frame\nvoid AFractalActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AFractalActor::DrawFractal(int32 Depth, FVector Location, float Size)\n{\n\tCreateFractal(Depth, Location, Size);\n}\n\nvoid AFractalActor::CreateFractal(int32 CurrentDepth, FVector Location, float Size)\n{\n\tif (CurrentDepth <= 0)\n\t{\n\t\treturn;\n\t}\n\n\t// Draw a box for the current level\n\tDrawDebugBox(GetWorld(), Location, FVector(Size * 0.5f), FColor::Blue, true, -1.0f, 0, 2.0f);\n\n\t// Calculate new size and offset for the next depth level\n\tfloat NewSize = Size * 0.5f;\n\tFVector Offset = FVector(NewSize, 0, 0);\n\n\t// Recurse to create smaller fractals\n\tCreateFractal(CurrentDepth - 1, Location + Offset, NewSize);\n\tCreateFractal(CurrentDepth - 1, Location - Offset, NewSize);\n\tCreateFractal(CurrentDepth - 1, Location + FVector(0, NewSize, 0), NewSize);\n\tCreateFractal(CurrentDepth - 1, Location - FVector(0, NewSize, 0), NewSize);\n\tCreateFractal(CurrentDepth - 1, Location + FVector(0, 0, NewSize), NewSize);\n\tCreateFractal(CurrentDepth - 1, Location - FVector(0, 0, NewSize), NewSize);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a music track.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MusicTrackActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMusicTrackActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMusicTrackActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Audio\")\n\tUSoundBase* MusicTrack;\n};\n```", "cpp_code": "```cpp\n#include \"MusicTrackActor.h\"\n\nAMusicTrackActor::AMusicTrackActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMusicTrackActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMusicTrackActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that logs its movement every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoggingMovementActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Time accumulator for logging\n\tfloat TimeAccumulator;\n\n\t// Logs the current position of the actor\n\tvoid LogMovement();\n};\n```", "cpp_code": "```cpp\n#include \"LoggingMovementActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingMovementActor::ALoggingMovementActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tTimeAccumulator = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALoggingMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeAccumulator += DeltaTime;\n\n\tif (TimeAccumulator >= 1.0f)\n\t{\n\t\tLogMovement();\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n\nvoid ALoggingMovementActor::LogMovement()\n{\n\tFVector ActorLocation = GetActorLocation();\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Actor Location: %s\"), *ActorLocation.ToString());\n}\n```"}
{"requirement": "Create a component that adjusts its scale based on distance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleByDistanceComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UScaleByDistanceComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUScaleByDistanceComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tAActor* TargetActor;\n\tfloat BaseScale;\n\tfloat ScaleFactor;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Scale\")\n\tvoid SetTargetActor(AActor* NewTarget);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Scale\")\n\tvoid SetScaleFactor(float NewScaleFactor);\n};\n```", "cpp_code": "```cpp\n#include \"ScaleByDistanceComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUScaleByDistanceComponent::UScaleByDistanceComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tBaseScale = 1.0f;\n\tScaleFactor = 0.01f;\n\tTargetActor = nullptr;\n}\n\nvoid UScaleByDistanceComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UScaleByDistanceComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (TargetActor)\n\t{\n\t\tfloat Distance = FVector::Dist(GetOwner()->GetActorLocation(), TargetActor->GetActorLocation());\n\t\tfloat NewScale = BaseScale + (Distance * ScaleFactor);\n\t\tGetOwner()->SetActorScale3D(FVector(NewScale));\n\t}\n}\n\nvoid UScaleByDistanceComponent::SetTargetActor(AActor* NewTarget)\n{\n\tTargetActor = NewTarget;\n}\n\nvoid UScaleByDistanceComponent::SetScaleFactor(float NewScaleFactor)\n{\n\tScaleFactor = NewScaleFactor;\n}\n```"}
{"requirement": "Create an actor with a customizable sound effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundEffectActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundEffectActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tASoundEffectActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sound effect property\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* SoundEffect;\n\n\t// Function to play the sound effect\n\tUFUNCTION(BlueprintCallable, Category = \"Sound\")\n\tvoid PlaySoundEffect();\n};\n```", "cpp_code": "```cpp\n#include \"SoundEffectActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundEffectActor::ASoundEffectActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the sound effect\n\tSoundEffect = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundEffectActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASoundEffectActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to play the sound effect\nvoid ASoundEffectActor::PlaySoundEffect()\n{\n\tif (SoundEffect)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundEffect, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a class that changes its rotation speed over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat InitialRotationSpeed;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationAcceleration;\n\n\tfloat CurrentRotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tInitialRotationSpeed = 10.0f;\n\tRotationAcceleration = 5.0f;\n\tCurrentRotationSpeed = InitialRotationSpeed;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update the current rotation speed\n\tCurrentRotationSpeed += RotationAcceleration * DeltaTime;\n\n\t// Calculate new rotation\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += CurrentRotationSpeed * DeltaTime;\n\n\t// Set the updated rotation\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an actor that can be thrown with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ThrowableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AThrowableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAThrowableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Throw\")\n\tfloat ThrowForce;\n\n\tUFUNCTION()\n\tvoid Throw();\n};\n```", "cpp_code": "```cpp\n#include \"ThrowableActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nAThrowableActor::AThrowableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tThrowForce = 1000.0f; // Default force value\n}\n\nvoid AThrowableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Bind the throw function to a key press\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tif (InputComponent)\n\t\t{\n\t\t\tInputComponent->BindAction(\"Throw\", IE_Pressed, this, &AThrowableActor::Throw);\n\t\t}\n\t}\n}\n\nvoid AThrowableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AThrowableActor::Throw()\n{\n\tif (UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(GetRootComponent()))\n\t{\n\t\tFVector ForwardVector = GetActorForwardVector();\n\t\tPrimitiveComponent->AddImpulse(ForwardVector * ThrowForce, NAME_None, true);\n\t}\n}\n```"}
{"requirement": "Create a simple star actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"StarActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AStarActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAStarActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Star mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StarMesh;\n};\n```", "cpp_code": "```cpp\n#include \"StarActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAStarActor::AStarActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the mesh component\n\tStarMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StarMesh\"));\n\tRootComponent = StarMesh;\n\n\t// Optionally, set the mesh here\n\t// static ConstructorHelpers::FObjectFinder<UStaticMesh> StarAsset(TEXT(\"/Game/Path/To/Your/StarMesh.StarMesh\"));\n\t// if (StarAsset.Succeeded())\n\t// {\n\t// \tStarMesh->SetStaticMesh(StarAsset.Object);\n\t// }\n}\n\n// Called when the game starts or when spawned\nvoid AStarActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AStarActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a light component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyLightActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyLightActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Light\")\n\tclass ULightComponent* LightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyLightActor.h\"\n#include \"Components/LightComponent.h\"\n\nAMyLightActor::AMyLightActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tLightComponent = CreateDefaultSubobject<ULightComponent>(TEXT(\"LightComponent\"));\n\tRootComponent = LightComponent;\n}\n\nvoid AMyLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that plays a sound when entering a volume.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundVolumeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundVolumeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundVolumeActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* TriggerVolume;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"SoundVolumeActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundVolumeActor::ASoundVolumeActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n\tRootComponent = TriggerVolume;\n\n\tTriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &ASoundVolumeActor::OnOverlapBegin);\n}\n\nvoid ASoundVolumeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundVolumeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundVolumeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (SoundToPlay && OtherActor != this)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that changes its mesh on click.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"MeshSwitcherComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UMeshSwitcherComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUMeshSwitcherComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void OnComponentClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed);\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MeshSwitch\")\n\tUStaticMesh* FirstMesh;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MeshSwitch\")\n\tUStaticMesh* SecondMesh;\n\nprivate:\n\tUPROPERTY()\n\tUStaticMeshComponent* MeshComponent;\n\n\tbool bUsingFirstMesh;\n};\n```", "cpp_code": "```cpp\n#include \"MeshSwitcherComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nUMeshSwitcherComponent::UMeshSwitcherComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbUsingFirstMesh = true;\n}\n\nvoid UMeshSwitcherComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tMeshComponent = GetOwner()->FindComponentByClass<UStaticMeshComponent>();\n\tif (MeshComponent && FirstMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(FirstMesh);\n\t}\n\n\tif (MeshComponent)\n\t{\n\t\tMeshComponent->OnClicked.AddDynamic(this, &UMeshSwitcherComponent::OnComponentClicked);\n\t}\n}\n\nvoid UMeshSwitcherComponent::OnComponentClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed)\n{\n\tif (!MeshComponent)\n\t{\n\t\treturn;\n\t}\n\n\tif (bUsingFirstMesh && SecondMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(SecondMesh);\n\t}\n\telse if (!bUsingFirstMesh && FirstMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(FirstMesh);\n\t}\n\n\tbUsingFirstMesh = !bUsingFirstMesh;\n}\n```"}
{"requirement": "Create an actor with a changing texture.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"TextureChangerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tATextureChangerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category = \"Texture\")\n\tTArray<UTexture*> Textures;\n\nprivate:\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\tint32 CurrentTextureIndex;\n\tfloat TimeSinceLastChange;\n\t\n\tUPROPERTY(EditAnywhere, Category = \"Texture\")\n\tfloat ChangeInterval;\n};\n```", "cpp_code": "```cpp\n#include \"TextureChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/Material.h\"\n\n// Sets default values\nATextureChangerActor::ATextureChangerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tUStaticMeshComponent* MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Initialize variables\n\tCurrentTextureIndex = 0;\n\tTimeSinceLastChange = 0.0f;\n\tChangeInterval = 2.0f; // Change texture every 2 seconds\n}\n\n// Called when the game starts or when spawned\nvoid ATextureChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tUStaticMeshComponent* MeshComponent = Cast<UStaticMeshComponent>(RootComponent);\n\tif (MeshComponent && MeshComponent->GetMaterial(0))\n\t{\n\t\tDynamicMaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t}\n}\n\n// Called every frame\nvoid ATextureChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterialInstance && Textures.Num() > 0)\n\t{\n\t\tTimeSinceLastChange += DeltaTime;\n\n\t\tif (TimeSinceLastChange >= ChangeInterval)\n\t\t{\n\t\t\tCurrentTextureIndex = (CurrentTextureIndex + 1) % Textures.Num();\n\t\t\tDynamicMaterialInstance->SetTextureParameterValue(FName(\"BaseTexture\"), Textures[CurrentTextureIndex]);\n\t\t\tTimeSinceLastChange = 0.0f;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a class that scales based on player proximity.", "header_code": "```cpp\nUCLASS()\nclass AProximityScaler : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAProximityScaler();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat MaxScale;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MinScale;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat ScaleDistanceThreshold;\n\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"ProximityScaler.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAProximityScaler::AProximityScaler()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMaxScale = 3.0f;\n\tMinScale = 1.0f;\n\tScaleDistanceThreshold = 1000.0f;\n}\n\nvoid AProximityScaler::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid AProximityScaler::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!PlayerActor)\n\t\treturn;\n\n\tfloat Distance = FVector::Dist(PlayerActor->GetActorLocation(), GetActorLocation());\n\tfloat ScaleFactor = FMath::Clamp(1.0f - (Distance / ScaleDistanceThreshold), 0.0f, 1.0f);\n\tfloat NewScale = FMath::Lerp(MinScale, MaxScale, ScaleFactor);\n\n\tSetActorScale3D(FVector(NewScale));\n}\n```"}
{"requirement": "Create an actor that emits a sound when destroyed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundEmitterActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundEmitterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundEmitterActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void Destroyed() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* DestroySound;\n};\n```", "cpp_code": "```cpp\n#include \"SoundEmitterActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundEmitterActor::ASoundEmitterActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASoundEmitterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundEmitterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundEmitterActor::Destroyed()\n{\n\tSuper::Destroyed();\n\n\tif (DestroySound != nullptr)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, DestroySound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a simple wave actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WaveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWaveActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAWaveActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Wave Settings\")\n\tfloat Amplitude;\n\n\tUPROPERTY(EditAnywhere, Category=\"Wave Settings\")\n\tfloat Frequency;\n\n\tFVector StartLocation;\n};\n```", "cpp_code": "```cpp\n#include \"WaveActor.h\"\n\n// Sets default values\nAWaveActor::AWaveActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAmplitude = 100.0f;\n\tFrequency = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AWaveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid AWaveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat Time = GetWorld()->GetTimeSeconds();\n\tFVector NewLocation = StartLocation;\n\tNewLocation.Z += Amplitude * FMath::Sin(Frequency * Time);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a player character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Player\")\n\tAPlayerCharacter* PlayerCharacterReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its emission over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EmissionChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AEmissionChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAEmissionChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\t// Time accumulator for emission change\n\tfloat TimeAccumulator;\n\n\t// Frequency of the emission change\n\tUPROPERTY(EditAnywhere, Category = \"Emission\")\n\tfloat EmissionFrequency;\n};\n```", "cpp_code": "```cpp\n#include \"EmissionChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nAEmissionChangingActor::AEmissionChangingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize variables\n\tTimeAccumulator = 0.0f;\n\tEmissionFrequency = 1.0f; // Default frequency\n\n\t// Create and set up the static mesh component\n\tUStaticMeshComponent* Mesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh\"));\n\tRootComponent = Mesh;\n\n\t// Create a dynamic material instance\n\tDynamicMaterial = Mesh->CreateAndSetMaterialInstanceDynamic(0);\n}\n\n// Called when the game starts or when spawned\nvoid AEmissionChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AEmissionChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterial)\n\t{\n\t\t// Update the time accumulator\n\t\tTimeAccumulator += DeltaTime;\n\n\t\t// Calculate a new emission value using a sine wave\n\t\tfloat EmissionValue = FMath::Abs(FMath::Sin(TimeAccumulator * EmissionFrequency));\n\n\t\t// Set the emission value to the material (assuming the material has a parameter named \"Emission\")\n\t\tDynamicMaterial->SetScalarParameterValue(TEXT(\"Emission\"), EmissionValue);\n\t}\n}\n```"}
{"requirement": "Create a component that logs its status when activated.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LoggingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULoggingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tULoggingComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called to activate the component\n\tUFUNCTION(BlueprintCallable, Category=\"Activation\")\n\tvoid ActivateComponent();\n};\n```", "cpp_code": "```cpp\n#include \"LoggingComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values for this component's properties\nULoggingComponent::ULoggingComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame. You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid ULoggingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called to activate the component\nvoid ULoggingComponent::ActivateComponent()\n{\n\tUE_LOG(LogTemp, Log, TEXT(\"ULoggingComponent activated on: %s\"), *GetOwner()->GetName());\n}\n```"}
{"requirement": "Create an actor with a color-changing light.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingLight.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AColorChangingLight : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorChangingLight();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPointLightComponent* PointLight;\n\n\tUPROPERTY(EditAnywhere, Category=\"Lighting\")\n\tfloat ColorChangeSpeed;\n\n\tFLinearColor CurrentColor;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingLight.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAColorChangingLight::AColorChangingLight()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\tColorChangeSpeed = 1.0f;\n\n\tCurrentColor = FLinearColor::Red;\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangingLight::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AColorChangingLight::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat Time = GetWorld()->GetTimeSeconds();\n\tCurrentColor.R = FMath::Abs(FMath::Sin(Time * ColorChangeSpeed));\n\tCurrentColor.G = FMath::Abs(FMath::Sin((Time + PI / 3) * ColorChangeSpeed));\n\tCurrentColor.B = FMath::Abs(FMath::Sin((Time + 2 * PI / 3) * ColorChangeSpeed));\n\n\tPointLight->SetLightColor(CurrentColor);\n}\n```"}
{"requirement": "Create a class that rotates based on mouse input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseRotatableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMouseRotatableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMouseRotatableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to rotate based on mouse input\n\tvoid RotateWithMouseInput();\n\nprivate:\n\t// Sensitivity for mouse rotation\n\tUPROPERTY(EditAnywhere, Category = \"Mouse Rotation\")\n\tfloat MouseSensitivity;\n\n\t// Stores the current rotation\n\tFRotator CurrentRotation;\n};\n```", "cpp_code": "```cpp\n#include \"MouseRotatableActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAMouseRotatableActor::AMouseRotatableActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize variables\n\tMouseSensitivity = 0.1f;\n\tCurrentRotation = FRotator::ZeroRotator;\n}\n\n// Called when the game starts or when spawned\nvoid AMouseRotatableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMouseRotatableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRotateWithMouseInput();\n}\n\nvoid AMouseRotatableActor::RotateWithMouseInput()\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tfloat MouseX, MouseY;\n\t\tPlayerController->GetInputMouseDelta(MouseX, MouseY);\n\n\t\t// Calculate rotation\n\t\tCurrentRotation.Yaw += MouseX * MouseSensitivity;\n\t\tCurrentRotation.Pitch += MouseY * MouseSensitivity;\n\n\t\t// Apply rotation\n\t\tSetActorRotation(CurrentRotation);\n\t}\n}\n```"}
{"requirement": "Create an actor that plays a sound on component hit.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"MySoundActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMySoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMySoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sound to play on hit\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* HitSound;\n\n\t// Root component\n\tUPROPERTY(VisibleAnywhere)\n\tUSceneComponent* RootComp;\n\n\t// Box collision component\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* BoxComponent;\n\n\t// Function to handle hit events\n\tUFUNCTION()\n\tvoid OnComponentHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"MySoundActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAMySoundActor::AMySoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create root component\n\tRootComp = CreateDefaultSubobject<USceneComponent>(TEXT(\"RootComponent\"));\n\tRootComponent = RootComp;\n\n\t// Create box component and attach to root\n\tBoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tBoxComponent->SetupAttachment(RootComp);\n\n\t// Bind the OnComponentHit function\n\tBoxComponent->OnComponentHit.AddDynamic(this, &AMySoundActor::OnComponentHit);\n}\n\n// Called when the game starts or when spawned\nvoid AMySoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMySoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle hit events\nvoid AMySoundActor::OnComponentHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (HitSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, HitSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a simple starfield actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"StarfieldActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AStarfieldActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAStarfieldActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Starfield\")\n\tint32 NumberOfStars;\n\n\tUPROPERTY(EditAnywhere, Category=\"Starfield\")\n\tfloat StarfieldRadius;\n\n\tUPROPERTY(EditAnywhere, Category=\"Starfield\")\n\tUStaticMesh* StarMesh;\n\n\tvoid CreateStarfield();\n};\n```", "cpp_code": "```cpp\n#include \"StarfieldActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n\nAStarfieldActor::AStarfieldActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tNumberOfStars = 100;\n\tStarfieldRadius = 1000.0f;\n\tStarMesh = nullptr;\n}\n\nvoid AStarfieldActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tCreateStarfield();\n}\n\nvoid AStarfieldActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AStarfieldActor::CreateStarfield()\n{\n\tif (!StarMesh)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Star mesh not set!\"));\n\t\treturn;\n\t}\n\n\tfor (int32 i = 0; i < NumberOfStars; ++i)\n\t{\n\t\tFVector RandomPosition = FMath::VRand() * FMath::FRandRange(0.0f, StarfieldRadius);\n\t\tUStaticMeshComponent* StarComponent = NewObject<UStaticMeshComponent>(this);\n\t\tStarComponent->SetStaticMesh(StarMesh);\n\t\tStarComponent->SetWorldLocation(RandomPosition);\n\t\tStarComponent->RegisterComponent();\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a static mesh.", "header_code": "```cpp\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyStaticMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Mesh\")\n\tUStaticMesh* StaticMeshReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyStaticMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its position with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PositionChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APositionChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tAPositionChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid MoveActor();\n\nprivate:\n\tFVector NewLocation;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MoveDistance;\n};\n```", "cpp_code": "```cpp\n#include \"PositionChanger.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAPositionChanger::APositionChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMoveDistance = 100.0f;\n}\n\nvoid APositionChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tNewLocation = GetActorLocation();\n}\n\nvoid APositionChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tif (PlayerController->IsInputKeyDown(EKeys::P))\n\t\t{\n\t\t\tMoveActor();\n\t\t}\n\t}\n}\n\nvoid APositionChanger::MoveActor()\n{\n\tNewLocation.X += MoveDistance;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a component with a custom tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomTickComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomTickComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUCustomTickComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void CustomTickFunction(float DeltaTime);\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tick\")\n\tbool bEnableCustomTick;\n};\n```", "cpp_code": "```cpp\n#include \"CustomTickComponent.h\"\n\nUCustomTickComponent::UCustomTickComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tbEnableCustomTick = true;\n}\n\nvoid UCustomTickComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCustomTickComponent::CustomTickFunction(float DeltaTime)\n{\n\tif (bEnableCustomTick)\n\t{\n\t\t// Custom tick logic here\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"CustomTickFunction called with DeltaTime: %f\"), DeltaTime);\n\t}\n}\n\nvoid UCustomTickComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Call the custom tick function\n\tCustomTickFunction(DeltaTime);\n}\n```"}
{"requirement": "Create an actor with a customizable light intensity.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightIntensityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ALightIntensityActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tALightIntensityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Light\")\n\tfloat LightIntensity;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPointLightComponent* PointLight;\n};\n```", "cpp_code": "```cpp\n#include \"LightIntensityActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nALightIntensityActor::ALightIntensityActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create PointLight component and attach it to the RootComponent\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\t// Set default light intensity\n\tLightIntensity = 3000.0f;\n\tPointLight->Intensity = LightIntensity;\n}\n\n// Called when the game starts or when spawned\nvoid ALightIntensityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Ensure the light intensity is set at the start\n\tPointLight->SetIntensity(LightIntensity);\n}\n\n// Called every frame\nvoid ALightIntensityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update the light intensity if it changes\n\tif (PointLight->Intensity != LightIntensity)\n\t{\n\t\tPointLight->SetIntensity(LightIntensity);\n\t}\n}\n```"}
{"requirement": "Create a class that adjusts its position with time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PositionAdjuster.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APositionAdjuster : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAPositionAdjuster();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialPosition;\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tFVector MovementPerSecond;\n};\n```", "cpp_code": "```cpp\n#include \"PositionAdjuster.h\"\n\nAPositionAdjuster::APositionAdjuster()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APositionAdjuster::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialPosition = GetActorLocation();\n}\n\nvoid APositionAdjuster::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFVector NewPosition = InitialPosition + (MovementPerSecond * DeltaTime);\n\tSetActorLocation(NewPosition);\n}\n```"}
{"requirement": "Create an actor that can be resized with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResizableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResizableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAResizableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to resize the actor\n\tvoid ResizeActor(float ScaleFactor);\n\nprivate:\n\t// Function to handle input\n\tvoid SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\n\t// Current scale factor\n\tfloat CurrentScaleFactor;\n};\n```", "cpp_code": "```cpp\n#include \"ResizableActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAResizableActor::AResizableActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCurrentScaleFactor = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AResizableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetupPlayerInputComponent(InputComponent);\n}\n\n// Called every frame\nvoid AResizableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResizableActor::ResizeActor(float ScaleFactor)\n{\n\tCurrentScaleFactor *= ScaleFactor;\n\tSetActorScale3D(FVector(CurrentScaleFactor));\n}\n\nvoid AResizableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ResizeActor\", IE_Pressed, this, &AResizableActor::ResizeActor, 1.1f);\n}\n```"}
{"requirement": "Create a simple vortex actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VortexActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVortexActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAVortexActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Vortex\")\n\tfloat VortexStrength = 1000.0f;\n\n\tUPROPERTY(EditAnywhere, Category=\"Vortex\")\n\tfloat VortexRadius = 500.0f;\n\n\tvoid ApplyVortexForce();\n};\n```", "cpp_code": "```cpp\n#include \"VortexActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAVortexActor::AVortexActor()\n{\n\t // Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AVortexActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AVortexActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tApplyVortexForce();\n}\n\nvoid AVortexActor::ApplyVortexForce()\n{\n\tFVector VortexLocation = GetActorLocation();\n\tfor (TActorIterator<AActor> It(GetWorld()); It; ++It)\n\t{\n\t\tAActor* Actor = *It;\n\t\tif (Actor != this)\n\t\t{\n\t\t\tUPrimitiveComponent* PrimitiveComponent = Actor->FindComponentByClass<UPrimitiveComponent>();\n\t\t\tif (PrimitiveComponent && PrimitiveComponent->IsSimulatingPhysics())\n\t\t\t{\n\t\t\t\tFVector Direction = (Actor->GetActorLocation() - VortexLocation);\n\t\t\t\tfloat Distance = Direction.Size();\n\t\t\t\tif (Distance < VortexRadius)\n\t\t\t\t{\n\t\t\t\t\tDirection.Normalize();\n\t\t\t\t\tFVector Force = Direction ^ FVector::UpVector * VortexStrength;\n\t\t\t\t\tPrimitiveComponent->AddForce(Force);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store the lifespan of an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Lifespan\")\n\tfloat Lifespan;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\t// Set default lifespan value\n\tLifespan = 0.0f;\n}\n```"}
{"requirement": "Create an actor that logs a message on destruction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Logging/LogMacros.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void BeginDestroy() override;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Engine/Engine.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyActor::BeginDestroy()\n{\n\tSuper::BeginDestroy();\n\tUE_LOG(LogTemp, Warning, TEXT(\"AMyActor is being destroyed\"));\n}\n```"}
{"requirement": "Create a component that changes color on proximity.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ColorChangeOnProximityComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UColorChangeOnProximityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUColorChangeOnProximityComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat ProximityRadius = 300.0f;\n\n\tUPROPERTY(EditAnywhere)\n\tFLinearColor CloseColor = FLinearColor::Red;\n\n\tUPROPERTY(EditAnywhere)\n\tFLinearColor FarColor = FLinearColor::Blue;\n\n\tUPROPERTY() \n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tvoid ChangeColorBasedOnProximity();\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeOnProximityComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUColorChangeOnProximityComponent::UColorChangeOnProximityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UColorChangeOnProximityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUMeshComponent* MeshComp = Owner->FindComponentByClass<UMeshComponent>();\n\t\tif (MeshComp)\n\t\t{\n\t\t\tDynamicMaterial = MeshComp->CreateAndSetMaterialInstanceDynamic(0);\n\t\t}\n\t}\n}\n\nvoid UColorChangeOnProximityComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tChangeColorBasedOnProximity();\n}\n\nvoid UColorChangeOnProximityComponent::ChangeColorBasedOnProximity()\n{\n\tif (!DynamicMaterial) return;\n\n\tAActor* PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n\tif (!PlayerPawn) return;\n\n\tfloat Distance = FVector::Dist(PlayerPawn->GetActorLocation(), GetOwner()->GetActorLocation());\n\n\tFLinearColor NewColor = (Distance < ProximityRadius) ? CloseColor : FarColor;\n\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", NewColor);\n}\n```"}
{"requirement": "Create an actor with a scalable mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalableMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AScalableMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAScalableMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Static Mesh Component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Mesh\")\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\t// Method to scale the mesh\n\tUFUNCTION(BlueprintCallable, Category = \"Mesh\")\n\tvoid ScaleMesh(FVector NewScale);\n};\n```", "cpp_code": "```cpp\n#include \"ScalableMeshActor.h\"\n\n// Sets default values\nAScalableMeshActor::AScalableMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the static mesh component and attach it to the root\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AScalableMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AScalableMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\n// Method to scale the mesh\nvoid AScalableMeshActor::ScaleMesh(FVector NewScale)\n{\n\tif (StaticMeshComponent)\n\t{\n\t\tStaticMeshComponent->SetWorldScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Create a class that moves towards a specified target.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MoveTowardsTarget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMoveTowardsTarget : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMoveTowardsTarget();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tAActor* TargetActor;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat Speed;\n};\n```", "cpp_code": "```cpp\n#include \"MoveTowardsTarget.h\"\n#include \"GameFramework/Actor.h\"\n\nAMoveTowardsTarget::AMoveTowardsTarget()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSpeed = 100.0f;\n}\n\nvoid AMoveTowardsTarget::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMoveTowardsTarget::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tFVector CurrentLocation = GetActorLocation();\n\t\tFVector TargetLocation = TargetActor->GetActorLocation();\n\t\tFVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n\t\tFVector NewLocation = CurrentLocation + Direction * Speed * DeltaTime;\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create an actor that plays a sound when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"ClickableSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AClickableSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAClickableSoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* ClickSound;\n\n\tUFUNCTION()\n\tvoid OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n};\n```", "cpp_code": "```cpp\n#include \"ClickableSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAClickableSoundActor::AClickableSoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Enable input to detect clicks\n\tEnableInput(GetWorld()->GetFirstPlayerController());\n\tOnClicked.AddDynamic(this, &AClickableSoundActor::OnClicked);\n}\n\nvoid AClickableSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AClickableSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AClickableSoundActor::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tif (ClickSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, ClickSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a simple black hole actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BlackHoleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ABlackHoleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tABlackHoleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The sphere component for the black hole's gravitational field\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUSphereComponent* BlackHoleSphere;\n\n\t// The strength of the black hole's pull\n\tUPROPERTY(EditAnywhere, Category = \"Black Hole\")\n\tfloat GravityStrength;\n\n\t// Function to apply gravitational pull\n\tvoid PullOverlappingActors();\n};\n```", "cpp_code": "```cpp\n#include \"BlackHoleActor.h\"\n#include \"Components/SphereComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Character.h\"\n\n// Sets default values\nABlackHoleActor::ABlackHoleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the sphere component and attach it to the root\n\tBlackHoleSphere = CreateDefaultSubobject<USphereComponent>(TEXT(\"BlackHoleSphere\"));\n\tRootComponent = BlackHoleSphere;\n\n\t// Initialize the gravity strength\n\tGravityStrength = 2000.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ABlackHoleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ABlackHoleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Apply gravitational pull to overlapping actors\n\tPullOverlappingActors();\n}\n\nvoid ABlackHoleActor::PullOverlappingActors()\n{\n\tTArray<AActor*> OverlappingActors;\n\tBlackHoleSphere->GetOverlappingActors(OverlappingActors);\n\n\tfor (AActor* Actor : OverlappingActors)\n\t{\n\t\tif (Actor && Actor != this)\n\t\t{\n\t\t\tUPrimitiveComponent* Component = Cast<UPrimitiveComponent>(Actor->GetRootComponent());\n\t\t\tif (Component && Component->IsSimulatingPhysics())\n\t\t\t{\n\t\t\t\t// Calculate direction and apply force\n\t\t\t\tFVector Direction = GetActorLocation() - Actor->GetActorLocation();\n\t\t\t\tDirection.Normalize();\n\t\t\t\tComponent->AddForce(Direction * GravityStrength);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store a velocity vector.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VelocityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVelocityActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAVelocityActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector Velocity;\n};\n```", "cpp_code": "```cpp\n#include \"VelocityActor.h\"\n\nAVelocityActor::AVelocityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AVelocityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AVelocityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that rotates around the camera.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Rotation speed around the camera\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationSpeed = 20.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tAActor* PlayerCameraManager = PlayerController->GetViewTarget();\n\t\tif (PlayerCameraManager)\n\t\t{\n\t\t\tFVector CameraLocation = PlayerCameraManager->GetActorLocation();\n\t\t\tFVector ActorLocation = GetActorLocation();\n\n\t\t\t// Calculate the rotation around the camera\n\t\t\tFVector Direction = ActorLocation - CameraLocation;\n\t\t\tDirection = Direction.RotateAngleAxis(RotationSpeed * DeltaTime, FVector::UpVector);\n\n\t\t\tSetActorLocation(CameraLocation + Direction);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a component with a custom start function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomStartComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomStartComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUCustomStartComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Custom start function\n\tUFUNCTION(BlueprintCallable, Category=\"Custom\")\n\tvoid CustomStartFunction();\n};\n```", "cpp_code": "```cpp\n#include \"CustomStartComponent.h\"\n\n// Sets default values for this component's properties\nUCustomStartComponent::UCustomStartComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\n// Called when the game starts\nvoid UCustomStartComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Custom initialization code here\n}\n\n// Custom start function\nvoid UCustomStartComponent::CustomStartFunction()\n{\n\t// Custom start logic here\n\tUE_LOG(LogTemp, Warning, TEXT(\"Custom start function called.\"));\n}\n```"}
{"requirement": "Create an actor with a customizable sound pitch.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"CustomSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* Sound;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tfloat PitchMultiplier;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Sound\")\n\tvoid PlaySound();\n};\n```", "cpp_code": "```cpp\n#include \"CustomSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n\n// Sets default values\nACustomSoundActor::ACustomSoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPitchMultiplier = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACustomSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ACustomSoundActor::PlaySound()\n{\n\tif (Sound)\n\t{\n\t\tUAudioComponent* AudioComponent = UGameplayStatics::SpawnSoundAtLocation(this, Sound, GetActorLocation());\n\t\tif (AudioComponent)\n\t\t{\n\t\t\tAudioComponent->SetPitchMultiplier(PitchMultiplier);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a class with a log message on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyOverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* CollisionBox;\n};\n```", "cpp_code": "```cpp\n#include \"MyOverlapActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\nAMyOverlapActor::AMyOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionBox\"));\n\tRootComponent = CollisionBox;\n\tCollisionBox->SetGenerateOverlapEvents(true);\n\tCollisionBox->OnComponentBeginOverlap.AddDynamic(this, &AMyOverlapActor::OnOverlapBegin);\n}\n\nvoid AMyOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor != this && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlap began with: %s\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Create an actor that expands with a timeline.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"ExpandingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AExpandingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAExpandingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* ExpansionCurve;\n\n\tFTimeline ExpansionTimeline;\n\n\tUFUNCTION()\n\tvoid HandleExpansionProgress(float Value);\n\n\tvoid SetupTimeline();\n};\n```", "cpp_code": "```cpp\n#include \"ExpandingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nAExpandingActor::AExpandingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AExpandingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tSetupTimeline();\n\tif (ExpansionTimeline.IsValid())\n\t{\n\t\tExpansionTimeline.PlayFromStart();\n\t}\n}\n\nvoid AExpandingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tif (ExpansionTimeline.IsValid())\n\t{\n\t\tExpansionTimeline.TickTimeline(DeltaTime);\n\t}\n}\n\nvoid AExpandingActor::SetupTimeline()\n{\n\tif (ExpansionCurve)\n\t{\n\t\tFOnTimelineFloat TimelineProgress;\n\t\tTimelineProgress.BindUFunction(this, FName(\"HandleExpansionProgress\"));\n\t\tExpansionTimeline.AddInterpFloat(ExpansionCurve, TimelineProgress);\n\t\tExpansionTimeline.SetLooping(false);\n\t}\n}\n\nvoid AExpandingActor::HandleExpansionProgress(float Value)\n{\n\tFVector NewScale = FMath::Lerp(FVector(1.0f, 1.0f, 1.0f), FVector(2.0f, 2.0f, 2.0f), Value);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a simple pyramid actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PyramidActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APyramidActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAPyramidActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* PyramidMesh;\n};\n```", "cpp_code": "```cpp\n#include \"PyramidActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAPyramidActor::APyramidActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component and set as root\n\tPyramidMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"PyramidMesh\"));\n\tRootComponent = PyramidMesh;\n\n\t// Load a simple pyramid mesh (assuming you have a pyramid mesh asset named 'PyramidMesh')\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh/PyramidMesh.PyramidMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tPyramidMesh->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid APyramidActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid APyramidActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a skeletal mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Mesh\")\n\tUSkeletalMesh* SkeletalMeshReference;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that flashes lights on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FlashLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFlashLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAFlashLightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Input function to toggle light\n\tvoid ToggleLight();\n\nprivate:\n\t// Point Light Component\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPointLightComponent* PointLight;\n\n\t// Light toggling state\n\tbool bIsLightOn;\n};\n```", "cpp_code": "```cpp\n#include \"FlashLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAFlashLightActor::AFlashLightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create PointLight component and attach to actor\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\t// Initialize light state\n\tbIsLightOn = false;\n\n\t// Initially, turn off the light\n\tPointLight->SetVisibility(bIsLightOn);\n}\n\n// Called when the game starts or when spawned\nvoid AFlashLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind the ToggleLight function to the input\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tInputComponent = NewObject<UInputComponent>(this);\n\t\tInputComponent->RegisterComponent();\n\t\tInputComponent->BindAction(\"ToggleLight\", IE_Pressed, this, &AFlashLightActor::ToggleLight);\n\t\tPlayerController->PushInputComponent(InputComponent);\n\t}\n}\n\n// Called every frame\nvoid AFlashLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Toggle the light on and off\nvoid AFlashLightActor::ToggleLight()\n{\n\tbIsLightOn = !bIsLightOn;\n\tPointLight->SetVisibility(bIsLightOn);\n}\n```"}
{"requirement": "Create a component that toggles visibility on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleVisibilityComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UToggleVisibilityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUToggleVisibilityComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPrimitiveComponent* OwnerPrimitive;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n\n// Sets default values for this component's properties\nUToggleVisibilityComponent::UToggleVisibilityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\n// Called when the game starts\nvoid UToggleVisibilityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Attempt to get the primitive component of the owner\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwnerPrimitive = Cast<UPrimitiveComponent>(Owner->GetComponentByClass(UPrimitiveComponent::StaticClass()));\n\t\tif (OwnerPrimitive)\n\t\t{\n\t\t\tOwnerPrimitive->OnComponentBeginOverlap.AddDynamic(this, &UToggleVisibilityComponent::OnOverlapBegin);\n\t\t}\n\t}\n}\n\n// Called every frame\nvoid UToggleVisibilityComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UToggleVisibilityComponent::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OwnerPrimitive)\n\t{\n\t\tbool bIsVisible = OwnerPrimitive->IsVisible();\n\t\tOwnerPrimitive->SetVisibility(!bIsVisible);\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable particle effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"CustomParticleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomParticleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomParticleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Particle System Component\n\tUParticleSystemComponent* ParticleSystemComponent;\n\n\t// Function to set the particle system\n\tUFUNCTION(BlueprintCallable, Category=\"Particles\")\n\tvoid SetParticleEffect(UParticleSystem* NewParticleSystem);\n};\n```", "cpp_code": "```cpp\n#include \"CustomParticleActor.h\"\n\n// Sets default values\nACustomParticleActor::ACustomParticleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the particle system component and attach it to the root\n\tParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystem\"));\n\tRootComponent = ParticleSystemComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomParticleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACustomParticleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to set the particle system\nvoid ACustomParticleActor::SetParticleEffect(UParticleSystem* NewParticleSystem)\n{\n\tif (ParticleSystemComponent)\n\t{\n\t\tParticleSystemComponent->SetTemplate(NewParticleSystem);\n\t}\n}\n```"}
{"requirement": "Create a class that logs a message on tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALoggingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"Engine/Engine.h\"\n\nALoggingActor::ALoggingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Logging message every tick\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that spins around the Z-axis.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpinningActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpinningActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpinningActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Rotation speed in degrees per second\n\tUPROPERTY(EditAnywhere, Category = \"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"SpinningActor.h\"\n\n// Sets default values\nASpinningActor::ASpinningActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationSpeed = 90.0f; // Default rotation speed\n}\n\n// Called when the game starts or when spawned\nvoid ASpinningActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpinningActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create a simple prism actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrismActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API APrismActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAPrismActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUProceduralMeshComponent* MeshComponent;\n\n\tvoid CreatePrism();\n};\n```", "cpp_code": "```cpp\n#include \"PrismActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\nAPrismActor::APrismActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"PrismMesh\"));\n\tRootComponent = MeshComponent;\n\n\tCreatePrism();\n}\n\nvoid APrismActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APrismActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APrismActor::CreatePrism()\n{\n\tTArray<FVector> Vertices;\n\tTArray<int32> Triangles;\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\tTArray<FColor> VertexColors;\n\tTArray<FProcMeshTangent> Tangents;\n\n\t// Define vertices for a simple triangular prism\n\tVertices.Add(FVector(0, 0, 0)); // Base triangle\n\tVertices.Add(FVector(100, 0, 0));\n\tVertices.Add(FVector(50, 100, 0));\n\n\tVertices.Add(FVector(0, 0, 100)); // Top triangle\n\tVertices.Add(FVector(100, 0, 100));\n\tVertices.Add(FVector(50, 100, 100));\n\n\t// Base face\n\tTriangles.Add(0);\n\tTriangles.Add(2);\n\tTriangles.Add(1);\n\n\t// Top face\n\tTriangles.Add(3);\n\tTriangles.Add(4);\n\tTriangles.Add(5);\n\n\t// Side faces\n\tTriangles.Add(0);\n\tTriangles.Add(1);\n\tTriangles.Add(4);\n\tTriangles.Add(0);\n\tTriangles.Add(4);\n\tTriangles.Add(3);\n\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\tTriangles.Add(5);\n\tTriangles.Add(1);\n\tTriangles.Add(5);\n\tTriangles.Add(4);\n\n\tTriangles.Add(2);\n\tTriangles.Add(0);\n\tTriangles.Add(3);\n\tTriangles.Add(2);\n\tTriangles.Add(3);\n\tTriangles.Add(5);\n\n\tMeshComponent->CreateMeshSection_LinearColor(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a material instance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Materials\")\n\tUMaterialInstance* MaterialInstanceReference;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that plays a sound on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/BoxComponent.h\"\n#include \"SoundOverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundOverlapActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  ASoundOverlapActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n  UBoxComponent* OverlapBox;\n\n  UPROPERTY(EditAnywhere, Category=\"Sound\")\n  USoundCue* SoundToPlay;\n\n  UFUNCTION()\n  void OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"SoundOverlapActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundOverlapActor::ASoundOverlapActor()\n{\n  PrimaryActorTick.bCanEverTick = false;\n\n  OverlapBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"OverlapBox\"));\n  RootComponent = OverlapBox;\n  OverlapBox->SetCollisionProfileName(TEXT(\"Trigger\"));\n  OverlapBox->OnComponentBeginOverlap.AddDynamic(this, &ASoundOverlapActor::OnOverlapBegin);\n}\n\nvoid ASoundOverlapActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid ASoundOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n  if (SoundToPlay != nullptr)\n  {\n\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n  }\n}\n```"}
{"requirement": "Create a component that changes material when activated.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"MaterialChangerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UMaterialChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUMaterialChangerComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Change material when activated\n\tUFUNCTION(BlueprintCallable, Category = \"Material\")\n\tvoid ChangeMaterial();\n\nprivate:\n\t// The material to change to\n\tUPROPERTY(EditAnywhere, Category = \"Material\")\n\tUMaterialInterface* NewMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialChangerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values for this component's properties\nUMaterialChangerComponent::UMaterialChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid UMaterialChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Change material when activated\nvoid UMaterialChangerComponent::ChangeMaterial()\n{\n\tif (!NewMaterial)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"NewMaterial is not set.\"));\n\t\treturn;\n\t}\n\n\tAActor* Owner = GetOwner();\n\tif (!Owner)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Owner not found.\"));\n\t\treturn;\n\t}\n\n\tTArray<UStaticMeshComponent*> StaticMeshComponents;\n\tOwner->GetComponents<UStaticMeshComponent>(StaticMeshComponents);\n\n\tfor (UStaticMeshComponent* MeshComponent : StaticMeshComponents)\n\t{\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a variable light intensity.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightIntensityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALightIntensityActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tALightIntensityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Lighting\")\n\tfloat LightIntensity;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPointLightComponent* PointLight;\n};\n```", "cpp_code": "```cpp\n#include \"LightIntensityActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nALightIntensityActor::ALightIntensityActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a point light component and attach it to the root\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\t// Set default light intensity\n\tLightIntensity = 3000.0f;\n\tPointLight->Intensity = LightIntensity;\n}\n\n// Called when the game starts or when spawned\nvoid ALightIntensityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Ensure the light intensity is set at the start\n\tPointLight->SetIntensity(LightIntensity);\n}\n\n// Called every frame\nvoid ALightIntensityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update light intensity if needed\n\tif (PointLight->Intensity != LightIntensity)\n\t{\n\t\tPointLight->SetIntensity(LightIntensity);\n\t}\n}\n```"}
{"requirement": "Create a class that scales up when near another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAScalingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat ScaleFactor = 1.5f;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat DetectionRadius = 500.0f;\n\n\tUFUNCTION()\n\tvoid CheckProximityAndScale();\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAScalingActor::AScalingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tCheckProximityAndScale();\n}\n\nvoid AScalingActor::CheckProximityAndScale()\n{\n\tTArray<AActor*> OverlappingActors;\n\tGetOverlappingActors(OverlappingActors);\n\n\tfor (AActor* Actor : OverlappingActors)\n\t{\n\t\tif (Actor && Actor != this)\n\t\t{\n\t\t\tfloat DistanceToActor = FVector::Dist(Actor->GetActorLocation(), GetActorLocation());\n\t\t\tif (DistanceToActor <= DetectionRadius)\n\t\t\t{\n\t\t\t\tSetActorScale3D(FVector(ScaleFactor));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tSetActorScale3D(FVector(1.0f));\n}\n```"}
{"requirement": "Create an actor that rotates towards a light source.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotateTowardsLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ARotateTowardsLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotateTowardsLightActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector GetDirectionToLight() const;\n\n\tUPROPERTY(EditAnywhere)\n\tAActor* LightSource;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed = 45.0f;\n};\n```", "cpp_code": "```cpp\n#include \"RotateTowardsLightActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\nARotateTowardsLightActor::ARotateTowardsLightActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARotateTowardsLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotateTowardsLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (LightSource)\n\t{\n\t\tFVector DirectionToLight = GetDirectionToLight();\n\t\tFRotator TargetRotation = UKismetMathLibrary::MakeRotFromX(DirectionToLight);\n\t\tFRotator NewRotation = FMath::RInterpTo(GetActorRotation(), TargetRotation, DeltaTime, RotationSpeed);\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n\nFVector ARotateTowardsLightActor::GetDirectionToLight() const\n{\n\tif (!LightSource)\n\t{\n\t\treturn FVector::ZeroVector;\n\t}\n\n\treturn (LightSource->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n}\n```"}
{"requirement": "Create a simple hexagon actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HexagonActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHexagonActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAHexagonActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* HexagonMesh;\n};\n```", "cpp_code": "```cpp\n#include \"HexagonActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAHexagonActor::AHexagonActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tHexagonMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"HexagonMesh\"));\n\tRootComponent = HexagonMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> HexagonAsset(TEXT(\"/Game/PathToYourHexagonMesh.HexagonMesh\"));\n\tif (HexagonAsset.Succeeded())\n\t{\n\t\tHexagonMesh->SetStaticMesh(HexagonAsset.Object);\n\t}\n}\n\nvoid AHexagonActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHexagonActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a HUD widget.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"YourPlayerController.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AYourPlayerController : public APlayerController\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"UI\")\n\tTSubclassOf<class UUserWidget> HUDWidgetClass;\n\n\tUPROPERTY(VisibleInstanceOnly, BlueprintReadOnly, Category=\"UI\")\n\tUUserWidget* HUDWidget;\n\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"YourPlayerController.h\"\n#include \"Blueprint/UserWidget.h\"\n\nvoid AYourPlayerController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (HUDWidgetClass)\n\t{\n\t\tHUDWidget = CreateWidget<UUserWidget>(this, HUDWidgetClass);\n\t\tif (HUDWidget)\n\t\t{\n\t\t\tHUDWidget->AddToViewport();\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that logs its distance from the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADistanceLoggerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAActor* PlayerActor;\n\n\tvoid LogDistanceToPlayer();\n};\n```", "cpp_code": "```cpp\n#include \"DistanceLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nADistanceLoggerActor::ADistanceLoggerActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ADistanceLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Get the player actor\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\n// Called every frame\nvoid ADistanceLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tLogDistanceToPlayer();\n}\n\nvoid ADistanceLoggerActor::LogDistanceToPlayer()\n{\n\tif (PlayerActor)\n\t{\n\t\tfloat Distance = FVector::Dist(PlayerActor->GetActorLocation(), GetActorLocation());\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Distance to player: %f\"), Distance);\n\t}\n}\n```"}
{"requirement": "Create a component with a custom activation function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomActivationComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomActivationComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUCustomActivationComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Custom Activation\")\n\tvoid CustomActivate();\n};\n```", "cpp_code": "```cpp\n#include \"CustomActivationComponent.h\"\n\nUCustomActivationComponent::UCustomActivationComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UCustomActivationComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCustomActivationComponent::CustomActivate()\n{\n\t// Implement your custom activation logic here\n\tUE_LOG(LogTemp, Warning, TEXT(\"CustomActivate function called.\"));\n}\n```"}
{"requirement": "Create an actor with a customizable rotation speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 180.0f; // Default rotation speed\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create a class that changes mesh based on a condition.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MeshChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMeshChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMeshChanger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMesh* FirstMesh;\n\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMesh* SecondMesh;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Mesh\")\n\tvoid ChangeMesh(bool bUseFirstMesh);\n};\n```", "cpp_code": "```cpp\n#include \"MeshChanger.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAMeshChanger::AMeshChanger()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AMeshChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMeshChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMeshChanger::ChangeMesh(bool bUseFirstMesh)\n{\n\tif (MeshComponent)\n\t{\n\t\tif (bUseFirstMesh && FirstMesh)\n\t\t{\n\t\t\tMeshComponent->SetStaticMesh(FirstMesh);\n\t\t}\n\t\telse if (SecondMesh)\n\t\t{\n\t\t\tMeshComponent->SetStaticMesh(SecondMesh);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that plays a sound when destroyed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundOnDestroyActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundOnDestroyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundOnDestroyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sound to play when destroyed\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* DestroySound;\n\n\t// Override the EndPlay function\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n};\n```", "cpp_code": "```cpp\n#include \"SoundOnDestroyActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundOnDestroyActor::ASoundOnDestroyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundOnDestroyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASoundOnDestroyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called when the actor is destroyed\nvoid ASoundOnDestroyActor::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// Check if the destroy sound is set\n\tif (DestroySound && EndPlayReason == EEndPlayReason::Destroyed)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, DestroySound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a simple octagon actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OctagonActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AOctagonActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOctagonActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Function to create the octagon shape\n\tvoid CreateOctagon();\n\n\t// Component to hold the octagon mesh\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* OctagonMesh;\n};\n```", "cpp_code": "```cpp\n#include \"OctagonActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAOctagonActor::AOctagonActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the StaticMeshComponent\n\tOctagonMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"OctagonMesh\"));\n\tRootComponent = OctagonMesh;\n\n\t// Find and set the octagon mesh (assuming you have an octagon mesh asset)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> OctagonAsset(TEXT(\"StaticMesh'/Game/PathToYourMesh/OctagonMesh.OctagonMesh'\"));\n\tif (OctagonAsset.Succeeded())\n\t{\n\t\tOctagonMesh->SetStaticMesh(OctagonAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AOctagonActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOctagonActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to create the octagon shape\nvoid AOctagonActor::CreateOctagon()\n{\n\t// Implementation for creating an octagon shape would go here if needed.\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a sound wave.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundWave.h\"\n#include \"YourClass.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourClass : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourClass();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Audio\")\n\tUSoundWave* SoundWaveReference;\n};\n```", "cpp_code": "```cpp\n#include \"YourClass.h\"\n\nAYourClass::AYourClass()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourClass::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourClass::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that moves up and down with a sine wave.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SineWaveMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASineWaveMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tASineWaveMover();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialLocation;\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Amplitude;\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Frequency;\n\tfloat RunningTime;\n};\n```", "cpp_code": "```cpp\n#include \"SineWaveMover.h\"\n\n// Sets default values\nASineWaveMover::ASineWaveMover()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAmplitude = 100.0f;\n\tFrequency = 1.0f;\n\tRunningTime = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASineWaveMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid ASineWaveMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRunningTime += DeltaTime;\n\tfloat DeltaHeight = Amplitude * FMath::Sin(Frequency * RunningTime);\n\tFVector NewLocation = InitialLocation;\n\tNewLocation.Z += DeltaHeight;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a component that logs its activation time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TimeLoggingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTimeLoggingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUTimeLoggingComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called when the component is activated\n\tvirtual void Activate(bool bReset = false) override;\n};\n```", "cpp_code": "```cpp\n#include \"TimeLoggingComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values for this component's properties\nUTimeLoggingComponent::UTimeLoggingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid UTimeLoggingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called when the component is activated\nvoid UTimeLoggingComponent::Activate(bool bReset)\n{\n\tSuper::Activate(bReset);\n\n\tFDateTime ActivationTime = FDateTime::Now();\n\tUE_LOG(LogTemp, Log, TEXT(\"Component activated at: %s\"), *ActivationTime.ToString());\n}\n```"}
{"requirement": "Create an actor with a customizable movement direction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomizableMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomizableMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomizableMovementActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Movement speed of the actor\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MovementSpeed;\n\n\t// Movement direction of the actor\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector MovementDirection;\n};\n```", "cpp_code": "```cpp\n#include \"CustomizableMovementActor.h\"\n\n// Sets default values\nACustomizableMovementActor::ACustomizableMovementActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default values\n\tMovementSpeed = 100.0f;\n\tMovementDirection = FVector(1.0f, 0.0f, 0.0f); // Default to moving along the X-axis\n}\n\n// Called when the game starts or when spawned\nvoid ACustomizableMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACustomizableMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Move the actor in the specified direction\n\tFVector NewLocation = GetActorLocation() + (MovementDirection * MovementSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a class that rotates based on player input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotationActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n\n\tvoid RotateActor(float Value);\n\nprivate:\n\tFRotator CurrentRotation;\n};\n```", "cpp_code": "```cpp\n#include \"RotationActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nARotationActor::ARotationActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 45.0f; // Default rotation speed\n}\n\nvoid ARotationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tfloat RotationInput;\n\t\tPlayerController->GetInputAxisValue(TEXT(\"Rotate\"), RotationInput);\n\t\tRotateActor(RotationInput);\n\t}\n}\n\nvoid ARotationActor::RotateActor(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tCurrentRotation = GetActorRotation();\n\t\tCurrentRotation.Yaw += Value * RotationSpeed * GetWorld()->GetDeltaSeconds();\n\t\tSetActorRotation(CurrentRotation);\n\t}\n}\n```"}
{"requirement": "Create an actor that can be toggled on/off with a key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to toggle the visibility\n\tvoid ToggleVisibility();\n\nprivate:\n\t// Tracks whether the actor is visible or not\n\tbool bIsVisible;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleableActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAToggleableActor::AToggleableActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsVisible = true; // Initially visible\n}\n\n// Called when the game starts or when spawned\nvoid AToggleableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AToggleableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Check if the player is pressing the 'T' key\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tif (PlayerController->WasInputKeyJustPressed(EKeys::T))\n\t\t{\n\t\t\tToggleVisibility();\n\t\t}\n\t}\n}\n\nvoid AToggleableActor::ToggleVisibility()\n{\n\tbIsVisible = !bIsVisible;\n\tSetActorHiddenInGame(!bIsVisible);\n\tSetActorEnableCollision(bIsVisible);\n}\n```"}
{"requirement": "Create a simple cylinder grid actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CylinderGridActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACylinderGridActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tACylinderGridActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tint32 GridRows;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tint32 GridColumns;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tfloat CylinderHeight;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tfloat CylinderRadius;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tfloat Spacing;\n\nprivate:\n\tvoid CreateCylinderGrid();\n};\n```", "cpp_code": "```cpp\n#include \"CylinderGridActor.h\"\n#include \"Engine/World.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACylinderGridActor::ACylinderGridActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tGridRows = 5;\n\tGridColumns = 5;\n\tCylinderHeight = 100.0f;\n\tCylinderRadius = 50.0f;\n\tSpacing = 150.0f;\n\n\tCreateCylinderGrid();\n}\n\n// Called when the game starts or when spawned\nvoid ACylinderGridActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACylinderGridActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACylinderGridActor::CreateCylinderGrid()\n{\n\tUStaticMesh* CylinderMesh = LoadObject<UStaticMesh>(nullptr, TEXT(\"/Engine/BasicShapes/Cylinder.Cylinder\"));\n\n\tif (CylinderMesh)\n\t{\n\t\tfor (int32 Row = 0; Row < GridRows; ++Row)\n\t\t{\n\t\t\tfor (int32 Col = 0; Col < GridColumns; ++Col)\n\t\t\t{\n\t\t\t\tFVector Position(Row * Spacing, Col * Spacing, 0);\n\t\t\t\tFTransform Transform(FRotator::ZeroRotator, Position);\n\n\t\t\t\tUStaticMeshComponent* CylinderComponent = NewObject<UStaticMeshComponent>(this);\n\t\t\t\tCylinderComponent->SetStaticMesh(CylinderMesh);\n\t\t\t\tCylinderComponent->SetWorldScale3D(FVector(CylinderRadius / 50.0f, CylinderRadius / 50.0f, CylinderHeight / 100.0f));\n\t\t\t\tCylinderComponent->SetWorldTransform(Transform);\n\t\t\t\tCylinderComponent->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepWorldTransform);\n\t\t\t\tCylinderComponent->RegisterComponent();\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a skybox.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SkyboxActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASkyboxActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tASkyboxActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Skybox\")\n\tclass UMaterialInterface* SkyboxMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"SkyboxActor.h\"\n\nASkyboxActor::ASkyboxActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASkyboxActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASkyboxActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that logs a message when activated.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Custom function to activate the actor\n\tUFUNCTION(BlueprintCallable, Category=\"Activation\")\n\tvoid ActivateActor();\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingActor::ALoggingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Custom function to activate the actor\nvoid ALoggingActor::ActivateActor()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Actor Activated!\"));\n\t}\n}\n```"}
{"requirement": "Create a component that rotates when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"RotatingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API URotatingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tURotatingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tvoid RotateActor();\n\n\tUPROPERTY(EditAnywhere)\n\tFRotator RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\nURotatingComponent::URotatingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tRotationSpeed = FRotator(0.f, 100.f, 0.f); // Default rotation speed\n}\n\nvoid URotatingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotatingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (GEngine && GEngine->GameViewport)\n\t{\n\t\tAPlayerController* PlayerController = GEngine->GetFirstLocalPlayerController(GetWorld());\n\t\tif (PlayerController)\n\t\t{\n\t\t\tif (PlayerController->IsInputKeyDown(EKeys::R)) // Change 'R' to any key you want to use\n\t\t\t{\n\t\t\t\tRotateActor();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid URotatingComponent::RotateActor()\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->AddActorLocalRotation(RotationSpeed * GetWorld()->GetDeltaSeconds());\n\t}\n}\n```"}
{"requirement": "Create an actor with a scalable light effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalableLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalableLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScalableLightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Point light component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Light\")\n\tclass UPointLightComponent* PointLight;\n\n\t// Function to scale light intensity\n\tUFUNCTION(BlueprintCallable, Category=\"Light\")\n\tvoid ScaleLightIntensity(float ScaleFactor);\n};\n```", "cpp_code": "```cpp\n#include \"ScalableLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nAScalableLightActor::AScalableLightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a point light component\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\t// Set default intensity\n\tPointLight->Intensity = 3000.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AScalableLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScalableLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to scale light intensity\nvoid AScalableLightActor::ScaleLightIntensity(float ScaleFactor)\n{\n\tif (PointLight)\n\t{\n\t\tPointLight->SetIntensity(PointLight->Intensity * ScaleFactor);\n\t}\n}\n```"}
{"requirement": "Create a class that changes its location with a trigger.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TriggerableMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATriggerableMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATriggerableMover();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnTriggerOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(EditAnywhere)\n\tFVector NewLocation;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* TriggerVolume;\n};\n```", "cpp_code": "```cpp\n#include \"TriggerableMover.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nATriggerableMover::ATriggerableMover()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n\tRootComponent = TriggerVolume;\n\n\tTriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &ATriggerableMover::OnTriggerOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ATriggerableMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATriggerableMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATriggerableMover::OnTriggerOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that spins at a constant rate.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpinningActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpinningActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tASpinningActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Spinning\")\n\tfloat RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"SpinningActor.h\"\n\nASpinningActor::ASpinningActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationRate = 45.0f; // degrees per second\n}\n\nvoid ASpinningActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpinningActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationRate * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create a simple octahedron actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OctahedronActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOctahedronActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAOctahedronActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUProceduralMeshComponent* MeshComponent;\n\n\tvoid CreateOctahedron();\n};\n```", "cpp_code": "```cpp\n#include \"OctahedronActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\n// Sets default values\nAOctahedronActor::AOctahedronActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"GeneratedMesh\"));\n\tRootComponent = MeshComponent;\n\n\tCreateOctahedron();\n}\n\n// Called when the game starts or when spawned\nvoid AOctahedronActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOctahedronActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOctahedronActor::CreateOctahedron()\n{\n\tTArray<FVector> Vertices;\n\tTArray<int32> Triangles;\n\n\t// Define the vertices of the octahedron\n\tVertices.Add(FVector(0, 0, 1));  // Top vertex\n\tVertices.Add(FVector(1, 0, 0));  // Right vertex\n\tVertices.Add(FVector(-1, 0, 0)); // Left vertex\n\tVertices.Add(FVector(0, 1, 0));  // Front vertex\n\tVertices.Add(FVector(0, -1, 0)); // Back vertex\n\tVertices.Add(FVector(0, 0, -1)); // Bottom vertex\n\n\t// Top half triangles\n\tTriangles.Add(0); Triangles.Add(2); Triangles.Add(3);\n\tTriangles.Add(0); Triangles.Add(3); Triangles.Add(1);\n\tTriangles.Add(0); Triangles.Add(1); Triangles.Add(4);\n\tTriangles.Add(0); Triangles.Add(4); Triangles.Add(2);\n\n\t// Bottom half triangles\n\tTriangles.Add(5); Triangles.Add(3); Triangles.Add(2);\n\tTriangles.Add(5); Triangles.Add(1); Triangles.Add(3);\n\tTriangles.Add(5); Triangles.Add(4); Triangles.Add(1);\n\tTriangles.Add(5); Triangles.Add(2); Triangles.Add(4);\n\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UVs;\n\tTArray<FProcMeshTangent> Tangents;\n\tTArray<FLinearColor> VertexColors;\n\n\t// Generate empty arrays for now\n\tfor (int32 i = 0; i < Vertices.Num(); i++)\n\t{\n\t\tNormals.Add(FVector(1, 0, 0));\n\t\tUVs.Add(FVector2D(0, 0));\n\t\tTangents.Add(FProcMeshTangent(0, 1, 0));\n\t\tVertexColors.Add(FLinearColor(1, 1, 1, 1));\n\t}\n\n\t// Create the mesh section\n\tMeshComponent->CreateMeshSection_LinearColor(0, Vertices, Triangles, Normals, UVs, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to an animation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Animation\")\n\tUAnimSequence* AnimationReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that plays a sound on interaction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundInteractionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundInteractionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundInteractionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundCue* InteractionSound;\n\n\tUFUNCTION()\n\tvoid PlaySound();\n};\n```", "cpp_code": "```cpp\n#include \"SoundInteractionActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundInteractionActor::ASoundInteractionActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundInteractionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASoundInteractionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundInteractionActor::PlaySound()\n{\n\tif (InteractionSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, InteractionSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that changes scale based on input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleChangerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UScaleChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUScaleChangerComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \t\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\t// Function to modify scale\n\tvoid ChangeScale(float ScaleFactor);\n\nprivate:\n\t// Input binding function\n\tvoid SetupInputComponent();\n\n\t// Reference to the input component\n\tUInputComponent* InputComponent;\n\n\t// Scale factor\n\tfloat CurrentScale;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values for this component's properties\nUScaleChangerComponent::UScaleChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCurrentScale = 1.0f;\n}\n\n// Called when the game starts\nvoid UScaleChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetupInputComponent();\n}\n\n// Called every frame\nvoid UScaleChangerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UScaleChangerComponent::ChangeScale(float ScaleFactor)\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tFVector NewScale = Owner->GetActorScale3D() * ScaleFactor;\n\t\tOwner->SetActorScale3D(NewScale);\n\t\tCurrentScale *= ScaleFactor;\n\t}\n}\n\nvoid UScaleChangerComponent::SetupInputComponent()\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tInputComponent = Owner->FindComponentByClass<UInputComponent>();\n\t\tif (InputComponent)\n\t\t{\n\t\t\tInputComponent->BindAction(\"IncreaseScale\", IE_Pressed, this, &UScaleChangerComponent::ChangeScale).bConsumeInput = false;\n\t\t\tInputComponent->BindAction(\"DecreaseScale\", IE_Pressed, this, &UScaleChangerComponent::ChangeScale).bConsumeInput = false;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable mesh switcher.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MeshSwitcherActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMeshSwitcherActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMeshSwitcherActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to switch mesh\n\tUFUNCTION(BlueprintCallable, Category=\"Mesh\")\n\tvoid SwitchMesh(UStaticMesh* NewMesh);\n\nprivate:\n\t// Static mesh component\n\tUPROPERTY(VisibleAnywhere, Category=\"Mesh\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MeshSwitcherActor.h\"\n\n// Sets default values\nAMeshSwitcherActor::AMeshSwitcherActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AMeshSwitcherActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMeshSwitcherActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Switch the mesh\nvoid AMeshSwitcherActor::SwitchMesh(UStaticMesh* NewMesh)\n{\n\tif (NewMesh && MeshComponent)\n\t{\n\t\tMeshComponent->SetStaticMesh(NewMesh);\n\t}\n}\n```"}
{"requirement": "Create a class that changes material based on time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ChangeMaterial();\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* Material1;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* Material2;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat ChangeInterval;\n\n\tfloat TimeSinceLastChange;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialChanger.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n\nAMaterialChanger::AMaterialChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tChangeInterval = 5.0f; // Default interval of 5 seconds\n\tTimeSinceLastChange = 0.0f;\n}\n\nvoid AMaterialChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMaterialChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeSinceLastChange += DeltaTime;\n\n\tif (TimeSinceLastChange >= ChangeInterval)\n\t{\n\t\tChangeMaterial();\n\t\tTimeSinceLastChange = 0.0f;\n\t}\n}\n\nvoid AMaterialChanger::ChangeMaterial()\n{\n\tUStaticMeshComponent* Mesh = FindComponentByClass<UStaticMeshComponent>();\n\n\tif (Mesh)\n\t{\n\t\tUMaterialInterface* CurrentMaterial = Mesh->GetMaterial(0);\n\t\tUMaterialInterface* NewMaterial = (CurrentMaterial == Material1) ? Material2 : Material1;\n\t\tMesh->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Create an actor that follows mouse movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseFollowerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMouseFollowerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic: \n\tAMouseFollowerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector2D GetMousePosition() const;\n};\n```", "cpp_code": "```cpp\n#include \"MouseFollowerActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Actor.h\"\n\nAMouseFollowerActor::AMouseFollowerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMouseFollowerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMouseFollowerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector2D MousePosition = GetMousePosition();\n\tFVector WorldLocation, WorldDirection;\n\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController && PlayerController->DeprojectScreenPositionToWorld(MousePosition.X, MousePosition.Y, WorldLocation, WorldDirection))\n\t{\n\t\tFVector NewLocation = WorldLocation + WorldDirection * 100.0f; // Adjust distance as needed\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n\nFVector2D AMouseFollowerActor::GetMousePosition() const\n{\n\tFVector2D MousePosition;\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tPlayerController->GetMousePosition(MousePosition.X, MousePosition.Y);\n\t}\n\treturn MousePosition;\n}\n```"}
{"requirement": "Create a simple rhombus actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RhombusActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARhombusActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARhombusActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* RhombusMesh;\n};\n```", "cpp_code": "```cpp\n#include \"RhombusActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nARhombusActor::ARhombusActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRhombusMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"RhombusMesh\"));\n\tRootComponent = RhombusMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> RhombusMeshAsset(TEXT(\"/Game/Path/To/Your/RhombusMesh.RhombusMesh\"));\n\tif (RhombusMeshAsset.Succeeded())\n\t{\n\t\tRhombusMesh->SetStaticMesh(RhombusMeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ARhombusActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARhombusActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a blueprint event.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"YourClass.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UYourClass : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPROPERTY(BlueprintAssignable, Category = \"Events\")\n\tFYourEventDelegate OnYourEvent;\n};\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FYourEventDelegate);\n```", "cpp_code": "```cpp\n#include \"YourClass.h\"\n\n// Implementation of any necessary methods or logic for UYourClass can be added here.\n\n// Example of calling the event\nvoid UYourClass::TriggerEvent()\n{\n\tOnYourEvent.Broadcast();\n}\n```"}
{"requirement": "Create an actor that emits particles on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ParticleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AParticleActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  AParticleActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  // Particle system component\n  UPROPERTY(VisibleAnywhere, Category = \"Particles\")\n  UParticleSystemComponent* ParticleSystem;\n\n  // Function to handle key press\n  void OnKeyPress();\n\nprotected:\n  // Input handling\n  virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ParticleActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAParticleActor::AParticleActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Create particle system component and attach to root\n  ParticleSystem = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystem\"));\n  RootComponent = ParticleSystem;\n}\n\n// Called when the game starts or when spawned\nvoid AParticleActor::BeginPlay()\n{\n  Super::BeginPlay();\n\n  // Ensure the input component is enabled\n  EnableInput(GetWorld()->GetFirstPlayerController());\n}\n\n// Called every frame\nvoid AParticleActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\n// Input setup\nvoid AParticleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n  Super::SetupPlayerInputComponent(PlayerInputComponent);\n  PlayerInputComponent->BindAction(\"EmitParticles\", IE_Pressed, this, &AParticleActor::OnKeyPress);\n}\n\n// Function to handle key press\nvoid AParticleActor::OnKeyPress()\n{\n  if (ParticleSystem && !ParticleSystem->IsActive())\n  {\n\tParticleSystem->ActivateSystem();\n  }\n}\n```"}
{"requirement": "Create a component that toggles light on/off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleLightComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UToggleLightComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this component's properties\n\tUToggleLightComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Function to toggle the light\n\tUFUNCTION(BlueprintCallable, Category=\"Light\")\n\tvoid ToggleLight();\n\nprivate:\n\t// Pointer to the light component\n\tUPROPERTY()\n\tclass ULightComponent* LightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleLightComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/LightComponent.h\"\n\n// Sets default values for this component's properties\nUToggleLightComponent::UToggleLightComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid UToggleLightComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Try to find the light component in the owner actor\n\tLightComponent = GetOwner()->FindComponentByClass<ULightComponent>();\n}\n\nvoid UToggleLightComponent::ToggleLight()\n{\n\tif (LightComponent)\n\t{\n\t\tLightComponent->ToggleVisibility();\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable spline path.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SplineComponent.h\"\n#include \"CustomSplineActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomSplineActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tACustomSplineActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Spline component to define the path\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Spline\")\n\tUSplineComponent* SplineComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CustomSplineActor.h\"\n#include \"Components/SplineComponent.h\"\n\n// Sets default values\nACustomSplineActor::ACustomSplineActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create spline component and attach it to the root\n\tSplineComponent = CreateDefaultSubobject<USplineComponent>(TEXT(\"SplineComponent\"));\n\tRootComponent = SplineComponent;\n\tSplineComponent->bEditableWhenInherited = true;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomSplineActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACustomSplineActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create a class that logs a message on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyLoggingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyLoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyLoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Logs a message when a key is pressed\n\tvoid LogMessage();\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"MyLoggingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAMyLoggingActor::AMyLoggingActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyLoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyLoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Logs a message when a key is pressed\nvoid AMyLoggingActor::LogMessage()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Key Pressed!\"));\n\t}\n}\n\n// Setup player input component\nvoid AMyLoggingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the LogMessage function to a key press event\n\tPlayerInputComponent->BindAction(\"LogKey\", IE_Pressed, this, &AMyLoggingActor::LogMessage);\n}\n```"}
{"requirement": "Create an actor that changes its scale with a button press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleChangingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  AScaleChangingActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  // Function to change scale\n  void ChangeScale();\n\nprivate:\n  // Scale factor\n  UPROPERTY(EditAnywhere, Category=\"Scale\")\n  FVector ScaleFactor;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangingActor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAScaleChangingActor::AScaleChangingActor()\n{\n  // Set this actor to call Tick() every frame\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Initialize scale factor\n  ScaleFactor = FVector(1.1f, 1.1f, 1.1f);\n}\n\n// Called when the game starts or when spawned\nvoid AScaleChangingActor::BeginPlay()\n{\n  Super::BeginPlay();\n\n  // Enable input\n  EnableInput(GetWorld()->GetFirstPlayerController());\n\n  // Bind input action\n  InputComponent->BindAction(\"ChangeScale\", IE_Pressed, this, &AScaleChangingActor::ChangeScale);\n}\n\n// Called every frame\nvoid AScaleChangingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\n// Change the scale of the actor\nvoid AScaleChangingActor::ChangeScale()\n{\n  FVector NewScale = GetActorScale3D() * ScaleFactor;\n  SetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a simple parallelogram actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ParallelogramActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AParallelogramActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAParallelogramActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* ParallelogramMesh;\n\n\tvoid CreateParallelogramMesh();\n};\n```", "cpp_code": "```cpp\n#include \"ParallelogramActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAParallelogramActor::AParallelogramActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tParallelogramMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"ParallelogramMesh\"));\n\tRootComponent = ParallelogramMesh;\n\n\t// Assuming a basic plane mesh is a placeholder for the parallelogram\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Engine/BasicShapes/Plane\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tParallelogramMesh->SetStaticMesh(MeshAsset.Object);\n\t\tCreateParallelogramMesh();\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AParallelogramActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AParallelogramActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid AParallelogramActor::CreateParallelogramMesh()\n{\n\t// Logic to modify the mesh to resemble a parallelogram\n\t// This could involve manipulating vertices if a custom mesh is created\n\t// For this placeholder, assume it's already a parallelogram shape\n\tParallelogramMesh->SetRelativeScale3D(FVector(1.0f, 1.0f, 0.1f));\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a sound component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundComponentExample.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API USoundComponentExample : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUSoundComponentExample();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* SoundComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SoundComponentExample.h\"\n\nUSoundComponentExample::USoundComponentExample()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid USoundComponentExample::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid USoundComponentExample::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n```"}
{"requirement": "Create an actor that changes its size over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SizeChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ASizeChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tASizeChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The rate at which the actor changes its size\n\tUPROPERTY(EditAnywhere, Category=\"Size\")\n\tfloat SizeChangeRate;\n\n\t// The maximum scale the actor can reach\n\tUPROPERTY(EditAnywhere, Category=\"Size\")\n\tFVector MaxScale;\n\n\t// The minimum scale the actor can reach\n\tUPROPERTY(EditAnywhere, Category=\"Size\")\n\tFVector MinScale;\n\n\t// Current scaling direction\n\tbool bIsIncreasing;\n};\n```", "cpp_code": "```cpp\n#include \"SizeChangingActor.h\"\n\n// Sets default values\nASizeChangingActor::ASizeChangingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSizeChangeRate = 0.5f;\n\tMaxScale = FVector(2.0f, 2.0f, 2.0f);\n\tMinScale = FVector(1.0f, 1.0f, 1.0f);\n\tbIsIncreasing = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASizeChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASizeChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentScale = GetActorScale3D();\n\n\tif (bIsIncreasing)\n\t{\n\t\tCurrentScale += FVector(SizeChangeRate * DeltaTime);\n\t\tif (CurrentScale.X >= MaxScale.X || CurrentScale.Y >= MaxScale.Y || CurrentScale.Z >= MaxScale.Z)\n\t\t{\n\t\t\tbIsIncreasing = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tCurrentScale -= FVector(SizeChangeRate * DeltaTime);\n\t\tif (CurrentScale.X <= MinScale.X || CurrentScale.Y <= MinScale.Y || CurrentScale.Z <= MinScale.Z)\n\t\t{\n\t\t\tbIsIncreasing = true;\n\t\t}\n\t}\n\n\tSetActorScale3D(CurrentScale);\n}\n```"}
{"requirement": "Create a component with a custom reset function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ResettableComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UResettableComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUResettableComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Custom reset function\n\tUFUNCTION(BlueprintCallable, Category=\"Reset\")\n\tvoid ResetComponent();\n\nprivate:\n\t// Example private property to reset\n\tUPROPERTY()\n\tint32 ExampleProperty;\n};\n```", "cpp_code": "```cpp\n#include \"ResettableComponent.h\"\n\n// Sets default values for this component's properties\nUResettableComponent::UResettableComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\t// Initialize the example property\n\tExampleProperty = 0;\n}\n\n// Called when the game starts\nvoid UResettableComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Custom reset function\nvoid UResettableComponent::ResetComponent()\n{\n\t// Reset the example property to its initial value\n\tExampleProperty = 0;\n\t// Additional reset logic can be added here\n}\n```"}
{"requirement": "Create an actor with a customizable light color.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomLightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Light component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Light\")\n\tclass UPointLightComponent* PointLight;\n\n\t// Light color property\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Light\")\n\tFColor LightColor;\n};\n```", "cpp_code": "```cpp\n#include \"CustomLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nACustomLightActor::ACustomLightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach the light component\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\t// Set default light color\n\tLightColor = FColor::White;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Set the initial light color\n\tPointLight->SetLightColor(LightColor);\n}\n\n// Called every frame\nvoid ACustomLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update the light color if it changes\n\tPointLight->SetLightColor(LightColor);\n}\n```"}
{"requirement": "Create a class that moves towards the camera.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MoveTowardsCamera.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMoveTowardsCamera : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMoveTowardsCamera();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat MovementSpeed = 100.0f;\n};\n```", "cpp_code": "```cpp\n#include \"MoveTowardsCamera.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAMoveTowardsCamera::AMoveTowardsCamera()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMoveTowardsCamera::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMoveTowardsCamera::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tFVector CameraLocation;\n\t\tFRotator CameraRotation;\n\t\tPlayerController->GetPlayerViewPoint(CameraLocation, CameraRotation);\n\n\t\tFVector Direction = (CameraLocation - GetActorLocation()).GetSafeNormal();\n\t\tFVector NewLocation = GetActorLocation() + Direction * MovementSpeed * DeltaTime;\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create an actor that can be interacted with using the mouse.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InteractiveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AInteractiveActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAInteractiveActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnMouseClicked();\n\n\tUFUNCTION()\n\tvoid OnMouseOverBegin();\n\n\tUFUNCTION()\n\tvoid OnMouseOverEnd();\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"InteractiveActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAInteractiveActor::AInteractiveActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetCollisionProfileName(TEXT(\"BlockAll\"));\n\tMeshComponent->SetGenerateOverlapEvents(true);\n\n\tMeshComponent->OnClicked.AddDynamic(this, &AInteractiveActor::OnMouseClicked);\n\tMeshComponent->OnBeginCursorOver.AddDynamic(this, &AInteractiveActor::OnMouseOverBegin);\n\tMeshComponent->OnEndCursorOver.AddDynamic(this, &AInteractiveActor::OnMouseOverEnd);\n}\n\n// Called when the game starts or when spawned\nvoid AInteractiveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AInteractiveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AInteractiveActor::OnMouseClicked()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Mesh Clicked\"));\n\t}\n}\n\nvoid AInteractiveActor::OnMouseOverBegin()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Mouse Over Begin\"));\n\t}\n}\n\nvoid AInteractiveActor::OnMouseOverEnd()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Blue, TEXT(\"Mouse Over End\"));\n\t}\n}\n```"}
{"requirement": "Create a simple cuboid actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CuboidActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACuboidActor : public AActor\n{\n  GENERATED_BODY()\n  \npublic: \n  // Sets default values for this actor's properties\n  ACuboidActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic: \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  UPROPERTY(VisibleAnywhere)\n  UStaticMeshComponent* CuboidMesh;\n};\n```", "cpp_code": "```cpp\n#include \"CuboidActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACuboidActor::ACuboidActor()\n{\n  // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  CuboidMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"CuboidMesh\"));\n  RootComponent = CuboidMesh;\n\n  // Set the static mesh for the cuboid\n  static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n  if (MeshAsset.Succeeded())\n  {\n\tCuboidMesh->SetStaticMesh(MeshAsset.Object);\n\tCuboidMesh->SetWorldScale3D(FVector(1.0f, 2.0f, 0.5f)); // Example scale for a cuboid\n  }\n}\n\n// Called when the game starts or when spawned\nvoid ACuboidActor::BeginPlay()\n{\n  Super::BeginPlay();\n  \n}\n\n// Called every frame\nvoid ACuboidActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a dynamic array.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY()\n\tTArray<int32> MyDynamicArray;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that plays an animation on a key event.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"AnimationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAnimationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAAnimationActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Animation to play\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Animation\")\n\tUAnimSequence* AnimationToPlay;\n\n\t// Skeletal Mesh Component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Animation\")\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n\n\t// Function to play animation\n\tUFUNCTION()\n\tvoid PlayAnimation();\n\n\t// Input function\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"AnimationActor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAAnimationActor::AAnimationActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the skeletal mesh component\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AAnimationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AAnimationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AAnimationActor::PlayAnimation()\n{\n\tif (SkeletalMeshComponent && AnimationToPlay)\n\t{\n\t\tUAnimInstance* AnimInstance = SkeletalMeshComponent->GetAnimInstance();\n\t\tif (AnimInstance)\n\t\t{\n\t\t\tAnimInstance->Montage_Play(AnimationToPlay);\n\t\t}\n\t}\n}\n\nvoid AAnimationActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the PlayAnimation function to a key event\n\tPlayerInputComponent->BindAction(\"PlayAnimation\", IE_Pressed, this, &AAnimationActor::PlayAnimation);\n}\n```"}
{"requirement": "Create a component that scales when a key is held down.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UScaleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUScaleComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFVector InitialScale;\n\tfloat ScaleFactor;\n\n\tvoid StartScaling();\n\tvoid StopScaling();\n};\n```", "cpp_code": "```cpp\n#include \"ScaleComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nUScaleComponent::UScaleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tScaleFactor = 1.01f;\n}\n\nvoid UScaleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialScale = GetOwner()->GetActorScale3D();\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tPlayerController->InputComponent->BindAction(\"Scale\", IE_Pressed, this, &UScaleComponent::StartScaling);\n\t\tPlayerController->InputComponent->BindAction(\"Scale\", IE_Released, this, &UScaleComponent::StopScaling);\n\t}\n}\n\nvoid UScaleComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (bIsScaling)\n\t{\n\t\tFVector NewScale = GetOwner()->GetActorScale3D() * ScaleFactor;\n\t\tGetOwner()->SetActorScale3D(NewScale);\n\t}\n}\n\nvoid UScaleComponent::StartScaling()\n{\n\tbIsScaling = true;\n}\n\nvoid UScaleComponent::StopScaling()\n{\n\tbIsScaling = false;\n}\n```"}
{"requirement": "Create an actor with a customizable material instance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tACustomMaterialActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Material Instance\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Material\")\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\n\t// Base Material\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Material\")\n\tUMaterialInterface* BaseMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"CustomMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nACustomMaterialActor::ACustomMaterialActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (BaseMaterial)\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(BaseMaterial, this);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\n// Called every frame\nvoid ACustomMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that changes its sound based on location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundLocationActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASoundLocationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundLocationActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tUSoundCue* DefaultSoundCue;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tUSoundCue* LocationSpecificSoundCue;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tFVector TargetLocation;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tfloat LocationThreshold;\n\nprivate:\n\tvoid UpdateSoundBasedOnLocation();\n};\n```", "cpp_code": "```cpp\n#include \"SoundLocationActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundLocationActor::ASoundLocationActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tLocationThreshold = 100.0f; // Default value, can be adjusted\n}\n\nvoid ASoundLocationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateSoundBasedOnLocation();\n}\n\nvoid ASoundLocationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateSoundBasedOnLocation();\n}\n\nvoid ASoundLocationActor::UpdateSoundBasedOnLocation()\n{\n\tif (!DefaultSoundCue || !LocationSpecificSoundCue)\n\t{\n\t\treturn;\n\t}\n\n\tFVector CurrentLocation = GetActorLocation();\n\tfloat Distance = FVector::Dist(CurrentLocation, TargetLocation);\n\n\tUSoundCue* SoundToPlay = (Distance <= LocationThreshold) ? LocationSpecificSoundCue : DefaultSoundCue;\n\n\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, CurrentLocation);\n}\n```"}
{"requirement": "Create an actor that changes rotation with arrow keys.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Input functions\n\tvoid RotateYaw(float Value);\n\tvoid RotatePitch(float Value);\n\nprivate:\n\t// Rotation speed\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationSpeed = 100.0f; // Default rotation speed\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Enable input for this actor\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tEnableInput(PlayerController);\n\n\t\tInputComponent->BindAxis(\"RotateYaw\", this, &ARotatingActor::RotateYaw);\n\t\tInputComponent->BindAxis(\"RotatePitch\", this, &ARotatingActor::RotatePitch);\n\t}\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARotatingActor::RotateYaw(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Yaw += Value * RotationSpeed * GetWorld()->GetDeltaSeconds();\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n\nvoid ARotatingActor::RotatePitch(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Pitch += Value * RotationSpeed * GetWorld()->GetDeltaSeconds();\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create a simple trapezoid actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TrapezoidActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATrapezoidActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tATrapezoidActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n#if WITH_EDITOR\n\tvirtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;\n#endif\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Trapezoid\")\n\tfloat TopWidth;\n\n\tUPROPERTY(EditAnywhere, Category=\"Trapezoid\")\n\tfloat BottomWidth;\n\n\tUPROPERTY(EditAnywhere, Category=\"Trapezoid\")\n\tfloat Height;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUProceduralMeshComponent* MeshComponent;\n\n\tvoid GenerateMesh();\n};\n```", "cpp_code": "```cpp\n#include \"TrapezoidActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\n// Sets default values\nATrapezoidActor::ATrapezoidActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"GeneratedMesh\"));\n\tRootComponent = MeshComponent;\n\n\tTopWidth = 100.0f;\n\tBottomWidth = 200.0f;\n\tHeight = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ATrapezoidActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGenerateMesh();\n}\n\nvoid ATrapezoidActor::GenerateMesh()\n{\n\tTArray<FVector> Vertices;\n\tTArray<int32> Triangles;\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\tTArray<FProcMeshTangent> Tangents;\n\tTArray<FColor> VertexColors;\n\n\t// Define vertices of the trapezoid\n\tVertices.Add(FVector(-TopWidth / 2, 0, Height)); // Top left\n\tVertices.Add(FVector(TopWidth / 2, 0, Height));  // Top right\n\tVertices.Add(FVector(-BottomWidth / 2, 0, 0));   // Bottom left\n\tVertices.Add(FVector(BottomWidth / 2, 0, 0));\t// Bottom right\n\n\t// Define two triangles\n\tTriangles.Add(0);\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\n\tTriangles.Add(1);\n\tTriangles.Add(3);\n\tTriangles.Add(2);\n\n\t// Normals\n\tfor (int32 i = 0; i < 4; ++i)\n\t{\n\t\tNormals.Add(FVector(0, -1, 0));\n\t}\n\n\t// UVs\n\tUV0.Add(FVector2D(0.0f, 0.0f));\n\tUV0.Add(FVector2D(1.0f, 0.0f));\n\tUV0.Add(FVector2D(0.0f, 1.0f));\n\tUV0.Add(FVector2D(1.0f, 1.0f));\n\n\t// Tangents\n\tfor (int32 i = 0; i < 4; ++i)\n\t{\n\t\tTangents.Add(FProcMeshTangent(1, 0, 0));\n\t}\n\n\t// Vertex colors\n\tfor (int32 i = 0; i < 4; ++i)\n\t{\n\t\tVertexColors.Add(FColor::White);\n\t}\n\n\tMeshComponent->CreateMeshSection_LinearColor(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n\n// Called every frame\nvoid ATrapezoidActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n#if WITH_EDITOR\nvoid ATrapezoidActor::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)\n{\n\tSuper::PostEditChangeProperty(PropertyChangedEvent);\n\n\tGenerateMesh();\n}\n#endif\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a visibility setting.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VisibilitySettings.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVisibilitySettings : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAVisibilitySettings();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Visibility Settings\")\n\tbool bIsVisible;\n};\n```", "cpp_code": "```cpp\n#include \"VisibilitySettings.h\"\n\nAVisibilitySettings::AVisibilitySettings()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsVisible = true; // Default value\n}\n\nvoid AVisibilitySettings::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AVisibilitySettings::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t// Update visibility based on bIsVisible\n\tSetActorHiddenInGame(!bIsVisible);\n}\n```"}
{"requirement": "Create an actor that logs its rotation every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingActor::ALoggingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator ActorRotation = GetActorRotation();\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor Rotation: Pitch=%f, Yaw=%f, Roll=%f\"), ActorRotation.Pitch, ActorRotation.Yaw, ActorRotation.Roll);\n}\n```"}
{"requirement": "Create a component that emits particles at intervals.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"ParticleEmitterComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECTNAME_API UParticleEmitterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUParticleEmitterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Activate(bool bReset = false) override;\n\tvirtual void Deactivate() override;\n\nprivate:\n\tUParticleSystemComponent* ParticleSystemComponent;\n\n\tFTimerHandle TimerHandle;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat EmissionInterval;\n\n\tUPROPERTY(EditAnywhere)\n\tUParticleSystem* ParticleSystemTemplate;\n\n\tvoid EmitParticles();\n};\n```", "cpp_code": "```cpp\n#include \"ParticleEmitterComponent.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n\nUParticleEmitterComponent::UParticleEmitterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tEmissionInterval = 1.0f; // Default interval\n\tParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystemComponent\"));\n}\n\nvoid UParticleEmitterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (ParticleSystemTemplate)\n\t{\n\t\tParticleSystemComponent->SetTemplate(ParticleSystemTemplate);\n\t}\n}\n\nvoid UParticleEmitterComponent::Activate(bool bReset)\n{\n\tSuper::Activate(bReset);\n\tif (GetWorld())\n\t{\n\t\tGetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &UParticleEmitterComponent::EmitParticles, EmissionInterval, true);\n\t}\n}\n\nvoid UParticleEmitterComponent::Deactivate()\n{\n\tSuper::Deactivate();\n\tGetWorld()->GetTimerManager().ClearTimer(TimerHandle);\n}\n\nvoid UParticleEmitterComponent::EmitParticles()\n{\n\tif (ParticleSystemComponent && ParticleSystemTemplate)\n\t{\n\t\tParticleSystemComponent->ActivateSystem();\n\t}\n}\n```"}
{"requirement": "Create an actor with customizable tick behavior.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomTickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomTickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACustomTickActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\t\n\tUFUNCTION(BlueprintCallable, Category=\"CustomTick\")\n\tvoid SetTickEnabled(bool bEnabled);\n\n\tUFUNCTION(BlueprintCallable, Category=\"CustomTick\")\n\tbool IsTickEnabled() const;\n\nprivate:\n\tbool bCanTick;\n};\n```", "cpp_code": "```cpp\n#include \"CustomTickActor.h\"\n\nACustomTickActor::ACustomTickActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbCanTick = true;\n}\n\nvoid ACustomTickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\t\n}\n\nvoid ACustomTickActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!bCanTick)\n\t{\n\t\treturn;\n\t}\n\n\t// Custom tick functionality here\n}\n\nvoid ACustomTickActor::SetTickEnabled(bool bEnabled)\n{\n\tbCanTick = bEnabled;\n\tPrimaryActorTick.SetTickFunctionEnable(bEnabled);\n}\n\nbool ACustomTickActor::IsTickEnabled() const\n{\n\treturn bCanTick;\n}\n```"}
{"requirement": "Create a class that logs a message on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACollisionLogger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnCollision(AActor* OverlappedActor, AActor* OtherActor);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionLogger.h\"\n#include \"GameFramework/Actor.h\"\n\nACollisionLogger::ACollisionLogger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tOnActorBeginOverlap.AddDynamic(this, &ACollisionLogger::OnCollision);\n}\n\nvoid ACollisionLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionLogger::OnCollision(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Collision detected with %s\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Create an actor that moves in a square path.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SquarePathActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASquarePathActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASquarePathActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector StartLocation;\n\tFVector CurrentTarget;\n\tTArray<FVector> PathPoints;\n\tint32 CurrentPathIndex;\n\tfloat MoveSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"SquarePathActor.h\"\n\nASquarePathActor::ASquarePathActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMoveSpeed = 100.0f;\n\tCurrentPathIndex = 0;\n}\n\nvoid ASquarePathActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartLocation = GetActorLocation();\n\tPathPoints.Add(StartLocation);\n\tPathPoints.Add(StartLocation + FVector(100, 0, 0));\n\tPathPoints.Add(StartLocation + FVector(100, 100, 0));\n\tPathPoints.Add(StartLocation + FVector(0, 100, 0));\n\tCurrentTarget = PathPoints[CurrentPathIndex];\n}\n\nvoid ASquarePathActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (FVector::Dist(GetActorLocation(), CurrentTarget) < KINDA_SMALL_NUMBER)\n\t{\n\t\tCurrentPathIndex = (CurrentPathIndex + 1) % PathPoints.Num();\n\t\tCurrentTarget = PathPoints[CurrentPathIndex];\n\t}\n\n\tFVector Direction = (CurrentTarget - GetActorLocation()).GetSafeNormal();\n\tSetActorLocation(GetActorLocation() + Direction * MoveSpeed * DeltaTime);\n}\n```"}
{"requirement": "Create a simple rhomboid actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RhomboidActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARhomboidActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARhomboidActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Rhomboid mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* RhomboidMesh;\n};\n```", "cpp_code": "```cpp\n#include \"RhomboidActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nARhomboidActor::ARhomboidActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach the rhomboid mesh component\n\tRhomboidMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"RhomboidMesh\"));\n\tRootComponent = RhomboidMesh;\n\n\t// Load a basic shape mesh (e.g., a cube) and scale it to form a rhomboid\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tRhomboidMesh->SetStaticMesh(MeshAsset.Object);\n\n\t\t// Set the scale to form a rhomboid shape\n\t\tRhomboidMesh->SetRelativeScale3D(FVector(1.0f, 0.5f, 0.5f));\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ARhomboidActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARhomboidActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to an input event.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Input\")\n\tFName InputEventName;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its texture on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TextureSwapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureSwapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATextureSwapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Texture\")\n\tUTexture* NewTexture;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"TextureSwapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nATextureSwapActor::ATextureSwapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ATextureSwapActor::OnOverlapBegin);\n}\n\nvoid ATextureSwapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATextureSwapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATextureSwapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (NewTexture && MeshComponent)\n\t{\n\t\tMeshComponent->SetMaterial(0, UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this));\n\t\tUMaterialInstanceDynamic* DynamicMaterial = Cast<UMaterialInstanceDynamic>(MeshComponent->GetMaterial(0));\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tDynamicMaterial->SetTextureParameterValue(TEXT(\"TextureParameter\"), NewTexture);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a component that toggles mesh visibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleVisibilityComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UToggleVisibilityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUToggleVisibilityComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void ToggleVisibility();\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values for this component's properties\nUToggleVisibilityComponent::UToggleVisibilityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid UToggleVisibilityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tMeshComponent = GetOwner()->FindComponentByClass<UStaticMeshComponent>();\n\tif (!MeshComponent)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"No StaticMeshComponent found on %s\"), *GetOwner()->GetName());\n\t}\n}\n\nvoid UToggleVisibilityComponent::ToggleVisibility()\n{\n\tif (MeshComponent)\n\t{\n\t\tbool bIsVisible = MeshComponent->IsVisible();\n\t\tMeshComponent->SetVisibility(!bIsVisible);\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable light flicker effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FlickeringLight.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFlickeringLight : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAFlickeringLight();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPointLightComponent* PointLight;\n\n\tUPROPERTY(EditAnywhere, Category=\"Flicker\")\n\tfloat FlickerIntensityMin;\n\n\tUPROPERTY(EditAnywhere, Category=\"Flicker\")\n\tfloat FlickerIntensityMax;\n\n\tUPROPERTY(EditAnywhere, Category=\"Flicker\")\n\tfloat FlickerSpeed;\n\n\tvoid FlickerLight(float DeltaTime);\n\n\tfloat CurrentIntensity;\n};\n```", "cpp_code": "```cpp\n#include \"FlickeringLight.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"Engine/World.h\"\n\nAFlickeringLight::AFlickeringLight()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\tFlickerIntensityMin = 1000.0f;\n\tFlickerIntensityMax = 3000.0f;\n\tFlickerSpeed = 5.0f;\n\n\tCurrentIntensity = FlickerIntensityMax;\n}\n\nvoid AFlickeringLight::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AFlickeringLight::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFlickerLight(DeltaTime);\n}\n\nvoid AFlickeringLight::FlickerLight(float DeltaTime)\n{\n\tfloat TargetIntensity = FMath::Lerp(FlickerIntensityMin, FlickerIntensityMax, FMath::FRand());\n\tCurrentIntensity = FMath::FInterpTo(CurrentIntensity, TargetIntensity, DeltaTime, FlickerSpeed);\n\tPointLight->SetIntensity(CurrentIntensity);\n}\n```"}
{"requirement": "Create a class that changes its scale based on time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScaleChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t/** Initial scale of the actor */\n\tFVector InitialScale;\n\n\t/** Time elapsed since start */\n\tfloat TimeElapsed;\n\n\t/** Scale factor per second */\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat ScaleFactorPerSecond;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangingActor.h\"\n\nAScaleChangingActor::AScaleChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tInitialScale = FVector(1.0f, 1.0f, 1.0f);\n\tTimeElapsed = 0.0f;\n\tScaleFactorPerSecond = 0.1f; // Example scale factor\n}\n\nvoid AScaleChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialScale = GetActorScale3D();\n}\n\nvoid AScaleChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeElapsed += DeltaTime;\n\n\tfloat ScaleFactor = 1.0f + (ScaleFactorPerSecond * TimeElapsed);\n\n\tSetActorScale3D(InitialScale * ScaleFactor);\n}\n```"}
{"requirement": "Create an actor that plays a sound when overlapping another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapSoundActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AOverlapSoundActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n  class UBoxComponent* OverlapComponent;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n  class USoundBase* SoundToPlay;\n\n  UFUNCTION()\n  void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapSoundActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAOverlapSoundActor::AOverlapSoundActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n\n  OverlapComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"OverlapComponent\"));\n  RootComponent = OverlapComponent;\n  OverlapComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapSoundActor::OnOverlapBegin);\n}\n\nvoid AOverlapSoundActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AOverlapSoundActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AOverlapSoundActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n  if (SoundToPlay && OtherActor != this)\n  {\n\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n  }\n}\n```"}
{"requirement": "Create a simple polyhedron actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimplePolyhedronActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimplePolyhedronActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASimplePolyhedronActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The procedural mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUProceduralMeshComponent* ProceduralMesh;\n\n\t// Function to create a simple polyhedron\n\tvoid CreatePolyhedron();\n};\n```", "cpp_code": "```cpp\n#include \"SimplePolyhedronActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\n// Sets default values\nASimplePolyhedronActor::ASimplePolyhedronActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the procedural mesh component\n\tProceduralMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"ProceduralMesh\"));\n\tRootComponent = ProceduralMesh;\n\n\t// Create the polyhedron\n\tCreatePolyhedron();\n}\n\n// Called when the game starts or when spawned\nvoid ASimplePolyhedronActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASimplePolyhedronActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASimplePolyhedronActor::CreatePolyhedron()\n{\n\t// Define vertices for a simple tetrahedron (a type of polyhedron)\n\tTArray<FVector> Vertices;\n\tVertices.Add(FVector(0, 0, 0));\n\tVertices.Add(FVector(100, 0, 0));\n\tVertices.Add(FVector(50, 100, 0));\n\tVertices.Add(FVector(50, 50, 100));\n\n\t// Define triangles for the tetrahedron\n\tTArray<int32> Triangles;\n\tTriangles.Add(0);\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\tTriangles.Add(0);\n\tTriangles.Add(2);\n\tTriangles.Add(3);\n\tTriangles.Add(0);\n\tTriangles.Add(3);\n\tTriangles.Add(1);\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\tTriangles.Add(3);\n\n\t// Empty arrays for normals, UVs, vertex colors, tangents\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\tTArray<FColor> VertexColors;\n\tTArray<FProcMeshTangent> Tangents;\n\n\t// Create the mesh section\n\tProceduralMesh->CreateMeshSection(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a spline component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/SplineComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MySplineActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMySplineActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMySplineActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Spline\")\n\tUSplineComponent* SplineComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MySplineActor.h\"\n\nAMySplineActor::AMySplineActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSplineComponent = CreateDefaultSubobject<USplineComponent>(TEXT(\"SplineComponent\"));\n\tRootComponent = SplineComponent;\n}\n\nvoid AMySplineActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMySplineActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes location with mouse movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseControlledActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMouseControlledActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMouseControlledActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid UpdateLocationWithMouse();\n\n\tFVector2D MousePosition;\n};\n```", "cpp_code": "```cpp\n#include \"MouseControlledActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAMouseControlledActor::AMouseControlledActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMouseControlledActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMouseControlledActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tUpdateLocationWithMouse();\n}\n\nvoid AMouseControlledActor::UpdateLocationWithMouse()\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\t// Get mouse position\n\t\tPlayerController->GetMousePosition(MousePosition.X, MousePosition.Y);\n\n\t\t// Convert mouse position to world position\n\t\tFVector WorldLocation, WorldDirection;\n\t\tPlayerController->DeprojectScreenPositionToWorld(MousePosition.X, MousePosition.Y, WorldLocation, WorldDirection);\n\n\t\t// Move the actor to the mouse world location\n\t\tSetActorLocation(WorldLocation);\n\t}\n}\n```"}
{"requirement": "Create a component with a custom toggle function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UToggleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUToggleComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category=\"Toggle\")\n\tvoid Toggle();\n\nprivate:\n\tbool bIsToggled;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleComponent.h\"\n\nUToggleComponent::UToggleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbIsToggled = false;\n}\n\nvoid UToggleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UToggleComponent::Toggle()\n{\n\tbIsToggled = !bIsToggled;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Toggle State: %s\"), bIsToggled ? TEXT(\"On\") : TEXT(\"Off\"));\n}\n```"}
{"requirement": "Create an actor with a customizable sound volume.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"CustomSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sound Component\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tUSoundBase* Sound;\n\n\t// Volume Multiplier\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tfloat VolumeMultiplier;\n};\n```", "cpp_code": "```cpp\n#include \"CustomSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundBase.h\"\n\n// Sets default values\nACustomSoundActor::ACustomSoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tVolumeMultiplier = 1.0f; // Default volume multiplier\n}\n\n// Called when the game starts or when spawned\nvoid ACustomSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Sound)\n\t{\n\t\tUGameplayStatics::SpawnSoundAtLocation(this, Sound, GetActorLocation(), FRotator::ZeroRotator, VolumeMultiplier);\n\t}\n}\n\n// Called every frame\nvoid ACustomSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that logs a message on mouse click.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogOnClickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALogOnClickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tALogOnClickActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to log a message on mouse click\n\tUFUNCTION()\n\tvoid OnMouseClick();\n};\n```", "cpp_code": "```cpp\n#include \"LogOnClickActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALogOnClickActor::ALogOnClickActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALogOnClickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tEnableInput(PlayerController);\n\t\tInputComponent->BindAction(\"LeftMouseClick\", IE_Pressed, this, &ALogOnClickActor::OnMouseClick);\n\t}\n}\n\n// Called every frame\nvoid ALogOnClickActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to log a message on mouse click\nvoid ALogOnClickActor::OnMouseClick()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Mouse Clicked!\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that rotates with mouse drag.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent);\n\nprivate:\n\tvoid RotateActor(float AxisValue);\n\n\tFVector2D InitialMousePosition;\n\tbool bIsDragging;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsDragging = false;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (APlayerController* PC = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tEnableInput(PC);\n\t\tSetupPlayerInputComponent(InputComponent);\n\t}\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsDragging)\n\t{\n\t\tFVector2D CurrentMousePosition;\n\t\tif (APlayerController* PC = GetWorld()->GetFirstPlayerController())\n\t\t{\n\t\t\tPC->GetMousePosition(CurrentMousePosition.X, CurrentMousePosition.Y);\n\n\t\t\tfloat DeltaX = CurrentMousePosition.X - InitialMousePosition.X;\n\n\t\t\tFRotator NewRotation = FRotator(0.f, DeltaX, 0.f);\n\t\t\tAddActorLocalRotation(NewRotation);\n\n\t\t\tInitialMousePosition = CurrentMousePosition;\n\t\t}\n\t}\n}\n\nvoid ARotatingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"Turn\", this, &ARotatingActor::RotateActor);\n\tPlayerInputComponent->BindAction(\"Drag\", IE_Pressed, this, &ARotatingActor::StartDrag);\n\tPlayerInputComponent->BindAction(\"Drag\", IE_Released, this, &ARotatingActor::StopDrag);\n}\n\nvoid ARotatingActor::RotateActor(float AxisValue)\n{\n\tif (bIsDragging && AxisValue != 0.0f)\n\t{\n\t\tAddActorLocalRotation(FRotator(0.f, AxisValue, 0.f));\n\t}\n}\n\nvoid ARotatingActor::StartDrag()\n{\n\tbIsDragging = true;\n\n\tif (APlayerController* PC = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tPC->GetMousePosition(InitialMousePosition.X, InitialMousePosition.Y);\n\t}\n}\n\nvoid ARotatingActor::StopDrag()\n{\n\tbIsDragging = false;\n}\n```"}
{"requirement": "Create a simple polygon actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimplePolygonActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimplePolygonActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASimplePolygonActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* PolygonMesh;\n\n\tvoid CreatePolygonMesh();\n};\n```", "cpp_code": "```cpp\n#include \"SimplePolygonActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n\n// Sets default values\nASimplePolygonActor::ASimplePolygonActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a static mesh component\n\tPolygonMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"PolygonMesh\"));\n\tRootComponent = PolygonMesh;\n\n\t// Create polygon mesh\n\tCreatePolygonMesh();\n}\n\n// Called when the game starts or when spawned\nvoid ASimplePolygonActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASimplePolygonActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASimplePolygonActor::CreatePolygonMesh()\n{\n\t// Load a simple polygon mesh from a file or create a custom mesh\n\t// For simplicity, we're using an existing engine mesh\n\tUStaticMesh* Mesh = LoadObject<UStaticMesh>(nullptr, TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n\tif (Mesh)\n\t{\n\t\tPolygonMesh->SetStaticMesh(Mesh);\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a material array.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AYourActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Materials\")\n  TArray<UMaterialInterface*> MaterialArray;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that plays a sound when entering a trigger box.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundTriggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundTriggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundTriggerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Trigger box component\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* TriggerBox;\n\n\t// Sound to play\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundToPlay;\n\n\t// Function to handle the trigger box overlap\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"SoundTriggerActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundTriggerActor::ASoundTriggerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and configure a trigger box component\n\tTriggerBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerBox\"));\n\tRootComponent = TriggerBox;\n\tTriggerBox->SetCollisionProfileName(TEXT(\"Trigger\"));\n\tTriggerBox->OnComponentBeginOverlap.AddDynamic(this, &ASoundTriggerActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ASoundTriggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASoundTriggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundTriggerActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (SoundToPlay && OtherActor != this)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that changes its scale when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleOnClickComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UScaleOnClickComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUScaleOnClickComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFVector OriginalScale;\n\tFVector TargetScale;\n\tbool bIsScaled;\n\n\tUFUNCTION()\n\tvoid OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n};\n```", "cpp_code": "```cpp\n#include \"ScaleOnClickComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Components/PrimitiveComponent.h\"\n\n// Sets default values for this component's properties\nUScaleOnClickComponent::UScaleOnClickComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tbIsScaled = false;\n\tTargetScale = FVector(2.0f, 2.0f, 2.0f); // Example scale factor\n}\n\n// Called when the game starts\nvoid UScaleOnClickComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOriginalScale = Owner->GetActorScale3D();\n\t\tOwner->OnClicked.AddDynamic(this, &UScaleOnClickComponent::OnClicked);\n\t}\n}\n\n// Called every frame\nvoid UScaleOnClickComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UScaleOnClickComponent::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tif (bIsScaled)\n\t\t{\n\t\t\tOwner->SetActorScale3D(OriginalScale);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOwner->SetActorScale3D(TargetScale);\n\t\t}\n\t\tbIsScaled = !bIsScaled;\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable collision response.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomCollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ACustomCollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tACustomCollisionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Collision\")\n\tclass UBoxComponent* CollisionComponent;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Collision\")\n\tvoid SetCollisionResponse(ECollisionChannel Channel, ECollisionResponse NewResponse);\n};\n```", "cpp_code": "```cpp\n#include \"CustomCollisionActor.h\"\n#include \"Components/BoxComponent.h\"\n\n// Sets default values\nACustomCollisionActor::ACustomCollisionActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the collision component\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\t// Set default collision responses\n\tCollisionComponent->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);\n}\n\n// Called when the game starts or when spawned\nvoid ACustomCollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACustomCollisionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ACustomCollisionActor::SetCollisionResponse(ECollisionChannel Channel, ECollisionResponse NewResponse)\n{\n\tif (CollisionComponent)\n\t{\n\t\tCollisionComponent->SetCollisionResponseToChannel(Channel, NewResponse);\n\t}\n}\n```"}
{"requirement": "Create a class that logs when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"KeyPressLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AKeyPressLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAKeyPressLogger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle key press\n\tvoid OnKeyPress(FKey Key);\n};\n```", "cpp_code": "```cpp\n#include \"KeyPressLogger.h\"\n#include \"Engine/Engine.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAKeyPressLogger::AKeyPressLogger()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AKeyPressLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (APlayerController* PC = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tPC->InputComponent->BindKey(EKeys::AnyKey, IE_Pressed, this, &AKeyPressLogger::OnKeyPress);\n\t}\n}\n\n// Called every frame\nvoid AKeyPressLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AKeyPressLogger::OnKeyPress(FKey Key)\n{\n\tif (GEngine)\n\t{\n\t\tFString KeyString = Key.GetDisplayName().ToString();\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Key Pressed: %s\"), *KeyString));\n\t}\n}\n```"}
{"requirement": "Create an actor that moves according to a path.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PathFollowingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APathFollowingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tAPathFollowingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Path\")\n\tTArray<FVector> PathPoints;\n\n\tint32 CurrentPathIndex;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"PathFollowingActor.h\"\n\nAPathFollowingActor::APathFollowingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentPathIndex = 0;\n\tMovementSpeed = 100.0f;\n}\n\nvoid APathFollowingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Initialize PathPoints with some example data\n\tPathPoints.Add(FVector(0, 0, 0));\n\tPathPoints.Add(FVector(300, 0, 0));\n\tPathPoints.Add(FVector(300, 300, 0));\n\tPathPoints.Add(FVector(0, 300, 0));\n}\n\nvoid APathFollowingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PathPoints.Num() == 0 || CurrentPathIndex >= PathPoints.Num())\n\t{\n\t\treturn;\n\t}\n\n\tFVector CurrentLocation = GetActorLocation();\n\tFVector TargetLocation = PathPoints[CurrentPathIndex];\n\n\tFVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n\tFVector NewLocation = CurrentLocation + Direction * MovementSpeed * DeltaTime;\n\n\tSetActorLocation(NewLocation);\n\n\tif (FVector::Dist(NewLocation, TargetLocation) < 10.0f)\n\t{\n\t\tCurrentPathIndex++;\n\t}\n\n\tif (CurrentPathIndex >= PathPoints.Num())\n\t{\n\t\tCurrentPathIndex = 0; // Loop back to start\n\t}\n}\n```"}
{"requirement": "Create a simple disc actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DiscActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADiscActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADiscActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* DiscMesh;\n};\n```", "cpp_code": "```cpp\n#include \"DiscActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nADiscActor::ADiscActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tDiscMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"DiscMesh\"));\n\tRootComponent = DiscMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> DiscMeshAsset(TEXT(\"/Game/Geometry/Meshes/DiscMesh.DiscMesh\"));\n\tif (DiscMeshAsset.Succeeded())\n\t{\n\t\tDiscMesh->SetStaticMesh(DiscMeshAsset.Object);\n\t}\n}\n\nvoid ADiscActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADiscActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a streaming level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Level\")\n\tULevelStreaming* StreamingLevelReference;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\t// Constructor logic here\n\tStreamingLevelReference = nullptr;\n}\n```"}
{"requirement": "Create an actor that logs a message when leaving a volume.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tALoggingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* Volume;\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\nALoggingActor::ALoggingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"Volume\"));\n\tRootComponent = Volume;\n\n\tVolume->OnComponentEndOverlap.AddDynamic(this, &ALoggingActor::OnOverlapEnd);\n}\n\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ALoggingActor::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (OtherActor && (OtherActor != this))\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Actor %s has left the volume.\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Create a component with a custom initialization function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomInitComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomInitComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUCustomInitComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION(BlueprintCallable, Category=\"Initialization\")\n\tvoid CustomInitialize();\n};\n```", "cpp_code": "```cpp\n#include \"CustomInitComponent.h\"\n\nUCustomInitComponent::UCustomInitComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UCustomInitComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Optionally call CustomInitialize here or elsewhere as needed\n}\n\nvoid UCustomInitComponent::CustomInitialize()\n{\n\t// Custom initialization logic here\n}\n```"}
{"requirement": "Create an actor with a customizable sound attenuation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundAttenuation.h\"\n#include \"Sound/SoundCue.h\"\n#include \"CustomSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACustomSoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundCue* SoundCue;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundAttenuation* SoundAttenuation;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Sound\")\n\tvoid PlaySound();\n};\n```", "cpp_code": "```cpp\n#include \"CustomSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n\nACustomSoundActor::ACustomSoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ACustomSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACustomSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACustomSoundActor::PlaySound()\n{\n\tif (SoundCue)\n\t{\n\t\tUAudioComponent* AudioComponent = UGameplayStatics::SpawnSoundAtLocation(this, SoundCue, GetActorLocation(), FRotator::ZeroRotator, 1.0f, 1.0f, 0.0f, SoundAttenuation);\n\t}\n}\n```"}
{"requirement": "Create a class that moves towards a light source.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MoveTowardsLight.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMoveTowardsLight : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMoveTowardsLight();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Function to move towards the light source\n\tvoid MoveTowardsLight(float DeltaTime);\n\n\t// The target light actor to move towards\n\tAActor* TargetLight;\n\n\t// Movement speed\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MoveTowardsLight.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAMoveTowardsLight::AMoveTowardsLight()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementSpeed = 100.0f; // default movement speed\n}\n\n// Called when the game starts or when spawned\nvoid AMoveTowardsLight::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Find the first light source in the world\n\tTArray<AActor*> FoundActors;\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), AActor::StaticClass(), FoundActors);\n\n\tfor (AActor* Actor : FoundActors)\n\t{\n\t\tif (Actor->ActorHasTag(\"Light\")) // Assuming the light source has been tagged as \"Light\"\n\t\t{\n\t\t\tTargetLight = Actor;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// Called every frame\nvoid AMoveTowardsLight::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetLight)\n\t{\n\t\tMoveTowardsLight(DeltaTime);\n\t}\n}\n\nvoid AMoveTowardsLight::MoveTowardsLight(float DeltaTime)\n{\n\tif (!TargetLight) return;\n\n\tFVector Direction = (TargetLight->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n\tFVector NewLocation = GetActorLocation() + (Direction * MovementSpeed * DeltaTime);\n\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that can be highlighted with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HighlightableActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AHighlightableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHighlightableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to toggle highlight\n\tvoid ToggleHighlight();\n\nprivate:\n\t// Material to apply when highlighted\n\tUMaterialInterface* HighlightMaterial;\n\n\t// Original material of the actor\n\tUMaterialInterface* OriginalMaterial;\n\n\t// Mesh component to apply the material to\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Whether the actor is currently highlighted\n\tbool bIsHighlighted;\n};\n```", "cpp_code": "```cpp\n#include \"HighlightableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAHighlightableActor::AHighlightableActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create MeshComponent and set as root\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Load the highlight material\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialFinder(TEXT(\"Material'/Game/HighlightMaterial.HighlightMaterial'\"));\n\tif (MaterialFinder.Succeeded())\n\t{\n\t\tHighlightMaterial = MaterialFinder.Object;\n\t}\n\n\t// Initialize the highlight state\n\tbIsHighlighted = false;\n}\n\n// Called when the game starts or when spawned\nvoid AHighlightableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Store the original material\n\tif (MeshComponent && MeshComponent->GetMaterial(0))\n\t{\n\t\tOriginalMaterial = MeshComponent->GetMaterial(0);\n\t}\n}\n\n// Called every frame\nvoid AHighlightableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to toggle highlight\nvoid AHighlightableActor::ToggleHighlight()\n{\n\tif (bIsHighlighted)\n\t{\n\t\t// Revert to the original material\n\t\tMeshComponent->SetMaterial(0, OriginalMaterial);\n\t}\n\telse\n\t{\n\t\t// Apply the highlight material\n\t\tMeshComponent->SetMaterial(0, HighlightMaterial);\n\t}\n\n\t// Toggle the highlight state\n\tbIsHighlighted = !bIsHighlighted;\n}\n```"}
{"requirement": "Create a simple square actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SquareActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASquareActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASquareActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* SquareMesh;\n};\n```", "cpp_code": "```cpp\n#include \"SquareActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASquareActor::ASquareActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a static mesh component\n\tSquareMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"SquareMesh\"));\n\tRootComponent = SquareMesh;\n\n\t// Find and set the static mesh for the square\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> SquareMeshAsset(TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n\tif (SquareMeshAsset.Succeeded())\n\t{\n\t\tSquareMesh->SetStaticMesh(SquareMeshAsset.Object);\n\t\tSquareMesh->SetWorldScale3D(FVector(1.f, 1.f, 0.01f)); // Scale to make it a square\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ASquareActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASquareActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a mesh array.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Meshes\")\n\tTArray<UStaticMeshComponent*> MeshArray;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Create an actor that changes its sound based on proximity.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ProximitySoundActor.generated.h\"\n\nclass UAudioComponent;\nclass USphereComponent;\n\nUCLASS()\nclass YOURPROJECT_API AProximitySoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAProximitySoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Function to handle proximity sound change\n\tvoid UpdateSoundBasedOnProximity();\n\n\t// Sphere component to detect proximity\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUSphereComponent* ProximitySphere;\n\n\t// Audio component to play sound\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUAudioComponent* AudioComponent;\n\n\t// Maximum distance at which the sound changes\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tfloat MaxProximityDistance;\n\n\t// The player character\n\tAPawn* PlayerPawn;\n};\n```", "cpp_code": "```cpp\n#include \"ProximitySoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAProximitySoundActor::AProximitySoundActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize components\n\tProximitySphere = CreateDefaultSubobject<USphereComponent>(TEXT(\"ProximitySphere\"));\n\tRootComponent = ProximitySphere;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n\n\tMaxProximityDistance = 1000.0f; // Example value, can be changed in editor\n}\n\n// Called when the game starts or when spawned\nvoid AProximitySoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\n// Called every frame\nvoid AProximitySoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tUpdateSoundBasedOnProximity();\n}\n\nvoid AProximitySoundActor::UpdateSoundBasedOnProximity()\n{\n\tif (!PlayerPawn) return;\n\n\tfloat DistanceToPlayer = FVector::Dist(PlayerPawn->GetActorLocation(), GetActorLocation());\n\n\tif (DistanceToPlayer <= MaxProximityDistance)\n\t{\n\t\t// Calculate volume based on distance\n\t\tfloat Volume = 1.0f - (DistanceToPlayer / MaxProximityDistance);\n\t\tAudioComponent->SetVolumeMultiplier(Volume);\n\t\tif (!AudioComponent->IsPlaying())\n\t\t{\n\t\t\tAudioComponent->Play();\n\t\t}\n\t}\n\telse\n\t{\n\t\tAudioComponent->Stop();\n\t}\n}\n```"}
{"requirement": "Create a component that logs its position every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"PositionLoggerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UPositionLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPositionLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tvoid LogPosition();\n\n\tFTimerHandle TimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"PositionLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nUPositionLoggerComponent::UPositionLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UPositionLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &UPositionLoggerComponent::LogPosition, 1.0f, true);\n}\n\nvoid UPositionLoggerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UPositionLoggerComponent::LogPosition()\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector Position = Owner->GetActorLocation();\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Actor Position: %s\"), *Position.ToString());\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable light spotlight.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SpotLightComponent.h\"\n#include \"CustomSpotlightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomSpotlightActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tACustomSpotlightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUSpotLightComponent* SpotLight;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light Settings\")\n\tfloat LightIntensity;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light Settings\")\n\tFColor LightColor;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light Settings\")\n\tfloat LightInnerConeAngle;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light Settings\")\n\tfloat LightOuterConeAngle;\n};\n```", "cpp_code": "```cpp\n#include \"CustomSpotlightActor.h\"\n\n// Sets default values\nACustomSpotlightActor::ACustomSpotlightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSpotLight = CreateDefaultSubobject<USpotLightComponent>(TEXT(\"SpotLight\"));\n\tRootComponent = SpotLight;\n\n\t// Set default values\n\tLightIntensity = 3000.0f;\n\tLightColor = FColor::White;\n\tLightInnerConeAngle = 20.0f;\n\tLightOuterConeAngle = 40.0f;\n\n\tSpotLight->SetIntensity(LightIntensity);\n\tSpotLight->SetLightColor(LightColor);\n\tSpotLight->SetInnerConeAngle(LightInnerConeAngle);\n\tSpotLight->SetOuterConeAngle(LightOuterConeAngle);\n}\n\n// Called when the game starts or when spawned\nvoid ACustomSpotlightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Initialize spotlight settings\n\tSpotLight->SetIntensity(LightIntensity);\n\tSpotLight->SetLightColor(LightColor);\n\tSpotLight->SetInnerConeAngle(LightInnerConeAngle);\n\tSpotLight->SetOuterConeAngle(LightOuterConeAngle);\n}\n\n// Called every frame\nvoid ACustomSpotlightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\t// If you want to update the spotlight properties dynamically, you can update here\n\tSpotLight->SetIntensity(LightIntensity);\n\tSpotLight->SetLightColor(LightColor);\n\tSpotLight->SetInnerConeAngle(LightInnerConeAngle);\n\tSpotLight->SetOuterConeAngle(LightOuterConeAngle);\n}\n```"}
{"requirement": "Create a class that changes its rotation based on tick time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = FRotator(0.f, 50.f, 0.f); // Example rotation speed\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFRotator NewRotation = GetActorRotation() + RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an actor that scales with mouse scroll.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid SetupInputComponent();\n\tvoid OnMouseWheelScrolled(float AxisValue);\n\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tfloat ScaleFactor;\n\n\tFVector InitialScale;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScaleFactor = 0.1f;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialScale = GetActorScale3D();\n\tSetupInputComponent();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScalingActor::SetupInputComponent()\n{\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tEnableInput(PlayerController);\n\t\tif (InputComponent)\n\t\t{\n\t\t\tInputComponent->BindAxis(\"MouseWheel\", this, &AScalingActor::OnMouseWheelScrolled);\n\t\t}\n\t}\n}\n\nvoid AScalingActor::OnMouseWheelScrolled(float AxisValue)\n{\n\tFVector NewScale = GetActorScale3D() + FVector(AxisValue * ScaleFactor);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a simple rectangular prism actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RectangularPrismActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARectangularPrismActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARectangularPrismActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* PrismMesh;\n};\n```", "cpp_code": "```cpp\n#include \"RectangularPrismActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nARectangularPrismActor::ARectangularPrismActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPrismMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"PrismMesh\"));\n\tRootComponent = PrismMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> PrismAsset(TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n\tif (PrismAsset.Succeeded())\n\t{\n\t\tPrismMesh->SetStaticMesh(PrismAsset.Object);\n\t\tPrismMesh->SetWorldScale3D(FVector(1.0f, 2.0f, 0.5f)); // Example scale to make it rectangular\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ARectangularPrismActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARectangularPrismActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a physics material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PhysicsEngine/PhysicsMaterial.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Physics\")\n\tUPhysicalMaterial* PhysicsMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\n// Add default functionality here for any IYourActor functions that are not pure virtual.\n```"}
{"requirement": "Create an actor that logs a message when a key is released.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"KeyReleaseLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AKeyReleaseLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAKeyReleaseLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tvoid OnKeyReleased();\n};\n```", "cpp_code": "```cpp\n#include \"KeyReleaseLoggerActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nAKeyReleaseLoggerActor::AKeyReleaseLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AKeyReleaseLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AKeyReleaseLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AKeyReleaseLoggerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"YourActionName\", IE_Released, this, &AKeyReleaseLoggerActor::OnKeyReleased);\n\t}\n}\n\nvoid AKeyReleaseLoggerActor::OnKeyReleased()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Key Released!\"));\n}\n```"}
{"requirement": "Create a component that changes color each second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ColorChangeComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UColorChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUColorChangeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tFTimerHandle ColorChangeTimerHandle;\n\tvoid ChangeColor();\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"TimerManager.h\"\n\nUColorChangeComponent::UColorChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UColorChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorld()->GetTimerManager().SetTimer(ColorChangeTimerHandle, this, &UColorChangeComponent::ChangeColor, 1.0f, true);\n}\n\nvoid UColorChangeComponent::ChangeColor()\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUMeshComponent* MeshComp = Owner->FindComponentByClass<UMeshComponent>();\n\t\tif (MeshComp)\n\t\t{\n\t\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComp->CreateAndSetMaterialInstanceDynamic(0);\n\t\t\tif (DynamicMaterial)\n\t\t\t{\n\t\t\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\t\t\tDynamicMaterial->SetVectorParameterValue(\"Color\", NewColor);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable mesh rotation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tARotatingMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mesh\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Rotation\")\n\tFRotator RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingMeshActor.h\"\n\n// Sets default values\nARotatingMeshActor::ARotatingMeshActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tRotationSpeed = FRotator(0.0f, 0.0f, 0.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ARotatingMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!RotationSpeed.IsZero())\n\t{\n\t\tFRotator NewRotation = GetActorRotation() + (RotationSpeed * DeltaTime);\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create a class that rotates with mouse input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationSpeed;\n\nprivate:\n\tvoid RotateWithMouseInput(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 100.0f; // Default rotation speed\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tRotateWithMouseInput(DeltaTime);\n}\n\nvoid ARotatingActor::RotateWithMouseInput(float DeltaTime)\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tfloat MouseX, MouseY;\n\t\tPlayerController->GetInputMouseDelta(MouseX, MouseY);\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Yaw += MouseX * RotationSpeed * DeltaTime;\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an actor that plays a sound on any interaction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Sound/SoundBase.h\"\n#include \"MyInteractiveSoundActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyInteractiveSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyInteractiveSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* InteractionSound;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Interaction\")\n\tvoid Interact();\n};\n```", "cpp_code": "```cpp\n#include \"MyInteractiveSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAMyInteractiveSoundActor::AMyInteractiveSoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyInteractiveSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyInteractiveSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid AMyInteractiveSoundActor::Interact()\n{\n\tif (InteractionSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, InteractionSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a simple spherical actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimpleSphericalActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimpleSphericalActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASimpleSphericalActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* SphereMesh;\n};\n```", "cpp_code": "```cpp\n#include \"SimpleSphericalActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nASimpleSphericalActor::ASimpleSphericalActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSphereMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"SphereMesh\"));\n\tRootComponent = SphereMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> SphereMeshAsset(TEXT(\"/Engine/BasicShapes/Sphere.Sphere\"));\n\tif (SphereMeshAsset.Succeeded())\n\t{\n\t\tSphereMesh->SetStaticMesh(SphereMeshAsset.Object);\n\t}\n}\n\nvoid ASimpleSphericalActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASimpleSphericalActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a default material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Materials\")\n\tUMaterialInterface* DefaultMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the default material reference to null\n\tDefaultMaterial = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its material on a key event.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMaterialChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* Material1;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* Material2;\n\n\tUFUNCTION()\n\tvoid ChangeMaterial();\n\n\tvoid SetupInputComponent();\n\nprivate:\n\tbool bUseMaterial1;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"Engine/Engine.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/InputSettings.h\"\n\nAMaterialChangingActor::AMaterialChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tbUseMaterial1 = true;\n}\n\nvoid AMaterialChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetupInputComponent();\n}\n\nvoid AMaterialChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMaterialChangingActor::ChangeMaterial()\n{\n\tif (bUseMaterial1)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material2);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n\tbUseMaterial1 = !bUseMaterial1;\n}\n\nvoid AMaterialChangingActor::SetupInputComponent()\n{\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tPlayerController->InputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AMaterialChangingActor::ChangeMaterial);\n\t}\n}\n```"}
{"requirement": "Create a component with a custom scale function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomScaleComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UCustomScaleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUCustomScaleComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Custom scale function\n\tUFUNCTION(BlueprintCallable, Category=\"Custom Scale\")\n\tvoid SetCustomScale(FVector NewScale);\n};\n```", "cpp_code": "```cpp\n#include \"CustomScaleComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values for this component's properties\nUCustomScaleComponent::UCustomScaleComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid UCustomScaleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Custom scale function\nvoid UCustomScaleComponent::SetCustomScale(FVector NewScale)\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->SetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable audio loop.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"CustomAudioLoopActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomAudioLoopActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tACustomAudioLoopActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Audio\")\n\tUSoundCue* AudioCue;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Audio\")\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CustomAudioLoopActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n\nACustomAudioLoopActor::ACustomAudioLoopActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tRootComponent = AudioComponent;\n\tAudioComponent->bAutoActivate = false;\n\tAudioComponent->bLooping = true;\n}\n\nvoid ACustomAudioLoopActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (AudioCue)\n\t{\n\t\tAudioComponent->SetSound(AudioCue);\n\t\tAudioComponent->Play();\n\t}\n}\n\nvoid ACustomAudioLoopActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that logs a message when touched by the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingTouchActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingTouchActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tALoggingTouchActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* CollisionBox;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingTouchActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingTouchActor::ALoggingTouchActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionBox\"));\n\tRootComponent = CollisionBox;\n\n\tCollisionBox->OnComponentBeginOverlap.AddDynamic(this, &ALoggingTouchActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingTouchActor::BeginPlay()\n{\n\tSuper::BeginPlay();\t\n}\n\n// Called every frame\nvoid ALoggingTouchActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ALoggingTouchActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tif (APlayerController* PlayerController = Cast<APlayerController>(OtherActor->GetInstigatorController()))\n\t\t{\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Player touched the actor!\"));\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that moves randomly in a defined space.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ARandomMover : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARandomMover();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector GetRandomLocation() const;\n\tFVector MovementBounds;\n\tfloat MoveSpeed;\n\tFVector TargetLocation;\n};\n```", "cpp_code": "```cpp\n#include \"RandomMover.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nARandomMover::ARandomMover()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementBounds = FVector(1000.0f, 1000.0f, 1000.0f); // Set the bounds for random movement\n\tMoveSpeed = 100.0f; // Set the movement speed\n}\n\nvoid ARandomMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tTargetLocation = GetRandomLocation();\n}\n\nvoid ARandomMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentLocation = GetActorLocation();\n\tif (FVector::Dist(CurrentLocation, TargetLocation) <= 10.0f) // If close to target, get a new target\n\t{\n\t\tTargetLocation = GetRandomLocation();\n\t}\n\n\tFVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n\tFVector NewLocation = CurrentLocation + Direction * MoveSpeed * DeltaTime;\n\tSetActorLocation(NewLocation);\n}\n\nFVector ARandomMover::GetRandomLocation() const\n{\n\tfloat RandomX = FMath::FRandRange(-MovementBounds.X, MovementBounds.X);\n\tfloat RandomY = FMath::FRandRange(-MovementBounds.Y, MovementBounds.Y);\n\tfloat RandomZ = FMath::FRandRange(-MovementBounds.Z, MovementBounds.Z);\n\treturn FVector(RandomX, RandomY, RandomZ);\n}\n```"}
{"requirement": "Create a simple pyramid mesh actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PyramidMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APyramidMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAPyramidMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUProceduralMeshComponent* ProceduralMesh;\n\n\tvoid CreatePyramidMesh();\n};\n```", "cpp_code": "```cpp\n#include \"PyramidMeshActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\nAPyramidMeshActor::APyramidMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tProceduralMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"ProceduralMesh\"));\n\tRootComponent = ProceduralMesh;\n\n\tCreatePyramidMesh();\n}\n\nvoid APyramidMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APyramidMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APyramidMeshActor::CreatePyramidMesh()\n{\n\tTArray<FVector> Vertices;\n\tTArray<int32> Triangles;\n\n\t// Define vertices\n\tVertices.Add(FVector(0, 0, 100)); // Top vertex\n\tVertices.Add(FVector(-100, -100, 0)); // Base - bottom left\n\tVertices.Add(FVector(100, -100, 0)); // Base - bottom right\n\tVertices.Add(FVector(100, 100, 0)); // Base - top right\n\tVertices.Add(FVector(-100, 100, 0)); // Base - top left\n\n\t// Define triangles\n\tTriangles.Add(0); Triangles.Add(2); Triangles.Add(1); // Side 1\n\tTriangles.Add(0); Triangles.Add(3); Triangles.Add(2); // Side 2\n\tTriangles.Add(0); Triangles.Add(4); Triangles.Add(3); // Side 3\n\tTriangles.Add(0); Triangles.Add(1); Triangles.Add(4); // Side 4\n\tTriangles.Add(1); Triangles.Add(2); Triangles.Add(3); // Base\n\tTriangles.Add(1); Triangles.Add(3); Triangles.Add(4); // Base\n\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\tTArray<FProcMeshTangent> Tangents;\n\tTArray<FLinearColor> VertexColors;\n\n\tProceduralMesh->CreateMeshSection_LinearColor(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a light map.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyLightMapActor.generated.h\"\n\nclass ULightMapTexture;\n\nUCLASS()\nclass MYPROJECT_API AMyLightMapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyLightMapActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Lighting\")\n\tULightMapTexture* LightMapReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyLightMapActor.h\"\n\nAMyLightMapActor::AMyLightMapActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n```"}
{"requirement": "Create an actor that plays a sound on start.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundPlayingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tASoundPlayingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Sound to play at start\n\tUPROPERTY(EditAnywhere, Category=\"Sound\")\n\tUSoundBase* StartSound;\n};\n```", "cpp_code": "```cpp\n#include \"SoundPlayingActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundPlayingActor::ASoundPlayingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundPlayingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (StartSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, StartSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that changes its mesh on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ChangeMeshOnCollisionComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UChangeMeshOnCollisionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUChangeMeshOnCollisionComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION()\n\tvoid OnCollision(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\n\tUPROPERTY(EditAnywhere, Category = \"Mesh\")\n\tUStaticMesh* NewMesh;\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMeshOnCollisionComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nUChangeMeshOnCollisionComponent::UChangeMeshOnCollisionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UChangeMeshOnCollisionComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tMeshComponent = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tMeshComponent->OnComponentHit.AddDynamic(this, &UChangeMeshOnCollisionComponent::OnCollision);\n\t\t}\n\t}\n}\n\nvoid UChangeMeshOnCollisionComponent::OnCollision(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (MeshComponent && NewMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(NewMesh);\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable tick rate.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomTickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomTickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACustomTickActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tick\")\n\tfloat CustomTickInterval;\n\nprivate:\n\tfloat TimeSinceLastTick;\n};\n```", "cpp_code": "```cpp\n#include \"CustomTickActor.h\"\n\nACustomTickActor::ACustomTickActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCustomTickInterval = 1.0f; // Default tick interval\n\tTimeSinceLastTick = 0.0f;\n}\n\nvoid ACustomTickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACustomTickActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeSinceLastTick += DeltaTime;\n\tif (TimeSinceLastTick >= CustomTickInterval)\n\t{\n\t\tTimeSinceLastTick = 0.0f;\n\n\t\t// Custom tick logic here\n\t}\n}\n```"}
{"requirement": "Create a class that changes position based on tick time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TickPositionChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATickPositionChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATickPositionChanger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector MovementVector;\n\tfloat Speed;\n};\n```", "cpp_code": "```cpp\n#include \"TickPositionChanger.h\"\n\n// Sets default values\nATickPositionChanger::ATickPositionChanger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize movement vector and speed\n\tMovementVector = FVector(1.0f, 0.0f, 0.0f);\n\tSpeed = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ATickPositionChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATickPositionChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate new position\n\tFVector NewLocation = GetActorLocation() + (MovementVector * Speed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that can change scale with arrow keys.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleChangingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic: \n  AScaleChangingActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic: \n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  void ChangeScale(float ScaleDelta);\n\n  UPROPERTY(EditAnywhere)\n  float ScaleStep;\n\n  void SetupInputComponent();\n  void IncreaseScale();\n  void DecreaseScale();\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangingActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAScaleChangingActor::AScaleChangingActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n  ScaleStep = 0.1f; \n}\n\nvoid AScaleChangingActor::BeginPlay()\n{\n  Super::BeginPlay();\n  SetupInputComponent();\n}\n\nvoid AScaleChangingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AScaleChangingActor::ChangeScale(float ScaleDelta)\n{\n  FVector NewScale = GetActorScale3D() + FVector(ScaleDelta);\n  SetActorScale3D(NewScale);\n}\n\nvoid AScaleChangingActor::SetupInputComponent()\n{\n  if (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n  {\n\tEnableInput(PlayerController);\n\tInputComponent->BindAction(\"IncreaseScale\", IE_Pressed, this, &AScaleChangingActor::IncreaseScale);\n\tInputComponent->BindAction(\"DecreaseScale\", IE_Pressed, this, &AScaleChangingActor::DecreaseScale);\n  }\n}\n\nvoid AScaleChangingActor::IncreaseScale()\n{\n  ChangeScale(ScaleStep);\n}\n\nvoid AScaleChangingActor::DecreaseScale()\n{\n  ChangeScale(-ScaleStep);\n}\n```"}
{"requirement": "Create a simple hexagonal actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HexagonalActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AHexagonalActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHexagonalActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Function to create hexagonal mesh\n\tvoid CreateHexagonalMesh();\n\n\t// Hexagonal mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUProceduralMeshComponent* HexMesh;\n};\n```", "cpp_code": "```cpp\n#include \"HexagonalActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\n// Sets default values\nAHexagonalActor::AHexagonalActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create procedural mesh component\n\tHexMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"HexMesh\"));\n\tRootComponent = HexMesh;\n\n\t// Create hexagonal mesh\n\tCreateHexagonalMesh();\n}\n\n// Called when the game starts or when spawned\nvoid AHexagonalActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AHexagonalActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHexagonalActor::CreateHexagonalMesh()\n{\n\t// Define vertices for a hexagon\n\tTArray<FVector> Vertices;\n\tfloat Radius = 100.0f;\n\tfor (int32 i = 0; i < 6; ++i)\n\t{\n\t\tfloat Angle = FMath::DegreesToRadians(60.f * i);\n\t\tVertices.Add(FVector(Radius * FMath::Cos(Angle), Radius * FMath::Sin(Angle), 0.f));\n\t}\n\n\t// Add center vertex\n\tVertices.Add(FVector(0.f, 0.f, 0.f));\n\n\t// Define triangles (two for each side of the hexagon)\n\tTArray<int32> Triangles;\n\tfor (int32 i = 0; i < 6; ++i)\n\t{\n\t\tTriangles.Add(i);\n\t\tTriangles.Add((i + 1) % 6);\n\t\tTriangles.Add(6); // center vertex\n\t}\n\n\t// Create mesh section\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\tTArray<FColor> VertexColors;\n\tTArray<FProcMeshTangent> Tangents;\n\n\tHexMesh->CreateMeshSection(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a volume control.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"VolumeControl.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UVolumeControl : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Audio\")\n\tfloat VolumeLevel;\n\n\tUVolumeControl();\n};\n```", "cpp_code": "```cpp\n#include \"VolumeControl.h\"\n\nUVolumeControl::UVolumeControl()\n{\n\tVolumeLevel = 1.0f; // Default volume level\n}\n```"}
{"requirement": "Create an actor that logs a message on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOverlapLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tclass UBoxComponent* BoxComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLoggerActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nAOverlapLoggerActor::AOverlapLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tBoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tRootComponent = BoxComponent;\n\n\tBoxComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapLoggerActor::OnOverlapBegin);\n}\n\nvoid AOverlapLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapLoggerActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Overlap Event Occurred!\"));\n\t}\n}\n```"}
{"requirement": "Create a component that toggles an audio effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"AudioEffectTogglerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UAudioEffectTogglerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUAudioEffectTogglerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Audio\")\n\tvoid ToggleAudioEffect();\n\nprivate:\n\tbool bIsEffectActive;\n\n\tUPROPERTY(EditAnywhere, Category=\"Audio\")\n\tUSoundCue* EffectSoundCue;\n\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"AudioEffectTogglerComponent.h\"\n#include \"Components/AudioComponent.h\"\n\nUAudioEffectTogglerComponent::UAudioEffectTogglerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbIsEffectActive = false;\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n}\n\nvoid UAudioEffectTogglerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (EffectSoundCue)\n\t{\n\t\tAudioComponent->SetSound(EffectSoundCue);\n\t}\n}\n\nvoid UAudioEffectTogglerComponent::ToggleAudioEffect()\n{\n\tif (!EffectSoundCue)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"EffectSoundCue is not set!\"));\n\t\treturn;\n\t}\n\n\tif (bIsEffectActive)\n\t{\n\t\tAudioComponent->Stop();\n\t}\n\telse\n\t{\n\t\tAudioComponent->Play();\n\t}\n\n\tbIsEffectActive = !bIsEffectActive;\n}\n```"}
{"requirement": "Create an actor with a customizable physics property.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomPhysicsActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomPhysicsActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tACustomPhysicsActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Physics\")\n\tfloat CustomMass;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Physics\")\n\tvoid SetMass(float NewMass);\n};\n```", "cpp_code": "```cpp\n#include \"CustomPhysicsActor.h\"\n\nACustomPhysicsActor::ACustomPhysicsActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCustomMass = 1.0f; // Default mass value\n}\n\nvoid ACustomPhysicsActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Set the initial mass\n\tif (UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(GetRootComponent()))\n\t{\n\t\tPrimitiveComponent->SetMassOverrideInKg(NAME_None, CustomMass);\n\t}\n}\n\nvoid ACustomPhysicsActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACustomPhysicsActor::SetMass(float NewMass)\n{\n\tCustomMass = NewMass;\n\tif (UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(GetRootComponent()))\n\t{\n\t\tPrimitiveComponent->SetMassOverrideInKg(NAME_None, CustomMass);\n\t}\n}\n```"}
{"requirement": "Create a class that logs a message when the game ends.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameEndLogger.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AGameEndLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAGameEndLogger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION()\n\tvoid OnGameEnd();\n};\n```", "cpp_code": "```cpp\n#include \"GameEndLogger.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAGameEndLogger::AGameEndLogger()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AGameEndLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AGameModeBase* GameMode = UGameplayStatics::GetGameMode(GetWorld()))\n\t{\n\t\tGameMode->OnEndPlay.AddDynamic(this, &AGameEndLogger::OnGameEnd);\n\t}\n}\n\nvoid AGameEndLogger::OnGameEnd()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"The game has ended.\"));\n}\n```"}
{"requirement": "Create an actor that follows a predefined path.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PathFollowingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APathFollowingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPathFollowingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Path\")\n\tTArray<FVector> PathPoints;\n\n\tint32 CurrentTargetIndex;\n\tfloat MovementSpeed;\n\n\tvoid FollowPath(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"PathFollowingActor.h\"\n\nAPathFollowingActor::APathFollowingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentTargetIndex = 0;\n\tMovementSpeed = 200.0f; // Default speed, can be adjusted\n}\n\nvoid APathFollowingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APathFollowingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFollowPath(DeltaTime);\n}\n\nvoid APathFollowingActor::FollowPath(float DeltaTime)\n{\n\tif (PathPoints.Num() == 0 || CurrentTargetIndex >= PathPoints.Num())\n\t{\n\t\treturn;\n\t}\n\n\tFVector CurrentLocation = GetActorLocation();\n\tFVector TargetLocation = PathPoints[CurrentTargetIndex];\n\tFVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n\n\tFVector NewLocation = CurrentLocation + Direction * MovementSpeed * DeltaTime;\n\tSetActorLocation(NewLocation);\n\n\tif (FVector::Dist(NewLocation, TargetLocation) < 10.0f)\n\t{\n\t\tCurrentTargetIndex++;\n\t}\n\n\tif (CurrentTargetIndex >= PathPoints.Num())\n\t{\n\t\tCurrentTargetIndex = 0; // Loop back to the start of the path\n\t}\n}\n```"}
{"requirement": "Create a simple ovoid actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OvoidActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AOvoidActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAOvoidActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* OvoidMesh;\n};\n```", "cpp_code": "```cpp\n#include \"OvoidActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAOvoidActor::AOvoidActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tOvoidMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"OvoidMesh\"));\n\tRootComponent = OvoidMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> OvoidAsset(TEXT(\"StaticMesh'/Engine/BasicShapes/Sphere.Sphere'\"));\n\tif (OvoidAsset.Succeeded())\n\t{\n\t\tOvoidMesh->SetStaticMesh(OvoidAsset.Object);\n\t\t// Scale the sphere to create an ovoid\n\t\tOvoidMesh->SetWorldScale3D(FVector(1.0f, 0.6f, 0.6f));\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AOvoidActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AOvoidActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a camera component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"CameraActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACameraActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACameraActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Camera\")\n\tUCameraComponent* CameraComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CameraActor.h\"\n\n// Sets default values\nACameraActor::ACameraActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the camera component\n\tCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"CameraComponent\"));\n\t// Attach the camera component to the root component\n\tRootComponent = CameraComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ACameraActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACameraActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Create an actor that plays a sound on a key release.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundOnKeyReleaseActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundOnKeyReleaseActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundOnKeyReleaseActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sound to play on key release\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* SoundToPlay;\n\n\t// Function to bind to input\n\tvoid OnKeyReleased();\n};\n```", "cpp_code": "```cpp\n#include \"SoundOnKeyReleaseActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nASoundOnKeyReleaseActor::ASoundOnKeyReleaseActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundOnKeyReleaseActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind the OnKeyReleased function to the input action\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tInputComponent = NewObject<UInputComponent>(this);\n\t\tInputComponent->RegisterComponent();\n\t\tInputComponent->BindAction(\"PlaySound\", IE_Released, this, &ASoundOnKeyReleaseActor::OnKeyReleased);\n\t\tPlayerController->PushInputComponent(InputComponent);\n\t}\n}\n\n// Called every frame\nvoid ASoundOnKeyReleaseActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to play the sound\nvoid ASoundOnKeyReleaseActor::OnKeyReleased()\n{\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that changes its light based on input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LightComponent.h\"\n#include \"LightChangerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULightChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tULightChangerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Light\")\n\tvoid ChangeLightIntensity(float NewIntensity);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Light\")\n\tvoid ChangeLightColor(FLinearColor NewColor);\n\nprivate:\n\tULightComponent* LightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"LightChangerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/LightComponent.h\"\n\nULightChangerComponent::ULightChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid ULightChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tLightComponent = GetOwner()->FindComponentByClass<ULightComponent>();\n\tif (!LightComponent)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"No LightComponent found on %s!\"), *GetOwner()->GetName());\n\t}\n}\n\nvoid ULightChangerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid ULightChangerComponent::ChangeLightIntensity(float NewIntensity)\n{\n\tif (LightComponent)\n\t{\n\t\tLightComponent->SetIntensity(NewIntensity);\n\t}\n}\n\nvoid ULightChangerComponent::ChangeLightColor(FLinearColor NewColor)\n{\n\tif (LightComponent)\n\t{\n\t\tLightComponent->SetLightColor(NewColor);\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable sound effect on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"CollisionSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sound to play upon collision\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundCue* CollisionSoundCue;\n\n\t// Function to handle collision\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\t// Root component\n\tUSceneComponent* RootComp;\n\n\t// Static mesh component\n\tUStaticMeshComponent* MeshComp;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionSoundActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nACollisionSoundActor::ACollisionSoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a root component\n\tRootComp = CreateDefaultSubobject<USceneComponent>(TEXT(\"RootComponent\"));\n\tRootComponent = RootComp;\n\n\t// Create a static mesh component\n\tMeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComp->SetupAttachment(RootComp);\n\n\t// Set up collision\n\tMeshComp->SetNotifyRigidBodyCollision(true);\n\tMeshComp->BodyInstance.SetCollisionProfileName(\"BlockAllDynamic\");\n\tMeshComp->OnComponentHit.AddDynamic(this, &ACollisionSoundActor::OnHit);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle collision\nvoid ACollisionSoundActor::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (CollisionSoundCue)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, CollisionSoundCue, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a class that changes its texture over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"TextureChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATextureChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tTArray<UTexture*> Textures;\n\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\n\tint32 CurrentTextureIndex;\n\tfloat TimeAccumulator;\n\tUPROPERTY(EditAnywhere)\n\tfloat ChangeInterval;\n\n\tvoid ChangeTexture();\n};\n```", "cpp_code": "```cpp\n#include \"TextureChanger.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n\nATextureChanger::ATextureChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\tCurrentTextureIndex = 0;\n\tTimeAccumulator = 0.0f;\n\tChangeInterval = 2.0f; // Default change interval is 2 seconds\n}\n\nvoid ATextureChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MeshComponent && MeshComponent->GetMaterial(0))\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\nvoid ATextureChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeAccumulator += DeltaTime;\n\tif (TimeAccumulator >= ChangeInterval && Textures.Num() > 0)\n\t{\n\t\tChangeTexture();\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n\nvoid ATextureChanger::ChangeTexture()\n{\n\tif (!DynamicMaterialInstance || Textures.Num() == 0)\n\t{\n\t\treturn;\n\t}\n\n\tCurrentTextureIndex = (CurrentTextureIndex + 1) % Textures.Num();\n\tDynamicMaterialInstance->SetTextureParameterValue(TEXT(\"Texture\"), Textures[CurrentTextureIndex]);\n}\n```"}
{"requirement": "Create an actor that moves towards another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMovingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Target actor to move towards\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tAActor* TargetActor;\n\n\t// Speed of movement\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\n// Sets default values\nAMovingActor::AMovingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementSpeed = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tFVector CurrentLocation = GetActorLocation();\n\t\tFVector TargetLocation = TargetActor->GetActorLocation();\n\t\tFVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n\t\tFVector NewLocation = CurrentLocation + Direction * MovementSpeed * DeltaTime;\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create a simple pentagon actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PentagonActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APentagonActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAPentagonActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* PentagonMesh;\n\n\tvoid CreatePentagon();\n};\n```", "cpp_code": "```cpp\n#include \"PentagonActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAPentagonActor::APentagonActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPentagonMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"PentagonMesh\"));\n\tRootComponent = PentagonMesh;\n\n\tCreatePentagon();\n}\n\n// Called when the game starts or when spawned\nvoid APentagonActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid APentagonActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid APentagonActor::CreatePentagon()\n{\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> PentagonMeshAsset(TEXT(\"StaticMesh'/Engine/BasicShapes/Cylinder.Cylinder'\"));\n\tif (PentagonMeshAsset.Succeeded())\n\t{\n\t\tPentagonMesh->SetStaticMesh(PentagonMeshAsset.Object);\n\t\tPentagonMesh->SetWorldScale3D(FVector(1.0f, 1.0f, 0.1f)); // Flatten the cylinder to make it appear as a 2D shape\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a light array.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Lighting\")\n\tTArray<ALight*> LightArray;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that logs a message on a specific event.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tALoggingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"Engine/Engine.h\"\n\nALoggingActor::ALoggingActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tUE_LOG(LogTemp, Warning, TEXT(\"LoggingActor has begun play!\"));\n}\n```"}
{"requirement": "Create a component with a custom rotation function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomRotationComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomRotationComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUCustomRotationComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Rotation\")\n\tvoid RotateActor(float DeltaTime);\n\nprivate:\n\tFRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"CustomRotationComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUCustomRotationComponent::UCustomRotationComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tRotationRate = FRotator(0.f, 90.f, 0.f); // Example rotation rate\n}\n\nvoid UCustomRotationComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCustomRotationComponent::RotateActor(float DeltaTime)\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFRotator NewRotation = Owner->GetActorRotation() + (RotationRate * DeltaTime);\n\t\tOwner->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable particle trail.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomParticleTrailActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomParticleTrailActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACustomParticleTrailActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Particle Trail\")\n\tUParticleSystem* ParticleTrail;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Particle Trail\")\n\tUParticleSystemComponent* ParticleSystemComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CustomParticleTrailActor.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n\nACustomParticleTrailActor::ACustomParticleTrailActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystemComponent\"));\n\tParticleSystemComponent->SetupAttachment(RootComponent);\n}\n\nvoid ACustomParticleTrailActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (ParticleTrail)\n\t{\n\t\tParticleSystemComponent->SetTemplate(ParticleTrail);\n\t}\n}\n\nvoid ACustomParticleTrailActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that logs a message when the actor is destroyed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called when the actor is being destroyed\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingActor::ALoggingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called when the actor is being destroyed\nvoid ALoggingActor::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Actor is being destroyed\"));\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Actor is being destroyed\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that can scale continuously over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScalingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The rate at which the actor scales over time\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tFVector ScalingRate;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n\n// Sets default values\nAScalingActor::AScalingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the scaling rate\n\tScalingRate = FVector(0.1f, 0.1f, 0.1f);\n}\n\n// Called when the game starts or when spawned\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate new scale\n\tFVector NewScale = GetActorScale3D() + (ScalingRate * DeltaTime);\n\n\t// Set the new scale\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a simple triangle actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TriangleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATriangleActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tATriangleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY()\n\tclass UProceduralMeshComponent* ProceduralMesh;\n\n\tvoid CreateTriangle();\n};\n```", "cpp_code": "```cpp\n#include \"TriangleActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\nATriangleActor::ATriangleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tProceduralMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"ProceduralMesh\"));\n\tRootComponent = ProceduralMesh;\n\n\tCreateTriangle();\n}\n\nvoid ATriangleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATriangleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATriangleActor::CreateTriangle()\n{\n\tTArray<FVector> Vertices;\n\tVertices.Add(FVector(0, 0, 0));\n\tVertices.Add(FVector(100, 0, 0));\n\tVertices.Add(FVector(0, 100, 0));\n\n\tTArray<int32> Triangles;\n\tTriangles.Add(0);\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\n\tTArray<FVector> Normals;\n\tNormals.Add(FVector(0, 0, 1));\n\tNormals.Add(FVector(0, 0, 1));\n\tNormals.Add(FVector(0, 0, 1));\n\n\tTArray<FVector2D> UV0;\n\tUV0.Add(FVector2D(0, 0));\n\tUV0.Add(FVector2D(1, 0));\n\tUV0.Add(FVector2D(0, 1));\n\n\tTArray<FProcMeshTangent> Tangents;\n\tTangents.Add(FProcMeshTangent(1, 0, 0));\n\tTangents.Add(FProcMeshTangent(1, 0, 0));\n\tTangents.Add(FProcMeshTangent(1, 0, 0));\n\n\tTArray<FLinearColor> VertexColors;\n\tVertexColors.Add(FLinearColor(1, 0, 0, 1));\n\tVertexColors.Add(FLinearColor(0, 1, 0, 1));\n\tVertexColors.Add(FLinearColor(0, 0, 1, 1));\n\n\tProceduralMesh->CreateMeshSection_LinearColor(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to an ambient sound.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/AmbientSound.h\"\n#include \"MyAmbientSoundActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyAmbientSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyAmbientSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tAAmbientSound* AmbientSoundReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyAmbientSoundActor.h\"\n\n// Sets default values\nAMyAmbientSoundActor::AMyAmbientSoundActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyAmbientSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Initialize or manipulate the AmbientSoundReference here if necessary\n}\n\n// Called every frame\nvoid AMyAmbientSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Logic to use the AmbientSoundReference can be added here\n}\n```"}
{"requirement": "Create an actor that plays a sound on component begin overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Components/BoxComponent.h\"\n#include \"SoundOverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUBoxComponent* OverlapComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* SoundToPlay;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"SoundOverlapActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundOverlapActor::ASoundOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tOverlapComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"OverlapComponent\"));\n\tRootComponent = OverlapComponent;\n\n\tOverlapComponent->OnComponentBeginOverlap.AddDynamic(this, &ASoundOverlapActor::OnOverlapBegin);\n}\n\nvoid ASoundOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (SoundToPlay && OtherActor != this)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that adjusts its position by input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"InputPositionAdjusterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UInputPositionAdjusterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUInputPositionAdjusterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void SetupInputComponent();\n\n\tUFUNCTION()\n\tvoid AdjustPosition(float Value);\n\nprivate:\n\tFVector MovementVector;\n\tclass APlayerController* PlayerController;\n};\n```", "cpp_code": "```cpp\n#include \"InputPositionAdjusterComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nUInputPositionAdjusterComponent::UInputPositionAdjusterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tMovementVector = FVector::ZeroVector;\n}\n\nvoid UInputPositionAdjusterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tPlayerController->InputComponent->BindAxis(\"MoveForward\", this, &UInputPositionAdjusterComponent::AdjustPosition);\n\t}\n}\n\nvoid UInputPositionAdjusterComponent::SetupInputComponent()\n{\n\tif (PlayerController && PlayerController->InputComponent)\n\t{\n\t\tPlayerController->InputComponent->BindAxis(\"MoveForward\", this, &UInputPositionAdjusterComponent::AdjustPosition);\n\t}\n}\n\nvoid UInputPositionAdjusterComponent::AdjustPosition(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tMovementVector.X = Value;\n\t\tAActor* Owner = GetOwner();\n\t\tif (Owner)\n\t\t{\n\t\t\tOwner->AddActorLocalOffset(MovementVector, true);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with an adjustable tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AdjustableTickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAdjustableTickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAAdjustableTickActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sets whether the actor should tick\n\tUFUNCTION(BlueprintCallable, Category=\"Tick\")\n\tvoid SetActorTickEnabled(bool bEnabled);\n\nprivate:\n\tbool bShouldTick;\n};\n```", "cpp_code": "```cpp\n#include \"AdjustableTickActor.h\"\n\n// Sets default values\nAAdjustableTickActor::AAdjustableTickActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tbShouldTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AAdjustableTickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AAdjustableTickActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!bShouldTick)\n\t{\n\t\treturn;\n\t}\n\n\t// Your tick code here\n}\n\nvoid AAdjustableTickActor::SetActorTickEnabled(bool bEnabled)\n{\n\tbShouldTick = bEnabled;\n\tSetActorTickEnabled(bShouldTick);\n}\n```"}
{"requirement": "Create an Actor class with a static mesh component using ConstructorHelpers to load a cube mesh asset.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CubeMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACubeMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACubeMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* CubeMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CubeMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACubeMeshActor::ACubeMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the static mesh component\n\tCubeMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"CubeMeshComponent\"));\n\tRootComponent = CubeMeshComponent;\n\n\t// Find and set the cube mesh asset\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> CubeMeshAsset(TEXT(\"/Game/Path/To/Your/CubeMesh.CubeMesh\"));\n\tif (CubeMeshAsset.Succeeded())\n\t{\n\t\tCubeMeshComponent->SetStaticMesh(CubeMeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ACubeMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n}\n\n// Called every frame\nvoid ACubeMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that moves the Actor upward by 10 units per second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMovingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyMovingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"MyMovingActor.h\"\n\n// Sets default values\nAMyMovingActor::AMyMovingActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation();\n\tNewLocation.Z += 10.0f * DeltaTime; // Move up by 10 units per second\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float variable to store health, with metadata to allow editing in the editor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHealthActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat Health;\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n\n// Sets default values\nAHealthActor::AHealthActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize health\n\tHealth = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent method in an Actor to bind the 'Jump' action to a function that logs a message.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AJumpLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AJumpLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAJumpLogger();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid LogJumpMessage();\n};\n```", "cpp_code": "```cpp\n#include \"AJumpLogger.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nAJumpLogger::AJumpLogger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AJumpLogger::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, &AJumpLogger::LogJumpMessage);\n\t}\n}\n\nvoid AJumpLogger::LogJumpMessage()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Jump action triggered!\"));\n\t}\n}\n```"}
{"requirement": "Create a simple custom Component class with a UPROPERTY integer that counts the number of ticks since the game started.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TickCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UTickCounterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUTickCounterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintReadOnly, VisibleAnywhere, Category=\"TickCounter\")\n\tint32 TickCount;\n};\n```", "cpp_code": "```cpp\n#include \"TickCounterComponent.h\"\n\nUTickCounterComponent::UTickCounterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTickCount = 0;\n}\n\nvoid UTickCounterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UTickCounterComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\t\n\tTickCount++;\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that returns the current location of the Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALocationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALocationActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Location\")\n\tFVector GetCurrentLocation() const;\n};\n```", "cpp_code": "```cpp\n#include \"LocationActor.h\"\n\n// Sets default values\nALocationActor::ALocationActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nFVector ALocationActor::GetCurrentLocation() const\n{\n\treturn GetActorLocation();\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in an Actor that broadcasts a message when the Actor is destroyed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyDestroyableActor.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnActorDestroyed);\n\nUCLASS()\nclass MYPROJECT_API AMyDestroyableActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMyDestroyableActor();\n\n\t// BlueprintAssignable delegate to broadcast when actor is destroyed\n\tUPROPERTY(BlueprintAssignable, Category=\"Events\")\n\tFOnActorDestroyed OnActorDestroyed;\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\t\n\t// Called when the actor is being destroyed\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n};\n```", "cpp_code": "```cpp\n#include \"MyDestroyableActor.h\"\n\n// Sets default values\nAMyDestroyableActor::AMyDestroyableActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyDestroyableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyDestroyableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called when the actor is being destroyed\nvoid AMyDestroyableActor::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\t\n\tif(EndPlayReason == EEndPlayReason::Destroyed)\n\t{\n\t\tOnActorDestroyed.Broadcast();\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that scales the Actor's mesh over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat ScalingFactor;\n\n\tFVector InitialScale;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tScalingFactor = 1.0f;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialScale = MeshComponent->GetComponentScale();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat ScaleIncrement = DeltaTime * ScalingFactor;\n\tFVector NewScale = InitialScale * (1.0f + ScaleIncrement);\n\tMeshComponent->SetWorldScale3D(NewScale);\n}\n```"}
{"requirement": "Create an Actor that logs a message to the console every time it overlaps with another Actor using OnBeginOverlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAOverlapLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLoggerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAOverlapLoggerActor::AOverlapLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapLoggerActor::OnOverlapBegin);\n}\n\nvoid AOverlapLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapLoggerActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlapped with: %s\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Use ConstructorHelpers to load a texture asset in an Actor and apply it to a material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TextureMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tATextureMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInstanceDynamic* DynamicMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"TextureMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nATextureMaterialActor::ATextureMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UTexture> TextureAsset(TEXT(\"/Game/Path/To/Your/Texture.Texture\"));\n\tif (TextureAsset.Succeeded())\n\t{\n\t\tUMaterialInterface* Material = StaticMeshComponent->GetMaterial(0);\n\t\tDynamicMaterial = UMaterialInstanceDynamic::Create(Material, this);\n\t\tDynamicMaterial->SetTextureParameterValue(\"TextureParameterName\", TextureAsset.Object);\n\t\tStaticMeshComponent->SetMaterial(0, DynamicMaterial);\n\t}\n}\n\nvoid ATextureMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATextureMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a custom Component that changes the color of its owning Actor every second using the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UColorChangeComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UColorChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUColorChangeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFLinearColor CurrentColor;\n\tfloat TimeAccumulator;\n};\n```", "cpp_code": "```cpp\n#include \"UColorChangeComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nUColorChangeComponent::UColorChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTimeAccumulator = 0.0f;\n}\n\nvoid UColorChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Initialize the color\n\tCurrentColor = FLinearColor::MakeRandomColor();\n\n\t// Change the actor's color initially\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tUStaticMeshComponent* MeshComp = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComp)\n\t\t{\n\t\t\tUMaterialInstanceDynamic* DynMaterial = MeshComp->CreateAndSetMaterialInstanceDynamic(0);\n\t\t\tif (DynMaterial)\n\t\t\t{\n\t\t\t\tDynMaterial->SetVectorParameterValue(\"Color\", CurrentColor);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UColorChangeComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTimeAccumulator += DeltaTime;\n\n\tif (TimeAccumulator >= 1.0f)\n\t{\n\t\tTimeAccumulator = 0.0f;\n\t\tCurrentColor = FLinearColor::MakeRandomColor();\n\n\t\tif (AActor* Owner = GetOwner())\n\t\t{\n\t\t\tUStaticMeshComponent* MeshComp = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t\t\tif (MeshComp)\n\t\t\t{\n\t\t\t\tUMaterialInstanceDynamic* DynMaterial = MeshComp->CreateAndSetMaterialInstanceDynamic(0);\n\t\t\t\tif (DynMaterial)\n\t\t\t\t{\n\t\t\t\t\tDynMaterial->SetVectorParameterValue(\"Color\", CurrentColor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement SetupPlayerInputComponent to bind an input to increase a UPROPERTY float speed variable in an Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"IncreaseSpeedActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AIncreaseSpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAIncreaseSpeedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat Speed;\n\n\tvoid IncreaseSpeed();\n};\n```", "cpp_code": "```cpp\n#include \"IncreaseSpeedActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nAIncreaseSpeedActor::AIncreaseSpeedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSpeed = 0.0f;\n}\n\nvoid AIncreaseSpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AIncreaseSpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AIncreaseSpeedActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"IncreaseSpeed\", IE_Pressed, this, &AIncreaseSpeedActor::IncreaseSpeed);\n}\n\nvoid AIncreaseSpeedActor::IncreaseSpeed()\n{\n\tSpeed += 10.0f;\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY for a material and a BlueprintCallable function to change its material at runtime.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMaterialChangerActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyMaterialChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyMaterialChangerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Material\")\n\tUMaterialInterface* Material;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Material\")\n\tvoid ChangeMaterial(UMaterialInterface* NewMaterial);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyMaterialChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyMaterialChangerActor::AMyMaterialChangerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Optionally set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyMaterialChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyMaterialChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyMaterialChangerActor::ChangeMaterial(UMaterialInterface* NewMaterial)\n{\n\tif (NewMaterial && MeshComponent)\n\t{\n\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t\tMaterial = NewMaterial;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in a Component to rotate its parent Actor around the Y-axis continually.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"URotatingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API URotatingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tURotatingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"URotatingComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nURotatingComponent::URotatingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tRotationSpeed = 45.0f; // Degrees per second\n}\n\nvoid URotatingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotatingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFRotator NewRotation = Owner->GetActorRotation();\n\t\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\t\tOwner->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh and set its collision to trigger a log message on overlap using OnBeginOverlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACollisionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"Engine/World.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nACollisionActor::ACollisionActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tMeshComponent->SetCollisionObjectType(ECollisionChannel::ECC_WorldDynamic);\n\tMeshComponent->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap);\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ACollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlap Begin with %s\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Implement a simple UPROPERTY boolean in an Actor to toggle visibility, with metadata to show in editor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyVisibilityToggleActor.generated.h\"\n\nUCLASS()\nclass AMyVisibilityToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyVisibilityToggleActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Visibility\")\n\tbool bIsVisible;\n\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"MyVisibilityToggleActor.h\"\n\nAMyVisibilityToggleActor::AMyVisibilityToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsVisible = true;\n}\n\nvoid AMyVisibilityToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tSetActorHiddenInGame(!bIsVisible);\n}\n```"}
{"requirement": "Create an Actor with a tick-based behavior that oscillates its scale between two values.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OscillatingScaleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOscillatingScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOscillatingScaleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Oscillation\")\n\tFVector MinScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Oscillation\")\n\tFVector MaxScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Oscillation\")\n\tfloat OscillationSpeed;\n\n\tfloat TimeAccumulator;\n};\n```", "cpp_code": "```cpp\n#include \"OscillatingScaleActor.h\"\n\nAOscillatingScaleActor::AOscillatingScaleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMinScale = FVector(1.0f, 1.0f, 1.0f);\n\tMaxScale = FVector(2.0f, 2.0f, 2.0f);\n\tOscillationSpeed = 1.0f;\n\tTimeAccumulator = 0.0f;\n}\n\nvoid AOscillatingScaleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOscillatingScaleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeAccumulator += DeltaTime * OscillationSpeed;\n\tfloat ScaleFactor = (FMath::Sin(TimeAccumulator) + 1.0f) / 2.0f; // Scales between 0 and 1\n\tFVector NewScale = FMath::Lerp(MinScale, MaxScale, ScaleFactor);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Set up an input binding in an Actor to toggle a debug message on and off whenever the 'C' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ADebugToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADebugToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADebugToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid ToggleDebugMessage();\n\n\tbool bIsDebugMessageVisible;\n};\n```", "cpp_code": "```cpp\n#include \"ADebugToggleActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nADebugToggleActor::ADebugToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsDebugMessageVisible = false;\n}\n\nvoid ADebugToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADebugToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADebugToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ToggleDebugMessage\", IE_Pressed, this, &ADebugToggleActor::ToggleDebugMessage);\n}\n\nvoid ADebugToggleActor::ToggleDebugMessage()\n{\n\tbIsDebugMessageVisible = !bIsDebugMessageVisible;\n\tif (bIsDebugMessageVisible)\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Debug Message ON\"));\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Debug Message OFF\"));\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that triggers when a specific function is called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UCustomComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnCustomFunctionCalled);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UUCustomComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUUCustomComponent();\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Custom\")\n\tFOnCustomFunctionCalled OnCustomFunctionCalled;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Custom\")\n\tvoid CustomFunction();\n};\n```", "cpp_code": "```cpp\n#include \"UCustomComponent.h\"\n\nUUCustomComponent::UUCustomComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UUCustomComponent::CustomFunction()\n{\n\t// Logic for the function\n\n\t// Trigger the delegate\n\tOnCustomFunctionCalled.Broadcast();\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor class to load a sound and play it when the Actor begins play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Sound/SoundWave.h\"\n#include \"Sound/SoundAttenuation.h\"\n#include \"ASoundPlayingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASoundPlayingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"ASoundPlayingActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"ConstructorHelpers.h\"\n\nASoundPlayingActor::ASoundPlayingActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tstatic ConstructorHelpers::FObjectFinder<USoundCue> SoundCueObj(TEXT(\"/Game/Audio/YourSoundCue.YourSoundCue\"));\n\tif (SoundCueObj.Succeeded())\n\t{\n\t\tSoundToPlay = SoundCueObj.Object;\n\t}\n}\n\nvoid ASoundPlayingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UFUNCTION that logs the Actor's transform when called from a Blueprint.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tALoggingActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Logging\")\n\tvoid LogActorTransform();\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\nALoggingActor::ALoggingActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALoggingActor::LogActorTransform()\n{\n\tFTransform ActorTransform = GetActorTransform();\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Location: %s, Rotation: %s, Scale: %s\"),\n\t\t\t*ActorTransform.GetLocation().ToString(),\n\t\t\t*ActorTransform.GetRotation().Rotator().ToString(),\n\t\t\t*ActorTransform.GetScale3D().ToString()));\n\t}\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor Transform - Location: %s, Rotation: %s, Scale: %s\"),\n\t\t*ActorTransform.GetLocation().ToString(),\n\t\t*ActorTransform.GetRotation().Rotator().ToString(),\n\t\t*ActorTransform.GetScale3D().ToString());\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that moves the Actor in a circular pattern over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CircularMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACircularMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACircularMovementActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat Radius;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat Speed;\n\n\tfloat CurrentAngle;\n};\n```", "cpp_code": "```cpp\n#include \"CircularMovementActor.h\"\n\nACircularMovementActor::ACircularMovementActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRadius = 100.0f;\n\tSpeed = 50.0f;\n\tCurrentAngle = 0.0f;\n}\n\nvoid ACircularMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACircularMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tCurrentAngle += Speed * DeltaTime;\n\tif (CurrentAngle >= 360.0f)\n\t{\n\t\tCurrentAngle -= 360.0f;\n\t}\n\t\n\tfloat RadAngle = FMath::DegreesToRadians(CurrentAngle);\n\tFVector NewLocation = FVector(FMath::Cos(RadAngle) * Radius, FMath::Sin(RadAngle) * Radius, GetActorLocation().Z);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector that represents a velocity, and move the owning Actor by this velocity every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UVelocityComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UVelocityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUVelocityComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector Velocity;\n};\n```", "cpp_code": "```cpp\n#include \"UVelocityComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUVelocityComponent::UVelocityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tVelocity = FVector::ZeroVector;\n}\n\nvoid UVelocityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UVelocityComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->AddActorWorldOffset(Velocity * DeltaTime);\n\t}\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor that reduces an integer UPROPERTY health when it collides with another Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Health\")\n\tint32 Health;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapActor::AOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tUBoxComponent* BoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tBoxComponent->SetupAttachment(MeshComponent);\n\tBoxComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n\n\tHealth = 100; // Default health value\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tHealth -= 10; // Reduce health by 10 or any other value when overlap begins\n\t}\n}\n```"}
{"requirement": "Create an Actor with a mesh and set up collision to print a message when an overlap begins.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"MyMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\nAMyMeshActor::AMyMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyMeshActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AMyMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyMeshActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Overlap Begin\"));\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a function in an Actor to toggle a UPROPERTY boolean, and bind this function to a key press in SetupPlayerInputComponent.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid ToggleBoolean();\n\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Toggle\")\n\tbool bIsToggled;\n\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAToggleActor::AToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsToggled = false;\n}\n\nvoid AToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleActor::ToggleBoolean()\n{\n\tbIsToggled = !bIsToggled;\n}\n\nvoid AToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"ToggleKey\", IE_Pressed, this, &AToggleActor::ToggleBoolean);\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector that updates to match its owner Actor's location each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULocationSyncComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULocationSyncComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tULocationSyncComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Location\", meta=(AllowPrivateAccess = \"true\"))\n\tFVector OwnerLocation;\n};\n```", "cpp_code": "```cpp\n#include \"ULocationSyncComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nULocationSyncComponent::ULocationSyncComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid ULocationSyncComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tOwnerLocation = GetOwner()->GetActorLocation();\n}\n\nvoid ULocationSyncComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tOwnerLocation = GetOwner()->GetActorLocation();\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that gradually changes the Actor's color over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAColorChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tFLinearColor CurrentColor;\n\tfloat ColorChangeSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAColorChangingActor::AColorChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tCurrentColor = FLinearColor::Red;\n\tColorChangeSpeed = 0.1f;\n}\n\nvoid AColorChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AColorChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tCurrentColor = CurrentColor.LinearRGBToHSV();\n\tCurrentColor.R += DeltaTime * ColorChangeSpeed; // Adjust the hue over time\n\tif (CurrentColor.R > 1.0f)\n\t{\n\t\tCurrentColor.R = 0.0f;\n\t}\n\n\tCurrentColor = CurrentColor.HSVToLinearRGB();\n\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"BaseColor\"), FVector(CurrentColor));\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that resets the Actor's location to the origin.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetLocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetLocationActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAResetLocationActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Actor\")\n\tvoid ResetLocationToOrigin();\n};\n```", "cpp_code": "```cpp\n#include \"ResetLocationActor.h\"\n\n// Sets default values\nAResetLocationActor::AResetLocationActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetLocationActor::ResetLocationToOrigin()\n{\n\tSetActorLocation(FVector::ZeroVector);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in an Actor to trigger when a specific input is detected.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InputDelegateActor.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInputDetected);\n\nUCLASS()\nclass YOURPROJECT_API AInputDelegateActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAInputDelegateActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUPROPERTY(BlueprintAssignable, Category = \"Input\")\n\tFOnInputDetected OnInputDetected;\n\nprivate:\n\tvoid DetectInput();\n};\n```", "cpp_code": "```cpp\n#include \"InputDelegateActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAInputDelegateActor::AInputDelegateActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AInputDelegateActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AInputDelegateActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"DetectInputAction\", IE_Pressed, this, &AInputDelegateActor::DetectInput);\n}\n\nvoid AInputDelegateActor::DetectInput()\n{\n\tOnInputDetected.Broadcast();\n}\n```"}
{"requirement": "Use ConstructorHelpers to load a skeletal mesh in an Actor's constructor and attach it to the root component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ASkeletalMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AASkeletalMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAASkeletalMeshActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ASkeletalMeshActor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAASkeletalMeshActor::AASkeletalMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<USkeletalMesh> SkeletalMeshAsset(TEXT(\"/Game/Path/To/Your/SkeletalMesh.SkeletalMesh\"));\n\tif (SkeletalMeshAsset.Succeeded())\n\t{\n\t\tSkeletalMeshComponent->SetSkeletalMesh(SkeletalMeshAsset.Object);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY for an integer score, and reset it to zero in a BlueprintCallable function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScoreActor();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Score\")\n\tint32 Score;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid ResetScore();\n};\n```", "cpp_code": "```cpp\n#include \"ScoreActor.h\"\n\nAScoreActor::AScoreActor()\n{\n\t// Set default score\n\tScore = 0;\n}\n\nvoid AScoreActor::ResetScore()\n{\n\tScore = 0;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that bounces the Actor up and down along the Z-axis.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BouncingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ABouncingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tABouncingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Bouncing\")\n\tfloat BounceHeight;\n\n\tUPROPERTY(EditAnywhere, Category=\"Bouncing\")\n\tfloat BounceSpeed;\n\n\tfloat RunningTime;\n};\n```", "cpp_code": "```cpp\n#include \"BouncingActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nABouncingActor::ABouncingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tBounceHeight = 100.0f;\n\tBounceSpeed = 1.0f;\n\tRunningTime = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ABouncingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ABouncingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation();\n\tfloat DeltaHeight = FMath::Sin(RunningTime + DeltaTime * BounceSpeed) - FMath::Sin(RunningTime);\n\tNewLocation.Z += DeltaHeight * BounceHeight;\n\tRunningTime += DeltaTime * BounceSpeed;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a Component that executes a custom event every 5 seconds using the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UTimerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTimerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUTimerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tvoid CustomEvent();\n\tfloat TimeAccumulator;\n\tconst float EventInterval = 5.0f;\n};\n```", "cpp_code": "```cpp\n#include \"UTimerComponent.h\"\n\nUTimerComponent::UTimerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTimeAccumulator = 0.0f;\n}\n\nvoid UTimerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UTimerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTimeAccumulator += DeltaTime;\n\tif (TimeAccumulator >= EventInterval)\n\t{\n\t\tCustomEvent();\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n\nvoid UTimerComponent::CustomEvent()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Custom Event Executed\"));\n}\n```"}
{"requirement": "Set up input binding in an Actor to rotate it left and right using the 'A' and 'D' keys.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotateActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotateActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotateActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Input bindings\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed;\n\n\tvoid RotateLeft();\n\tvoid RotateRight();\n};\n```", "cpp_code": "```cpp\n#include \"RotateActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nARotateActor::ARotateActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ARotateActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotateActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid ARotateActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"RotateLeft\", IE_Pressed, this, &ARotateActor::RotateLeft);\n\tPlayerInputComponent->BindAction(\"RotateRight\", IE_Pressed, this, &ARotateActor::RotateRight);\n}\n\nvoid ARotateActor::RotateLeft()\n{\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw -= RotationSpeed * GetWorld()->GetDeltaSeconds();\n\tSetActorRotation(NewRotation);\n}\n\nvoid ARotateActor::RotateRight()\n{\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * GetWorld()->GetDeltaSeconds();\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY FString and a BlueprintCallable function to change its value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MyCategory\")\n\tFString MyString;\n\n\tUFUNCTION(BlueprintCallable, Category=\"MyCategory\")\n\tvoid SetMyString(const FString& NewString);\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::SetMyString(const FString& NewString)\n{\n\tMyString = NewString;\n}\n```"}
{"requirement": "Implement an OnBeginOverlap in an Actor that logs the name of the other Actor it collides with.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACollisionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION()\n\tvoid OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"ConstructorHelpers.h\"\n\nACollisionActor::ACollisionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionActor::OnBeginOverlap);\n}\n\nvoid ACollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionActor::OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor)\n\t{\n\t\tFString OtherActorName = OtherActor->GetName();\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlapped with actor: %s\"), *OtherActorName);\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY boolean that toggles every second using the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UToggleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UUToggleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUUToggleComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Toggle\", meta=(AllowPrivateAccess = \"true\"))\n\tbool bIsToggled;\n\n\tfloat TimeAccumulator;\n};\n```", "cpp_code": "```cpp\n#include \"UToggleComponent.h\"\n\nUUToggleComponent::UUToggleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tbIsToggled = false;\n\tTimeAccumulator = 0.0f;\n}\n\nvoid UUToggleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UUToggleComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTimeAccumulator += DeltaTime;\n\tif (TimeAccumulator >= 1.0f)\n\t{\n\t\tbIsToggled = !bIsToggled;\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to gradually increase a float UPROPERTY speed variable.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedIncreasingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedIncreasingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpeedIncreasingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat Speed;\n\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat SpeedIncrement;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedIncreasingActor.h\"\n\n// Sets default values\nASpeedIncreasingActor::ASpeedIncreasingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSpeed = 0.0f;\n\tSpeedIncrement = 10.0f; // Increment value per second\n}\n\n// Called when the game starts or when spawned\nvoid ASpeedIncreasingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpeedIncreasingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tSpeed += SpeedIncrement * DeltaTime;\n}\n```"}
{"requirement": "Create an Actor that uses ConstructorHelpers to load and apply a specific material to its mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Materials/Material.h\"\n\nAMaterialActor::AMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/Path/To/Your/Material.Material\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetMaterial(0, MaterialAsset.Object);\n\t}\n}\n\nvoid AMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to broadcast when the owning Actor's location changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULocationChangeNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnLocationChanged, const FVector&, NewLocation);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULocationChangeNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tULocationChangeNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFVector LastLocation;\n\npublic:\n\tUPROPERTY(BlueprintAssignable, Category=\"Location\")\n\tFOnLocationChanged OnLocationChanged;\n};\n```", "cpp_code": "```cpp\n#include \"ULocationChangeNotifierComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nULocationChangeNotifierComponent::ULocationChangeNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid ULocationChangeNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tLastLocation = Owner->GetActorLocation();\n\t}\n}\n\nvoid ULocationChangeNotifierComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector CurrentLocation = Owner->GetActorLocation();\n\t\tif (!CurrentLocation.Equals(LastLocation))\n\t\t{\n\t\t\tOnLocationChanged.Broadcast(CurrentLocation);\n\t\t\tLastLocation = CurrentLocation;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float variable representing health and log it at every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyHealthActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMyHealthActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat Health;\n};\n```", "cpp_code": "```cpp\n#include \"MyHealthActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nAMyHealthActor::AMyHealthActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHealth = 100.0f; // Default health value\n}\n\nvoid AMyHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Health: %f\"), Health);\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent method to toggle a static mesh's visibility with the 'V' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AToggleMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAToggleMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid ToggleMeshVisibility();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"ConstructorHelpers.h\"\n\nAToggleMeshActor::AToggleMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AToggleMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleMeshActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleMeshActor::ToggleMeshVisibility);\n}\n\nvoid AToggleMeshActor::ToggleMeshVisibility()\n{\n\tif (MeshComponent)\n\t{\n\t\tMeshComponent->SetVisibility(!MeshComponent->IsVisible());\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY FVector and a BlueprintCallable function to set its value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyVectorActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyVectorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMyVectorActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Vector\")\n\tvoid SetVectorValue(const FVector& NewValue);\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Vector\")\n\tFVector VectorValue;\n};\n```", "cpp_code": "```cpp\n#include \"MyVectorActor.h\"\n\nAMyVectorActor::AMyVectorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tVectorValue = FVector::ZeroVector;\n}\n\nvoid AMyVectorActor::SetVectorValue(const FVector& NewValue)\n{\n\tVectorValue = NewValue;\n}\n```"}
{"requirement": "Implement a Tick function in a Component that changes its owning Actor's rotation over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"URotatingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API URotatingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tURotatingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"URotatingComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nURotatingComponent::URotatingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tRotationRate = FRotator(0.0f, 10.0f, 0.0f); // Default rotation rate\n}\n\nvoid URotatingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotatingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFRotator NewRotation = Owner->GetActorRotation() + (RotationRate * DeltaTime);\n\t\tOwner->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with collision set to print a message when it begins overlapping with another Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapActor::AOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set a static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Set collision\n\tMeshComponent->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\tMeshComponent->SetCollisionObjectType(ECollisionChannel::ECC_WorldDynamic);\n\tMeshComponent->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap);\n\t\n\t// Bind overlap event\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this))\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Overlap Begin\"));\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to log a custom message when the 'Enter' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to log a custom message\n\tvoid LogCustomMessage();\n\n\t// Override SetupPlayerInputComponent\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingActor::ALoggingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Log a custom message\nvoid ALoggingActor::LogCustomMessage()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Enter key pressed - Custom message logged!\"));\n}\n\n// Setup player input bindings\nvoid ALoggingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the Enter key to LogCustomMessage\n\tPlayerInputComponent->BindAction(\"LogMessage\", IE_Pressed, this, &ALoggingActor::LogCustomMessage);\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY integer counter that increases every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCounterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUCounterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Counter\")\n\tint32 Counter;\n};\n```", "cpp_code": "```cpp\n#include \"UCounterComponent.h\"\n\nUCounterComponent::UCounterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCounter = 0;\n}\n\nvoid UCounterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCounterComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tCounter++;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to simulate simple gravity by moving down the Z-axis.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GravityActor.generated.h\"\n\nUCLASS()\nclass AGravityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAGravityActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Gravity\")\n\tfloat GravityStrength;\n};\n```", "cpp_code": "```cpp\n#include \"GravityActor.h\"\n\nAGravityActor::AGravityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tGravityStrength = 980.0f; // Default gravity strength assuming cm/s^2\n}\n\nvoid AGravityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AGravityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation();\n\tNewLocation.Z -= GravityStrength * DeltaTime;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a particle system and attach it to the Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"AParticleActor.generated.h\"\n\nUCLASS()\nclass AParticleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAParticleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUParticleSystemComponent* ParticleSystemComponent;\n};\n```", "cpp_code": "```cpp\n#include \"AParticleActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Particles/ParticleSystem.h\"\n\n// Sets default values\nAParticleActor::AParticleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the particle system component\n\tParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystemComponent\"));\n\tRootComponent = ParticleSystemComponent;\n\n\t// Find the particle system asset\n\tstatic ConstructorHelpers::FObjectFinder<UParticleSystem> ParticleAsset(TEXT(\"/Game/Particles/P_MyParticleSystem.P_MyParticleSystem\"));\n\tif (ParticleAsset.Succeeded())\n\t{\n\t\tParticleSystemComponent->SetTemplate(ParticleAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AParticleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n}\n\n// Called every frame\nvoid AParticleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function to double a UPROPERTY integer value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DoubleValueActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADoubleValueActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADoubleValueActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Value\")\n\tvoid DoubleValue();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Value\")\n\tint32 Value;\n};\n```", "cpp_code": "```cpp\n#include \"DoubleValueActor.h\"\n\n// Sets default values\nADoubleValueActor::ADoubleValueActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tValue = 0;\n}\n\n// Called when the game starts or when spawned\nvoid ADoubleValueActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADoubleValueActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADoubleValueActor::DoubleValue()\n{\n\tValue *= 2;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to check and log its distance from the origin every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceLoggerActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADistanceLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADistanceLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tfloat TimeSinceLastLog;\n\n\tvoid LogDistanceFromOrigin();\n};\n```", "cpp_code": "```cpp\n#include \"DistanceLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\nADistanceLoggerActor::ADistanceLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTimeSinceLastLog = 0.0f;\n}\n\nvoid ADistanceLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADistanceLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeSinceLastLog += DeltaTime;\n\tif (TimeSinceLastLog >= 1.0f)\n\t{\n\t\tLogDistanceFromOrigin();\n\t\tTimeSinceLastLog = 0.0f;\n\t}\n}\n\nvoid ADistanceLoggerActor::LogDistanceFromOrigin()\n{\n\tFVector ActorLocation = GetActorLocation();\n\tfloat Distance = ActorLocation.Size();\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Distance from Origin: %f\"), Distance));\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that broadcasts every time the owning Actor ticks.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UDelegateTickComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnActorTick);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UDelegateTickComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUDelegateTickComponent();\n\n\tvirtual void BeginPlay() override;\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Tick\")\n\tFOnActorTick OnActorTick;\n};\n```", "cpp_code": "```cpp\n#include \"UDelegateTickComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUDelegateTickComponent::UDelegateTickComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UDelegateTickComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UDelegateTickComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (OnActorTick.IsBound())\n\t{\n\t\tOnActorTick.Broadcast();\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to trigger a function that prints the current game time on 'T' key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintGameTimeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APrintGameTimeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPrintGameTimeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to print the current game time\n\tvoid PrintGameTime();\n};\n```", "cpp_code": "```cpp\n#include \"PrintGameTimeActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/InputSettings.h\"\n\n// Sets default values\nAPrintGameTimeActor::APrintGameTimeActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid APrintGameTimeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APrintGameTimeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid APrintGameTimeActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"PrintGameTime\", IE_Pressed, this, &APrintGameTimeActor::PrintGameTime);\n\t}\n}\n\n// Function to print the current game time\nvoid APrintGameTimeActor::PrintGameTime()\n{\n\tif (GetWorld())\n\t{\n\t\tfloat CurrentTime = GetWorld()->GetTimeSeconds();\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Current Game Time: %f\"), CurrentTime);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY array of integers and a BlueprintCallable function to add an element.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyIntegerArrayActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyIntegerArrayActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyIntegerArrayActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"IntegerArray\")\n\tTArray<int32> IntegerArray;\n\n\tUFUNCTION(BlueprintCallable, Category = \"IntegerArray\")\n\tvoid AddInteger(int32 NewInteger);\n};\n```", "cpp_code": "```cpp\n#include \"MyIntegerArrayActor.h\"\n\n// Sets default values\nAMyIntegerArrayActor::AMyIntegerArrayActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyIntegerArrayActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyIntegerArrayActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyIntegerArrayActor::AddInteger(int32 NewInteger)\n{\n\tIntegerArray.Add(NewInteger);\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor that changes a UPROPERTY color when it overlaps.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapColorChangeActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AOverlapColorChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOverlapColorChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Color\")\n\tFLinearColor OverlapColor;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nAOverlapColorChangeActor::AOverlapColorChangeActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapColorChangeActor::OnBeginOverlap);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapColorChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapColorChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapColorChangeActor::OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), OverlapColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY representing an angle, incremented by 5 degrees each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UAngleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UAngleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUAngleComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Angle\")\n\tfloat Angle;\n};\n```", "cpp_code": "```cpp\n#include \"UAngleComponent.h\"\n\nUAngleComponent::UAngleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tAngle = 0.0f;\n}\n\nvoid UAngleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UAngleComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Increment the angle by 5 degrees each tick\n\tAngle += 5.0f;\n\n\t// Keep the angle in the range [0, 360)\n\tif (Angle >= 360.0f)\n\t{\n\t\tAngle -= 360.0f;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that oscillates the Actor's rotation between two angles.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OscillatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOscillatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAOscillatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Oscillation\")\n\tFRotator StartRotation;\n\n\tUPROPERTY(EditAnywhere, Category=\"Oscillation\")\n\tFRotator EndRotation;\n\n\tUPROPERTY(EditAnywhere, Category=\"Oscillation\")\n\tfloat OscillationSpeed;\n\n\tfloat CurrentTime;\n};\n```", "cpp_code": "```cpp\n#include \"OscillatingActor.h\"\n\nAOscillatingActor::AOscillatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tStartRotation = FRotator(0.0f, 0.0f, 0.0f);\n\tEndRotation = FRotator(0.0f, 180.0f, 0.0f);\n\tOscillationSpeed = 1.0f;\n\tCurrentTime = 0.0f;\n}\n\nvoid AOscillatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOscillatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tCurrentTime += DeltaTime * OscillationSpeed;\n\tfloat Alpha = (FMath::Sin(CurrentTime) + 1.0f) / 2.0f;\n\tFRotator NewRotation = FMath::Lerp(StartRotation, EndRotation, Alpha);\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an Actor with a mesh loaded using ConstructorHelpers and a BlueprintCallable function to toggle collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMyActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Collision\")\n\tvoid ToggleCollision();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.MeshName\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AMyActor::ToggleCollision()\n{\n\tif (MeshComponent->IsCollisionEnabled())\n\t{\n\t\tMeshComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\t}\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component that triggers when a string UPROPERTY changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UStringChangeComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnStringChanged, const FString&, NewString);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UStringChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUStringChangeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(BlueprintAssignable, Category=\"StringChange\")\n\tFOnStringChanged OnStringChanged;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"StringChange\")\n\tFString MonitoredString;\n\n\tUFUNCTION()\n\tvoid SetMonitoredString(const FString& NewString);\n\nprivate:\n\tFString PreviousString;\n};\n```", "cpp_code": "```cpp\n#include \"UStringChangeComponent.h\"\n\nUStringChangeComponent::UStringChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tPreviousString = \"\";\n}\n\nvoid UStringChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UStringChangeComponent::SetMonitoredString(const FString& NewString)\n{\n\tif (MonitoredString != NewString)\n\t{\n\t\tMonitoredString = NewString;\n\t\tOnStringChanged.Broadcast(MonitoredString);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY FVector velocity, and move the Actor by this velocity each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector Velocity;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!Velocity.IsZero())\n\t{\n\t\tFVector NewLocation = GetActorLocation() + (Velocity * DeltaTime);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent method to bind a key to reset an Actor's position to a start point.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"ResetPositionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetPositionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResetPositionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tFVector StartPosition;\n\n\tvoid ResetPosition();\n};\n```", "cpp_code": "```cpp\n#include \"ResetPositionActor.h\"\n#include \"GameFramework/InputSettings.h\"\n#include \"Components/InputComponent.h\"\n\nAResetPositionActor::AResetPositionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetPositionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tStartPosition = GetActorLocation();\n}\n\nvoid AResetPositionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetPositionActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"ResetPosition\", IE_Pressed, this, &AResetPositionActor::ResetPosition);\n\t}\n}\n\nvoid AResetPositionActor::ResetPosition()\n{\n\tSetActorLocation(StartPosition);\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function to log its current velocity UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VelocityLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVelocityLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAVelocityLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Velocity\")\n\tvoid LogCurrentVelocity();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Movement\", meta=(AllowPrivateAccess=\"true\"))\n\tFVector CurrentVelocity;\n};\n```", "cpp_code": "```cpp\n#include \"VelocityLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nAVelocityLoggerActor::AVelocityLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentVelocity = FVector::ZeroVector;\n}\n\nvoid AVelocityLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AVelocityLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t// Update the CurrentVelocity with actor's velocity (example logic)\n\tCurrentVelocity = GetVelocity();\n}\n\nvoid AVelocityLoggerActor::LogCurrentVelocity()\n{\n\tif(GEngine)\n\t{\n\t\tFString VelocityString = CurrentVelocity.ToString();\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Current Velocity: %s\"), *VelocityString));\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in a Component to gradually change its owning Actor's scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UScaleChangingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UScaleChangingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUScaleChangingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector TargetScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tfloat ScaleSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"UScaleChangingComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUScaleChangingComponent::UScaleChangingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tTargetScale = FVector(2.0f, 2.0f, 2.0f);\n\tScaleSpeed = 0.1f;\n}\n\nvoid UScaleChangingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UScaleChangingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector CurrentScale = Owner->GetActorScale3D();\n\t\tFVector NewScale = FMath::VInterpTo(CurrentScale, TargetScale, DeltaTime, ScaleSpeed);\n\t\tOwner->SetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh and print its world position when it begins play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAMyStaticMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Static Mesh Component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// Create and set Static Mesh Component\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Optionally set a mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Print the Actor's world position\n\tFVector WorldPosition = GetActorLocation();\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor World Position: %s\"), *WorldPosition.ToString());\n}\n```"}
{"requirement": "Set up an input binding in an Actor to log a message when the 'Space' key is released.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpaceKeyActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpaceKeyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpaceKeyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to handle space key release\n\tvoid OnSpaceKeyReleased();\n};\n```", "cpp_code": "```cpp\n#include \"SpaceKeyActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nASpaceKeyActor::ASpaceKeyActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASpaceKeyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpaceKeyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpaceKeyActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"Jump\", IE_Released, this, &ASpaceKeyActor::OnSpaceKeyReleased);\n\t}\n}\n\nvoid ASpaceKeyActor::OnSpaceKeyReleased()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Space key released\"));\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY boolean that toggles when a custom method is called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UToggleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UToggleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUToggleComponent();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Toggle\")\n\tvoid ToggleBoolean();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Toggle\")\n\tbool bIsToggled;\n};\n```", "cpp_code": "```cpp\n#include \"UToggleComponent.h\"\n\nUToggleComponent::UToggleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbIsToggled = false;\n}\n\nvoid UToggleComponent::ToggleBoolean()\n{\n\tbIsToggled = !bIsToggled;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to smoothly transition its location towards a target point.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SmoothTransitionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASmoothTransitionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASmoothTransitionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector TargetLocation;\n\tUPROPERTY(EditAnywhere)\n\tfloat TransitionSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"SmoothTransitionActor.h\"\n#include \"GameFramework/Actor.h\"\n\nASmoothTransitionActor::ASmoothTransitionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTransitionSpeed = 10.0f; // Default speed\n}\n\nvoid ASmoothTransitionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Initialize TargetLocation to some value\n\tTargetLocation = FVector(1000.0f, 1000.0f, 1000.0f);\n}\n\nvoid ASmoothTransitionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentLocation = GetActorLocation();\n\tFVector NewLocation = FMath::VInterpTo(CurrentLocation, TargetLocation, DeltaTime, TransitionSpeed);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a sound cue and play it when the Actor collides.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"MySoundActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMySoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMySoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUAudioComponent* AudioComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUSoundCue* SoundCue;\n};\n```", "cpp_code": "```cpp\n#include \"MySoundActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMySoundActor::AMySoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n\n\tstatic ConstructorHelpers::FObjectFinder<USoundCue> SoundCueObject(TEXT(\"/Game/Audio/MySoundCue.MySoundCue\"));\n\tif (SoundCueObject.Succeeded())\n\t{\n\t\tSoundCue = SoundCueObject.Object;\n\t\tAudioComponent->SetSound(SoundCue);\n\t}\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMySoundActor::OnOverlapBegin);\n}\n\nvoid AMySoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMySoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMySoundActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (SoundCue && !AudioComponent->IsPlaying())\n\t{\n\t\tAudioComponent->Play();\n\t}\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function to return a UPROPERTY integer score value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScoreActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Score\")\n\tint32 GetScore() const;\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Score\")\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreActor.h\"\n\nAScoreActor::AScoreActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// Initialize score\n\tScore = 0;\n}\n\nint32 AScoreActor::GetScore() const\n{\n\treturn Score;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to gradually decrease a float UPROPERTY health variable over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAHealthActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat Health;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat HealthDecreaseRate;\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n\n// Sets default values\nAHealthActor::AHealthActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default values\n\tHealth = 100.0f;\n\tHealthDecreaseRate = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Decrease health over time\n\tHealth -= HealthDecreaseRate * DeltaTime;\n\t// Ensure health doesn't drop below zero\n\tif (Health < 0.0f)\n\t{\n\t\tHealth = 0.0f;\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that triggers on every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UComponentWithDelegate.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnTickDelegate);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UComponentWithDelegate : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUComponentWithDelegate();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Event\")\n\tFOnTickDelegate OnTick;\n};\n```", "cpp_code": "```cpp\n#include \"UComponentWithDelegate.h\"\n\nUComponentWithDelegate::UComponentWithDelegate()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UComponentWithDelegate::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UComponentWithDelegate::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tOnTick.Broadcast();\n}\n```"}
{"requirement": "Set up input binding in an Actor to increase an integer UPROPERTY counter by 1 on 'I' key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyCounterActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyCounterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyCounterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to increase the counter\n\tvoid IncreaseCounter();\n\n\t// Input Component Setup\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Counter\")\n\tint32 Counter;\n};\n```", "cpp_code": "```cpp\n#include \"MyCounterActor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAMyCounterActor::AMyCounterActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tCounter = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AMyCounterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyCounterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyCounterActor::IncreaseCounter()\n{\n\tCounter++;\n}\n\n// Setup player input\nvoid AMyCounterActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"IncreaseCounter\", IE_Pressed, this, &AMyCounterActor::IncreaseCounter);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY for a material and a function to log its name when called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid LogMaterialName();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Material\")\n\tUMaterialInterface* Material;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Materials/MaterialInterface.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyActor::LogMaterialName()\n{\n\tif (Material)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Material Name: %s\"), *Material->GetName());\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Material is not set.\"));\n\t}\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor that calls a BlueprintCallable function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Overlap\")\n\tvoid BlueprintCallableFunction();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/CollisionProfile.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapActor::AOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComponent->SetCollisionProfileName(UCollisionProfile::Pawn_ProfileName);\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tBlueprintCallableFunction();\n}\n\nvoid AOverlapActor::BlueprintCallableFunction()\n{\n\t// Implement your logic here\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector representing direction, and update the owning Actor's forward vector each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UDirectionComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UDirectionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUDirectionComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Direction\")\n\tFVector Direction;\n};\n```", "cpp_code": "```cpp\n#include \"UDirectionComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values for this component's properties\nUDirectionComponent::UDirectionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\t// Initialize the direction vector\n\tDirection = FVector(1.0f, 0.0f, 0.0f);\n}\n\n// Called when the game starts\nvoid UDirectionComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid UDirectionComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Update the owning Actor's forward vector\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->SetActorRotation(Direction.Rotation());\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that makes it look at a fixed point in space.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LookAtPointActor.generated.h\"\n\nUCLASS()\nclass ALookAtPointActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tALookAtPointActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Look At\")\n\tFVector LookAtPoint;\n};\n```", "cpp_code": "```cpp\n#include \"LookAtPointActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nALookAtPointActor::ALookAtPointActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t // Initialize LookAtPoint to a default value\n\t LookAtPoint = FVector(0.0f, 0.0f, 0.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ALookAtPointActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALookAtPointActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate the direction to look at\n\tFVector Direction = LookAtPoint - GetActorLocation();\n\tDirection.Normalize();\n\n\t// Construct a rotation to look at the point\n\tFRotator NewRotation = Direction.Rotation();\n\n\t// Set the actor's rotation to the new rotation\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an Actor with a static mesh component, and attach a particle system loaded via ConstructorHelpers.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUParticleSystemComponent* ParticleSystemComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\tParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystemComponent\"));\n\tParticleSystemComponent->SetupAttachment(StaticMeshComponent);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UParticleSystem> ParticleAsset(TEXT(\"/Game/Path/To/Your/ParticleSystem.ParticleSystem\"));\n\tif (ParticleAsset.Succeeded())\n\t{\n\t\tParticleSystemComponent->SetTemplate(ParticleAsset.Object);\n\t}\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to notify when an integer UPROPERTY changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UChangeNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnIntegerChanged, int32, NewValue);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UChangeNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUChangeNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(BlueprintAssignable, Category=\"Events\")\n\tFOnIntegerChanged OnIntegerChanged;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Notifier\")\n\tvoid SetNotifiableInteger(int32 NewValue);\n\nprivate:\n\tUPROPERTY()\n\tint32 NotifiableInteger;\n};\n```", "cpp_code": "```cpp\n#include \"UChangeNotifierComponent.h\"\n\nUChangeNotifierComponent::UChangeNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tNotifiableInteger = 0;\n}\n\nvoid UChangeNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UChangeNotifierComponent::SetNotifiableInteger(int32 NewValue)\n{\n\tif (NotifiableInteger != NewValue)\n\t{\n\t\tNotifiableInteger = NewValue;\n\t\tOnIntegerChanged.Broadcast(NewValue);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float representing scale, and a function to reset it to 1.0.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyScaleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMyScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyScaleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Scale\")\n\tvoid ResetScale();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Scale\")\n\tfloat Scale;\n};\n```", "cpp_code": "```cpp\n#include \"MyScaleActor.h\"\n\n// Sets default values\nAMyScaleActor::AMyScaleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the scale\n\tScale = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMyScaleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyScaleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid AMyScaleActor::ResetScale()\n{\n\tScale = 1.0f;\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind an action that logs the actor's current scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"ScaleLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScaleLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid LogActorScale();\n};\n```", "cpp_code": "```cpp\n#include \"ScaleLoggerActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nAScaleLoggerActor::AScaleLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AScaleLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScaleLoggerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"LogScale\", IE_Pressed, this, &AScaleLoggerActor::LogActorScale);\n\t}\n}\n\nvoid AScaleLoggerActor::LogActorScale()\n{\n\tFVector ActorScale = GetActorScale3D();\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor Scale: %s\"), *ActorScale.ToString());\n}\n```"}
{"requirement": "Create an Actor with a FVector UPROPERTY velocity and apply it to the Actor's movement each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMovingActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector Velocity;\n};\n```", "cpp_code": "```cpp\n#include \"MyMovingActor.h\"\n\nAMyMovingActor::AMyMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tVelocity = FVector::ZeroVector;\n}\n\nvoid AMyMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!Velocity.IsZero())\n\t{\n\t\tFVector NewLocation = GetActorLocation() + (Velocity * DeltaTime);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in a Component to increase the owning Actor's size over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"USizeIncreaseComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API USizeIncreaseComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUSizeIncreaseComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Size\")\n\tfloat SizeIncreaseRate;\n};\n```", "cpp_code": "```cpp\n#include \"USizeIncreaseComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUSizeIncreaseComponent::USizeIncreaseComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tSizeIncreaseRate = 1.0f;\n}\n\nvoid USizeIncreaseComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid USizeIncreaseComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector NewScale = Owner->GetActorScale3D() + FVector(SizeIncreaseRate * DeltaTime);\n\t\tOwner->SetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh, and implement collision to log the other Actor's velocity on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n#include \"Logging/LogMacros.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"MyOverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMyOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMesh;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"MyOverlapActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"GameFramework/MovementComponent.h\"\n\n// Sets default values\nAMyOverlapActor::AMyOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tStaticMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMesh\"));\n\tRootComponent = StaticMesh;\n\n\tStaticMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\tStaticMesh->SetCollisionObjectType(ECollisionChannel::ECC_WorldDynamic);\n\tStaticMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap);\n\n\tStaticMesh->OnComponentBeginOverlap.AddDynamic(this, &AMyOverlapActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid AMyOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUMovementComponent* MovementComponent = OtherActor->FindComponentByClass<UMovementComponent>();\n\t\tif (MovementComponent)\n\t\t{\n\t\t\tFVector Velocity = MovementComponent->Velocity;\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Overlapping Actor's Velocity: %s\"), *Velocity.ToString());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to call a function that toggles a UPROPERTY boolean.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to toggle the boolean\n\tUFUNCTION()\n\tvoid ToggleBoolean();\n\n\t// Input Component binding\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Boolean to toggle\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Toggle\")\n\tbool bIsToggled;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleActor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAToggleActor::AToggleActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t bIsToggled = false;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\n// Called to bind functionality to input\nvoid AToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleAction\", IE_Pressed, this, &AToggleActor::ToggleBoolean);\n}\n\n// Function to toggle the boolean\nvoid AToggleActor::ToggleBoolean()\n{\n\tbIsToggled = !bIsToggled;\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY float that increases by 0.5 every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFloatIncrementComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatIncrementComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFloatIncrementComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Increment\")\n\tfloat IncrementingFloat;\n};\n```", "cpp_code": "```cpp\n#include \"UFloatIncrementComponent.h\"\n\nUFloatIncrementComponent::UFloatIncrementComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tIncrementingFloat = 0.0f;\n}\n\nvoid UFloatIncrementComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFloatIncrementComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tIncrementingFloat += 0.5f;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to rotate it around its origin continually.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Rotation\")\n\tFRotator RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Set default rotation speed\n\tRotationSpeed = FRotator(0.f, 45.f, 0.f); // 45 degrees per second around Y-axis\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate the new rotation\n\tFRotator NewRotation = GetActorRotation() + (RotationSpeed * DeltaTime);\n\n\t// Set the new rotation\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load and display a specific texture on its mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"MyTextureActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyTextureActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyTextureActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY()\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"MyTextureActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"Materials/Material.h\"\n#include \"Engine/Texture2D.h\"\n\nAMyTextureActor::AMyTextureActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/StarterContent/Materials/M_Brick_Clay.M_Brick_Clay\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MaterialAsset.Object, MeshComponent);\n\t\tstatic ConstructorHelpers::FObjectFinder<UTexture2D> TextureAsset(TEXT(\"/Game/StarterContent/Textures/T_Brick_Clay_BC.T_Brick_Clay_BC\"));\n\t\tif (TextureAsset.Succeeded())\n\t\t{\n\t\t\tDynamicMaterialInstance->SetTextureParameterValue(TEXT(\"Texture\"), TextureAsset.Object);\n\t\t}\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\nvoid AMyTextureActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyTextureActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that returns its current location as a string.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALocationActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tALocationActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Location\")\n\tFString GetLocationAsString() const;\n};\n```", "cpp_code": "```cpp\n#include \"LocationActor.h\"\n\nALocationActor::ALocationActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nFString ALocationActor::GetLocationAsString() const\n{\n\tFVector Location = GetActorLocation();\n\treturn FString::Printf(TEXT(\"X: %f, Y: %f, Z: %f\"), Location.X, Location.Y, Location.Z);\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to modify its material color based on its Z-coordinate.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADynamicColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADynamicColorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Material\")\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tvoid UpdateMaterialColor();\n};\n```", "cpp_code": "```cpp\n#include \"DynamicColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nADynamicColorActor::ADynamicColorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ADynamicColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MeshComponent)\n\t{\n\t\tDynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t}\n}\n\nvoid ADynamicColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tUpdateMaterialColor();\n}\n\nvoid ADynamicColorActor::UpdateMaterialColor()\n{\n\tif (DynamicMaterial)\n\t{\n\t\tfloat ZHeight = GetActorLocation().Z;\n\t\tFLinearColor NewColor = FLinearColor::LerpUsingHSV(FLinearColor::Red, FLinearColor::Blue, FMath::Clamp(ZHeight / 1000.0f, 0.0f, 1.0f));\n\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that broadcasts when a UPROPERTY float exceeds a threshold.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFloatThresholdComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnThresholdExceeded);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatThresholdComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFloatThresholdComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"FloatThreshold\")\n\tfloat MonitoredFloat;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"FloatThreshold\")\n\tfloat Threshold;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"FloatThreshold\")\n\tFOnThresholdExceeded OnThresholdExceeded;\n\nprivate:\n\tvoid CheckThreshold();\n};\n```", "cpp_code": "```cpp\n#include \"UFloatThresholdComponent.h\"\n\nUFloatThresholdComponent::UFloatThresholdComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tMonitoredFloat = 0.0f;\n\tThreshold = 100.0f; // Default threshold value\n}\n\nvoid UFloatThresholdComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFloatThresholdComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tCheckThreshold();\n}\n\nvoid UFloatThresholdComponent::CheckThreshold()\n{\n\tif (MonitoredFloat > Threshold)\n\t{\n\t\tOnThresholdExceeded.Broadcast();\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to print a message when the mouse left button is clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseClickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMouseClickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMouseClickActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid OnLeftMouseClick();\n};\n```", "cpp_code": "```cpp\n#include \"MouseClickActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nAMouseClickActor::AMouseClickActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AMouseClickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMouseClickActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"LeftMouseClick\", IE_Pressed, this, &AMouseClickActor::OnLeftMouseClick);\n\t}\n}\n\nvoid AMouseClickActor::OnLeftMouseClick()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Left Mouse Button Clicked!\"));\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY integer for health and a function to decrease it by a specified amount.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAHealthActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tint32 Health;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Health\")\n\tvoid DecreaseHealth(int32 Amount);\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n\nAHealthActor::AHealthActor()\n{\n\t// Set default health value\n\tHealth = 100;\n}\n\nvoid AHealthActor::DecreaseHealth(int32 Amount)\n{\n\tHealth -= Amount;\n\tif (Health < 0)\n\t{\n\t\tHealth = 0;\n\t}\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor that prints both Actors' names.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapPrinterActor.generated.h\"\n\nUCLASS()\nclass AOverlapPrinterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOverlapPrinterActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapPrinterActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"ConstructorHelpers.h\"\n\nAOverlapPrinterActor::AOverlapPrinterActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapPrinterActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AOverlapPrinterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapPrinterActor::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && (OtherActor != this))\n\t{\n\t\tFString OverlappedActorName = OverlappedActor->GetName();\n\t\tFString OtherActorName = OtherActor->GetName();\n\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Overlapped Actor: %s, Other Actor: %s\"), *OverlappedActorName, *OtherActorName));\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector that interpolates towards a target location each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UInterpLocationComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UInterpLocationComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUInterpLocationComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n\tFVector CurrentLocation;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n\tFVector TargetLocation;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n\tfloat InterpSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"UInterpLocationComponent.h\"\n\nUInterpLocationComponent::UInterpLocationComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tInterpSpeed = 1.0f;\n}\n\nvoid UInterpLocationComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCurrentLocation = GetOwner()->GetActorLocation();\n}\n\nvoid UInterpLocationComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (FVector::Dist(CurrentLocation, TargetLocation) > KINDA_SMALL_NUMBER)\n\t{\n\t\tCurrentLocation = FMath::VInterpTo(CurrentLocation, TargetLocation, DeltaTime, InterpSpeed);\n\t\tGetOwner()->SetActorLocation(CurrentLocation);\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that changes its pitch by a small amount each frame.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PitchChangingActor.generated.h\"\n\nUCLASS()\nclass APitchChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPitchChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Pitch\")\n\tfloat PitchChangeRate;\n};\n```", "cpp_code": "```cpp\n#include \"PitchChangingActor.h\"\n\n// Sets default values\nAPitchChangingActor::APitchChangingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Set default pitch change rate\n\tPitchChangeRate = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid APitchChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APitchChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Get current rotation\n\tFRotator CurrentRotation = GetActorRotation();\n\n\t// Modify the pitch\n\tCurrentRotation.Pitch += PitchChangeRate * DeltaTime;\n\n\t// Set new rotation\n\tSetActorRotation(CurrentRotation);\n}\n```"}
{"requirement": "Create an Actor with a static mesh and load a material using ConstructorHelpers to apply to its mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMyStaticMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Mesh\")\n\tUStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.MeshName\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/Path/To/Your/Material.MaterialName\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetMaterial(0, MaterialAsset.Object);\n\t}\n}\n\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyStaticMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to fire when a bool UPROPERTY changes state.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UExampleComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBoolChanged, bool, NewValue);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UExampleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUExampleComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION()\n\tvoid SetBoolProperty(bool NewValue);\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Event\")\n\tFOnBoolChanged OnBoolChanged;\n\nprivate:\n\tUPROPERTY()\n\tbool bExampleBool;\n};\n```", "cpp_code": "```cpp\n#include \"UExampleComponent.h\"\n\nUExampleComponent::UExampleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbExampleBool = false;\n}\n\nvoid UExampleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UExampleComponent::SetBoolProperty(bool NewValue)\n{\n\tif (bExampleBool != NewValue)\n\t{\n\t\tbExampleBool = NewValue;\n\t\tOnBoolChanged.Broadcast(bExampleBool);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float representing rotation speed and apply it in the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 45.0f; // Default rotation speed\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind an axis that controls the Actor's forward movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"MyPawn.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyPawn : public APawn\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this pawn's properties\n\tAMyPawn();\n\nprotected:\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Called for forwards/backward input\n\tvoid MoveForward(float Value);\n\nprivate:\n\t// The mesh component for the pawn\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyPawn.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAMyPawn::AMyPawn()\n{\n\t// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set a default mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called to bind functionality to input\nvoid AMyPawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &AMyPawn::MoveForward);\n}\n\n// Called for forwards/backward input\nvoid AMyPawn::MoveForward(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\t// Add movement in that direction\n\t\tAddMovementInput(GetActorForwardVector(), Value);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a function to reset a UPROPERTY integer score and bind it to a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetScoreActor.generated.h\"\n\nUCLASS()\nclass AResetScoreActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResetScoreActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid ResetScore();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Score\")\n\tint32 Score;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ResetScoreActor.h\"\n#include \"Components/InputComponent.h\"\n\nAResetScoreActor::AResetScoreActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScore = 0;\n}\n\nvoid AResetScoreActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AResetScoreActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetScoreActor::ResetScore()\n{\n\tScore = 0;\n}\n\nvoid AResetScoreActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetScore\", IE_Pressed, this, &AResetScoreActor::ResetScore);\n}\n```"}
{"requirement": "Implement a Tick function in a Component to change its owning Actor's color over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UColorChangingComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UColorChangingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUColorChangingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFLinearColor CurrentColor;\n\tfloat TimeAccumulator;\n};\n```", "cpp_code": "```cpp\n#include \"UColorChangingComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nUColorChangingComponent::UColorChangingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCurrentColor = FLinearColor::White;\n\tTimeAccumulator = 0.0f;\n}\n\nvoid UColorChangingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UColorChangingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTimeAccumulator += DeltaTime;\n\tfloat SineValue = FMath::Sin(TimeAccumulator);\n\tCurrentColor = FLinearColor(0.5f * (SineValue + 1.0f), 0.0f, 1.0f - 0.5f * (SineValue + 1.0f));\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUMeshComponent* MeshComp = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComp)\n\t\t{\n\t\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComp->CreateAndSetMaterialInstanceDynamic(0);\n\t\t\tif (DynamicMaterial)\n\t\t\t{\n\t\t\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", CurrentColor);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh component, and log a message every time it moves.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AMovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMovingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tFVector LastLocation;\n};\n```", "cpp_code": "```cpp\n#include \"AMovingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMovingActor::AMovingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach static mesh component\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Example of setting a default static mesh (ensure you have a valid asset in your project)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/YourPath/YourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tLastLocation = GetActorLocation();\n}\n\n// Called when the game starts or when spawned\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentLocation = GetActorLocation();\n\tif (!CurrentLocation.Equals(LastLocation))\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Actor moved to: %s\"), *CurrentLocation.ToString());\n\t\tLastLocation = CurrentLocation;\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to increase a float UPROPERTY speed variable on 'Up' arrow key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Speed\")\n\tfloat Speed;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid IncreaseSpeed();\n};\n```", "cpp_code": "```cpp\n#include \"SpeedActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\nASpeedActor::ASpeedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSpeed = 0.0f;\n}\n\nvoid ASpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpeedActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"IncreaseSpeed\", IE_Pressed, this, &ASpeedActor::IncreaseSpeed);\n}\n\nvoid ASpeedActor::IncreaseSpeed()\n{\n\tSpeed += 10.0f; // Increase speed by 10 units\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FString and a method to append text to it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UTextAppenderComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTextAppenderComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUTextAppenderComponent();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Text\")\n\tvoid AppendText(const FString& NewText);\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Text\")\n\tFString Text;\n};\n```", "cpp_code": "```cpp\n#include \"UTextAppenderComponent.h\"\n\nUTextAppenderComponent::UTextAppenderComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UTextAppenderComponent::AppendText(const FString& NewText)\n{\n\tText.Append(NewText);\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to animate its mesh scaling in response to a sine wave.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SineWaveScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ASineWaveScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASineWaveScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tfloat RunningTime;\n};\n```", "cpp_code": "```cpp\n#include \"SineWaveScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nASineWaveScalingActor::ASineWaveScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRunningTime = 0.0f;\n}\n\nvoid ASineWaveScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASineWaveScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRunningTime += DeltaTime;\n\tfloat ScaleFactor = FMath::Sin(RunningTime);\n\tMeshComponent->SetWorldScale3D(FVector(ScaleFactor));\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a blueprint and spawn it when the Actor is initialized.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditDefaultsOnly, Category = \"Spawning\")\n\tTSubclassOf<AActor> BlueprintToSpawn;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Find the blueprint class\n\tstatic ConstructorHelpers::FObjectFinder<UClass> BlueprintClass(TEXT(\"/Game/Blueprints/MyBlueprint.MyBlueprint_C\"));\n\tif (BlueprintClass.Succeeded())\n\t{\n\t\tBlueprintToSpawn = BlueprintClass.Object;\n\t}\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (BlueprintToSpawn)\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tGetWorld()->SpawnActor<AActor>(BlueprintToSpawn, GetActorLocation(), GetActorRotation(), SpawnParams);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that prints the number of ticks since the game started.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TickCounterActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATickCounterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATickCounterActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Tick\")\n\tvoid PrintTickCount();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tint32 TickCount;\n};\n```", "cpp_code": "```cpp\n#include \"TickCounterActor.h\"\n#include \"Engine/Engine.h\"\n\nATickCounterActor::ATickCounterActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTickCount = 0;\n}\n\nvoid ATickCounterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATickCounterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tTickCount++;\n}\n\nvoid ATickCounterActor::PrintTickCount()\n{\n\tif (GEngine)\n\t{\n\t\tFString TickCountMessage = FString::Printf(TEXT(\"Ticks since game started: %d\"), TickCount);\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TickCountMessage);\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to simulate a pendulum-like movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PendulumActor.generated.h\"\n\nUCLASS()\nclass APendulumActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPendulumActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat SwingAmplitude;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat SwingFrequency;\n\n\tfloat InitialYaw;\n};\n```", "cpp_code": "```cpp\n#include \"PendulumActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAPendulumActor::APendulumActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tSwingAmplitude = 30.0f; // 30 degrees\n\tSwingFrequency = 1.0f; // 1 oscillation per second\n}\n\nvoid APendulumActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tInitialYaw = GetActorRotation().Yaw;\n}\n\nvoid APendulumActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat Time = GetWorld()->GetTimeSeconds();\n\tfloat DeltaYaw = SwingAmplitude * FMath::Sin(SwingFrequency * Time);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw = InitialYaw + DeltaYaw;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that fires every time a specific input is detected.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UInputDetectComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInputDetected);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UUInputDetectComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this component's properties\n\tUUInputDetectComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Input\")\n\tFOnInputDetected OnInputDetected;\n\nprivate:\n\tvoid HandleInput();\n};\n```", "cpp_code": "```cpp\n#include \"UInputDetectComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values for this component's properties\nUUInputDetectComponent::UUInputDetectComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\n// Called when the game starts\nvoid UUInputDetectComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind input\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tif (UInputComponent* InputComponent = Owner->FindComponentByClass<UInputComponent>())\n\t\t{\n\t\t\tSetupPlayerInputComponent(InputComponent);\n\t\t}\n\t}\n}\n\nvoid UUInputDetectComponent::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"YourInputAction\", IE_Pressed, this, &UUInputDetectComponent::HandleInput);\n\t}\n}\n\nvoid UUInputDetectComponent::HandleInput()\n{\n\tOnInputDetected.Broadcast();\n}\n```"}
{"requirement": "Set up input binding in an Actor to log a message whenever the 'Left' arrow key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InputBindingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AInputBindingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAInputBindingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to handle input\n\tvoid HandleLeftArrow();\n};\n```", "cpp_code": "```cpp\n#include \"InputBindingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAInputBindingActor::AInputBindingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AInputBindingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AInputBindingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid AInputBindingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"LeftArrow\", IE_Pressed, this, &AInputBindingActor::HandleLeftArrow);\n\t}\n}\n\n// Function to handle input\nvoid AInputBindingActor::HandleLeftArrow()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Left Arrow Key Pressed\"));\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY array of FVectors and a function to clear the array.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyVectorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyVectorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMyVectorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Vectors\")\n\tTArray<FVector> VectorArray;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Vectors\")\n\tvoid ClearVectorArray();\n};\n```", "cpp_code": "```cpp\n#include \"MyVectorActor.h\"\n\nAMyVectorActor::AMyVectorActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyVectorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyVectorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyVectorActor::ClearVectorArray()\n{\n\tVectorArray.Empty();\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor to stop its movement when colliding with a specific tag.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor);\n\n\tUPROPERTY(EditAnywhere)\n\tFName StopTag;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nAOverlapActor::AOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnBeginOverlap);\n}\n\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && OtherActor != this && OtherActor->ActorHasTag(StopTag))\n\t{\n\t\tMeshComponent->SetPhysicsLinearVelocity(FVector::ZeroVector);\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY representing the last known location of its owning Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULastKnownLocationComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass MYPROJECT_API ULastKnownLocationComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tULastKnownLocationComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Location\")\n\tFVector LastKnownLocation;\n\n\tvoid UpdateLastKnownLocation();\n};\n```", "cpp_code": "```cpp\n#include \"ULastKnownLocationComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nULastKnownLocationComponent::ULastKnownLocationComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid ULastKnownLocationComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateLastKnownLocation();\n}\n\nvoid ULastKnownLocationComponent::UpdateLastKnownLocation()\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tLastKnownLocation = Owner->GetActorLocation();\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to apply a constant upward force to itself.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UpwardForceActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AUpwardForceActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAUpwardForceActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat ForceMagnitude;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"UpwardForceActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAUpwardForceActor::AUpwardForceActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tForceMagnitude = 1000.0f; // Example force magnitude\n}\n\n// Called when the game starts or when spawned\nvoid AUpwardForceActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AUpwardForceActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (MeshComponent)\n\t{\n\t\tFVector UpwardForce = FVector(0.0f, 0.0f, ForceMagnitude);\n\t\tMeshComponent->AddForce(UpwardForce);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh component and an OnBeginOverlap event to change its material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyOverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Materials\")\n\tUMaterialInterface* OverlapMaterial;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"MyOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyOverlapActor::AMyOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Static Mesh Component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set up overlap event\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyOverlapActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid AMyOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OverlapMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, OverlapMaterial);\n\t}\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to notify when a float UPROPERTY reaches zero.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UZeroNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnZeroReached);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UZeroNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUZeroNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"ZeroNotifier\")\n\tfloat MonitoredValue;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"ZeroNotifier\")\n\tFOnZeroReached OnZeroReached;\n\n\tUFUNCTION()\n\tvoid CheckValue();\n};\n```", "cpp_code": "```cpp\n#include \"UZeroNotifierComponent.h\"\n\nUZeroNotifierComponent::UZeroNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tMonitoredValue = 0.0f;\n}\n\nvoid UZeroNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UZeroNotifierComponent::CheckValue()\n{\n\tif (MonitoredValue == 0.0f)\n\t{\n\t\tOnZeroReached.Broadcast();\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY for a light intensity and a function to toggle the light.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyLightActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMyLightActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid ToggleLight();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light\")\n\tfloat LightIntensity;\n\nprivate:\n\tUPROPERTY()\n\tclass UPointLightComponent* PointLight;\n};\n```", "cpp_code": "```cpp\n#include \"MyLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\nAMyLightActor::AMyLightActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tPointLight->SetupAttachment(RootComponent);\n\tLightIntensity = 3000.0f;\n\tPointLight->SetIntensity(LightIntensity);\n}\n\nvoid AMyLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyLightActor::ToggleLight()\n{\n\tif (PointLight)\n\t{\n\t\tPointLight->ToggleVisibility();\n\t}\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind a key to change an Actor's color dynamically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ChangeColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAChangeColorActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid ChangeColor();\n};\n```", "cpp_code": "```cpp\n#include \"ChangeColorActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAChangeColorActor::AChangeColorActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetMaterial(0, UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this));\n}\n\n// Called when the game starts or when spawned\nvoid AChangeColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AChangeColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid AChangeColorActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"ChangeColor\", IE_Pressed, this, &AChangeColorActor::ChangeColor);\n\t}\n}\n\nvoid AChangeColorActor::ChangeColor()\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = Cast<UMaterialInstanceDynamic>(MeshComponent->GetMaterial(0));\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", NewColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY FVector and a BlueprintCallable function to set its value from a Blueprint.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyVectorActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyVectorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyVectorActor();\n\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Vector\")\n\tFVector MyVector;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Vector\")\n\tvoid SetMyVector(const FVector& NewVector);\n};\n```", "cpp_code": "```cpp\n#include \"MyVectorActor.h\"\n\nAMyVectorActor::AMyVectorActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AMyVectorActor::SetMyVector(const FVector& NewVector)\n{\n\tMyVector = NewVector;\n}\n```"}
{"requirement": "Implement a Tick function in a Component to cycle the owning Actor's color through a gradient over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ColorCyclerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UColorCyclerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUColorCyclerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tvoid CycleColor(float DeltaTime);\n\n\tFLinearColor CurrentColor;\n\tfloat ColorChangeSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"ColorCyclerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nUColorCyclerComponent::UColorCyclerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tColorChangeSpeed = 1.0f;\n\tCurrentColor = FLinearColor::Red;\n}\n\nvoid UColorCyclerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UColorCyclerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tCycleColor(DeltaTime);\n}\n\nvoid UColorCyclerComponent::CycleColor(float DeltaTime)\n{\n\tif(AActor* Owner = GetOwner())\n\t{\n\t\tUMeshComponent* MeshComponent = Owner->FindComponentByClass<UMeshComponent>();\n\t\tif(MeshComponent)\n\t\t{\n\t\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\t\tif(DynamicMaterial)\n\t\t\t{\n\t\t\t\tCurrentColor.R += ColorChangeSpeed * DeltaTime;\n\t\t\t\tCurrentColor.G += ColorChangeSpeed * DeltaTime;\n\t\t\t\tCurrentColor.B += ColorChangeSpeed * DeltaTime;\n\n\t\t\t\tif(CurrentColor.R > 1.0f) CurrentColor.R -= 1.0f;\n\t\t\t\tif(CurrentColor.G > 1.0f) CurrentColor.G -= 1.0f;\n\t\t\t\tif(CurrentColor.B > 1.0f) CurrentColor.B -= 1.0f;\n\n\t\t\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", CurrentColor);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a mesh and print its rotation when it receives an input from the user.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"PrintRotationActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APrintRotationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPrintRotationActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid PrintRotation();\n};\n```", "cpp_code": "```cpp\n#include \"PrintRotationActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/InputSettings.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAPrintRotationActor::APrintRotationActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid APrintRotationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APrintRotationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APrintRotationActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"PrintRotation\", IE_Pressed, this, &APrintRotationActor::PrintRotation);\n}\n\nvoid APrintRotationActor::PrintRotation()\n{\n\tFRotator ActorRotation = GetActorRotation();\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor Rotation: Pitch=%f, Yaw=%f, Roll=%f\"), ActorRotation.Pitch, ActorRotation.Yaw, ActorRotation.Roll);\n}\n```"}
{"requirement": "Set up an input binding in an Actor to decrease a UPROPERTY float health value when 'H' is pressed.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHealthActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input bindings\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat Health;\n\n\tUFUNCTION()\n\tvoid DecreaseHealth();\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAHealthActor::AHealthActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t Health = 100.0f; // Initialize health\n}\n\n// Called when the game starts or when spawned\nvoid AHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input bindings\nvoid AHealthActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the DecreaseHealth function to the 'H' key\n\tPlayerInputComponent->BindAction(\"DecreaseHealth\", IE_Pressed, this, &AHealthActor::DecreaseHealth);\n}\n\nvoid AHealthActor::DecreaseHealth()\n{\n\tHealth -= 10.0f; // Decrease health by 10\n\tif (Health < 0.0f)\n\t{\n\t\tHealth = 0.0f; // Clamp health to zero\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY integer counter that resets every time it reaches a specified value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCounterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUCounterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Counter\")\n\tvoid IncrementCounter();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Counter\")\n\tint32 Counter;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Counter\")\n\tint32 ResetValue;\n};\n```", "cpp_code": "```cpp\n#include \"UCounterComponent.h\"\n\nUCounterComponent::UCounterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCounter = 0;\n\tResetValue = 10; // Default reset value, can be set in editor\n}\n\nvoid UCounterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCounterComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\t// This component does not need to tick for this functionality\n}\n\nvoid UCounterComponent::IncrementCounter()\n{\n\tCounter++;\n\tif (Counter >= ResetValue)\n\t{\n\t\tCounter = 0;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to make it look at the player's camera location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LookAtPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALookAtPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALookAtPlayerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAPlayerCameraManager* PlayerCameraManager;\n};\n```", "cpp_code": "```cpp\n#include \"LookAtPlayerActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Camera/PlayerCameraManager.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nALookAtPlayerActor::ALookAtPlayerActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALookAtPlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tPlayerCameraManager = PlayerController->PlayerCameraManager;\n\t}\n}\n\n// Called every frame\nvoid ALookAtPlayerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerCameraManager)\n\t{\n\t\tFVector CameraLocation = PlayerCameraManager->GetCameraLocation();\n\t\tFRotator LookAtRotation = (CameraLocation - GetActorLocation()).Rotation();\n\t\tSetActorRotation(LookAtRotation);\n\t}\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load and apply a specific sound to play on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"CollisionSoundActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACollisionSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACollisionSoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUAudioComponent* AudioComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUSoundCue* CollisionSound;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionSoundActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nACollisionSoundActor::ACollisionSoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n\n\tstatic ConstructorHelpers::FObjectFinder<USoundCue> SoundCueFinder(TEXT(\"/Game/Audio/MyCollisionSoundCue.MyCollisionSoundCue\"));\n\tif (SoundCueFinder.Succeeded())\n\t{\n\t\tCollisionSound = SoundCueFinder.Object;\n\t\tAudioComponent->SetSound(CollisionSound);\n\t}\n\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ACollisionSoundActor::OnHit);\n}\n\nvoid ACollisionSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionSoundActor::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (CollisionSound && AudioComponent)\n\t{\n\t\tAudioComponent->Play();\n\t}\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that returns the distance to the player's controller.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADistanceActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Distance\")\n\tfloat GetDistanceToPlayer() const;\n};\n```", "cpp_code": "```cpp\n#include \"DistanceActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nADistanceActor::ADistanceActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nfloat ADistanceActor::GetDistanceToPlayer() const\n{\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController && PlayerController->GetPawn())\n\t{\n\t\tFVector PlayerLocation = PlayerController->GetPawn()->GetActorLocation();\n\t\tFVector ActorLocation = GetActorLocation();\n\t\treturn FVector::Dist(PlayerLocation, ActorLocation);\n\t}\n\treturn -1.0f; // Return -1 if the player controller or pawn is not found\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to create a pulsing effect by scaling the mesh over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PulsingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APulsingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPulsingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Pulse\")\n\tfloat PulseSpeed;\n\n\tUPROPERTY(EditAnywhere, Category = \"Pulse\")\n\tfloat PulseScaleAmplitude;\n};\n```", "cpp_code": "```cpp\n#include \"PulsingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAPulsingActor::APulsingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tPulseSpeed = 2.0f;\n\tPulseScaleAmplitude = 0.5f;\n}\n\nvoid APulsingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APulsingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat RunningTime = GetGameTimeSinceCreation();\n\tfloat ScaleFactor = 1.0f + PulseScaleAmplitude * FMath::Sin(PulseSpeed * RunningTime);\n\tMeshComponent->SetWorldScale3D(FVector(ScaleFactor));\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that broadcasts when the owning Actor's visibility changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UVisibilityChangeComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnVisibilityChanged, bool, bIsVisible);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UVisibilityChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUVisibilityChangeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOwnerVisibilityChanged();\n\npublic:\n\tUPROPERTY(BlueprintAssignable, Category=\"Visibility\")\n\tFOnVisibilityChanged OnVisibilityChanged;\n};\n```", "cpp_code": "```cpp\n#include \"UVisibilityChangeComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUVisibilityChangeComponent::UVisibilityChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UVisibilityChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->OnActorHiddenInGame.AddDynamic(this, &UVisibilityChangeComponent::OnOwnerVisibilityChanged);\n\t\tOwner->OnActorEndPlay.AddDynamic(this, &UVisibilityChangeComponent::OnOwnerVisibilityChanged);\n\t}\n}\n\nvoid UVisibilityChangeComponent::OnOwnerVisibilityChanged()\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tbool bIsVisible = !Owner->bHidden;\n\t\tOnVisibilityChanged.Broadcast(bIsVisible);\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to trigger a function that logs the current frame number.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogFrameActor.generated.h\"\n\nUCLASS()\nclass ALogFrameActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALogFrameActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid LogCurrentFrameNumber();\n};\n```", "cpp_code": "```cpp\n#include \"LogFrameActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nALogFrameActor::ALogFrameActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ALogFrameActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALogFrameActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ALogFrameActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"LogFrame\", IE_Pressed, this, &ALogFrameActor::LogCurrentFrameNumber);\n}\n\nvoid ALogFrameActor::LogCurrentFrameNumber()\n{\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Frame Number: %d\"), GFrameNumber);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY array of strings and a BlueprintCallable function to add to it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStringArrayActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStringArrayActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyStringArrayActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"StringArray\")\n\tvoid AddStringToArray(const FString& NewString);\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"StringArray\")\n\tTArray<FString> StringArray;\n};\n```", "cpp_code": "```cpp\n#include \"MyStringArrayActor.h\"\n\nAMyStringArrayActor::AMyStringArrayActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AMyStringArrayActor::AddStringToArray(const FString& NewString)\n{\n\tStringArray.Add(NewString);\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor that reverses its velocity upon collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionReverser.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionReverser : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACollisionReverser();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tFVector Velocity;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionReverser.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nACollisionReverser::ACollisionReverser()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionReverser::OnBeginOverlap);\n\n\tVelocity = FVector(100.f, 0.f, 0.f);\n}\n\nvoid ACollisionReverser::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionReverser::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation() + (Velocity * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n\nvoid ACollisionReverser::OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tVelocity = -Velocity;\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector velocity that accelerates every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UVelocityComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UVelocityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUVelocityComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Velocity\")\n\tFVector Velocity;\n\n\tUPROPERTY(EditAnywhere, Category=\"Velocity\")\n\tFVector Acceleration;\n};\n```", "cpp_code": "```cpp\n#include \"UVelocityComponent.h\"\n\n// Sets default values for this component's properties\nUVelocityComponent::UVelocityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\t// Initialize default velocity and acceleration\n\tVelocity = FVector::ZeroVector;\n\tAcceleration = FVector(10.0f, 0.0f, 0.0f); // Example acceleration\n}\n\n// Called when the game starts\nvoid UVelocityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid UVelocityComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Accelerate velocity\n\tVelocity += Acceleration * DeltaTime;\n\n\t// Log the current velocity (optional)\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Velocity: %s\"), *Velocity.ToString());\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to adjust its yaw based on the current game time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YawAdjustActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AYawAdjustActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic: \n\t// Sets default values for this actor's properties\n\tAYawAdjustActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"YawAdjustActor.h\"\n\n// Sets default values\nAYawAdjustActor::AYawAdjustActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize rotation speed\n\tRotationSpeed = 90.0f; // Degrees per second\n}\n\n// Called when the game starts or when spawned\nvoid AYawAdjustActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AYawAdjustActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Get the current time in seconds\n\tfloat CurrentTime = GetWorld()->GetTimeSeconds();\n\n\t// Calculate new yaw based on the time and rotation speed\n\tfloat NewYaw = CurrentTime * RotationSpeed;\n\n\t// Get current rotation\n\tFRotator CurrentRotation = GetActorRotation();\n\n\t// Adjust yaw\n\tCurrentRotation.Yaw = NewYaw;\n\n\t// Set new rotation\n\tSetActorRotation(CurrentRotation);\n}\n```"}
{"requirement": "Create an Actor with a static mesh and a BlueprintCallable function to toggle its physics simulation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TogglePhysicsActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ATogglePhysicsActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tATogglePhysicsActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Physics\")\n\tvoid TogglePhysicsSimulation();\n};\n```", "cpp_code": "```cpp\n#include \"TogglePhysicsActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nATogglePhysicsActor::ATogglePhysicsActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetSimulatePhysics(false);\n}\n\nvoid ATogglePhysicsActor::TogglePhysicsSimulation()\n{\n\tif (MeshComponent)\n\t{\n\t\tbool bIsSimulating = MeshComponent->IsSimulatingPhysics();\n\t\tMeshComponent->SetSimulatePhysics(!bIsSimulating);\n\t}\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to notify when a string UPROPERTY is appended.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UStringAppendNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnStringAppended, const FString&, NewString);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UStringAppendNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUStringAppendNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(BlueprintAssignable, Category=\"String\")\n\tFOnStringAppended OnStringAppended;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"String\")\n\tFString MyString;\n\n\tUFUNCTION(BlueprintCallable, Category=\"String\")\n\tvoid AppendToString(const FString& StringToAppend);\n};\n```", "cpp_code": "```cpp\n#include \"UStringAppendNotifierComponent.h\"\n\nUStringAppendNotifierComponent::UStringAppendNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UStringAppendNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UStringAppendNotifierComponent::AppendToString(const FString& StringToAppend)\n{\n\tMyString.Append(StringToAppend);\n\tOnStringAppended.Broadcast(MyString);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float for movement speed, modifiable via a public method.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMovementActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Public method to set movement speed\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid SetMovementSpeed(float NewSpeed);\n\nprivate:\n\t// Movement speed of the actor\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovementActor.h\"\n\n// Sets default values\nAMovementActor::AMovementActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementSpeed = 600.0f; // Default movement speed\n}\n\n// Called when the game starts or when spawned\nvoid AMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\n// Public method to set movement speed\nvoid AMovementActor::SetMovementSpeed(float NewSpeed)\n{\n\tMovementSpeed = NewSpeed;\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind an input that changes an Actor's scale uniformly.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UniformScaleActor.generated.h\"\n\nUCLASS()\nclass AUniformScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAUniformScaleActor();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid ChangeScale(float ScaleDelta);\n\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tfloat ScaleFactor;\n};\n```", "cpp_code": "```cpp\n#include \"UniformScaleActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAUniformScaleActor::AUniformScaleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScaleFactor = 1.0f;\n}\n\nvoid AUniformScaleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"ChangeScale\", this, &AUniformScaleActor::ChangeScale);\n}\n\nvoid AUniformScaleActor::ChangeScale(float ScaleDelta)\n{\n\tFVector NewScale = GetActorScale3D();\n\tNewScale *= (1.0f + ScaleDelta * ScaleFactor);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY integer and a BlueprintCallable function to double its value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DoubleValueActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADoubleValueActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tADoubleValueActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Value\")\n\tvoid DoubleValue();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Value\")\n\tint32 IntegerValue;\n};\n```", "cpp_code": "```cpp\n#include \"DoubleValueActor.h\"\n\nADoubleValueActor::ADoubleValueActor()\n{\n\t// Set default value for the integer\n\tIntegerValue = 0;\n}\n\nvoid ADoubleValueActor::DoubleValue()\n{\n\tIntegerValue *= 2;\n}\n```"}
{"requirement": "Implement a Tick function in a Component to animate its owning Actor's rotation over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"URotateComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API URotateComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tURotateComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"URotateComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nURotateComponent::URotateComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tRotationRate = FRotator(0.f, 10.f, 0.f);\n}\n\nvoid URotateComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotateComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFRotator NewRotation = Owner->GetActorRotation() + (RotationRate * DeltaTime);\n\t\tOwner->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh component, and use OnBeginOverlap to print the overlapping Actor's location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapActor::AOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach static mesh component\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Set up overlap event\n\tStaticMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n\n\t// Example of setting a static mesh (assuming you have a valid asset)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tFVector ActorLocation = OtherActor->GetActorLocation();\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlapping Actor Location: %s\"), *ActorLocation.ToString());\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to reset a FVector UPROPERTY to zero on 'R' key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetVectorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetVectorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAResetVectorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ResetVector();\n\n\tUPROPERTY(EditAnywhere)\n\tFVector ResettableVector;\n};\n```", "cpp_code": "```cpp\n#include \"ResetVectorActor.h\"\n#include \"Components/InputComponent.h\"\n\nAResetVectorActor::AResetVectorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetVectorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AResetVectorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetVectorActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetVector\", IE_Pressed, this, &AResetVectorActor::ResetVector);\n}\n\nvoid AResetVectorActor::ResetVector()\n{\n\tResettableVector = FVector::ZeroVector;\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FString that logs a message whenever its value changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UStringLoggerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UStringLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUStringLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void LogStringChange();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Logging\")\n\tFString LoggedString;\n\n\tUFUNCTION()\n\tvoid OnRep_LoggedString();\n\n\tFString PreviousString;\n};\n```", "cpp_code": "```cpp\n#include \"UStringLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUStringLoggerComponent::UStringLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UStringLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPreviousString = LoggedString;\n}\n\nvoid UStringLoggerComponent::LogStringChange()\n{\n\tif (LoggedString != PreviousString)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"String changed from %s to %s\"), *PreviousString, *LoggedString);\n\t\tPreviousString = LoggedString;\n\t}\n}\n\nvoid UStringLoggerComponent::OnRep_LoggedString()\n{\n\tLogStringChange();\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to apply a damping effect to its velocity over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DampingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADampingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADampingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Damping\")\n\tFVector Velocity;\n\n\tUPROPERTY(EditAnywhere, Category=\"Damping\")\n\tfloat DampingFactor;\n};\n```", "cpp_code": "```cpp\n#include \"DampingActor.h\"\n\nADampingActor::ADampingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tVelocity = FVector(100.f, 0.f, 0.f);\n\tDampingFactor = 0.98f;\n}\n\nvoid ADampingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADampingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Apply damping to the velocity\n\tVelocity *= DampingFactor;\n\n\t// Update the actor's location based on the velocity\n\tFVector NewLocation = GetActorLocation() + Velocity * DeltaTime;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a mesh and attach it to the Actor's root component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyMeshActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAMyMeshActor::AMyMeshActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the mesh component and attach it to the root\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Use ConstructorHelpers to find and load the mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that logs its current forward vector.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoggingActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Logging\")\n\tvoid LogForwardVector() const;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingActor::ALoggingActor()\n{\n\t // Set this actor to call Tick() every frame.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ALoggingActor::LogForwardVector() const\n{\n\tif(GEngine)\n\t{\n\t\tFVector ForwardVector = GetActorForwardVector();\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Forward Vector: %s\"), *ForwardVector.ToString()));\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to continuously update its velocity based on player input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\tvoid MoveForward(float Value);\n\tvoid MoveRight(float Value);\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector Velocity;\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MaxSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMaxSpeed = 600.0f;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!Velocity.IsZero())\n\t{\n\t\tVelocity = Velocity.GetClampedToMaxSize(MaxSpeed);\n\t\tAddActorWorldOffset(Velocity * DeltaTime, true);\n\t}\n}\n\nvoid AMyActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &AMyActor::MoveForward);\n\tPlayerInputComponent->BindAxis(\"MoveRight\", this, &AMyActor::MoveRight);\n}\n\nvoid AMyActor::MoveForward(float Value)\n{\n\tFVector Forward = GetActorForwardVector();\n\tVelocity.X = Value * MaxSpeed;\n}\n\nvoid AMyActor::MoveRight(float Value)\n{\n\tFVector Right = GetActorRightVector();\n\tVelocity.Y = Value * MaxSpeed;\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate to fire when the owning Actor's Y position changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"AYPositionChangeNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnYPositionChanged, float, NewYPosition);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UAYPositionChangeNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUAYPositionChangeNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"EventDispatchers\")\n\tFOnYPositionChanged OnYPositionChanged;\n\nprivate:\n\tfloat LastYPosition;\n};\n```", "cpp_code": "```cpp\n#include \"AYPositionChangeNotifierComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUAYPositionChangeNotifierComponent::UAYPositionChangeNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tLastYPosition = 0.0f;\n}\n\nvoid UAYPositionChangeNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tLastYPosition = Owner->GetActorLocation().Y;\n\t}\n}\n\nvoid UAYPositionChangeNotifierComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tfloat CurrentYPosition = Owner->GetActorLocation().Y;\n\t\tif (!FMath::IsNearlyEqual(CurrentYPosition, LastYPosition))\n\t\t{\n\t\t\tOnYPositionChanged.Broadcast(CurrentYPosition);\n\t\t\tLastYPosition = CurrentYPosition;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to print a message when a specific gamepad button is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GamepadInputActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AGamepadInputActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAGamepadInputActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid OnGamepadButtonPressed();\n};\n```", "cpp_code": "```cpp\n#include \"GamepadInputActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nAGamepadInputActor::AGamepadInputActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AGamepadInputActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AGamepadInputActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"GamepadButton\", IE_Pressed, this, &AGamepadInputActor::OnGamepadButtonPressed);\n}\n\nvoid AGamepadInputActor::OnGamepadButtonPressed()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Gamepad button pressed!\"));\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY array of floats and a BlueprintCallable function to compute the average.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AverageCalculatorActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AAverageCalculatorActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAAverageCalculatorActor();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Values\")\n\tTArray<float> FloatValues;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Calculation\")\n\tfloat CalculateAverage() const;\n};\n```", "cpp_code": "```cpp\n#include \"AverageCalculatorActor.h\"\n\nAAverageCalculatorActor::AAverageCalculatorActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nfloat AAverageCalculatorActor::CalculateAverage() const\n{\n\tif (FloatValues.Num() == 0)\n\t{\n\t\treturn 0.0f;\n\t}\n\n\tfloat Sum = 0.0f;\n\tfor (float Value : FloatValues)\n\t{\n\t\tSum += Value;\n\t}\n\treturn Sum / FloatValues.Num();\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor to log the tags of the overlapping Actors.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOverlapLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLoggerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"GameFramework/Actor.h\"\n\nAOverlapLoggerActor::AOverlapLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapLoggerActor::OnOverlapBegin);\n}\n\nvoid AOverlapLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapLoggerActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tfor (const FName& Tag : OtherActor->Tags)\n\t\t{\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Overlapping Actor Tag: %s\"), *Tag.ToString());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector representing a target location and interpolate towards it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UInterpolatingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UInterpolatingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUInterpolatingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n\tFVector TargetLocation;\n\nprivate:\n\tFVector CurrentLocation;\n\tUPROPERTY(EditAnywhere, Category=\"Interpolation\")\n\tfloat InterpolationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"UInterpolatingComponent.h\"\n\nUInterpolatingComponent::UInterpolatingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tInterpolationSpeed = 1.0f;\n}\n\nvoid UInterpolatingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCurrentLocation = GetOwner()->GetActorLocation();\n}\n\nvoid UInterpolatingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\t\n\tif (!FMath::IsNearlyEqual(CurrentLocation.Size(), TargetLocation.Size(), 1.0f))\n\t{\n\t\tCurrentLocation = FMath::VInterpTo(CurrentLocation, TargetLocation, DeltaTime, InterpolationSpeed);\n\t\tGetOwner()->SetActorLocation(CurrentLocation);\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to adjust its material's emissive strength based on game time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EmissiveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AEmissiveActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAEmissiveActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Emissive\")\n\tfloat EmissiveStrength;\n\n\tUPROPERTY(EditAnywhere, Category = \"Emissive\")\n\tfloat EmissiveMultiplier;\n\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"EmissiveActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAEmissiveActor::AEmissiveActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tEmissiveStrength = 1.0f;\n\tEmissiveMultiplier = 1.0f;\n}\n\nvoid AEmissiveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MeshComponent->GetMaterial(0))\n\t{\n\t\tDynamicMaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t}\n}\n\nvoid AEmissiveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterialInstance)\n\t{\n\t\tfloat GameTime = GetWorld()->GetTimeSeconds();\n\t\tfloat NewEmissiveStrength = EmissiveStrength + FMath::Sin(GameTime) * EmissiveMultiplier;\n\t\tDynamicMaterialInstance->SetScalarParameterValue(\"EmissiveStrength\", NewEmissiveStrength);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh loaded using ConstructorHelpers and simulate physics on it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyPhysicsActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyPhysicsActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyPhysicsActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Mesh\", meta = (AllowPrivateAccess = \"true\"))\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyPhysicsActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyPhysicsActor::AMyPhysicsActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetSimulatePhysics(true);\n}\n\n// Called when the game starts or when spawned\nvoid AMyPhysicsActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyPhysicsActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to fire when a UPROPERTY health variable is modified.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UHealthComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnHealthChangedSignature, float, NewHealth);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UUHealthComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUUHealthComponent();\n\n\tUPROPERTY(BlueprintAssignable, Category = \"Health\")\n\tFOnHealthChangedSignature OnHealthChanged;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Health\")\n\tfloat Health;\n\npublic:\n\tvoid SetHealth(float NewHealth);\n\tfloat GetHealth() const;\n};\n```", "cpp_code": "```cpp\n#include \"UHealthComponent.h\"\n\nUUHealthComponent::UUHealthComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tHealth = 100.0f; // Default health value\n}\n\nvoid UUHealthComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UUHealthComponent::SetHealth(float NewHealth)\n{\n\tif (Health != NewHealth)\n\t{\n\t\tHealth = NewHealth;\n\t\tOnHealthChanged.Broadcast(Health);\n\t}\n}\n\nfloat UUHealthComponent::GetHealth() const\n{\n\treturn Health;\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float representing bounce factor and a method to apply it on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BounceActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ABounceActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tABounceActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Bounce\")\n\tfloat BounceFactor;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"BounceActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nABounceActor::ABounceActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tUStaticMeshComponent* MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->SetNotifyRigidBodyCollision(true);\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ABounceActor::OnHit);\n\n\tBounceFactor = 1.2f;\n}\n\n// Called when the game starts or when spawned\nvoid ABounceActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ABounceActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle collision\nvoid ABounceActor::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tFVector Velocity = GetVelocity();\n\t\tFVector ReflectedVelocity = FMath::GetReflectionVector(Velocity, Hit.Normal);\n\t\tSetActorLocation(GetActorLocation() + ReflectedVelocity * BounceFactor);\n\t}\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind an axis input to control an Actor's vertical movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"VerticalMovementActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AVerticalMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAVerticalMovementActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Movement\", meta = (AllowPrivateAccess = \"true\"))\n\tfloat MovementSpeed;\n\n\t// Function to handle vertical movement\n\tvoid MoveVertical(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"VerticalMovementActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAVerticalMovementActor::AVerticalMovementActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set default movement speed\n\tMovementSpeed = 100.f;\n}\n\n// Called when the game starts or when spawned\nvoid AVerticalMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AVerticalMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid AVerticalMovementActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tcheck(PlayerInputComponent);\n\tPlayerInputComponent->BindAxis(\"MoveVertical\", this, &AVerticalMovementActor::MoveVertical);\n}\n\n// Function to handle vertical movement\nvoid AVerticalMovementActor::MoveVertical(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tFVector NewLocation = GetActorLocation();\n\t\tNewLocation.Z += Value * MovementSpeed * GetWorld()->GetDeltaSeconds();\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY integer for score and a function to increment it by a given value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAScoreActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Score\")\n\tint32 Score;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid IncrementScore(int32 Value);\n};\n```", "cpp_code": "```cpp\n#include \"ScoreActor.h\"\n\n// Sets default values\nAScoreActor::AScoreActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize Score\n\tScore = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AScoreActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AScoreActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid AScoreActor::IncrementScore(int32 Value)\n{\n\tScore += Value;\n}\n```"}
{"requirement": "Implement a Tick function in a Component to simulate a flickering light effect on its owning Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFlickeringLightComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFlickeringLightComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUFlickeringLightComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Flickering\")\n\tfloat MinIntensity;\n\n\tUPROPERTY(EditAnywhere, Category = \"Flickering\")\n\tfloat MaxIntensity;\n\n\tUPROPERTY(EditAnywhere, Category = \"Flickering\")\n\tfloat FlickerSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"UFlickeringLightComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"Math/UnrealMathUtility.h\"\n\nUFlickeringLightComponent::UFlickeringLightComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tMinIntensity = 1000.0f;\n\tMaxIntensity = 5000.0f;\n\tFlickerSpeed = 5.0f;\n}\n\nvoid UFlickeringLightComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFlickeringLightComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tUPointLightComponent* PointLight = Owner->FindComponentByClass<UPointLightComponent>();\n\t\tif (PointLight)\n\t\t{\n\t\t\tfloat NewIntensity = FMath::Lerp(MinIntensity, MaxIntensity, FMath::RandRange(0.0f, 1.0f));\n\t\t\tPointLight->SetIntensity(NewIntensity);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh and use OnBeginOverlap to log a message about the collision details.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionOverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACollisionOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor,\n\t\t\t\t\t\tclass UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,\n\t\t\t\t\t\tbool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACollisionOverlapActor::ACollisionOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionOverlapActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionOverlapActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor,\n\t\t\t\t\t\t\t\t\t\t\tclass UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,\n\t\t\t\t\t\t\t\t\t\t\tbool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (GEngine)\n\t{\n\t\tFString ActorName = OtherActor ? OtherActor->GetName() : TEXT(\"None\");\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Overlap Begin with: %s\"), *ActorName));\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to increase a UPROPERTY integer count whenever the 'E' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyIncrementActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyIncrementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyIncrementActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Counter\")\n\tint32 Count;\n\n\tvoid IncrementCount();\n};\n```", "cpp_code": "```cpp\n#include \"MyIncrementActor.h\"\n#include \"Components/InputComponent.h\"\n\nAMyIncrementActor::AMyIncrementActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCount = 0;\n}\n\nvoid AMyIncrementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyIncrementActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"IncreaseCount\", IE_Pressed, this, &AMyIncrementActor::IncrementCount);\n}\n\nvoid AMyIncrementActor::IncrementCount()\n{\n\tCount++;\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FString to store a log message, and a method to print it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULogMessageComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULogMessageComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tULogMessageComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Log\")\n\tFString LogMessage;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Log\")\n\tvoid PrintLogMessage() const;\n};\n```", "cpp_code": "```cpp\n#include \"ULogMessageComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nULogMessageComponent::ULogMessageComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid ULogMessageComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ULogMessageComponent::PrintLogMessage() const\n{\n\tif (!LogMessage.IsEmpty())\n\t{\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Log Message: %s\"), *LogMessage);\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Log Message is empty.\"));\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to rotate its mesh around its local Z-axis.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nARotatingMeshActor::ARotatingMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRotationSpeed = 45.0f; // Degrees per second\n}\n\nvoid ARotatingMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = MeshComponent->GetRelativeRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tMeshComponent->SetRelativeRotation(NewRotation);\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a texture and apply it to its material upon initialization.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TextureLoadingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ATextureLoadingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tATextureLoadingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"TextureLoadingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nATextureLoadingActor::ATextureLoadingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Load a static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Load a material\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/StarterContent/Materials/M_Basic_Wall.M_Basic_Wall\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MaterialAsset.Object, MeshComponent);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n\n\t// Load a texture\n\tstatic ConstructorHelpers::FObjectFinder<UTexture> TextureAsset(TEXT(\"/Game/StarterContent/Textures/T_Brick_Clay_Beige_D.T_Brick_Clay_Beige_D\"));\n\tif (TextureAsset.Succeeded() && DynamicMaterialInstance)\n\t{\n\t\tDynamicMaterialInstance->SetTextureParameterValue(\"BaseTexture\", TextureAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ATextureLoadingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATextureLoadingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that returns its current scale as a string.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAScaleActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Scale\")\n\tFString GetCurrentScaleAsString() const;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleActor.h\"\n\nAScaleActor::AScaleActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nFString AScaleActor::GetCurrentScaleAsString() const\n{\n\tFVector Scale = GetActorScale3D();\n\treturn FString::Printf(TEXT(\"X: %f, Y: %f, Z: %f\"), Scale.X, Scale.Y, Scale.Z);\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to modify its material color based on its distance from a point.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADistanceColorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector TargetPoint;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MaxDistance;\n\n\tUMaterialInstanceDynamic* DynamicMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"DistanceColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nADistanceColorActor::ADistanceColorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"Material'/Game/StarterContent/Materials/M_Basic_Wall.M_Basic_Wall'\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterial = UMaterialInstanceDynamic::Create(MaterialAsset.Object, this);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterial);\n\t}\n\n\tTargetPoint = FVector(0.0f, 0.0f, 0.0f);\n\tMaxDistance = 1000.0f;\n}\n\nvoid ADistanceColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADistanceColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterial)\n\t{\n\t\tfloat Distance = FVector::Dist(TargetPoint, GetActorLocation());\n\t\tfloat LerpValue = FMath::Clamp(Distance / MaxDistance, 0.0f, 1.0f);\n\t\tFLinearColor NewColor = FLinearColor::LerpUsingHSV(FLinearColor::Green, FLinearColor::Red, LerpValue);\n\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate to notify when the owning Actor's velocity changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"AVelocityChangeNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnVelocityChanged, FVector, NewVelocity);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UVelocityChangeNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUVelocityChangeNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Velocity\")\n\tFOnVelocityChanged OnVelocityChanged;\n\nprivate:\n\tFVector PreviousVelocity;\n};\n```", "cpp_code": "```cpp\n#include \"AVelocityChangeNotifierComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUVelocityChangeNotifierComponent::UVelocityChangeNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UVelocityChangeNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tPreviousVelocity = Owner->GetVelocity();\n\t}\n}\n\nvoid UVelocityChangeNotifierComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector CurrentVelocity = Owner->GetVelocity();\n\t\tif (!CurrentVelocity.Equals(PreviousVelocity))\n\t\t{\n\t\t\tOnVelocityChanged.Broadcast(CurrentVelocity);\n\t\t\tPreviousVelocity = CurrentVelocity;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to trigger a function that toggles a UPROPERTY boolean state.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ToggleBoolean();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Toggle\", meta=(AllowPrivateAccess=\"true\"))\n\tbool bToggleState;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAToggleActor::AToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbToggleState = false;\n}\n\nvoid AToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ToggleAction\", IE_Pressed, this, &AToggleActor::ToggleBoolean);\n}\n\nvoid AToggleActor::ToggleBoolean()\n{\n\tbToggleState = !bToggleState;\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY for a string name and a BlueprintCallable function to change it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"MyActor\")\n\tvoid SetName(const FString& NewName);\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MyActor\")\n\tFString Name;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tName = TEXT(\"DefaultName\");\n}\n\nvoid AMyActor::SetName(const FString& NewName)\n{\n\tName = NewName;\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor to apply a force to the overlapping Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyOverlapActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMesh;\n\n\tUFUNCTION()\n\tvoid OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUPROPERTY(EditAnywhere)\n\tfloat ForceMagnitude;\n};\n```", "cpp_code": "```cpp\n#include \"MyOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Character.h\"\n\n// Sets default values\nAMyOverlapActor::AMyOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMesh\"));\n\tRootComponent = StaticMesh;\n\n\tStaticMesh->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tStaticMesh->OnComponentBeginOverlap.AddDynamic(this, &AMyOverlapActor::OnBeginOverlap);\n\n\tForceMagnitude = 1000.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMyOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyOverlapActor::OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && OtherActor != this && OtherComp)\n\t{\n\t\tUPrimitiveComponent* OtherPrimitive = Cast<UPrimitiveComponent>(OtherComp);\n\t\tif (OtherPrimitive && OtherPrimitive->IsSimulatingPhysics())\n\t\t{\n\t\t\tFVector ForceDirection = OtherActor->GetActorLocation() - GetActorLocation();\n\t\t\tForceDirection.Normalize();\n\t\t\tOtherPrimitive->AddForce(ForceDirection * ForceMagnitude, NAME_None, true);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector representing a direction, and normalize it each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UNormalizingDirectionComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UNormalizingDirectionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUNormalizingDirectionComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Direction\")\n\tFVector Direction;\n};\n```", "cpp_code": "```cpp\n#include \"UNormalizingDirectionComponent.h\"\n\nUNormalizingDirectionComponent::UNormalizingDirectionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tDirection = FVector(1.0f, 0.0f, 0.0f); // Default direction\n}\n\nvoid UNormalizingDirectionComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UNormalizingDirectionComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (!Direction.IsZero())\n\t{\n\t\tDirection.Normalize();\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to change its pitch gradually as time progresses.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PitchChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APitchChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAPitchChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Pitch\")\n\tfloat PitchChangeRate;\n};\n```", "cpp_code": "```cpp\n#include \"PitchChangeActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAPitchChangeActor::APitchChangeActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPitchChangeRate = 10.0f; // Default pitch change rate per second\n}\n\n// Called when the game starts or when spawned\nvoid APitchChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid APitchChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Pitch += PitchChangeRate * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an Actor with a mesh and a BlueprintCallable function to toggle its visibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleVisibilityActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visibility\")\n\tvoid ToggleVisibility();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\t// Initialize the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set a default static mesh (assuming a mesh exists at this path)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tif (MeshComponent)\n\t{\n\t\tbool bIsVisible = MeshComponent->IsVisible();\n\t\tMeshComponent->SetVisibility(!bIsVisible);\n\t}\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to fire when a UPROPERTY float is halved.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFloatHalvedComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnFloatHalved);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatHalvedComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUFloatHalvedComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Float\")\n\tfloat TargetFloat;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Event\")\n\tFOnFloatHalved OnFloatHalved;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Float\")\n\tvoid HalveFloat();\n};\n```", "cpp_code": "```cpp\n#include \"UFloatHalvedComponent.h\"\n\nUFloatHalvedComponent::UFloatHalvedComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UFloatHalvedComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFloatHalvedComponent::HalveFloat()\n{\n\tTargetFloat /= 2.0f;\n\tOnFloatHalved.Broadcast();\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float representing a rotation rate, applied each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationRate = 45.0f; // Example default value\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationRate * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind a key to reset an Actor's velocity to zero.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"ResetVelocityActor.generated.h\"\n\nUCLASS()\nclass AResetVelocityActor : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResetVelocityActor();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid ResetVelocity();\n};\n```", "cpp_code": "```cpp\n#include \"ResetVelocityActor.h\"\n#include \"GameFramework/InputSettings.h\"\n#include \"Components/InputComponent.h\"\n\nAResetVelocityActor::AResetVelocityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetVelocityActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetVelocity\", IE_Pressed, this, &AResetVelocityActor::ResetVelocity);\n}\n\nvoid AResetVelocityActor::ResetVelocity()\n{\n\tif (UCharacterMovementComponent* MovementComponent = GetCharacterMovement())\n\t{\n\t\tMovementComponent->Velocity = FVector::ZeroVector;\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY FVector and a function to log its current position.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyPositionLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyPositionLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyPositionLoggerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to log the current position\n\tUFUNCTION()\n\tvoid LogCurrentPosition();\n\n\t// FVector to hold the position\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Position\")\n\tFVector CurrentPosition;\n};\n```", "cpp_code": "```cpp\n#include \"MyPositionLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAMyPositionLoggerActor::AMyPositionLoggerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyPositionLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Initialize CurrentPosition with the Actor's initial position\n\tCurrentPosition = GetActorLocation();\n}\n\n// Called every frame\nvoid AMyPositionLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update CurrentPosition each frame\n\tCurrentPosition = GetActorLocation();\n}\n\n// Function to log the current position\nvoid AMyPositionLoggerActor::LogCurrentPosition()\n{\n\t// Log the current position to the output log\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Current Position: %s\"), *CurrentPosition.ToString()));\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in a Component to transition its owning Actor's material over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UTransitionMaterialComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTransitionMaterialComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUTransitionMaterialComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\tfloat TransitionProgress;\n\n\tUPROPERTY(EditAnywhere, Category=\"Transition\")\n\tfloat TransitionDuration;\n};\n```", "cpp_code": "```cpp\n#include \"UTransitionMaterialComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nUTransitionMaterialComponent::UTransitionMaterialComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTransitionProgress = 0.0f;\n\tTransitionDuration = 5.0f; // default transition duration\n}\n\nvoid UTransitionMaterialComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUStaticMeshComponent* MeshComponent = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tUMaterialInterface* Material = MeshComponent->GetMaterial(0);\n\t\t\tDynamicMaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamicFromMaterial(0, Material);\n\t\t}\n\t}\n}\n\nvoid UTransitionMaterialComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (DynamicMaterialInstance && TransitionProgress < 1.0f)\n\t{\n\t\tTransitionProgress += DeltaTime / TransitionDuration;\n\t\tDynamicMaterialInstance->SetScalarParameterValue(TEXT(\"BlendFactor\"), FMath::Clamp(TransitionProgress, 0.0f, 1.0f));\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh component and a function to print a message when it begins play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAMyStaticMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Optionally set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUE_LOG(LogTemp, Warning, TEXT(\"AMyStaticMeshActor has begun play.\"));\n}\n```"}
{"requirement": "Set up an input binding in an Actor to call a function that toggles between two UPROPERTY states.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Toggle\")\n\tbool bIsToggled;\n\n\tvoid ToggleState();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAToggleActor::AToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tbIsToggled = false;\n}\n\nvoid AToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"ToggleInput\", IE_Pressed, this, &AToggleActor::ToggleState);\n\t}\n}\n\nvoid AToggleActor::ToggleState()\n{\n\tbIsToggled = !bIsToggled;\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY integer representing a tick counter that resets every 100 ticks.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TickCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTickCounterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUTickCounterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Tick\")\n\tint32 TickCounter;\n};\n```", "cpp_code": "```cpp\n#include \"TickCounterComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUTickCounterComponent::UTickCounterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTickCounter = 0;\n}\n\nvoid UTickCounterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UTickCounterComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTickCounter++;\n\tif (TickCounter >= 100)\n\t{\n\t\tTickCounter = 0;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to always face towards the player character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FacePlayerActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AFacePlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAFacePlayerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAActor* PlayerCharacter;\n};\n```", "cpp_code": "```cpp\n#include \"FacePlayerActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Actor.h\"\n\nAFacePlayerActor::AFacePlayerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AFacePlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);\n}\n\nvoid AFacePlayerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerCharacter)\n\t{\n\t\tFVector Direction = PlayerCharacter->GetActorLocation() - GetActorLocation();\n\t\tDirection.Z = 0; // Ignore Z-axis to only rotate on the X-Y plane\n\t\tFRotator NewRotation = Direction.Rotation();\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a mesh and set it as the root component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyMeshActor.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAMyMeshActor::AMyMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\n\t// Set the mesh component as the root component\n\tRootComponent = MeshComponent;\n\n\t// Find and load the mesh asset\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/MeshAsset.MeshAsset\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that calculates and logs its speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Speed\")\n\tvoid CalculateAndLogSpeed();\n\nprivate:\n\tFVector PreviousLocation;\n\tfloat Speed;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nASpeedActor::ASpeedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSpeed = 0.0f;\n}\n\nvoid ASpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPreviousLocation = GetActorLocation();\n}\n\nvoid ASpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tCalculateAndLogSpeed();\n}\n\nvoid ASpeedActor::CalculateAndLogSpeed()\n{\n\tFVector CurrentLocation = GetActorLocation();\n\tfloat Distance = FVector::Dist(CurrentLocation, PreviousLocation);\n\tSpeed = Distance / GetWorld()->GetDeltaSeconds();\n\tUE_LOG(LogTemp, Log, TEXT(\"Speed: %f units/s\"), Speed);\n\tPreviousLocation = CurrentLocation;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to create a breathing effect by adjusting its scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BreathingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ABreathingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tABreathingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Breathing\")\n\tfloat BreathingSpeed;\n\n\tUPROPERTY(EditAnywhere, Category=\"Breathing\")\n\tfloat BreathingScaleAmplitude;\n\n\tFVector OriginalScale;\n};\n```", "cpp_code": "```cpp\n#include \"BreathingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nABreathingActor::ABreathingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tBreathingSpeed = 1.0f;\n\tBreathingScaleAmplitude = 0.1f;\n}\n\n// Called when the game starts or when spawned\nvoid ABreathingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tOriginalScale = GetActorScale3D();\n}\n\n// Called every frame\nvoid ABreathingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat ScaleOffset = FMath::Sin(GetWorld()->GetTimeSeconds() * BreathingSpeed) * BreathingScaleAmplitude;\n\tSetActorScale3D(OriginalScale + FVector(ScaleOffset, ScaleOffset, ScaleOffset));\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that fires when the owning Actor's Z position changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UPositionChangeComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnZPositionChanged);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UPositionChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUPositionChangeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Position\")\n\tFOnZPositionChanged OnZPositionChanged;\n\nprivate:\n\tfloat LastZPosition;\n};\n```", "cpp_code": "```cpp\n#include \"UPositionChangeComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUPositionChangeComponent::UPositionChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UPositionChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tLastZPosition = Owner->GetActorLocation().Z;\n\t}\n}\n\nvoid UPositionChangeComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tfloat CurrentZPosition = Owner->GetActorLocation().Z;\n\t\tif (!FMath::IsNearlyEqual(CurrentZPosition, LastZPosition))\n\t\t{\n\t\t\tOnZPositionChanged.Broadcast();\n\t\t\tLastZPosition = CurrentZPosition;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to print a message whenever the 'X' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintMessageActor.generated.h\"\n\nUCLASS()\nclass APrintMessageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPrintMessageActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid PrintMessage();\n};\n```", "cpp_code": "```cpp\n#include \"PrintMessageActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAPrintMessageActor::APrintMessageActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APrintMessageActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APrintMessageActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"PrintMessage\", IE_Pressed, this, &APrintMessageActor::PrintMessage);\n\t}\n}\n\nvoid APrintMessageActor::PrintMessage()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"The 'X' key was pressed!\"));\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY array of integers and a function to reverse its order.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReversingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AReversingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAReversingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Array\")\n\tvoid ReverseArray();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Array\")\n\tTArray<int32> IntArray;\n};\n```", "cpp_code": "```cpp\n#include \"ReversingActor.h\"\n\nAReversingActor::AReversingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AReversingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AReversingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AReversingActor::ReverseArray()\n{\n\tIntArray.Reverse();\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor to log both Actors' world positions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tAOverlapLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION()\n\tvoid OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLoggerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"ConstructorHelpers.h\"\n\nAOverlapLoggerActor::AOverlapLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetGenerateOverlapEvents(true);\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapLoggerActor::OnOverlapBegin);\n}\n\nvoid AOverlapLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapLoggerActor::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OverlappedActor && OtherActor && OverlappedActor != OtherActor)\n\t{\n\t\tFVector OverlappedActorLocation = OverlappedActor->GetActorLocation();\n\t\tFVector OtherActorLocation = OtherActor->GetActorLocation();\n\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Overlapped Actor Location: %s\"), *OverlappedActorLocation.ToString());\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Other Actor Location: %s\"), *OtherActorLocation.ToString());\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector that applies as a force to the owning Actor each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UForceApplierComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UForceApplierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUForceApplierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Force\")\n\tFVector AppliedForce;\n};\n```", "cpp_code": "```cpp\n#include \"UForceApplierComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUForceApplierComponent::UForceApplierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tAppliedForce = FVector::ZeroVector;\n}\n\nvoid UForceApplierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UForceApplierComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->AddForce(AppliedForce);\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to adjust its yaw based on the distance to the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YawAdjusterActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AYawAdjusterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAYawAdjusterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"YawAdjustment\")\n\tfloat YawSpeed;\n\n\tUPROPERTY(EditAnywhere, Category = \"YawAdjustment\")\n\tfloat MaxDistance;\n\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"YawAdjusterActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAYawAdjusterActor::AYawAdjusterActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tYawSpeed = 10.0f;\n\tMaxDistance = 1000.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AYawAdjusterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Find the player actor\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\n// Called every frame\nvoid AYawAdjusterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerActor)\n\t{\n\t\t// Calculate the distance to the player\n\t\tfloat DistanceToPlayer = FVector::Dist(PlayerActor->GetActorLocation(), GetActorLocation());\n\n\t\tif (DistanceToPlayer <= MaxDistance)\n\t\t{\n\t\t\t// Calculate the yaw adjustment based on the distance\n\t\t\tfloat YawAdjustment = YawSpeed * (1.0f - (DistanceToPlayer / MaxDistance)) * DeltaTime;\n\n\t\t\t// Apply the yaw adjustment to the actor\n\t\t\tFRotator NewRotation = GetActorRotation();\n\t\t\tNewRotation.Yaw += YawAdjustment;\n\t\t\tSetActorRotation(NewRotation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh using ConstructorHelpers and apply a dynamic material instance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADynamicMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADynamicMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nADynamicMeshActor::ADynamicMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/StarterContent/Materials/M_Basic_Wall.M_Basic_Wall\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MaterialAsset.Object, MeshComponent);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\nvoid ADynamicMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADynamicMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to fire when a float UPROPERTY is reset.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFloatResetComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FFloatResetDelegate, float, NewValue);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatResetComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFloatResetComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"FloatReset\")\n\tvoid ResetFloat();\n\n\tUPROPERTY(BlueprintAssignable, Category=\"FloatReset\")\n\tFFloatResetDelegate OnFloatReset;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"FloatReset\")\n\tfloat FloatValue;\n};\n```", "cpp_code": "```cpp\n#include \"UFloatResetComponent.h\"\n\nUFloatResetComponent::UFloatResetComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tFloatValue = 0.0f;\n}\n\nvoid UFloatResetComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFloatResetComponent::ResetFloat()\n{\n\tFloatValue = 0.0f;\n\tOnFloatReset.Broadcast(FloatValue);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float speed and a method to cap its value within a range.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedCapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedCapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedCapActor();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat Speed;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid CapSpeed(float MinSpeed, float MaxSpeed);\n};\n```", "cpp_code": "```cpp\n#include \"SpeedCapActor.h\"\n\nASpeedCapActor::ASpeedCapActor()\n{\n\t// Set default speed value\n\tSpeed = 0.0f;\n}\n\nvoid ASpeedCapActor::CapSpeed(float MinSpeed, float MaxSpeed)\n{\n\tif (Speed < MinSpeed)\n\t{\n\t\tSpeed = MinSpeed;\n\t}\n\telse if (Speed > MaxSpeed)\n\t{\n\t\tSpeed = MaxSpeed;\n\t}\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind a key to change an Actor's material at runtime.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAChangeMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n\n\tvoid ChangeMaterial();\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAChangeMaterialActor::AChangeMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AChangeMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMaterialActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AChangeMaterialActor::ChangeMaterial);\n}\n\nvoid AChangeMaterialActor::ChangeMaterial()\n{\n\tif (MeshComponent && NewMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY integer score and a function to increase it by a specific value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAScoreActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid IncreaseScore(int32 Value);\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Score\")\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreActor.h\"\n\n// Sets default values\nAScoreActor::AScoreActor()\n{\n\t// Initialize score to 0\n\tScore = 0;\n}\n\nvoid AScoreActor::IncreaseScore(int32 Value)\n{\n\tScore += Value;\n}\n```"}
{"requirement": "Implement a Tick function in a Component to animate the owning Actor's position along the X-axis.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UAnimatePositionComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UAnimatePositionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUAnimatePositionComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tfloat Speed = 100.0f; // Speed of movement along the X-axis\n};\n```", "cpp_code": "```cpp\n#include \"UAnimatePositionComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUAnimatePositionComponent::UAnimatePositionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UAnimatePositionComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UAnimatePositionComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector NewLocation = Owner->GetActorLocation();\n\t\tNewLocation.X += Speed * DeltaTime;\n\t\tOwner->SetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh and an OnBeginOverlap event to apply a new material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialOverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMesh;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"ConstructorHelpers.h\"\n\nAMaterialOverlapActor::AMaterialOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMesh\"));\n\tRootComponent = StaticMesh;\n\n\tStaticMesh->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tStaticMesh->OnComponentBeginOverlap.AddDynamic(this, &AMaterialOverlapActor::OnOverlapBegin);\n\n\t// Set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMesh->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AMaterialOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMaterialOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMaterialOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (NewMaterial && OtherActor != this)\n\t{\n\t\tStaticMesh->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to reset a float UPROPERTY value to its default on 'K' press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetFloatActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetFloatActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAResetFloatActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (AllowPrivateAccess = \"true\"))\n\tfloat ResettableFloat;\n\n\tUPROPERTY(EditDefaultsOnly, Category = \"Defaults\")\n\tfloat DefaultFloatValue;\n\n\tvoid ResetFloatToDefault();\n};\n```", "cpp_code": "```cpp\n#include \"ResetFloatActor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAResetFloatActor::AResetFloatActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default values\n\tDefaultFloatValue = 100.0f; // Example default value\n\tResettableFloat = DefaultFloatValue;\n}\n\n// Called when the game starts or when spawned\nvoid AResetFloatActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AResetFloatActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetFloatActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetFloat\", IE_Pressed, this, &AResetFloatActor::ResetFloatToDefault);\n}\n\nvoid AResetFloatActor::ResetFloatToDefault()\n{\n\tResettableFloat = DefaultFloatValue;\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FString to store a custom message, updated each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UCustomMessageComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomMessageComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUCustomMessageComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Custom\", meta = (AllowPrivateAccess = \"true\"))\n\tFString CustomMessage;\n};\n```", "cpp_code": "```cpp\n#include \"UCustomMessageComponent.h\"\n\nUCustomMessageComponent::UCustomMessageComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCustomMessage = TEXT(\"Initial Message\");\n}\n\nvoid UCustomMessageComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Initialization or other BeginPlay logic\n}\n\nvoid UCustomMessageComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\t\n\t// Update CustomMessage each tick\n\tCustomMessage = FString::Printf(TEXT(\"Updated Message at Time: %f\"), GetWorld()->GetTimeSeconds());\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to apply a gradual rotation based on game time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Set default rotation rate\n\tRotationRate = FRotator(0.f, 20.f, 0.f);\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Gradually rotate the actor\n\tFRotator NewRotation = GetActorRotation() + (RotationRate * DeltaTime);\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a sound asset and play it upon receiving input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundActor.generated.h\"\n\nUCLASS()\nclass ASoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY()\n\tUSoundBase* SoundToPlay;\n\n\tvoid PlaySound();\n};\n```", "cpp_code": "```cpp\n#include \"SoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nASoundActor::ASoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tstatic ConstructorHelpers::FObjectFinder<USoundBase> SoundAsset(TEXT(\"/Game/Audio/MySound.MySound\"));\n\tif (SoundAsset.Succeeded())\n\t{\n\t\tSoundToPlay = SoundAsset.Object;\n\t}\n}\n\nvoid ASoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"PlaySound\", IE_Pressed, this, &ASoundActor::PlaySound);\n\t}\n}\n\nvoid ASoundActor::PlaySound()\n{\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that returns the distance to another Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADistanceActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Utilities\")\n\tfloat GetDistanceToActor(AActor* OtherActor) const;\n};\n```", "cpp_code": "```cpp\n#include \"DistanceActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nADistanceActor::ADistanceActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nfloat ADistanceActor::GetDistanceToActor(AActor* OtherActor) const\n{\n\tif (!OtherActor)\n\t{\n\t\treturn 0.0f;\n\t}\n\n\treturn FVector::Dist(this->GetActorLocation(), OtherActor->GetActorLocation());\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to pulse its material's emissive color over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EmissivePulseActor.generated.h\"\n\nUCLASS()\nclass AEmissivePulseActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAEmissivePulseActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tUPROPERTY(EditAnywhere, Category = \"Pulse\")\n\tfloat PulseSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"EmissivePulseActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAEmissivePulseActor::AEmissivePulseActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tPulseSpeed = 2.0f;\n}\n\nvoid AEmissivePulseActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MeshComponent)\n\t{\n\t\tDynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t}\n}\n\nvoid AEmissivePulseActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterial)\n\t{\n\t\tfloat EmissiveStrength = (FMath::Sin(GetWorld()->TimeSeconds * PulseSpeed) + 1.0f) * 0.5f;\n\t\tDynamicMaterial->SetScalarParameterValue(\"EmissiveStrength\", EmissiveStrength);\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that broadcasts when the owning Actor's visibility toggles.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"AToggleVisibilityComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnVisibilityToggled, bool, bIsVisible);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UAToggleVisibilityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUAToggleVisibilityComponent();\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Toggle\")\n\tFOnVisibilityToggled OnVisibilityToggled;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tvoid HandleVisibilityChange();\n\tbool bLastVisibilityState;\n};\n```", "cpp_code": "```cpp\n#include \"AToggleVisibilityComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUAToggleVisibilityComponent::UAToggleVisibilityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UAToggleVisibilityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tbLastVisibilityState = Owner->IsVisible();\n\t\tOwner->OnActorBeginCursorOver.AddDynamic(this, &UAToggleVisibilityComponent::HandleVisibilityChange);\n\t\tOwner->OnActorEndCursorOver.AddDynamic(this, &UAToggleVisibilityComponent::HandleVisibilityChange);\n\t}\n}\n\nvoid UAToggleVisibilityComponent::HandleVisibilityChange()\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tbool bCurrentVisibilityState = Owner->IsVisible();\n\t\tif (bCurrentVisibilityState != bLastVisibilityState)\n\t\t{\n\t\t\tbLastVisibilityState = bCurrentVisibilityState;\n\t\t\tOnVisibilityToggled.Broadcast(bCurrentVisibilityState);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to print a message when a specific mouse button is clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseClickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMouseClickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMouseClickActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid OnMouseClick();\n};\n```", "cpp_code": "```cpp\n#include \"MouseClickActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAMouseClickActor::AMouseClickActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMouseClickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMouseClickActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMouseClickActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"LeftMouseClick\", IE_Pressed, this, &AMouseClickActor::OnMouseClick);\n\t}\n}\n\nvoid AMouseClickActor::OnMouseClick()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Mouse button clicked!\"));\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY array of floats and a function to calculate their sum.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyFloatArrayActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyFloatArrayActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMyFloatArrayActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Array of floats\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Float Array\")\n\tTArray<float> FloatArray;\n\n\t// Function to calculate sum of floats\n\tUFUNCTION(BlueprintCallable, Category = \"Float Array\")\n\tfloat CalculateSum() const;\n};\n```", "cpp_code": "```cpp\n#include \"MyFloatArrayActor.h\"\n\n// Sets default values\nAMyFloatArrayActor::AMyFloatArrayActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyFloatArrayActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Function to calculate sum of floats\nfloat AMyFloatArrayActor::CalculateSum() const\n{\n\tfloat Sum = 0.0f;\n\tfor (float Value : FloatArray)\n\t{\n\t\tSum += Value;\n\t}\n\treturn Sum;\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor to reverse its movement direction upon collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReverseMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AReverseMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAReverseMovementActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tFVector MovementDirection;\n\n\tUFUNCTION()\n\tvoid OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor);\n};\n```", "cpp_code": "```cpp\n#include \"ReverseMovementActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAReverseMovementActor::AReverseMovementActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMovementDirection = FVector(1.0f, 0.0f, 0.0f);\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AReverseMovementActor::OnBeginOverlap);\n}\n\n// Called when the game starts or when spawned\nvoid AReverseMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AReverseMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation() + (MovementDirection * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n\nvoid AReverseMovementActor::OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tMovementDirection *= -1.0f;\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector representing a velocity, updated based on user input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UVelocityComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UVelocityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUVelocityComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector Velocity;\n\n\tvoid UpdateVelocity(float DeltaTime);\n\nprivate:\n\tvoid MoveForward(float Value);\n\tvoid MoveRight(float Value);\n\n\tFVector InputDirection;\n};\n```", "cpp_code": "```cpp\n#include \"UVelocityComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\nUVelocityComponent::UVelocityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UVelocityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->InputComponent = NewObject<UInputComponent>(Owner);\n\t\tOwner->InputComponent->RegisterComponent();\n\t\tSetupPlayerInputComponent(Owner->InputComponent);\n\t}\n}\n\nvoid UVelocityComponent::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &UVelocityComponent::MoveForward);\n\t\tPlayerInputComponent->BindAxis(\"MoveRight\", this, &UVelocityComponent::MoveRight);\n\t}\n}\n\nvoid UVelocityComponent::MoveForward(float Value)\n{\n\tInputDirection.X = Value;\n}\n\nvoid UVelocityComponent::MoveRight(float Value)\n{\n\tInputDirection.Y = Value;\n}\n\nvoid UVelocityComponent::UpdateVelocity(float DeltaTime)\n{\n\tVelocity = InputDirection * 100.0f;  // Scale the input for velocity\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to adjust its pitch based on its distance from an object.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceBasedPitchActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceBasedPitchActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADistanceBasedPitchActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tAActor* TargetActor;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid AdjustPitchBasedOnDistance();\n};\n```", "cpp_code": "```cpp\n#include \"DistanceBasedPitchActor.h\"\n#include \"Engine/World.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nADistanceBasedPitchActor::ADistanceBasedPitchActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\nvoid ADistanceBasedPitchActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADistanceBasedPitchActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tAdjustPitchBasedOnDistance();\n}\n\nvoid ADistanceBasedPitchActor::AdjustPitchBasedOnDistance()\n{\n\tif (TargetActor)\n\t{\n\t\tfloat Distance = FVector::Dist(GetActorLocation(), TargetActor->GetActorLocation());\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Pitch = FMath::Clamp(Distance, 0.0f, 90.0f); // Example: Clamping pitch based on distance\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh and a BlueprintCallable function to switch between two materials.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialSwitchActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialSwitchActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialSwitchActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Material\")\n\tvoid SwitchMaterial();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Material\")\n\tUMaterialInterface* Material1;\n\n\tUPROPERTY(EditAnywhere, Category = \"Material\")\n\tUMaterialInterface* Material2;\n\n\tbool bUseFirstMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialSwitchActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nAMaterialSwitchActor::AMaterialSwitchActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tbUseFirstMaterial = true;\n}\n\nvoid AMaterialSwitchActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Material1 != nullptr)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n}\n\nvoid AMaterialSwitchActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMaterialSwitchActor::SwitchMaterial()\n{\n\tif (bUseFirstMaterial && Material2 != nullptr)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material2);\n\t}\n\telse if (!bUseFirstMaterial && Material1 != nullptr)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n\n\tbUseFirstMaterial = !bUseFirstMaterial;\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to fire when a UPROPERTY health value decreases.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UHealthComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnHealthChanged);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UHealthComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUHealthComponent();\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Health\")\n\tFOnHealthChanged OnHealthChanged;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat Health;\n\n\tUFUNCTION()\n\tvoid DecreaseHealth(float Amount);\n};\n```", "cpp_code": "```cpp\n#include \"UHealthComponent.h\"\n\nUHealthComponent::UHealthComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tHealth = 100.0f;\n}\n\nvoid UHealthComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UHealthComponent::DecreaseHealth(float Amount)\n{\n\tfloat OldHealth = Health;\n\tHealth = FMath::Clamp(Health - Amount, 0.0f, 100.0f);\n\tif (Health < OldHealth)\n\t{\n\t\tOnHealthChanged.Broadcast();\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float for jump strength and a method to apply it on input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"JumpActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AJumpActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAJumpActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUFUNCTION()\n\tvoid ApplyJump();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Jump\")\n\tfloat JumpStrength;\n};\n```", "cpp_code": "```cpp\n#include \"JumpActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAJumpActor::AJumpActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tJumpStrength = 600.0f; // Default jump strength value\n}\n\nvoid AJumpActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AJumpActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AJumpActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, &AJumpActor::ApplyJump);\n}\n\nvoid AJumpActor::ApplyJump()\n{\n\tif (ACharacter* Character = Cast<ACharacter>(GetOwner()))\n\t{\n\t\tCharacter->LaunchCharacter(FVector(0, 0, JumpStrength), false, false);\n\t}\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind an axis input to control an Actor's yaw rotation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"AYawControlPawn.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AYawControlPawn : public APawn\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this pawn's properties\n\tAYawControlPawn();\n\nprotected:\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to handle the yaw input\n\tvoid Turn(float Value);\n\n\t// Mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"AYawControlPawn.h\"\n#include \"Components/InputComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAYawControlPawn::AYawControlPawn()\n{\n\t// Set this pawn to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Optionally set a default mesh (Replace with your path)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called to bind functionality to input\nvoid AYawControlPawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tsuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the Turn function to the \"Turn\" axis\n\tPlayerInputComponent->BindAxis(\"Turn\", this, &AYawControlPawn::Turn);\n}\n\n// Function to handle the yaw input\nvoid AYawControlPawn::Turn(float Value)\n{\n\tif (FMath::Abs(Value) > KINDA_SMALL_NUMBER)\n\t{\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Yaw += Value;\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY integer for health and a function to reduce it over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAHealthActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tint32 Health;\n\n\tvoid ReduceHealth(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n\nAHealthActor::AHealthActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHealth = 100;\n}\n\nvoid AHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tReduceHealth(DeltaTime);\n}\n\nvoid AHealthActor::ReduceHealth(float DeltaTime)\n{\n\tHealth -= FMath::FloorToInt(DeltaTime * 10); // Reduces health over time\n\tif (Health < 0)\n\t{\n\t\tHealth = 0;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in a Component to simulate a lighting effect on the owning Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULightingEffectComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULightingEffectComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this component's properties\n\tULightingEffectComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tfloat LightIntensity;\n\tfloat LightChangeRate;\n};\n```", "cpp_code": "```cpp\n#include \"ULightingEffectComponent.h\"\n\n// Sets default values for this component's properties\nULightingEffectComponent::ULightingEffectComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tLightIntensity = 0.0f;\n\tLightChangeRate = 100.0f;\n}\n\n// Called when the game starts\nvoid ULightingEffectComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ULightingEffectComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Simulate a pulsing light effect\n\tLightIntensity += LightChangeRate * DeltaTime;\n\tif (LightIntensity > 300.0f || LightIntensity < 0.0f)\n\t{\n\t\tLightChangeRate = -LightChangeRate;\n\t}\n\n\t// Assuming the Owner has a PointLightComponent\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tTArray<UActorComponent*> Components = Owner->GetComponentsByClass(UPointLightComponent::StaticClass());\n\t\tfor (UActorComponent* Component : Components)\n\t\t{\n\t\t\tUPointLightComponent* LightComponent = Cast<UPointLightComponent>(Component);\n\t\t\tif (LightComponent)\n\t\t\t{\n\t\t\t\tLightComponent->SetIntensity(LightIntensity);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh and use OnBeginOverlap to log a message about the collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyOverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"MyOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyOverlapActor::AMyOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Find and set a static mesh for the component\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyOverlapActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid AMyOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Overlap Begin Event Triggered\"));\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to increase a UPROPERTY integer score whenever the 'Z' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreIncrementer.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreIncrementer : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScoreIncrementer();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Score\")\n\tint32 Score;\n\n\tvoid IncreaseScore();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreIncrementer.h\"\n#include \"Components/InputComponent.h\"\n\nAScoreIncrementer::AScoreIncrementer()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScore = 0;\n}\n\nvoid AScoreIncrementer::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScoreIncrementer::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScoreIncrementer::IncreaseScore()\n{\n\tScore++;\n}\n\nvoid AScoreIncrementer::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"IncreaseScore\", IE_Pressed, this, &AScoreIncrementer::IncreaseScore);\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FString to store a debug message, printed each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UPrintDebugMessageComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UPrintDebugMessageComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPrintDebugMessageComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Debug\")\n\tFString DebugMessage;\n};\n```", "cpp_code": "```cpp\n#include \"UPrintDebugMessageComponent.h\"\n\nUPrintDebugMessageComponent::UPrintDebugMessageComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tDebugMessage = TEXT(\"Default Debug Message\");\n}\n\nvoid UPrintDebugMessageComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UPrintDebugMessageComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tUE_LOG(LogTemp, Warning, TEXT(\"%s\"), *DebugMessage);\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to rotate its mesh around a fixed point in space.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARotatingMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFVector RotationPoint;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nARotatingMeshActor::ARotatingMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/YourMeshPath.YourMeshName\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRotationPoint = FVector::ZeroVector;\n\tRotationSpeed = 30.0f; // degrees per second\n}\n\nvoid ARotatingMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (MeshComponent)\n\t{\n\t\tFRotator CurrentRotation = GetActorRotation();\n\t\tCurrentRotation.Yaw += RotationSpeed * DeltaTime;\n\t\tFQuat QuatRotation = FQuat(CurrentRotation);\n\n\t\tFVector Direction = GetActorLocation() - RotationPoint;\n\t\tDirection = QuatRotation.RotateVector(Direction);\n\n\t\tSetActorLocation(RotationPoint + Direction);\n\t\tSetActorRotation(QuatRotation);\n\t}\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a material and apply it to a dynamic material instance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialDynamicActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialDynamicActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialDynamicActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* BaseMaterial;\n\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialDynamicActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nAMaterialDynamicActor::AMaterialDynamicActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialFinder(TEXT(\"/Game/Path/To/Your/Material.YourMaterial\"));\n\tif (MaterialFinder.Succeeded())\n\t{\n\t\tBaseMaterial = MaterialFinder.Object;\n\t}\n}\n\nvoid AMaterialDynamicActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (BaseMaterial)\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(BaseMaterial, this);\n\t\tif (DynamicMaterialInstance)\n\t\t{\n\t\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that returns its current forward direction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DirectionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADirectionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADirectionActor();\n\n\t// BlueprintCallable function to get the forward direction\n\tUFUNCTION(BlueprintCallable, Category=\"Direction\")\n\tFVector GetForwardDirection() const;\n};\n```", "cpp_code": "```cpp\n#include \"DirectionActor.h\"\n\n// Sets default values\nADirectionActor::ADirectionActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nFVector ADirectionActor::GetForwardDirection() const\n{\n\treturn GetActorForwardVector();\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to adjust its material color based on the game world time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADynamicMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADynamicMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY()\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tvoid UpdateMaterialColor(float GameTime);\n};\n```", "cpp_code": "```cpp\n#include \"DynamicMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nADynamicMaterialActor::ADynamicMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ADynamicMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MeshComponent->GetMaterial(0))\n\t{\n\t\tDynamicMaterial = UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterial);\n\t}\n}\n\nvoid ADynamicMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat GameTime = GetWorld()->GetTimeSeconds();\n\tUpdateMaterialColor(GameTime);\n}\n\nvoid ADynamicMaterialActor::UpdateMaterialColor(float GameTime)\n{\n\tif (DynamicMaterial)\n\t{\n\t\tfloat RedValue = FMath::Abs(FMath::Sin(GameTime));\n\t\tFLinearColor NewColor(RedValue, 0.0f, 0.0f, 1.0f);\n\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", NewColor);\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate to notify when the owning Actor's scale changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleChangeNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnScaleChanged);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UScaleChangeNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUScaleChangeNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintAssignable)\n\tFOnScaleChanged OnScaleChanged;\n\nprivate:\n\tFVector LastScale;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangeNotifierComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUScaleChangeNotifierComponent::UScaleChangeNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UScaleChangeNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tLastScale = Owner->GetActorScale3D();\n\t}\n}\n\nvoid UScaleChangeNotifierComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector CurrentScale = Owner->GetActorScale3D();\n\t\tif (!CurrentScale.Equals(LastScale))\n\t\t{\n\t\t\tOnScaleChanged.Broadcast();\n\t\t\tLastScale = CurrentScale;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to trigger a function that toggles the visibility of its mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AToggleMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid ToggleMeshVisibility();\n};\n```", "cpp_code": "```cpp\n#include \"AToggleMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"Components/InputComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAToggleMeshActor::AToggleMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AToggleMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleMeshActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleMeshActor::ToggleMeshVisibility);\n}\n\nvoid AToggleMeshActor::ToggleMeshVisibility()\n{\n\tif (MeshComponent)\n\t{\n\t\tMeshComponent->SetVisibility(!MeshComponent->IsVisible());\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY for a string message and a function to print it when called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MessageActor.generated.h\"\n\nUCLASS()\nclass AMessageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMessageActor();\n\n\tUFUNCTION()\n\tvoid PrintMessage() const;\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Message\")\n\tFString Message;\n};\n```", "cpp_code": "```cpp\n#include \"MessageActor.h\"\n#include \"Engine/Engine.h\"\n\nAMessageActor::AMessageActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tMessage = \"Default Message\";\n}\n\nvoid AMessageActor::PrintMessage() const\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, Message);\n\t}\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor to change its velocity upon collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector NewVelocity;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACollisionActor::ACollisionActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionActor::OnBeginOverlap);\n\n\t// Assuming a default mesh is set in the editor or here using ConstructorHelpers\n\t// static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Mesh.MeshName\"));\n\t// if (MeshAsset.Succeeded())\n\t// {\n\t//\t MeshComponent->SetStaticMesh(MeshAsset.Object);\n\t// }\n\n\tNewVelocity = FVector(100.f, 0.f, 0.f); // Example velocity change\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionActor::OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tMeshComponent->SetPhysicsLinearVelocity(NewVelocity);\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector representing a target direction, interpolated each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UInterpolatingDirectionComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UInterpolatingDirectionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:  \n\tUInterpolatingDirectionComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:   \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n\tFVector TargetDirection;\n\nprivate:\n\tFVector CurrentDirection;\n\tfloat InterpolationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"UInterpolatingDirectionComponent.h\"\n\nUInterpolatingDirectionComponent::UInterpolatingDirectionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCurrentDirection = FVector::ZeroVector;\n\tInterpolationSpeed = 5.0f; // Default interpolation speed\n}\n\nvoid UInterpolatingDirectionComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UInterpolatingDirectionComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Interpolate the current direction towards the target direction\n\tCurrentDirection = FMath::VInterpTo(CurrentDirection, TargetDirection, DeltaTime, InterpolationSpeed);\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to adjust its roll based on its speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RollingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARollingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARollingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The speed of the actor\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat Speed;\n\n\t// Adjust roll based on speed\n\tvoid AdjustRoll(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"RollingActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nARollingActor::ARollingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize speed\n\tSpeed = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ARollingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARollingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tAdjustRoll(DeltaTime);\n}\n\nvoid ARollingActor::AdjustRoll(float DeltaTime)\n{\n\t// Calculate the new roll based on speed\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Roll += Speed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an Actor with a mesh and a BlueprintCallable function to toggle its physics on and off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TogglePhysicsActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATogglePhysicsActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATogglePhysicsActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Physics\")\n\tvoid TogglePhysics();\n};\n```", "cpp_code": "```cpp\n#include \"TogglePhysicsActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nATogglePhysicsActor::ATogglePhysicsActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetSimulatePhysics(false);\n}\n\nvoid ATogglePhysicsActor::TogglePhysics()\n{\n\tbool bIsSimulatingPhysics = MeshComponent->IsSimulatingPhysics();\n\tMeshComponent->SetSimulatePhysics(!bIsSimulatingPhysics);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to fire when a UPROPERTY float changes its value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFloatChangeNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FFloatValueChangedSignature, float, NewValue);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatChangeNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUFloatChangeNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(BlueprintAssignable, Category=\"Events\")\n\tFFloatValueChangedSignature OnFloatValueChanged;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Float\")\n\tvoid SetFloatValue(float NewValue);\n\nprivate:\n\tUPROPERTY()\n\tfloat FloatValue;\n};\n```", "cpp_code": "```cpp\n#include \"UFloatChangeNotifierComponent.h\"\n\nUFloatChangeNotifierComponent::UFloatChangeNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tFloatValue = 0.0f;\n}\n\nvoid UFloatChangeNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFloatChangeNotifierComponent::SetFloatValue(float NewValue)\n{\n\tif (FloatValue != NewValue)\n\t{\n\t\tFloatValue = NewValue;\n\t\tOnFloatValueChanged.Broadcast(NewValue);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float for rotation speed, applied to its yaw rotation each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationSpeed = 45.0f; // Default rotation speed\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind a key to reset an Actor's position to the origin.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AResettableActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AResettableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResettableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid ResetPosition();\n};\n```", "cpp_code": "```cpp\n#include \"AResettableActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\nAResettableActor::AResettableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResettableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AResettableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResettableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetPosition\", IE_Pressed, this, &AResettableActor::ResetPosition);\n}\n\nvoid AResettableActor::ResetPosition()\n{\n\tSetActorLocation(FVector::ZeroVector);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY FVector and a function to log its current location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyCustomActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyCustomActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMyCustomActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Location\")\n\tFVector CurrentLocation;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Location\")\n\tvoid LogCurrentLocation();\n};\n```", "cpp_code": "```cpp\n#include \"MyCustomActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\nAMyCustomActor::AMyCustomActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentLocation = FVector::ZeroVector;\n}\n\nvoid AMyCustomActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyCustomActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyCustomActor::LogCurrentLocation()\n{\n\tCurrentLocation = GetActorLocation();\n\tif (GEngine)\n\t{\n\t\tFString LocationString = CurrentLocation.ToString();\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Current Location: %s\"), *LocationString));\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in a Component to animate its owning Actor's material over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UMaterialAnimatorComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURGAME_API UMaterialAnimatorComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUMaterialAnimatorComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\tfloat AnimationTime;\n};\n```", "cpp_code": "```cpp\n#include \"UMaterialAnimatorComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nUMaterialAnimatorComponent::UMaterialAnimatorComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tAnimationTime = 0.0f;\n}\n\nvoid UMaterialAnimatorComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUStaticMeshComponent* MeshComponent = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tUMaterialInterface* Material = MeshComponent->GetMaterial(0);\n\t\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(Material, this);\n\t\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t\t}\n\t}\n}\n\nvoid UMaterialAnimatorComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (DynamicMaterialInstance)\n\t{\n\t\tAnimationTime += DeltaTime;\n\t\tfloat ParameterValue = FMath::Sin(AnimationTime);\n\t\tDynamicMaterialInstance->SetScalarParameterValue(TEXT(\"MyParameter\"), ParameterValue);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh component and a function to print a message when play starts.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMyStaticMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Static mesh component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Optionally set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh>MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tUE_LOG(LogTemp, Warning, TEXT(\"Play has started!\"));\n}\n```"}
{"requirement": "Set up an input binding in an Actor to call a function that toggles a UPROPERTY boolean status.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid ToggleStatus();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Toggle\")\n\tbool bIsToggled;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\nAToggleActor::AToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsToggled = false;\n}\n\nvoid AToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleActor::ToggleStatus()\n{\n\tbIsToggled = !bIsToggled;\n}\n\nvoid AToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleAction\", IE_Pressed, this, &AToggleActor::ToggleStatus);\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY integer representing a tick counter that resets every 50 ticks.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TickCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTickCounterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUTickCounterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Tick\")\n\tint32 TickCounter;\n};\n```", "cpp_code": "```cpp\n#include \"TickCounterComponent.h\"\n\nUTickCounterComponent::UTickCounterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTickCounter = 0;\n}\n\nvoid UTickCounterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UTickCounterComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTickCounter++;\n\tif (TickCounter >= 50)\n\t{\n\t\tTickCounter = 0;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to always face towards a moving target.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FaceTargetActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFaceTargetActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAFaceTargetActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Target\")\n\tAActor* TargetActor;\n};\n```", "cpp_code": "```cpp\n#include \"FaceTargetActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAFaceTargetActor::AFaceTargetActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AFaceTargetActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AFaceTargetActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tFVector Direction = (TargetActor->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n\t\tFRotator NewRotation = Direction.Rotation();\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load and set a mesh as the root component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AMyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"AMyActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that logs its speed in the console.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASpeedLoggerActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Speed\")\n\tvoid LogSpeed() const;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat Speed;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nASpeedLoggerActor::ASpeedLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSpeed = 0.0f;\n}\n\nvoid ASpeedLoggerActor::LogSpeed() const\n{\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Speed: %f\"), Speed);\n}\n```"}
{"requirement": "Implement a dynamic weather system that changes based on game time and location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicWeatherSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADynamicWeatherSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADynamicWeatherSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to update the weather based on time and location\n\tvoid UpdateWeather();\n\n\t// Current weather state\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \"Weather\")\n\tFString CurrentWeatherState;\n\n\t// Game time\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Weather\")\n\tfloat GameTime;\n\n\t// Game location\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Weather\")\n\tFVector PlayerLocation;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicWeatherSystem.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nADynamicWeatherSystem::ADynamicWeatherSystem()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentWeatherState = \"Clear\";\n}\n\n// Called when the game starts or when spawned\nvoid ADynamicWeatherSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADynamicWeatherSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update the game time\n\tGameTime += DeltaTime;\n\n\t// Call weather update function\n\tUpdateWeather();\n}\n\nvoid ADynamicWeatherSystem::UpdateWeather()\n{\n\t// Simple example logic: Change weather based on game time and location\n\tif (GameTime < 12.0f)\n\t{\n\t\tCurrentWeatherState = \"Sunny\";\n\t}\n\telse if (GameTime < 18.0f)\n\t{\n\t\tCurrentWeatherState = \"Cloudy\";\n\t}\n\telse\n\t{\n\t\tCurrentWeatherState = \"Rainy\";\n\t}\n\n\t// Modify weather based on location, for example:\n\tif (PlayerLocation.Z > 1000.0f)\n\t{\n\t\tCurrentWeatherState = \"Snowy\";\n\t}\n\n\t// You can expand this logic based on more complex needs\n\n\t// Debug output\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Weather: %s\"), *CurrentWeatherState);\n}\n```"}
{"requirement": "Create an AI-driven enemy that adapts its strategy based on the player's actions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AdaptiveAIEnemy.generated.h\"\n\nUCLASS()\nclass MYGAME_API AAdaptiveAIEnemy : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAAdaptiveAIEnemy();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid AnalyzePlayerActions();\n\tvoid AdaptStrategy();\n\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tfloat ReactionTime;\n\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tTArray<FString> PlayerActions;\n\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tFString CurrentStrategy;\n};\n```", "cpp_code": "```cpp\n#include \"AdaptiveAIEnemy.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nAAdaptiveAIEnemy::AAdaptiveAIEnemy()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tReactionTime = 2.0f; // Default reaction time\n}\n\nvoid AAdaptiveAIEnemy::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAdaptiveAIEnemy::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tAnalyzePlayerActions();\n\tAdaptStrategy();\n}\n\nvoid AAdaptiveAIEnemy::AnalyzePlayerActions()\n{\n\t// Mock player actions analysis\n\tPlayerActions.Add(\"Attack\");\n\tPlayerActions.Add(\"Defend\");\n}\n\nvoid AAdaptiveAIEnemy::AdaptStrategy()\n{\n\tif (PlayerActions.Num() == 0) return;\n\n\tFString LastAction = PlayerActions.Last();\n\n\tif (LastAction == \"Attack\")\n\t{\n\t\tCurrentStrategy = \"Defensive\";\n\t}\n\telse if (LastAction == \"Defend\")\n\t{\n\t\tCurrentStrategy = \"Aggressive\";\n\t}\n\telse\n\t{\n\t\tCurrentStrategy = \"Neutral\";\n\t}\n\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Strategy: %s\"), *CurrentStrategy);\n}\n```"}
{"requirement": "Develop a customizable character creation screen with a wide range of options.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CharacterCreationScreen.generated.h\"\n\nUCLASS()\nclass MYGAME_API ACharacterCreationScreen : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACharacterCreationScreen();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Character Creation\")\n\tvoid CustomizeCharacter(FString OptionType, FString OptionValue);\n\nprivate:\n\tvoid InitializeDefaultCharacter();\n\tvoid UpdateCharacterAppearance();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Character Options\", meta=(AllowPrivateAccess=\"true\"))\n\tTMap<FString, FString> CharacterOptions;\n};\n```", "cpp_code": "```cpp\n#include \"CharacterCreationScreen.h\"\n\nACharacterCreationScreen::ACharacterCreationScreen()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tInitializeDefaultCharacter();\n}\n\nvoid ACharacterCreationScreen::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACharacterCreationScreen::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACharacterCreationScreen::CustomizeCharacter(FString OptionType, FString OptionValue)\n{\n\tif (CharacterOptions.Contains(OptionType))\n\t{\n\t\tCharacterOptions[OptionType] = OptionValue;\n\t}\n\telse\n\t{\n\t\tCharacterOptions.Add(OptionType, OptionValue);\n\t}\n\n\tUpdateCharacterAppearance();\n}\n\nvoid ACharacterCreationScreen::InitializeDefaultCharacter()\n{\n\tCharacterOptions.Add(TEXT(\"HairColor\"), TEXT(\"Black\"));\n\tCharacterOptions.Add(TEXT(\"SkinTone\"), TEXT(\"Light\"));\n\tCharacterOptions.Add(TEXT(\"Outfit\"), TEXT(\"Casual\"));\n\t// Add more default options as needed\n}\n\nvoid ACharacterCreationScreen::UpdateCharacterAppearance()\n{\n\t// Implementation to update the character appearance based on CharacterOptions\n\t// This would typically involve changing meshes, materials, or other properties\n}\n```"}
{"requirement": "Integrate a real-time voice chat system for multiplayer communication.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VoiceChatManager.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVoiceChatManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAVoiceChatManager();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"VoiceChat\")\n\tvoid InitializeVoiceChat();\n\n\tUFUNCTION(BlueprintCallable, Category = \"VoiceChat\")\n\tvoid StartVoiceChat();\n\n\tUFUNCTION(BlueprintCallable, Category = \"VoiceChat\")\n\tvoid StopVoiceChat();\n\nprivate:\n\tvoid OnVoiceChatInitialized(bool bSuccess);\n};\n```", "cpp_code": "```cpp\n#include \"VoiceChatManager.h\"\n#include \"OnlineSubsystem.h\"\n#include \"OnlineSubsystemUtils.h\"\n#include \"Interfaces/VoiceInterface.h\"\n\nAVoiceChatManager::AVoiceChatManager()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AVoiceChatManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitializeVoiceChat();\n}\n\nvoid AVoiceChatManager::InitializeVoiceChat()\n{\n\tIOnlineSubsystem* OnlineSub = IOnlineSubsystem::Get();\n\tif (OnlineSub)\n\t{\n\t\tIOnlineVoicePtr VoiceInterface = OnlineSub->GetVoiceInterface();\n\t\tif (VoiceInterface.IsValid())\n\t\t{\n\t\t\tVoiceInterface->AddOnVoiceChatInitializedDelegate_Handle(FOnVoiceChatInitializedDelegate::CreateUObject(this, &AVoiceChatManager::OnVoiceChatInitialized));\n\t\t\tVoiceInterface->InitializeVoiceChat();\n\t\t}\n\t}\n}\n\nvoid AVoiceChatManager::StartVoiceChat()\n{\n\tIOnlineSubsystem* OnlineSub = IOnlineSubsystem::Get();\n\tif (OnlineSub)\n\t{\n\t\tIOnlineVoicePtr VoiceInterface = OnlineSub->GetVoiceInterface();\n\t\tif (VoiceInterface.IsValid())\n\t\t{\n\t\t\tVoiceInterface->StartNetworkedVoice(0);\n\t\t}\n\t}\n}\n\nvoid AVoiceChatManager::StopVoiceChat()\n{\n\tIOnlineSubsystem* OnlineSub = IOnlineSubsystem::Get();\n\tif (OnlineSub)\n\t{\n\t\tIOnlineVoicePtr VoiceInterface = OnlineSub->GetVoiceInterface();\n\t\tif (VoiceInterface.IsValid())\n\t\t{\n\t\t\tVoiceInterface->StopNetworkedVoice(0);\n\t\t}\n\t}\n}\n\nvoid AVoiceChatManager::OnVoiceChatInitialized(bool bSuccess)\n{\n\tif (bSuccess)\n\t{\n\t\tStartVoiceChat();\n\t}\n}\n```"}
{"requirement": "Design a modular inventory system that supports item stacking and sorting.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"InventorySystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FInventoryItem\n{\n\tGENERATED_BODY()\n\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Inventory\")\n\tFString ItemName;\n\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Inventory\")\n\tint32 Quantity;\n\n\tFInventoryItem() : ItemName(\"\"), Quantity(1) {}\n\tFInventoryItem(FString Name, int32 Qty) : ItemName(Name), Quantity(Qty) {}\n};\n\nUCLASS(Blueprintable)\nclass YOURPROJECT_API UInventorySystem : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUInventorySystem();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tvoid AddItem(FString ItemName, int32 Quantity);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tvoid RemoveItem(FString ItemName, int32 Quantity);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tvoid SortInventory();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Inventory\")\n\tTArray<FInventoryItem> InventoryItems;\n\nprivate:\n\tFInventoryItem* FindItemByName(FString ItemName);\n};\n```", "cpp_code": "```cpp\n#include \"InventorySystem.h\"\n\nUInventorySystem::UInventorySystem()\n{\n\t// Constructor logic if needed\n}\n\nvoid UInventorySystem::AddItem(FString ItemName, int32 Quantity)\n{\n\tif (Quantity <= 0) return;\n\n\tFInventoryItem* ExistingItem = FindItemByName(ItemName);\n\tif (ExistingItem)\n\t{\n\t\tExistingItem->Quantity += Quantity;\n\t}\n\telse\n\t{\n\t\tInventoryItems.Add(FInventoryItem(ItemName, Quantity));\n\t}\n}\n\nvoid UInventorySystem::RemoveItem(FString ItemName, int32 Quantity)\n{\n\tif (Quantity <= 0) return;\n\n\tFInventoryItem* ExistingItem = FindItemByName(ItemName);\n\tif (ExistingItem)\n\t{\n\t\tExistingItem->Quantity -= Quantity;\n\t\tif (ExistingItem->Quantity <= 0)\n\t\t{\n\t\t\tInventoryItems.RemoveSingle(*ExistingItem);\n\t\t}\n\t}\n}\n\nvoid UInventorySystem::SortInventory()\n{\n\tInventoryItems.Sort([](const FInventoryItem& A, const FInventoryItem& B) {\n\t\treturn A.ItemName < B.ItemName;\n\t});\n}\n\nFInventoryItem* UInventorySystem::FindItemByName(FString ItemName)\n{\n\tfor (FInventoryItem& Item : InventoryItems)\n\t{\n\t\tif (Item.ItemName == ItemName)\n\t\t{\n\t\t\treturn &Item;\n\t\t}\n\t}\n\treturn nullptr;\n}\n```"}
{"requirement": "Construct a spline-based railway system for a train simulation game.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SplineComponent.h\"\n#include \"RailwaySystem.generated.h\"\n\nUCLASS()\nclass TRAINSIM_API ARailwaySystem : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tARailwaySystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Spline component to define the railway path\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Railway\")\n\tUSplineComponent* RailwaySpline;\n};\n```", "cpp_code": "```cpp\n#include \"RailwaySystem.h\"\n#include \"Components/SplineMeshComponent.h\"\n\n// Sets default values\nARailwaySystem::ARailwaySystem()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the spline component and attach it to the root\n\tRailwaySpline = CreateDefaultSubobject<USplineComponent>(TEXT(\"RailwaySpline\"));\n\tRootComponent = RailwaySpline;\n\n\t// Example setup: add spline point\n\tRailwaySpline->AddSplinePoint(FVector(0.0f, 0.0f, 0.0f), ESplineCoordinateSpace::Local, true);\n\tRailwaySpline->AddSplinePoint(FVector(1000.0f, 0.0f, 0.0f), ESplineCoordinateSpace::Local, true);\n\n\t// Update the spline\n\tRailwaySpline->UpdateSpline();\n}\n\n// Called when the game starts or when spawned\nvoid ARailwaySystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Additional initialization can be done here\n}\n\n// Called every frame\nvoid ARailwaySystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Any per-frame logic for the railway system can be added here\n}\n```"}
{"requirement": "Implement a cinematic camera system for scripted game sequences.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CinematicCameraSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ACinematicCameraSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACinematicCameraSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Cinematic\")\n\tvoid PlayCinematic();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Cinematic\")\n\tvoid StopCinematic();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Cinematic\")\n\tTArray<AActor*> CameraActors;\n\n\tint32 CurrentCameraIndex;\n\tbool bIsPlaying;\n\tfloat Timer;\n\n\tvoid SwitchToNextCamera();\n};\n```", "cpp_code": "```cpp\n#include \"CinematicCameraSystem.h\"\n#include \"Camera/CameraActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nACinematicCameraSystem::ACinematicCameraSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentCameraIndex = 0;\n\tbIsPlaying = false;\n\tTimer = 0.0f;\n}\n\nvoid ACinematicCameraSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Initialize cameras or other necessary elements here\n}\n\nvoid ACinematicCameraSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsPlaying)\n\t{\n\t\tTimer -= DeltaTime;\n\t\tif (Timer <= 0.0f)\n\t\t{\n\t\t\tSwitchToNextCamera();\n\t\t}\n\t}\n}\n\nvoid ACinematicCameraSystem::PlayCinematic()\n{\n\tif (CameraActors.Num() > 0)\n\t{\n\t\tbIsPlaying = true;\n\t\tCurrentCameraIndex = 0;\n\t\tTimer = 5.0f; // Duration for each camera shot\n\t\tUGameplayStatics::GetPlayerController(GetWorld(), 0)->SetViewTarget(CameraActors[CurrentCameraIndex]);\n\t}\n}\n\nvoid ACinematicCameraSystem::StopCinematic()\n{\n\tbIsPlaying = false;\n\t// Optionally reset view target to player\n\t// UGameplayStatics::GetPlayerController(GetWorld(), 0)->SetViewTarget(PlayerCharacter);\n}\n\nvoid ACinematicCameraSystem::SwitchToNextCamera()\n{\n\tif (CameraActors.Num() > 0)\n\t{\n\t\tCurrentCameraIndex = (CurrentCameraIndex + 1) % CameraActors.Num();\n\t\tTimer = 5.0f; // Duration for each camera shot\n\t\tUGameplayStatics::GetPlayerController(GetWorld(), 0)->SetViewTarget(CameraActors[CurrentCameraIndex]);\n\t}\n}\n```"}
{"requirement": "Create an intuitive drag-and-drop crafting system for players to combine items.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"CraftingSystemWidget.generated.h\"\n\nUCLASS()\nclass MYGAME_API UCraftingSystemWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUCraftingSystemWidget(const FObjectInitializer& ObjectInitializer);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Crafting\")\n\tvoid OnItemDropped(UObject* Item1, UObject* Item2);\n\n\tUFUNCTION(BlueprintImplementableEvent, Category = \"Crafting\")\n\tvoid OnCraftingSuccess(UObject* CraftedItem);\n\n\tUFUNCTION(BlueprintImplementableEvent, Category = \"Crafting\")\n\tvoid OnCraftingFailure();\n\nprivate:\n\tUObject* CombineItems(UObject* Item1, UObject* Item2);\n};\n```", "cpp_code": "```cpp\n#include \"CraftingSystemWidget.h\"\n\nUCraftingSystemWidget::UCraftingSystemWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UCraftingSystemWidget::OnItemDropped(UObject* Item1, UObject* Item2)\n{\n\tif (Item1 && Item2)\n\t{\n\t\tUObject* CraftedItem = CombineItems(Item1, Item2);\n\t\tif (CraftedItem)\n\t\t{\n\t\t\tOnCraftingSuccess(CraftedItem);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOnCraftingFailure();\n\t\t}\n\t}\n\telse\n\t{\n\t\tOnCraftingFailure();\n\t}\n}\n\nUObject* UCraftingSystemWidget::CombineItems(UObject* Item1, UObject* Item2)\n{\n\t// Placeholder for combination logic\n\t// This should be replaced with actual game logic to combine items\n\tif (Item1->GetClass() == Item2->GetClass()) // Example condition\n\t{\n\t\t// Return a new crafted item\n\t\treturn NewObject<UObject>(this, Item1->GetClass());\n\t}\n\treturn nullptr;\n}\n```"}
{"requirement": "Develop a procedurally generated terrain for an open-world exploration game.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ProceduralTerrain.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AProceduralTerrain : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAProceduralTerrain();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Size of the terrain\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Terrain\")\n\tint32 Width;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Terrain\")\n\tint32 Height;\n\n\t// Scale for noise function\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Terrain\")\n\tfloat NoiseScale;\n\n\t// Generate the terrain\n\tUFUNCTION(BlueprintCallable, Category=\"Terrain\")\n\tvoid GenerateTerrain();\n\nprivate:\n\tvoid CreateTerrainMesh();\n\tfloat GenerateHeight(int32 X, int32 Y);\n\n\tUProceduralMeshComponent* TerrainMesh;\n};\n```", "cpp_code": "```cpp\n#include \"ProceduralTerrain.h\"\n#include \"ProceduralMeshComponent.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\nAProceduralTerrain::AProceduralTerrain()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTerrainMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"TerrainMesh\"));\n\tRootComponent = TerrainMesh;\n\n\tWidth = 100;\n\tHeight = 100;\n\tNoiseScale = 0.1f;\n}\n\nvoid AProceduralTerrain::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGenerateTerrain();\n}\n\nvoid AProceduralTerrain::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AProceduralTerrain::GenerateTerrain()\n{\n\tCreateTerrainMesh();\n}\n\nvoid AProceduralTerrain::CreateTerrainMesh()\n{\n\tTArray<FVector> Vertices;\n\tTArray<int32> Triangles;\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\tTArray<FProcMeshTangent> Tangents;\n\tTArray<FLinearColor> VertexColors;\n\n\tfor (int32 Y = 0; Y <= Height; ++Y)\n\t{\n\t\tfor (int32 X = 0; X <= Width; ++X)\n\t\t{\n\t\t\tfloat Z = GenerateHeight(X, Y);\n\t\t\tVertices.Add(FVector(X * 100, Y * 100, Z));\n\t\t\tNormals.Add(FVector(0, 0, 1));\n\t\t\tUV0.Add(FVector2D((float)X / Width, (float)Y / Height));\n\t\t\tVertexColors.Add(FLinearColor::White);\n\t\t\tTangents.Add(FProcMeshTangent(1, 0, 0));\n\t\t}\n\t}\n\n\tfor (int32 Y = 0; Y < Height; ++Y)\n\t{\n\t\tfor (int32 X = 0; X < Width; ++X)\n\t\t{\n\t\t\tint32 BottomLeft = Y * (Width + 1) + X;\n\t\t\tint32 BottomRight = BottomLeft + 1;\n\t\t\tint32 TopLeft = BottomLeft + Width + 1;\n\t\t\tint32 TopRight = TopLeft + 1;\n\n\t\t\tTriangles.Add(BottomLeft);\n\t\t\tTriangles.Add(TopLeft);\n\t\t\tTriangles.Add(TopRight);\n\n\t\t\tTriangles.Add(BottomLeft);\n\t\t\tTriangles.Add(TopRight);\n\t\t\tTriangles.Add(BottomRight);\n\t\t}\n\t}\n\n\tTerrainMesh->CreateMeshSection_LinearColor(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n\nfloat AProceduralTerrain::GenerateHeight(int32 X, int32 Y)\n{\n\tfloat NoiseValue = UKismetMathLibrary::PerlinNoise2D(FVector2D(X * NoiseScale, Y * NoiseScale));\n\treturn NoiseValue * 1000.0f; // Adjust the multiplier for height variation\n}\n```"}
{"requirement": "Integrate a gesture-based input system for VR interactions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GestureInputSystem.generated.h\"\n\nUCLASS()\nclass VRPROJECT_API AGestureInputSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAGestureInputSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Gesture\")\n\tvoid RecognizeGesture();\n\nprivate:\n\tvoid InitializeGestureRecognition();\n\n\tvoid ProcessGestureInput();\n\n\t// Add more private members and methods as needed for gesture recognition\n};\n```", "cpp_code": "```cpp\n#include \"GestureInputSystem.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nAGestureInputSystem::AGestureInputSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AGestureInputSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitializeGestureRecognition();\n}\n\nvoid AGestureInputSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tProcessGestureInput();\n}\n\nvoid AGestureInputSystem::InitializeGestureRecognition()\n{\n\t// Initialize any systems or libraries needed for gesture recognition\n}\n\nvoid AGestureInputSystem::RecognizeGesture()\n{\n\t// Implement gesture recognition logic\n\t// This could involve checking hand positions, velocities, etc.\n}\n\nvoid AGestureInputSystem::ProcessGestureInput()\n{\n\t// Continuously process input to detect and respond to gestures\n\tRecognizeGesture();\n}\n```"}
{"requirement": "Design a weather-responsive character movement system that affects speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"WeatherResponsiveCharacter.generated.h\"\n\nUENUM(BlueprintType)\nenum class EWeatherType : uint8\n{\n\tSunny UMETA(DisplayName = \"Sunny\"),\n\tRainy UMETA(DisplayName = \"Rainy\"),\n\tSnowy UMETA(DisplayName = \"Snowy\")\n};\n\nUCLASS()\nclass AWeatherResponsiveCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWeatherResponsiveCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Weather\")\n\tEWeatherType CurrentWeather;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Movement\")\n\tfloat BaseSpeed;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Movement\")\n\tfloat SpeedMultiplier;\n\n\tvoid UpdateMovementSpeed();\n};\n```", "cpp_code": "```cpp\n#include \"WeatherResponsiveCharacter.h\"\n\nAWeatherResponsiveCharacter::AWeatherResponsiveCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tBaseSpeed = 600.0f;\n\tSpeedMultiplier = 1.0f;\n\tCurrentWeather = EWeatherType::Sunny;\n}\n\nvoid AWeatherResponsiveCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateMovementSpeed();\n}\n\nvoid AWeatherResponsiveCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateMovementSpeed();\n}\n\nvoid AWeatherResponsiveCharacter::UpdateMovementSpeed()\n{\n\tswitch (CurrentWeather)\n\t{\n\tcase EWeatherType::Sunny:\n\t\tSpeedMultiplier = 1.0f;\n\t\tbreak;\n\tcase EWeatherType::Rainy:\n\t\tSpeedMultiplier = 0.8f;\n\t\tbreak;\n\tcase EWeatherType::Snowy:\n\t\tSpeedMultiplier = 0.6f;\n\t\tbreak;\n\tdefault:\n\t\tSpeedMultiplier = 1.0f;\n\t\tbreak;\n\t}\n\tGetCharacterMovement()->MaxWalkSpeed = BaseSpeed * SpeedMultiplier;\n}\n```"}
{"requirement": "Implement a pathfinding system with obstacle avoidance for NPCs.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"NPCPathfinder.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ANPCPathfinder : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tANPCPathfinder();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Pathfinding\")\n\tAActor* Target;\n\n\tUPROPERTY(EditAnywhere, Category=\"Pathfinding\")\n\tfloat MovementSpeed;\n\n\tUFUNCTION()\n\tvoid FindPathToTarget();\n\n\tUFUNCTION()\n\tvoid AvoidObstacles();\n\n\tFVector CurrentDestination;\n};\n```", "cpp_code": "```cpp\n#include \"NPCPathfinder.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n#include \"DrawDebugHelpers.h\"\n\nANPCPathfinder::ANPCPathfinder()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementSpeed = 300.0f;\n}\n\nvoid ANPCPathfinder::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tFindPathToTarget();\n}\n\nvoid ANPCPathfinder::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector Direction = (CurrentDestination - GetActorLocation()).GetSafeNormal();\n\tSetActorLocation(GetActorLocation() + Direction * MovementSpeed * DeltaTime);\n\n\tAvoidObstacles();\n\n\tif (FVector::Dist(GetActorLocation(), CurrentDestination) < 100.f)\n\t{\n\t\tFindPathToTarget();\n\t}\n}\n\nvoid ANPCPathfinder::FindPathToTarget()\n{\n\tif (!Target) return;\n\n\t// Here you would implement your pathfinding logic\n\t// This is just setting the target location directly for simplicity\n\tCurrentDestination = Target->GetActorLocation();\n}\n\nvoid ANPCPathfinder::AvoidObstacles()\n{\n\tFVector Forward = GetActorForwardVector();\n\tFVector Start = GetActorLocation();\n\tFVector End = Start + Forward * 100.f;\n\n\tFHitResult HitResult;\n\tFCollisionQueryParams CollisionParams;\n\tCollisionParams.AddIgnoredActor(this);\n\n\tif (GetWorld()->LineTraceSingleByChannel(HitResult, Start, End, ECC_Visibility, CollisionParams))\n\t{\n\t\tFVector AvoidanceDirection = FVector::CrossProduct(HitResult.Normal, FVector::UpVector).GetSafeNormal();\n\t\tCurrentDestination += AvoidanceDirection * 200.f;\n\n\t\tDrawDebugLine(GetWorld(), Start, HitResult.Location, FColor::Red, false, 1.0f);\n\t}\n\telse\n\t{\n\t\tDrawDebugLine(GetWorld(), Start, End, FColor::Green, false, 1.0f);\n\t}\n}\n```"}
{"requirement": "Create a realistic day-night cycle with dynamic lighting and shadows.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DayNightCycle.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADayNightCycle : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADayNightCycle();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Day Night Settings\")\n\tfloat DayLengthInMinutes;\n\n\tUPROPERTY(EditAnywhere, Category = \"Day Night Settings\")\n\tADirectionalLight* DirectionalLight;\n\n\tUPROPERTY(EditAnywhere, Category = \"Day Night Settings\")\n\tASkyLight* SkyLight;\n\n\tUPROPERTY(EditAnywhere, Category = \"Day Night Settings\")\n\tfloat TimeScale;\n\n\tfloat CurrentTime;\n\n\tvoid UpdateLighting(float DeltaTime);\n\n\tvoid SetSunPosition(float TimeOfDay);\n};\n```", "cpp_code": "```cpp\n#include \"DayNightCycle.h\"\n#include \"Engine/World.h\"\n#include \"Components/DirectionalLightComponent.h\"\n#include \"Components/SkyLightComponent.h\"\n\nADayNightCycle::ADayNightCycle()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tDayLengthInMinutes = 1.0f;\n\tTimeScale = 1.0f;\n\tCurrentTime = 0.0f;\n}\n\nvoid ADayNightCycle::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (DirectionalLight && SkyLight)\n\t{\n\t\tDirectionalLight->SetMobility(EComponentMobility::Movable);\n\t\tSkyLight->SetMobility(EComponentMobility::Movable);\n\t}\n}\n\nvoid ADayNightCycle::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tUpdateLighting(DeltaTime);\n}\n\nvoid ADayNightCycle::UpdateLighting(float DeltaTime)\n{\n\tif (!DirectionalLight || !SkyLight) return;\n\n\tfloat DayLengthInSeconds = DayLengthInMinutes * 60.0f;\n\tCurrentTime += DeltaTime * TimeScale;\n\n\tif (CurrentTime > DayLengthInSeconds)\n\t{\n\t\tCurrentTime -= DayLengthInSeconds;\n\t}\n\n\tfloat TimeOfDay = CurrentTime / DayLengthInSeconds;\n\tSetSunPosition(TimeOfDay);\n}\n\nvoid ADayNightCycle::SetSunPosition(float TimeOfDay)\n{\n\tif (!DirectionalLight) return;\n\n\tfloat SunAngle = FMath::Lerp(-90.0f, 270.0f, TimeOfDay);\n\tFRotator NewRotation(SunAngle, 0.0f, 0.0f);\n\tDirectionalLight->GetLightComponent()->SetWorldRotation(NewRotation);\n\n\tSkyLight->GetLightComponent()->RecaptureSky();\n}\n```"}
{"requirement": "Develop a UI widget system for displaying quest objectives and progress.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"QuestObjectiveWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UQuestObjectiveWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Quest\")\n\tvoid UpdateQuestObjective(const FString& ObjectiveText, float Progress);\n\nprotected:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UTextBlock* ObjectiveTextBlock;\n\n\tUPROPERTY(meta = (BindWidget))\n\tclass UProgressBar* ObjectiveProgressBar;\n};\n```", "cpp_code": "```cpp\n#include \"QuestObjectiveWidget.h\"\n#include \"Components/TextBlock.h\"\n#include \"Components/ProgressBar.h\"\n\nvoid UQuestObjectiveWidget::UpdateQuestObjective(const FString& ObjectiveText, float Progress)\n{\n\tif (ObjectiveTextBlock)\n\t{\n\t\tObjectiveTextBlock->SetText(FText::FromString(ObjectiveText));\n\t}\n\n\tif (ObjectiveProgressBar)\n\t{\n\t\tObjectiveProgressBar->SetPercent(Progress);\n\t}\n}\n```"}
{"requirement": "Construct a system to handle multiple save files with user profiles.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/SaveGame.h\"\n#include \"UserProfileSaveGame.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UUserProfileSaveGame : public USaveGame\n{\n\tGENERATED_BODY()\n\npublic:\n\tUUserProfileSaveGame();\n\n\tUPROPERTY(VisibleAnywhere, Category = \"Profile\")\n\tFString UserName;\n\n\tUPROPERTY(VisibleAnywhere, Category = \"Profile\")\n\tint32 UserLevel;\n\n\tUPROPERTY(VisibleAnywhere, Category = \"Profile\")\n\tint32 UserScore;\n};\n\nUCLASS()\nclass YOURGAME_API UUserProfileManager : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUUserProfileManager();\n\n\tUFUNCTION(BlueprintCallable, Category = \"SaveLoad\")\n\tbool SaveProfile(const FString& SlotName, const int32 UserIndex, const FString& UserName, const int32 UserLevel, const int32 UserScore);\n\n\tUFUNCTION(BlueprintCallable, Category = \"SaveLoad\")\n\tUUserProfileSaveGame* LoadProfile(const FString& SlotName, const int32 UserIndex);\n};\n```", "cpp_code": "```cpp\n#include \"UserProfileSaveGame.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUUserProfileSaveGame::UUserProfileSaveGame()\n{\n\tUserName = TEXT(\"DefaultUser\");\n\tUserLevel = 1;\n\tUserScore = 0;\n}\n\nUUserProfileManager::UUserProfileManager()\n{\n}\n\nbool UUserProfileManager::SaveProfile(const FString& SlotName, const int32 UserIndex, const FString& UserName, const int32 UserLevel, const int32 UserScore)\n{\n\tUUserProfileSaveGame* SaveGameInstance = Cast<UUserProfileSaveGame>(UGameplayStatics::CreateSaveGameObject(UUserProfileSaveGame::StaticClass()));\n\n\tif (SaveGameInstance)\n\t{\n\t\tSaveGameInstance->UserName = UserName;\n\t\tSaveGameInstance->UserLevel = UserLevel;\n\t\tSaveGameInstance->UserScore = UserScore;\n\n\t\treturn UGameplayStatics::SaveGameToSlot(SaveGameInstance, SlotName, UserIndex);\n\t}\n\n\treturn false;\n}\n\nUUserProfileSaveGame* UUserProfileManager::LoadProfile(const FString& SlotName, const int32 UserIndex)\n{\n\tUUserProfileSaveGame* LoadedGame = Cast<UUserProfileSaveGame>(UGameplayStatics::LoadGameFromSlot(SlotName, UserIndex));\n\treturn LoadedGame;\n}\n```"}
{"requirement": "Implement a real-time strategy game AI that can manage resources efficiently.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RTSAIManager.generated.h\"\n\nUCLASS()\nclass RTSGAME_API ARTSAIManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARTSAIManager();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ManageResources();\n\tvoid AllocateWorkers();\n\tvoid MonitorResourceLevels();\n\n\tUPROPERTY(EditAnywhere)\n\tint32 TotalResources;\n\n\tUPROPERTY(EditAnywhere)\n\tint32 WorkersAvailable;\n\n\tUPROPERTY(EditAnywhere)\n\tint32 DesiredResourceLevel;\n};\n```", "cpp_code": "```cpp\n#include \"RTSAIManager.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nARTSAIManager::ARTSAIManager()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTotalResources = 1000;\n\tWorkersAvailable = 20;\n\tDesiredResourceLevel = 2000;\n}\n\nvoid ARTSAIManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorld()->GetTimerManager().SetTimerForNextTick(this, &ARTSAIManager::ManageResources);\n}\n\nvoid ARTSAIManager::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tMonitorResourceLevels();\n}\n\nvoid ARTSAIManager::ManageResources()\n{\n\tif (TotalResources < DesiredResourceLevel)\n\t{\n\t\tAllocateWorkers();\n\t}\n\telse\n\t{\n\t\t// Logic for when resource needs are satisfied\n\t}\n\tGetWorld()->GetTimerManager().SetTimerForNextTick(this, &ARTSAIManager::ManageResources);\n}\n\nvoid ARTSAIManager::AllocateWorkers()\n{\n\tif (WorkersAvailable > 0)\n\t{\n\t\t// Simulate resource collection by workers\n\t\tint32 ResourcesGathered = FMath::RandRange(10, 50);\n\t\tTotalResources += ResourcesGathered;\n\t\t--WorkersAvailable;\n\t}\n}\n\nvoid ARTSAIManager::MonitorResourceLevels()\n{\n\tif (TotalResources >= DesiredResourceLevel && WorkersAvailable < 20)\n\t{\n\t\t// Simulate workers returning to the pool\n\t\t++WorkersAvailable;\n\t}\n}\n```"}
{"requirement": "Design an underwater physics system that affects buoyancy and movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UnderwaterPhysicsSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AUnderwaterPhysicsSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAUnderwaterPhysicsSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Buoyancy\")\n\tfloat BuoyancyFactor;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Buoyancy\")\n\tfloat WaterDensity;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat DragCoefficient;\n\nprivate:\n\tvoid ApplyBuoyancyAndDrag();\n};\n```", "cpp_code": "```cpp\n#include \"UnderwaterPhysicsSystem.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nAUnderwaterPhysicsSystem::AUnderwaterPhysicsSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tBuoyancyFactor = 1.0f;\n\tWaterDensity = 1000.0f; // kg/m^3, density of water\n\tDragCoefficient = 0.47f; // typical drag coefficient for a sphere\n}\n\nvoid AUnderwaterPhysicsSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AUnderwaterPhysicsSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tApplyBuoyancyAndDrag();\n}\n\nvoid AUnderwaterPhysicsSystem::ApplyBuoyancyAndDrag()\n{\n\t// Assuming this actor has a primitive component\n\tUPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(GetComponentByClass(UPrimitiveComponent::StaticClass()));\n\tif (PrimitiveComponent)\n\t{\n\t\tFVector ActorLocation = GetActorLocation();\n\t\tfloat Depth = FMath::Max(0.0f, -ActorLocation.Z); // Assuming water surface at Z = 0\n\n\t\t// Buoyant force = Water Density * Volume Displaced * Gravity\n\t\tfloat Volume = PrimitiveComponent->GetMass() / WaterDensity; // Volume = Mass / Density\n\t\tFVector BuoyantForce = FVector(0, 0, WaterDensity * Volume * BuoyancyFactor * GetWorld()->GetGravityZ());\n\n\t\t// Drag force = 0.5 * WaterDensity * Velocity^2 * DragCoefficient * Area\n\t\tFVector Velocity = PrimitiveComponent->GetComponentVelocity();\n\t\tFVector DragForce = -0.5f * WaterDensity * Velocity.SizeSquared() * DragCoefficient * Velocity.GetSafeNormal();\n\n\t\t// Apply forces\n\t\tPrimitiveComponent->AddForce(BuoyantForce);\n\t\tPrimitiveComponent->AddForce(DragForce);\n\t}\n}\n```"}
{"requirement": "Create a particle system for simulating realistic smoke and fire effects.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ParticleDefinitions.h\"\n#include \"FireSmokeParticleSystem.generated.h\"\n\nUCLASS()\nclass AFireSmokeParticleSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFireSmokeParticleSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Particle System\")\n\tUParticleSystemComponent* FireParticleSystem;\n\n\tUPROPERTY(EditAnywhere, Category = \"Particle System\")\n\tUParticleSystemComponent* SmokeParticleSystem;\n\n\tvoid InitializeParticleSystems();\n};\n```", "cpp_code": "```cpp\n#include \"FireSmokeParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAFireSmokeParticleSystem::AFireSmokeParticleSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tFireParticleSystem = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"FireParticleSystem\"));\n\tSmokeParticleSystem = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"SmokeParticleSystem\"));\n\n\tRootComponent = FireParticleSystem;\n\tSmokeParticleSystem->SetupAttachment(RootComponent);\n\n\tInitializeParticleSystems();\n}\n\nvoid AFireSmokeParticleSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AFireSmokeParticleSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AFireSmokeParticleSystem::InitializeParticleSystems()\n{\n\tstatic ConstructorHelpers::FObjectFinder<UParticleSystem> FireParticleAsset(TEXT(\"/Game/Particles/P_Fire\"));\n\tif (FireParticleAsset.Succeeded())\n\t{\n\t\tFireParticleSystem->SetTemplate(FireParticleAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UParticleSystem> SmokeParticleAsset(TEXT(\"/Game/Particles/P_Smoke\"));\n\tif (SmokeParticleAsset.Succeeded())\n\t{\n\t\tSmokeParticleSystem->SetTemplate(SmokeParticleAsset.Object);\n\t}\n\n\tFireParticleSystem->bAutoActivate = true;\n\tSmokeParticleSystem->bAutoActivate = true;\n}\n```"}
{"requirement": "Develop a customizable HUD that players can personalize for their playstyle.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/HUD.h\"\n#include \"CustomizableHUD.generated.h\"\n\nUCLASS()\nclass MYGAME_API ACustomizableHUD : public AHUD\n{\n\tGENERATED_BODY()\n\npublic:\n\tACustomizableHUD();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void DrawHUD() override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"HUD\")\n\tvoid SetHUDVisibility(bool bIsVisible);\n\n\tUFUNCTION(BlueprintCallable, Category=\"HUD\")\n\tvoid SetHUDColor(FLinearColor NewColor);\n\nprivate:\n\tbool bHUDVisible;\n\tFLinearColor HUDColor;\n};\n```", "cpp_code": "```cpp\n#include \"CustomizableHUD.h\"\n#include \"Engine/Canvas.h\"\n#include \"Engine/Font.h\"\n\nACustomizableHUD::ACustomizableHUD()\n\t: bHUDVisible(true), HUDColor(FLinearColor::White)\n{\n}\n\nvoid ACustomizableHUD::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACustomizableHUD::DrawHUD()\n{\n\tSuper::DrawHUD();\n\n\tif (bHUDVisible)\n\t{\n\t\t// Example: Draw a simple crosshair\n\t\tif (Canvas)\n\t\t{\n\t\t\tconst FVector2D Center(Canvas->ClipX * 0.5f, Canvas->ClipY * 0.5f);\n\t\t\tconst FVector2D CrosshairDrawPosition(Center.X - 5.0f, Center.Y - 5.0f);\n\t\t\tFCanvasTileItem TileItem(CrosshairDrawPosition, FVector2D(10.0f, 10.0f), HUDColor);\n\t\t\tTileItem.BlendMode = SE_BLEND_Translucent;\n\t\t\tCanvas->DrawItem(TileItem);\n\t\t}\n\t}\n}\n\nvoid ACustomizableHUD::SetHUDVisibility(bool bIsVisible)\n{\n\tbHUDVisible = bIsVisible;\n}\n\nvoid ACustomizableHUD::SetHUDColor(FLinearColor NewColor)\n{\n\tHUDColor = NewColor;\n}\n```"}
{"requirement": "Integrate a multi-platform controller support system for diverse devices.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"MultiPlatformControllerSupport.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMultiPlatformControllerSupport : public APlayerController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMultiPlatformControllerSupport();\n\nprotected:\n\tvirtual void SetupInputComponent() override;\n\nprivate:\n\tvoid HandleGamepadInput();\n\tvoid HandleKeyboardInput();\n\tvoid HandlePlatformSpecificInput();\n};\n```", "cpp_code": "```cpp\n#include \"MultiPlatformControllerSupport.h\"\n#include \"GameFramework/InputSettings.h\"\n#include \"GameFramework/PlayerInput.h\"\n\nAMultiPlatformControllerSupport::AMultiPlatformControllerSupport()\n{\n\t// Constructor logic if needed\n}\n\nvoid AMultiPlatformControllerSupport::SetupInputComponent()\n{\n\tSuper::SetupInputComponent();\n\n\tif (InputComponent)\n\t{\n\t\t// Bind common actions\n\t\tInputComponent->BindAction(\"Jump\", IE_Pressed, this, &AMultiPlatformControllerSupport::HandleGamepadInput);\n\t\tInputComponent->BindAction(\"Fire\", IE_Pressed, this, &AMultiPlatformControllerSupport::HandleKeyboardInput);\n\n\t\t// Bind platform-specific actions\n\t\tHandlePlatformSpecificInput();\n\t}\n}\n\nvoid AMultiPlatformControllerSupport::HandleGamepadInput()\n{\n\t// Handle gamepad-specific input\n\tUE_LOG(LogTemp, Log, TEXT(\"Gamepad input handled.\"));\n}\n\nvoid AMultiPlatformControllerSupport::HandleKeyboardInput()\n{\n\t// Handle keyboard-specific input\n\tUE_LOG(LogTemp, Log, TEXT(\"Keyboard input handled.\"));\n}\n\nvoid AMultiPlatformControllerSupport::HandlePlatformSpecificInput()\n{\n#if PLATFORM_PS4\n\tInputComponent->BindAction(\"SpecialAction\", IE_Pressed, this, &AMultiPlatformControllerSupport::HandleGamepadInput);\n\tUE_LOG(LogTemp, Log, TEXT(\"PS4-specific input bound.\"));\n#elif PLATFORM_XBOXONE\n\tInputComponent->BindAction(\"SpecialAction\", IE_Pressed, this, &AMultiPlatformControllerSupport::HandleGamepadInput);\n\tUE_LOG(LogTemp, Log, TEXT(\"Xbox-specific input bound.\"));\n#elif PLATFORM_WINDOWS\n\tInputComponent->BindAction(\"SpecialAction\", IE_Pressed, this, &AMultiPlatformControllerSupport::HandleKeyboardInput);\n\tUE_LOG(LogTemp, Log, TEXT(\"Windows-specific input bound.\"));\n#endif\n}\n```"}
{"requirement": "Design a photo mode feature allowing players to capture in-game screenshots.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PhotoModeManager.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APhotoModeManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPhotoModeManager();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"PhotoMode\")\n\tvoid ActivatePhotoMode();\n\n\tUFUNCTION(BlueprintCallable, Category=\"PhotoMode\")\n\tvoid CaptureScreenshot();\n\nprivate:\n\tbool bIsPhotoModeActive;\n};\n```", "cpp_code": "```cpp\n#include \"PhotoModeManager.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAPhotoModeManager::APhotoModeManager()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsPhotoModeActive = false;\n}\n\nvoid APhotoModeManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APhotoModeManager::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t// Optionally implement any real-time updates or checks during photo mode\n}\n\nvoid APhotoModeManager::ActivatePhotoMode()\n{\n\tbIsPhotoModeActive = !bIsPhotoModeActive;\n\tif (bIsPhotoModeActive)\n\t{\n\t\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\t\tif (PlayerController)\n\t\t{\n\t\t\tPlayerController->SetViewTarget(this);\n\t\t\t// Additional setup for photo mode, like disabling HUD, pausing game, etc.\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Reset any changes made during photo mode activation\n\t}\n}\n\nvoid APhotoModeManager::CaptureScreenshot()\n{\n\tif (bIsPhotoModeActive)\n\t{\n\t\t// Capture screenshot\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->GameViewport->Viewport->TakeHighResScreenShot();\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an adaptive soundtrack system that changes based on player location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"AdaptiveSoundtrackSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAdaptiveSoundtrackSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAdaptiveSoundtrackSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tTMap<FString, USoundCue*> LocationSoundMap;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tFString CurrentLocation;\n\nprivate:\n\tUAudioComponent* AudioComponent;\n\n\tvoid UpdateSoundtrack();\n};\n```", "cpp_code": "```cpp\n#include \"AdaptiveSoundtrackSystem.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAAdaptiveSoundtrackSystem::AAdaptiveSoundtrackSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->bAutoActivate = false;\n\tRootComponent = AudioComponent;\n}\n\nvoid AAdaptiveSoundtrackSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateSoundtrack();\n}\n\nvoid AAdaptiveSoundtrackSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Example logic for determining player location\n\t// This should be replaced with your project's specific logic\n\tFVector PlayerLocation = UGameplayStatics::GetPlayerPawn(GetWorld(), 0)->GetActorLocation();\n\tif (PlayerLocation.X > 1000.0f) {\n\t\tCurrentLocation = \"Area1\";\n\t} else {\n\t\tCurrentLocation = \"Area2\";\n\t}\n\n\tUpdateSoundtrack();\n}\n\nvoid AAdaptiveSoundtrackSystem::UpdateSoundtrack()\n{\n\tUSoundCue** SoundCue = LocationSoundMap.Find(CurrentLocation);\n\tif (SoundCue && *SoundCue)\n\t{\n\t\tif (AudioComponent->Sound != *SoundCue)\n\t\t{\n\t\t\tAudioComponent->SetSound(*SoundCue);\n\t\t\tAudioComponent->Play();\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a tree growth simulation system for a nature-based game.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TreeGrowthSystem.generated.h\"\n\nUCLASS()\nclass NATUREGAME_API ATreeGrowthSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tATreeGrowthSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Growth\")\n\tfloat GrowthRate;\n\n\tUPROPERTY(EditAnywhere, Category=\"Growth\")\n\tfloat CurrentHeight;\n\n\tUPROPERTY(EditAnywhere, Category=\"Growth\")\n\tfloat MaxHeight;\n\n\tvoid SimulateGrowth(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"TreeGrowthSystem.h\"\n\nATreeGrowthSystem::ATreeGrowthSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tGrowthRate = 1.0f;\n\tCurrentHeight = 0.0f;\n\tMaxHeight = 100.0f;\n}\n\nvoid ATreeGrowthSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATreeGrowthSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tSimulateGrowth(DeltaTime);\n}\n\nvoid ATreeGrowthSystem::SimulateGrowth(float DeltaTime)\n{\n\tif(CurrentHeight < MaxHeight)\n\t{\n\t\tCurrentHeight += GrowthRate * DeltaTime;\n\t\tCurrentHeight = FMath::Min(CurrentHeight, MaxHeight);\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Tree Height: %f\"), CurrentHeight);\n\t}\n}\n```"}
{"requirement": "Develop a virtual economy system with fluctuating prices and trade routes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EconomySystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AEconomySystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAEconomySystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Economy\")\n\tTMap<FString, float> CommodityPrices;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Economy\")\n\tTArray<FString> TradeRoutes;\n\n\tvoid UpdatePrices();\n\tvoid UpdateTradeRoutes();\n};\n```", "cpp_code": "```cpp\n#include \"EconomySystem.h\"\n#include \"Math/UnrealMathUtility.h\"\n\nAEconomySystem::AEconomySystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize prices and trade routes\n\tCommodityPrices.Add(TEXT(\"Gold\"), 100.0f);\n\tCommodityPrices.Add(TEXT(\"Silver\"), 50.0f);\n\n\tTradeRoutes.Add(TEXT(\"RouteA\"));\n\tTradeRoutes.Add(TEXT(\"RouteB\"));\n}\n\nvoid AEconomySystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AEconomySystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tUpdatePrices();\n\tUpdateTradeRoutes();\n}\n\nvoid AEconomySystem::UpdatePrices()\n{\n\tfor (auto& Elem : CommodityPrices)\n\t{\n\t\tfloat Fluctuation = FMath::FRandRange(-5.0f, 5.0f);\n\t\tElem.Value += Fluctuation;\n\t\tElem.Value = FMath::Max(0.0f, Elem.Value); // Ensure non-negative price\n\t}\n}\n\nvoid AEconomySystem::UpdateTradeRoutes()\n{\n\t// Example logic to change trade routes, could be more complex\n\tif (FMath::RandBool())\n\t{\n\t\tif (!TradeRoutes.Contains(TEXT(\"RouteC\")))\n\t\t{\n\t\t\tTradeRoutes.Add(TEXT(\"RouteC\"));\n\t\t}\n\t}\n\telse\n\t{\n\t\tTradeRoutes.Remove(TEXT(\"RouteC\"));\n\t}\n}\n```"}
{"requirement": "Design a branching dialogue system for interactive storytelling.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DialogueSystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FDialogueOption\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString OptionText;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 NextNodeID;\n};\n\nUSTRUCT(BlueprintType)\nstruct FDialogueNode\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 NodeID;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString DialogueText;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tTArray<FDialogueOption> Options;\n};\n\nUCLASS()\nclass YOURGAME_API ADialogueSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADialogueSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tTMap<int32, FDialogueNode> DialogueTree;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Dialogue\")\n\tvoid StartDialogue(int32 StartNodeID);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Dialogue\")\n\tFDialogueNode GetCurrentNode() const;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Dialogue\")\n\tvoid SelectOption(int32 OptionIndex);\n\nprivate:\n\tint32 CurrentNodeID;\n};\n```", "cpp_code": "```cpp\n#include \"DialogueSystem.h\"\n\nADialogueSystem::ADialogueSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentNodeID = -1;\n}\n\nvoid ADialogueSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADialogueSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADialogueSystem::StartDialogue(int32 StartNodeID)\n{\n\tif (DialogueTree.Contains(StartNodeID))\n\t{\n\t\tCurrentNodeID = StartNodeID;\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Invalid StartNodeID\"));\n\t}\n}\n\nFDialogueNode ADialogueSystem::GetCurrentNode() const\n{\n\tif (DialogueTree.Contains(CurrentNodeID))\n\t{\n\t\treturn DialogueTree[CurrentNodeID];\n\t}\n\n\treturn FDialogueNode();\n}\n\nvoid ADialogueSystem::SelectOption(int32 OptionIndex)\n{\n\tif (DialogueTree.Contains(CurrentNodeID))\n\t{\n\t\tconst FDialogueNode& Node = DialogueTree[CurrentNodeID];\n\n\t\tif (Node.Options.IsValidIndex(OptionIndex))\n\t\t{\n\t\t\tCurrentNodeID = Node.Options[OptionIndex].NextNodeID;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Invalid OptionIndex\"));\n\t\t}\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Invalid CurrentNodeID\"));\n\t}\n}\n```"}
{"requirement": "Create a ragdoll physics system for character death animations.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"RagdollCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ARagdollCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tARagdollCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \t\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Function to trigger ragdoll physics\n\tUFUNCTION(BlueprintCallable, Category = \"Ragdoll\")\n\tvoid EnableRagdoll();\n\nprivate:\n\t// Helper function to configure ragdoll\n\tvoid InitializeRagdollPhysics();\n};\n```", "cpp_code": "```cpp\n#include \"RagdollCharacter.h\"\n\nARagdollCharacter::ARagdollCharacter()\n{\n\t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARagdollCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitializeRagdollPhysics();\n}\n\nvoid ARagdollCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\nvoid ARagdollCharacter::EnableRagdoll()\n{\n\t// Switch the character mesh to use physics simulation\n\tGetMesh()->SetSimulatePhysics(true);\n\tGetMesh()->SetCollisionProfileName(TEXT(\"Ragdoll\"));\n}\n\nvoid ARagdollCharacter::InitializeRagdollPhysics()\n{\n\t// Ensure physics is initially disabled\n\tGetMesh()->SetSimulatePhysics(false);\n\tGetMesh()->SetCollisionProfileName(TEXT(\"CharacterMesh\"));\n}\n```"}
{"requirement": "Implement a system for dynamically loading and unloading level assets.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicLevelLoader.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADynamicLevelLoader : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tADynamicLevelLoader();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category=\"Level\")\n\tvoid LoadLevel(FName LevelName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Level\")\n\tvoid UnloadLevel(FName LevelName);\n\nprivate:\n\tTMap<FName, ULevelStreaming*> LoadedLevels;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicLevelLoader.h\"\n#include \"Engine/World.h\"\n#include \"Engine/LevelStreamingDynamic.h\"\n\nADynamicLevelLoader::ADynamicLevelLoader()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ADynamicLevelLoader::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADynamicLevelLoader::LoadLevel(FName LevelName)\n{\n\tif (!LoadedLevels.Contains(LevelName))\n\t{\n\t\tULevelStreamingDynamic* StreamingLevel = ULevelStreamingDynamic::LoadLevelInstance(this, LevelName.ToString(), FVector::ZeroVector, FRotator::ZeroRotator, true);\n\t\tif (StreamingLevel)\n\t\t{\n\t\t\tLoadedLevels.Add(LevelName, StreamingLevel);\n\t\t}\n\t}\n}\n\nvoid ADynamicLevelLoader::UnloadLevel(FName LevelName)\n{\n\tif (LoadedLevels.Contains(LevelName))\n\t{\n\t\tULevelStreaming* StreamingLevel = LoadedLevels[LevelName];\n\t\tif (StreamingLevel)\n\t\t{\n\t\t\tStreamingLevel->SetShouldBeLoaded(false);\n\t\t\tStreamingLevel->SetShouldBeVisible(false);\n\t\t\tStreamingLevel->bShouldBlockOnLoad = false;\n\t\t\tStreamingLevel->OnLevelUnloaded.RemoveAll(this);\n\t\t\tLoadedLevels.Remove(LevelName);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Develop a skill tree progression system with unlockable abilities.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SkillTreeSystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FSkillNode\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Skill\")\n\tFString SkillName;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Skill\")\n\tbool bIsUnlocked;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Skill\")\n\tTArray<int32> PrerequisiteSkills;\n};\n\nUCLASS()\nclass YOURGAME_API ASkillTreeSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASkillTreeSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Skill Tree\")\n\tTArray<FSkillNode> Skills;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Skill Tree\")\n\tbool UnlockSkill(int32 SkillIndex);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Skill Tree\")\n\tbool IsSkillUnlocked(int32 SkillIndex) const;\n};\n```", "cpp_code": "```cpp\n#include \"SkillTreeSystem.h\"\n\nASkillTreeSystem::ASkillTreeSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASkillTreeSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASkillTreeSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nbool ASkillTreeSystem::UnlockSkill(int32 SkillIndex)\n{\n\tif (Skills.IsValidIndex(SkillIndex))\n\t{\n\t\tFSkillNode& Skill = Skills[SkillIndex];\n\t\tfor (int32 Prerequisite : Skill.PrerequisiteSkills)\n\t\t{\n\t\t\tif (!IsSkillUnlocked(Prerequisite))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tSkill.bIsUnlocked = true;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool ASkillTreeSystem::IsSkillUnlocked(int32 SkillIndex) const\n{\n\tif (Skills.IsValidIndex(SkillIndex))\n\t{\n\t\treturn Skills[SkillIndex].bIsUnlocked;\n\t}\n\treturn false;\n}\n```"}
{"requirement": "Construct a localization system for supporting multiple languages.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"LocalizationManager.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ULocalizationManager : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tULocalizationManager();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Localization\")\n\tvoid InitializeLocalization();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Localization\")\n\tFString GetLocalizedString(const FString& Key);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Localization\")\n\tvoid SetCurrentLanguage(const FString& LanguageCode);\n\nprivate:\n\tTMap<FString, FString> LocalizationMap;\n\tFString CurrentLanguage;\n\n\tvoid LoadLocalizationData();\n};\n```", "cpp_code": "```cpp\n#include \"LocalizationManager.h\"\n#include \"Misc/Paths.h\"\n#include \"Misc/FileHelper.h\"\n#include \"JsonObjectConverter.h\"\n\nULocalizationManager::ULocalizationManager()\n{\n\tCurrentLanguage = TEXT(\"en\"); // Default language\n\tInitializeLocalization();\n}\n\nvoid ULocalizationManager::InitializeLocalization()\n{\n\tLoadLocalizationData();\n}\n\nvoid ULocalizationManager::LoadLocalizationData()\n{\n\tFString FilePath = FPaths::ProjectContentDir() / \"Localization\" / (CurrentLanguage + \".json\");\n\tFString JsonString;\n\n\tif (FFileHelper::LoadFileToString(JsonString, *FilePath))\n\t{\n\t\tTSharedPtr<FJsonObject> JsonObject;\n\t\tTSharedRef<TJsonReader<>> Reader = TJsonReaderFactory<>::Create(JsonString);\n\n\t\tif (FJsonSerializer::Deserialize(Reader, JsonObject) && JsonObject.IsValid())\n\t\t{\n\t\t\tfor (auto& Elem : JsonObject->Values)\n\t\t\t{\n\t\t\t\tLocalizationMap.Add(Elem.Key, Elem.Value->AsString());\n\t\t\t}\n\t\t}\n\t}\n}\n\nFString ULocalizationManager::GetLocalizedString(const FString& Key)\n{\n\tif (LocalizationMap.Contains(Key))\n\t{\n\t\treturn LocalizationMap[Key];\n\t}\n\treturn FString(\"[Missing Localization]\");\n}\n\nvoid ULocalizationManager::SetCurrentLanguage(const FString& LanguageCode)\n{\n\tCurrentLanguage = LanguageCode;\n\tLocalizationMap.Empty();\n\tLoadLocalizationData();\n}\n```"}
{"requirement": "Integrate a weather forecast system that players can access in real-time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WeatherForecastSystem.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AWeatherForecastSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAWeatherForecastSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Retrieves the current weather forecast\n\tUFUNCTION(BlueprintCallable, Category = \"Weather\")\n\tFString GetWeatherForecast();\n\nprivate:\n\t// Helper function to fetch weather data from an API\n\tFString FetchWeatherData();\n\n\t// Stores the latest weather data\n\tFString CurrentWeather;\n};\n```", "cpp_code": "```cpp\n#include \"WeatherForecastSystem.h\"\n#include \"HttpModule.h\"\n#include \"Interfaces/IHttpResponse.h\"\n#include \"Json.h\"\n#include \"JsonUtilities.h\"\n\n// Sets default values\nAWeatherForecastSystem::AWeatherForecastSystem()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AWeatherForecastSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCurrentWeather = FetchWeatherData();\n}\n\n// Called every frame\nvoid AWeatherForecastSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nFString AWeatherForecastSystem::GetWeatherForecast()\n{\n\treturn CurrentWeather;\n}\n\nFString AWeatherForecastSystem::FetchWeatherData()\n{\n\tFString WeatherData = \"\";\n\tTSharedRef<IHttpRequest> Request = FHttpModule::Get().CreateRequest();\n\tRequest->OnProcessRequestComplete().BindLambda([&WeatherData](FHttpRequestPtr Request, FHttpResponsePtr Response, bool bWasSuccessful)\n\t{\n\t\tif (bWasSuccessful && Response.IsValid())\n\t\t{\n\t\t\tWeatherData = Response->GetContentAsString();\n\t\t}\n\t});\n\n\t// You'd replace this URL with the actual API endpoint you are using\n\tRequest->SetURL(\"http://api.openweathermap.org/data/2.5/weather?q=London&appid=YOUR_API_KEY\");\n\tRequest->SetVerb(\"GET\");\n\tRequest->ProcessRequest();\n\n\treturn WeatherData;\n}\n```"}
{"requirement": "Design an achievement and trophy system with unlockable rewards.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AchievementSystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FAchievement\n{\n\tGENERATED_BODY()\n\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Achievement\")\n\tFString Name;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Achievement\")\n\tFString Description;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Achievement\")\n\tbool bIsUnlocked;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Achievement\")\n\tint32 RewardPoints;\n};\n\nUCLASS()\nclass YOURGAME_API AAchievementSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAAchievementSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Achievements\")\n\tvoid UnlockAchievement(const FString& AchievementName);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Achievements\")\n\tint32 GetTotalRewardPoints() const;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Achievements\")\n\tTArray<FAchievement> Achievements;\n};\n```", "cpp_code": "```cpp\n#include \"AchievementSystem.h\"\n\nAAchievementSystem::AAchievementSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AAchievementSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Initialize Achievements\n\tAchievements.Add({\"First Kill\", \"Achieve your first kill.\", false, 10});\n\tAchievements.Add({\"Master Explorer\", \"Explore all areas of the map.\", false, 20});\n}\n\nvoid AAchievementSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AAchievementSystem::UnlockAchievement(const FString& AchievementName)\n{\n\tfor (FAchievement& Achievement : Achievements)\n\t{\n\t\tif (Achievement.Name == AchievementName && !Achievement.bIsUnlocked)\n\t\t{\n\t\t\tAchievement.bIsUnlocked = true;\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Achievement Unlocked: %s\"), *Achievement.Name);\n\t\t\t// Add additional logic for rewards here\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint32 AAchievementSystem::GetTotalRewardPoints() const\n{\n\tint32 TotalPoints = 0;\n\tfor (const FAchievement& Achievement : Achievements)\n\t{\n\t\tif (Achievement.bIsUnlocked)\n\t\t{\n\t\t\tTotalPoints += Achievement.RewardPoints;\n\t\t}\n\t}\n\treturn TotalPoints;\n}\n```"}
{"requirement": "Create a dynamic soundtrack that responds to player actions and events.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"DynamicSoundtrackManager.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADynamicSoundtrackManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADynamicSoundtrackManager();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Soundtrack\")\n\tvoid PlayActionSoundtrack();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Soundtrack\")\n\tvoid PlayEventSoundtrack();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Soundtrack\")\n\tUSoundCue* ActionSoundCue;\n\n\tUPROPERTY(EditAnywhere, Category = \"Soundtrack\")\n\tUSoundCue* EventSoundCue;\n\n\tUAudioComponent* AudioComponent;\n\n\tvoid InitializeAudioComponent();\n};\n```", "cpp_code": "```cpp\n#include \"DynamicSoundtrackManager.h\"\n#include \"Components/AudioComponent.h\"\n\nADynamicSoundtrackManager::ADynamicSoundtrackManager()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ADynamicSoundtrackManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitializeAudioComponent();\n}\n\nvoid ADynamicSoundtrackManager::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADynamicSoundtrackManager::InitializeAudioComponent()\n{\n\tAudioComponent = NewObject<UAudioComponent>(this);\n\tAudioComponent->SetupAttachment(RootComponent);\n\tAudioComponent->bAutoActivate = false;\n\tAudioComponent->RegisterComponent();\n}\n\nvoid ADynamicSoundtrackManager::PlayActionSoundtrack()\n{\n\tif (ActionSoundCue && AudioComponent)\n\t{\n\t\tAudioComponent->SetSound(ActionSoundCue);\n\t\tAudioComponent->Play();\n\t}\n}\n\nvoid ADynamicSoundtrackManager::PlayEventSoundtrack()\n{\n\tif (EventSoundCue && AudioComponent)\n\t{\n\t\tAudioComponent->SetSound(EventSoundCue);\n\t\tAudioComponent->Play();\n\t}\n}\n```"}
{"requirement": "Develop an AI-driven dialogue system that simulates realistic conversations.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AIDialogueSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAIDialogueSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAAIDialogueSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to initialize dialogue\n\tUFUNCTION(BlueprintCallable, Category = \"Dialogue\")\n\tvoid StartDialogue();\n\n\t// Function to process player input\n\tUFUNCTION(BlueprintCallable, Category = \"Dialogue\")\n\tFString ProcessPlayerInput(const FString& PlayerInput);\n\nprivate:\n\t// AI model for generating responses\n\tclass AIDialogueModel* DialogueModel;\n\n\t// Function to generate AI response\n\tFString GenerateAIResponse(const FString& PlayerInput);\n};\n```", "cpp_code": "```cpp\n#include \"AIDialogueSystem.h\"\n#include \"AIDialogueModel.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAAIDialogueSystem::AAIDialogueSystem()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the dialogue model\n\tDialogueModel = new AIDialogueModel();\n}\n\n// Called when the game starts or when spawned\nvoid AAIDialogueSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AAIDialogueSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AAIDialogueSystem::StartDialogue()\n{\n\t// Example starting dialogue\n\tUE_LOG(LogTemp, Warning, TEXT(\"AI: Hello, how can I help you today?\"));\n}\n\nFString AAIDialogueSystem::ProcessPlayerInput(const FString& PlayerInput)\n{\n\t// Generate AI response based on player input\n\tFString AIResponse = GenerateAIResponse(PlayerInput);\n\tUE_LOG(LogTemp, Warning, TEXT(\"AI: %s\"), *AIResponse);\n\treturn AIResponse;\n}\n\nFString AAIDialogueSystem::GenerateAIResponse(const FString& PlayerInput)\n{\n\t// Use the AI model to generate a response\n\treturn DialogueModel->GenerateResponse(PlayerInput);\n}\n```"}
{"requirement": "Implement a networking lobby system for matchmaking and team creation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"LobbyGameMode.generated.h\"\n\nUCLASS()\nclass MYGAME_API ALobbyGameMode : public AGameModeBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tALobbyGameMode();\n\n\tvirtual void PostLogin(APlayerController* NewPlayer) override;\n\tvirtual void Logout(AController* Exiting) override;\n\nprotected:\n\tUFUNCTION(BlueprintCallable, Category = \"Lobby\")\n\tvoid StartMatchmaking();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Lobby\")\n\tvoid CreateTeams();\n\nprivate:\n\tvoid UpdateLobby();\n\n\tTArray<APlayerController*> PlayerControllers;\n\n\tint32 MaxPlayers;\n\tint32 TeamSize;\n};\n```", "cpp_code": "```cpp\n#include \"LobbyGameMode.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"TimerManager.h\"\n\nALobbyGameMode::ALobbyGameMode()\n{\n\tMaxPlayers = 10;\n\tTeamSize = 5;\n}\n\nvoid ALobbyGameMode::PostLogin(APlayerController* NewPlayer)\n{\n\tSuper::PostLogin(NewPlayer);\n\n\tPlayerControllers.Add(NewPlayer);\n\tUpdateLobby();\n}\n\nvoid ALobbyGameMode::Logout(AController* Exiting)\n{\n\tSuper::Logout(Exiting);\n\n\tAPlayerController* ExitingPlayer = Cast<APlayerController>(Exiting);\n\tif (ExitingPlayer)\n\t{\n\t\tPlayerControllers.Remove(ExitingPlayer);\n\t\tUpdateLobby();\n\t}\n}\n\nvoid ALobbyGameMode::StartMatchmaking()\n{\n\tif (PlayerControllers.Num() >= MaxPlayers)\n\t{\n\t\tCreateTeams();\n\t\t// Transition to match level or start the game session\n\t}\n}\n\nvoid ALobbyGameMode::CreateTeams()\n{\n\t// Logic for creating teams from PlayerControllers array\n\tint32 TeamCount = PlayerControllers.Num() / TeamSize;\n\tfor (int32 i = 0; i < TeamCount; ++i)\n\t{\n\t\t// Create a team and add players\n\t}\n\t// Handle any remaining players\n}\n\nvoid ALobbyGameMode::UpdateLobby()\n{\n\t// Update lobby UI or state to reflect current players\n\tif (PlayerControllers.Num() == MaxPlayers)\n\t{\n\t\tGetWorldTimerManager().SetTimerForNextTick(this, &ALobbyGameMode::StartMatchmaking);\n\t}\n}\n```"}
{"requirement": "Design a vehicle customization system with a variety of parts and options.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"VehicleCustomizationSystem.generated.h\"\n\nUENUM(BlueprintType)\nenum class ECustomizationPart : uint8\n{\n\tBody UMETA(DisplayName = \"Body\"),\n\tWheels UMETA(DisplayName = \"Wheels\"),\n\tEngine UMETA(DisplayName = \"Engine\"),\n\tPaint UMETA(DisplayName = \"Paint\")\n};\n\nUSTRUCT(BlueprintType)\nstruct FVehiclePartOption\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString PartName;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tfloat Cost;\n};\n\nUCLASS(Blueprintable)\nclass UVehicleCustomizationSystem : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUVehicleCustomizationSystem();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Customization\")\n\tvoid CustomizeVehicle(ECustomizationPart PartType, const FString& OptionName);\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Customization\")\n\tTMap<ECustomizationPart, TArray<FVehiclePartOption>> AvailableParts;\n};\n```", "cpp_code": "```cpp\n#include \"VehicleCustomizationSystem.h\"\n\nUVehicleCustomizationSystem::UVehicleCustomizationSystem()\n{\n\t// Initialize available parts with some default options\n\tAvailableParts.Add(ECustomizationPart::Body, { { \"Standard Body\", 1000.0f }, { \"Sports Body\", 3000.0f } });\n\tAvailableParts.Add(ECustomizationPart::Wheels, { { \"Alloy Wheels\", 500.0f }, { \"Sport Wheels\", 1500.0f } });\n\tAvailableParts.Add(ECustomizationPart::Engine, { { \"V6 Engine\", 5000.0f }, { \"V8 Engine\", 8000.0f } });\n\tAvailableParts.Add(ECustomizationPart::Paint, { { \"Red Paint\", 200.0f }, { \"Blue Paint\", 200.0f } });\n}\n\nvoid UVehicleCustomizationSystem::CustomizeVehicle(ECustomizationPart PartType, const FString& OptionName)\n{\n\tif (AvailableParts.Contains(PartType))\n\t{\n\t\tconst TArray<FVehiclePartOption>& PartOptions = AvailableParts[PartType];\n\t\tfor (const FVehiclePartOption& Option : PartOptions)\n\t\t{\n\t\t\tif (Option.PartName == OptionName)\n\t\t\t{\n\t\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Customizing %s with option: %s\"), *UEnum::GetValueAsString(PartType), *Option.PartName);\n\t\t\t\t// Apply customization logic here\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tUE_LOG(LogTemp, Warning, TEXT(\"Option %s not found for part %s\"), *OptionName, *UEnum::GetValueAsString(PartType));\n}\n```"}
{"requirement": "Create an advanced foliage system that reacts to player movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReactiveFoliage.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AReactiveFoliage : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAReactiveFoliage();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Foliage\")\n\tfloat ReactionRadius;\n\n\tUPROPERTY(EditAnywhere, Category=\"Foliage\")\n\tfloat ReactionStrength;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Foliage\")\n\tvoid ReactToPlayer(AActor* Player);\n\nprivate:\n\tvoid ApplyFoliageEffect();\n};\n```", "cpp_code": "```cpp\n#include \"ReactiveFoliage.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAReactiveFoliage::AReactiveFoliage()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tReactionRadius = 500.0f;\n\tReactionStrength = 1.0f;\n}\n\nvoid AReactiveFoliage::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AReactiveFoliage::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tAActor* Player = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n\tif (Player)\n\t{\n\t\tReactToPlayer(Player);\n\t}\n}\n\nvoid AReactiveFoliage::ReactToPlayer(AActor* Player)\n{\n\tif (!Player)\n\t\treturn;\n\n\tfloat Distance = FVector::Dist(Player->GetActorLocation(), GetActorLocation());\n\tif (Distance <= ReactionRadius)\n\t{\n\t\tApplyFoliageEffect();\n\t}\n}\n\nvoid AReactiveFoliage::ApplyFoliageEffect()\n{\n\t// Implement foliage reaction logic here, such as applying forces or animations\n\tUE_LOG(LogTemp, Warning, TEXT(\"Foliage reacts with strength: %f\"), ReactionStrength);\n}\n```"}
{"requirement": "Develop a heatmap system for tracking player movements and behaviors.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HeatmapTracker.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHeatmapTracker : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAHeatmapTracker();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable)\n\tvoid RecordPlayerPosition(FVector PlayerPosition);\n\n\tUFUNCTION(BlueprintCallable)\n\tTMap<FVector, int32> GetHeatmapData() const;\n\nprivate:\n\tTMap<FVector, int32> HeatmapData;\n\tvoid UpdateHeatmap(FVector Position);\n};\n```", "cpp_code": "```cpp\n#include \"HeatmapTracker.h\"\n\nAHeatmapTracker::AHeatmapTracker()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AHeatmapTracker::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHeatmapTracker::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHeatmapTracker::RecordPlayerPosition(FVector PlayerPosition)\n{\n\tUpdateHeatmap(PlayerPosition);\n}\n\nTMap<FVector, int32> AHeatmapTracker::GetHeatmapData() const\n{\n\treturn HeatmapData;\n}\n\nvoid AHeatmapTracker::UpdateHeatmap(FVector Position)\n{\n\tif (HeatmapData.Contains(Position))\n\t{\n\t\tHeatmapData[Position] += 1;\n\t}\n\telse\n\t{\n\t\tHeatmapData.Add(Position, 1);\n\t}\n}\n```"}
{"requirement": "Integrate a real-time reflection system for water and glass surfaces.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReflectionSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AReflectionSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAReflectionSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPlanarReflectionComponent* WaterReflection;\n\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPlanarReflectionComponent* GlassReflection;\n\n\tvoid SetupReflectionComponents();\n};\n```", "cpp_code": "```cpp\n#include \"ReflectionSystem.h\"\n#include \"Components/PlanarReflectionComponent.h\"\n#include \"Engine/Engine.h\"\n\nAReflectionSystem::AReflectionSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tWaterReflection = CreateDefaultSubobject<UPlanarReflectionComponent>(TEXT(\"WaterReflection\"));\n\tWaterReflection->SetupAttachment(RootComponent);\n\n\tGlassReflection = CreateDefaultSubobject<UPlanarReflectionComponent>(TEXT(\"GlassReflection\"));\n\tGlassReflection->SetupAttachment(RootComponent);\n\n\tSetupReflectionComponents();\n}\n\nvoid AReflectionSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AReflectionSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AReflectionSystem::SetupReflectionComponents()\n{\n\tif (WaterReflection)\n\t{\n\t\tWaterReflection->bShowPreviewPlane = true;\n\t\tWaterReflection->ScreenPercentage = 100;\n\t\tWaterReflection->NormalDistortionStrength = 500;\n\t\tWaterReflection->CaptureMaterial = nullptr; // Assign a specific water reflection material if available\n\t}\n\n\tif (GlassReflection)\n\t{\n\t\tGlassReflection->bShowPreviewPlane = true;\n\t\tGlassReflection->ScreenPercentage = 100;\n\t\tGlassReflection->NormalDistortionStrength = 250;\n\t\tGlassReflection->CaptureMaterial = nullptr; // Assign a specific glass reflection material if available\n\t}\n}\n```"}
{"requirement": "Design a destructible environment system with realistic debris physics.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DestructibleEnvironment.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADestructibleEnvironment : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADestructibleEnvironment();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to apply damage to the destructible object\n\tUFUNCTION(BlueprintCallable, Category = \"Destruction\")\n\tvoid ApplyDamage(float DamageAmount, FVector HitLocation, FVector ImpulseDirection);\n\nprivate:\n\t// Destructible mesh component\n\tUPROPERTY(VisibleAnywhere, Category = \"Destruction\")\n\tclass UDestructibleComponent* DestructibleComponent;\n\n\t// Damage threshold\n\tUPROPERTY(EditDefaultsOnly, Category = \"Destruction\")\n\tfloat DamageThreshold;\n};\n```", "cpp_code": "```cpp\n#include \"DestructibleEnvironment.h\"\n#include \"DestructibleComponent.h\"\n\n// Sets default values\nADestructibleEnvironment::ADestructibleEnvironment()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create destructible component\n\tDestructibleComponent = CreateDefaultSubobject<UDestructibleComponent>(TEXT(\"DestructibleComponent\"));\n\tRootComponent = DestructibleComponent;\n\n\t// Set default damage threshold\n\tDamageThreshold = 25.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ADestructibleEnvironment::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ADestructibleEnvironment::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADestructibleEnvironment::ApplyDamage(float DamageAmount, FVector HitLocation, FVector ImpulseDirection)\n{\n\tif (DestructibleComponent && DamageAmount >= DamageThreshold)\n\t{\n\t\t// Apply damage to the destructible mesh\n\t\tDestructibleComponent->ApplyDamage(DamageAmount, HitLocation, ImpulseDirection, 1000.0f);\n\t}\n}\n```"}
{"requirement": "Implement a character emotion system that influences dialogue and actions.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"EmotionCharacter.generated.h\"\n\nUENUM(BlueprintType)\nenum class EEmotionState : uint8\n{\n\tNeutral UMETA(DisplayName = \"Neutral\"),\n\tHappy UMETA(DisplayName = \"Happy\"),\n\tSad UMETA(DisplayName = \"Sad\"),\n\tAngry UMETA(DisplayName = \"Angry\")\n};\n\nUCLASS()\nclass MYGAME_API AEmotionCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAEmotionCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Emotion\")\n\tvoid SetEmotionState(EEmotionState NewState);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Emotion\")\n\tEEmotionState GetEmotionState() const;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Emotion\")\n\tvoid PerformActionBasedOnEmotion();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Emotion\")\n\tFString GetDialogueBasedOnEmotion() const;\n\nprivate:\n\tEEmotionState CurrentEmotionState;\n\n\tvoid UpdateCharacterBehavior();\n};\n```", "cpp_code": "```cpp\n#include \"EmotionCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n\nAEmotionCharacter::AEmotionCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentEmotionState = EEmotionState::Neutral;\n}\n\nvoid AEmotionCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AEmotionCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateCharacterBehavior();\n}\n\nvoid AEmotionCharacter::SetEmotionState(EEmotionState NewState)\n{\n\tif (CurrentEmotionState != NewState)\n\t{\n\t\tCurrentEmotionState = NewState;\n\t\tUpdateCharacterBehavior();\n\t}\n}\n\nEEmotionState AEmotionCharacter::GetEmotionState() const\n{\n\treturn CurrentEmotionState;\n}\n\nvoid AEmotionCharacter::PerformActionBasedOnEmotion()\n{\n\tswitch (CurrentEmotionState)\n\t{\n\tcase EEmotionState::Happy:\n\t\tUKismetSystemLibrary::PrintString(this, TEXT(\"Character is jumping with joy!\"));\n\t\tbreak;\n\tcase EEmotionState::Sad:\n\t\tUKismetSystemLibrary::PrintString(this, TEXT(\"Character is sitting down sadly.\"));\n\t\tbreak;\n\tcase EEmotionState::Angry:\n\t\tUKismetSystemLibrary::PrintString(this, TEXT(\"Character is stomping angrily!\"));\n\t\tbreak;\n\tdefault:\n\t\tUKismetSystemLibrary::PrintString(this, TEXT(\"Character is standing still.\"));\n\t\tbreak;\n\t}\n}\n\nFString AEmotionCharacter::GetDialogueBasedOnEmotion() const\n{\n\tswitch (CurrentEmotionState)\n\t{\n\tcase EEmotionState::Happy:\n\t\treturn TEXT(\"I'm feeling great today!\");\n\tcase EEmotionState::Sad:\n\t\treturn TEXT(\"I'm not feeling so good...\");\n\tcase EEmotionState::Angry:\n\t\treturn TEXT(\"I'm really upset right now!\");\n\tdefault:\n\t\treturn TEXT(\"Hello there.\");\n\t}\n}\n\nvoid AEmotionCharacter::UpdateCharacterBehavior()\n{\n\t// This function could be expanded to influence animations, sounds, etc.\n\tPerformActionBasedOnEmotion();\n}\n```"}
{"requirement": "Create a virtual marketplace for players to buy and sell in-game items.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Marketplace.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FItem\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString ItemName;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 ItemID;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tfloat Price;\n};\n\nUCLASS()\nclass YOURGAME_API AMarketplace : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMarketplace();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Marketplace\")\n\tbool BuyItem(int32 ItemID, int32 BuyerID);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Marketplace\")\n\tbool SellItem(FItem Item, int32 SellerID);\n\nprivate:\n\tUPROPERTY()\n\tTArray<FItem> ItemsForSale;\n\n\tUPROPERTY()\n\tTMap<int32, float> PlayerBalances;\n};\n```", "cpp_code": "```cpp\n#include \"Marketplace.h\"\n\nAMarketplace::AMarketplace()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMarketplace::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMarketplace::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nbool AMarketplace::BuyItem(int32 ItemID, int32 BuyerID)\n{\n\tfor (FItem& Item : ItemsForSale)\n\t{\n\t\tif (Item.ItemID == ItemID)\n\t\t{\n\t\t\tif (PlayerBalances.Contains(BuyerID) && PlayerBalances[BuyerID] >= Item.Price)\n\t\t\t{\n\t\t\t\tPlayerBalances[BuyerID] -= Item.Price;\n\t\t\t\tItemsForSale.Remove(Item);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool AMarketplace::SellItem(FItem Item, int32 SellerID)\n{\n\tItemsForSale.Add(Item);\n\tif (!PlayerBalances.Contains(SellerID))\n\t{\n\t\tPlayerBalances.Add(SellerID, 0.0f);\n\t}\n\treturn true;\n}\n```"}
{"requirement": "Develop an AI companion system that assists players during combat.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"AICompanionCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AAICompanionCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tAAICompanionCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Assist player in combat\n\tUFUNCTION(BlueprintCallable, Category=\"AI\")\n\tvoid AssistPlayerInCombat();\n\nprivate:\n\t// Helper functions\n\tvoid FindClosestEnemy();\n\tvoid AttackEnemy();\n\n\t// Variables\n\tAActor* PlayerCharacter;\n\tAActor* CurrentTarget;\n\n};\n```", "cpp_code": "```cpp\n#include \"AICompanionCharacter.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAAICompanionCharacter::AAICompanionCharacter()\n{\n\t// Set this character to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AAICompanionCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);\n\tCurrentTarget = nullptr;\n}\n\n// Called every frame\nvoid AAICompanionCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tAssistPlayerInCombat();\n}\n\n// Called to bind functionality to input\nvoid AAICompanionCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\nvoid AAICompanionCharacter::AssistPlayerInCombat()\n{\n\tFindClosestEnemy();\n\tif (CurrentTarget)\n\t{\n\t\tAttackEnemy();\n\t}\n}\n\nvoid AAICompanionCharacter::FindClosestEnemy()\n{\n\t// Logic to find the closest enemy to the player character\n\t// This is a placeholder for actual implementation\n\tTArray<AActor*> Enemies;\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), ACharacter::StaticClass(), Enemies);\n\n\tAActor* ClosestEnemy = nullptr;\n\tfloat MinDistance = FLT_MAX;\n\n\tfor (AActor* Enemy : Enemies)\n\t{\n\t\tfloat Distance = FVector::Dist(PlayerCharacter->GetActorLocation(), Enemy->GetActorLocation());\n\t\tif (Distance < MinDistance)\n\t\t{\n\t\t\tMinDistance = Distance;\n\t\t\tClosestEnemy = Enemy;\n\t\t}\n\t}\n\n\tCurrentTarget = ClosestEnemy;\n}\n\nvoid AAICompanionCharacter::AttackEnemy()\n{\n\t// Logic to attack the current target\n\t// This is a placeholder for actual implementation\n\tif (CurrentTarget)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Attacking enemy: %s\"), *CurrentTarget->GetName());\n\t}\n}\n```"}
{"requirement": "Construct a gravity-altering mechanic for a physics-based puzzle game.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GravityAlterer.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AGravityAlterer : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAGravityAlterer();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to alter gravity\n\tUFUNCTION(BlueprintCallable, Category=\"Gravity\")\n\tvoid AlterGravity(float NewGravityScale);\n\nprivate:\n\t// Store the original gravity scale\n\tfloat OriginalGravityScale;\n\n\t// Current gravity scale\n\tfloat CurrentGravityScale;\n};\n```", "cpp_code": "```cpp\n#include \"GravityAlterer.h\"\n#include \"GameFramework/Character.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAGravityAlterer::AGravityAlterer()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\tOriginalGravityScale = 1.0f;\n\tCurrentGravityScale = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AGravityAlterer::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Cache the original gravity scale from the world settings\n\tif (ACharacter* PlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0))\n\t{\n\t\tOriginalGravityScale = PlayerCharacter->GetCharacterMovement()->GravityScale;\n\t}\n}\n\n// Called every frame\nvoid AGravityAlterer::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to alter gravity\nvoid AGravityAlterer::AlterGravity(float NewGravityScale)\n{\n\tif (ACharacter* PlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0))\n\t{\n\t\tPlayerCharacter->GetCharacterMovement()->GravityScale = NewGravityScale;\n\t\tCurrentGravityScale = NewGravityScale;\n\t}\n}\n```"}
{"requirement": "Integrate a procedural animation system for natural character movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"ProceduralCharacter.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AProceduralCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAProceduralCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid UpdateProceduralAnimation(float DeltaTime);\n\nprivate:\n\tFVector CalculateFootIKPosition(const FVector& FootLocation);\n\n\tUPROPERTY(EditAnywhere, Category = \"Procedural Animation\")\n\tfloat FootIKOffset;\n};\n```", "cpp_code": "```cpp\n#include \"ProceduralCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\nAProceduralCharacter::AProceduralCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tFootIKOffset = 10.0f; // Default foot offset value\n}\n\nvoid AProceduralCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AProceduralCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateProceduralAnimation(DeltaTime);\n}\n\nvoid AProceduralCharacter::UpdateProceduralAnimation(float DeltaTime)\n{\n\t// Placeholder for logic to update procedural animation\n\t// Example: Adjust foot positions based on terrain\n\tFVector LeftFootLocation = GetMesh()->GetBoneLocation(FName(\"foot_l\"));\n\tFVector RightFootLocation = GetMesh()->GetBoneLocation(FName(\"foot_r\"));\n\n\tFVector NewLeftFootIKPosition = CalculateFootIKPosition(LeftFootLocation);\n\tFVector NewRightFootIKPosition = CalculateFootIKPosition(RightFootLocation);\n\n\t// Apply IK adjustments (example)\n\t// This would typically involve adjusting the skeleton/mesh bones\n\t// GetMesh()->SetBoneLocationByName(FName(\"foot_l\"), NewLeftFootIKPosition, EBoneSpaces::WorldSpace);\n\t// GetMesh()->SetBoneLocationByName(FName(\"foot_r\"), NewRightFootIKPosition, EBoneSpaces::WorldSpace);\n}\n\nFVector AProceduralCharacter::CalculateFootIKPosition(const FVector& FootLocation)\n{\n\t// Simple example of adjusting foot location\n\t// In practice, you'd perform raycasts and more complex calculations\n\tFVector AdjustedPosition = FootLocation;\n\tAdjustedPosition.Z -= FootIKOffset; // Move foot down by offset\n\treturn AdjustedPosition;\n}\n```"}
{"requirement": "Design a combat system with diverse weapons and special abilities.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CombatSystem.generated.h\"\n\nUENUM(BlueprintType)\nenum class EWeaponType : uint8\n{\n\tEWT_Sword UMETA(DisplayName = \"Sword\"),\n\tEWT_Bow UMETA(DisplayName = \"Bow\"),\n\tEWT_Staff UMETA(DisplayName = \"Staff\")\n};\n\nUCLASS()\nclass YOURGAME_API AWeapon : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWeapon();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Weapon\")\n\tEWeaponType WeaponType;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Weapon\")\n\tfloat Damage;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Combat\")\n\tvirtual void Attack();\n};\n\nUCLASS()\nclass YOURGAME_API ACombatCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tACombatCharacter();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Combat\")\n\tTArray<AWeapon*> Inventory;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Combat\")\n\tAWeapon* CurrentWeapon;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Combat\")\n\tvoid SwitchWeapon(int32 WeaponIndex);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Combat\")\n\tvoid UseSpecialAbility();\n\nprotected:\n\tUFUNCTION()\n\tvoid SwordSpecialAbility();\n\n\tUFUNCTION()\n\tvoid BowSpecialAbility();\n\n\tUFUNCTION()\n\tvoid StaffSpecialAbility();\n};\n```", "cpp_code": "```cpp\n#include \"CombatSystem.h\"\n#include \"GameFramework/Actor.h\"\n\nAWeapon::AWeapon()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tDamage = 10.0f;\n\tWeaponType = EWeaponType::EWT_Sword;\n}\n\nvoid AWeapon::Attack()\n{\n\t// Attack logic based on WeaponType\n\tswitch (WeaponType)\n\t{\n\tcase EWeaponType::EWT_Sword:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Sword attack!\"));\n\t\tbreak;\n\tcase EWeaponType::EWT_Bow:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Bow attack!\"));\n\t\tbreak;\n\tcase EWeaponType::EWT_Staff:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Staff attack!\"));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nACombatCharacter::ACombatCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentWeapon = nullptr;\n}\n\nvoid ACombatCharacter::SwitchWeapon(int32 WeaponIndex)\n{\n\tif (Inventory.IsValidIndex(WeaponIndex))\n\t{\n\t\tCurrentWeapon = Inventory[WeaponIndex];\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Switched weapon to index: %d\"), WeaponIndex);\n\t}\n}\n\nvoid ACombatCharacter::UseSpecialAbility()\n{\n\tif (!CurrentWeapon) return;\n\n\tswitch (CurrentWeapon->WeaponType)\n\t{\n\tcase EWeaponType::EWT_Sword:\n\t\tSwordSpecialAbility();\n\t\tbreak;\n\tcase EWeaponType::EWT_Bow:\n\t\tBowSpecialAbility();\n\t\tbreak;\n\tcase EWeaponType::EWT_Staff:\n\t\tStaffSpecialAbility();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid ACombatCharacter::SwordSpecialAbility()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Unleashing Sword Special Ability!\"));\n\t// Implement sword special ability logic\n}\n\nvoid ACombatCharacter::BowSpecialAbility()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Unleashing Bow Special Ability!\"));\n\t// Implement bow special ability logic\n}\n\nvoid ACombatCharacter::StaffSpecialAbility()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Unleashing Staff Special Ability!\"));\n\t// Implement staff special ability logic\n}\n```"}
{"requirement": "Create a scoring system for tracking player performance and high scores.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoringSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AScoringSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScoringSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Scoring\")\n\tvoid AddScore(int32 Points);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Scoring\")\n\tint32 GetScore() const;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Scoring\")\n\tvoid ResetScore();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Scoring\")\n\tvoid AddHighScore(int32 Score);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Scoring\")\n\tTArray<int32> GetHighScores() const;\n\nprivate:\n\tint32 CurrentScore;\n\tTArray<int32> HighScores;\n};\n```", "cpp_code": "```cpp\n#include \"ScoringSystem.h\"\n\nAScoringSystem::AScoringSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentScore = 0;\n}\n\nvoid AScoringSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScoringSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScoringSystem::AddScore(int32 Points)\n{\n\tCurrentScore += Points;\n}\n\nint32 AScoringSystem::GetScore() const\n{\n\treturn CurrentScore;\n}\n\nvoid AScoringSystem::ResetScore()\n{\n\tCurrentScore = 0;\n}\n\nvoid AScoringSystem::AddHighScore(int32 Score)\n{\n\tHighScores.Add(Score);\n\tHighScores.Sort([](const int32& A, const int32& B) {\n\t\treturn A > B;\n\t});\n}\n\nTArray<int32> AScoringSystem::GetHighScores() const\n{\n\treturn HighScores;\n}\n```"}
{"requirement": "Develop a spectator mode for watching multiplayer matches live.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"SpectatorPlayerController.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASpectatorPlayerController : public APlayerController\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpectatorPlayerController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void SetupInputComponent() override;\n\nprivate:\n\tvoid ToggleSpectatorMode();\n};\n```", "cpp_code": "```cpp\n#include \"SpectatorPlayerController.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/SpectatorPawn.h\"\n#include \"Engine/World.h\"\n\nASpectatorPlayerController::ASpectatorPlayerController()\n{\n\t// Set this player controller to not possess a pawn at start\n\tbAutoManageActiveCameraTarget = false;\n}\n\nvoid ASpectatorPlayerController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tToggleSpectatorMode();\n}\n\nvoid ASpectatorPlayerController::SetupInputComponent()\n{\n\tSuper::SetupInputComponent();\n\tInputComponent->BindAction(\"ToggleSpectatorMode\", IE_Pressed, this, &ASpectatorPlayerController::ToggleSpectatorMode);\n}\n\nvoid ASpectatorPlayerController::ToggleSpectatorMode()\n{\n\tif (IsInState(NAME_Spectating))\n\t{\n\t\t// If already spectating, return to player mode or switch camera\n\t\tChangeState(NAME_Playing);\n\t}\n\telse\n\t{\n\t\t// Switch to spectator mode\n\t\tChangeState(NAME_Spectating);\n\t\tif (GetSpectatorPawn() == nullptr)\n\t\t{\n\t\t\t// Spawn a spectator pawn if doesn't exist\n\t\t\tASpectatorPawn* NewSpectatorPawn = GetWorld()->SpawnActor<ASpectatorPawn>(ASpectatorPawn::StaticClass(), FVector::ZeroVector, FRotator::ZeroRotator);\n\t\t\tPossess(NewSpectatorPawn);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a 3D minimap system that updates based on player exploration.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MinimapSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AMinimapSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMinimapSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to update the minimap based on player exploration\n\tUFUNCTION()\n\tvoid UpdateMinimap();\n\nprivate:\n\t// Minimap texture\n\tUPROPERTY(EditAnywhere, Category = \"Minimap\")\n\tUTexture2D* MinimapTexture;\n\n\t// Player reference\n\tUPROPERTY()\n\tAPlayerController* PlayerController;\n};\n```", "cpp_code": "```cpp\n#include \"MinimapSystem.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Texture2D.h\"\n\n// Sets default values\nAMinimapSystem::AMinimapSystem()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMinimapSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Initialize player controller\n\tPlayerController = GetWorld()->GetFirstPlayerController();\n\n\t// Initialize the minimap texture if needed\n\tif (!MinimapTexture)\n\t{\n\t\tMinimapTexture = NewObject<UTexture2D>(this, UTexture2D::StaticClass());\n\t}\n}\n\n// Called every frame\nvoid AMinimapSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update the minimap every frame\n\tUpdateMinimap();\n}\n\n// Function to update the minimap based on player exploration\nvoid AMinimapSystem::UpdateMinimap()\n{\n\tif (PlayerController)\n\t{\n\t\t// Logic to update the minimap texture based on player position\n\t\tFVector PlayerLocation = PlayerController->GetPawn()->GetActorLocation();\n\n\t\t// Example logic to modify the minimap texture (not implemented)\n\t\t// You can draw on the texture or update its UVs based on the player's location\n\t}\n}\n```"}
{"requirement": "Create a particle effect editor for designing custom visual effects.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"ParticleEffectEditor.generated.h\"\n\nUCLASS(Blueprintable)\nclass MYPROJECT_API UParticleEffectEditor : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUParticleEffectEditor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Particle Effect\")\n\tvoid CreateNewEffect(const FString& EffectName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Particle Effect\")\n\tvoid AddEmitterToEffect(const FString& EffectName, const FString& EmitterName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Particle Effect\")\n\tvoid SetEmitterParameter(const FString& EmitterName, const FString& ParameterName, float Value);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Particle Effect\")\n\tvoid SaveEffect(const FString& EffectName);\n\nprivate:\n\tTMap<FString, class UParticleSystem*> ParticleEffects;\n};\n```", "cpp_code": "```cpp\n#include \"ParticleEffectEditor.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleEmitter.h\"\n#include \"Engine/World.h\"\n\nUParticleEffectEditor::UParticleEffectEditor()\n{\n\t// Constructor logic if needed\n}\n\nvoid UParticleEffectEditor::CreateNewEffect(const FString& EffectName)\n{\n\tif (!ParticleEffects.Contains(EffectName))\n\t{\n\t\tUParticleSystem* NewEffect = NewObject<UParticleSystem>(this, UParticleSystem::StaticClass(), *EffectName);\n\t\tParticleEffects.Add(EffectName, NewEffect);\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Created new particle effect: %s\"), *EffectName);\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Effect %s already exists!\"), *EffectName);\n\t}\n}\n\nvoid UParticleEffectEditor::AddEmitterToEffect(const FString& EffectName, const FString& EmitterName)\n{\n\tif (UParticleSystem** FoundEffect = ParticleEffects.Find(EffectName))\n\t{\n\t\tUParticleEmitter* NewEmitter = NewObject<UParticleEmitter>(this, UParticleEmitter::StaticClass(), *EmitterName);\n\t\t(*FoundEffect)->Emitters.Add(NewEmitter);\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Added emitter %s to effect %s\"), *EmitterName, *EffectName);\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Effect %s not found!\"), *EffectName);\n\t}\n}\n\nvoid UParticleEffectEditor::SetEmitterParameter(const FString& EmitterName, const FString& ParameterName, float Value)\n{\n\tfor (auto& EffectPair : ParticleEffects)\n\t{\n\t\tfor (UParticleEmitter* Emitter : EffectPair.Value->Emitters)\n\t\t{\n\t\t\tif (Emitter->GetName() == EmitterName)\n\t\t\t{\n\t\t\t\t// Example: Modify an emitter parameter\n\t\t\t\t// This is a placeholder; real implementation depends on the parameter structure\n\t\t\t\t// Emitter->SetFloatParameter(ParameterName, Value);\n\t\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Set parameter %s to %f on emitter %s\"), *ParameterName, Value, *EmitterName);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tUE_LOG(LogTemp, Warning, TEXT(\"Emitter %s not found!\"), *EmitterName);\n}\n\nvoid UParticleEffectEditor::SaveEffect(const FString& EffectName)\n{\n\tif (UParticleSystem** FoundEffect = ParticleEffects.Find(EffectName))\n\t{\n\t\t// Saving logic here, could involve writing to disk or saving in memory\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Saved effect %s\"), *EffectName);\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Effect %s not found!\"), *EffectName);\n\t}\n}\n```"}
{"requirement": "Develop a seamless world streaming system for large open-world games.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WorldStreamingManager.generated.h\"\n\nUCLASS()\nclass OPENWORLDGAME_API AWorldStreamingManager : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAWorldStreamingManager();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid StreamInLevels();\n\tvoid StreamOutLevels();\n\t\n\tUPROPERTY(EditAnywhere, Category=\"Streaming\")\n\tTArray<FName> LevelsToStream;\n\t\n\tUPROPERTY(EditAnywhere, Category=\"Streaming\")\n\tfloat LoadRadius;\n\n\tUPROPERTY(EditAnywhere, Category=\"Streaming\")\n\tfloat UnloadRadius;\n\n\tUPROPERTY(VisibleAnywhere, Category=\"Streaming\")\n\tAPlayerController* PlayerController;\n};\n```", "cpp_code": "```cpp\n#include \"WorldStreamingManager.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAWorldStreamingManager::AWorldStreamingManager()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tLoadRadius = 5000.0f;\n\tUnloadRadius = 6000.0f;\n}\n\nvoid AWorldStreamingManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n}\n\nvoid AWorldStreamingManager::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tStreamInLevels();\n\tStreamOutLevels();\n}\n\nvoid AWorldStreamingManager::StreamInLevels()\n{\n\tif (!PlayerController) return;\n\n\tFVector PlayerLocation = PlayerController->GetPawn()->GetActorLocation();\n\n\tfor (const FName& LevelName : LevelsToStream)\n\t{\n\t\tULevelStreaming* Level = UGameplayStatics::GetStreamingLevel(this, LevelName);\n\t\tif (Level && !Level->IsLevelLoaded())\n\t\t{\n\t\t\tFVector LevelLocation = FVector(0); // Assume origin or calculate based on design\n\t\t\tfloat Distance = FVector::Dist(PlayerLocation, LevelLocation);\n\t\t\tif (Distance < LoadRadius)\n\t\t\t{\n\t\t\t\tLevel->SetShouldBeLoaded(true);\n\t\t\t\tLevel->SetShouldBeVisible(true);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid AWorldStreamingManager::StreamOutLevels()\n{\n\tif (!PlayerController) return;\n\n\tFVector PlayerLocation = PlayerController->GetPawn()->GetActorLocation();\n\n\tfor (const FName& LevelName : LevelsToStream)\n\t{\n\t\tULevelStreaming* Level = UGameplayStatics::GetStreamingLevel(this, LevelName);\n\t\tif (Level && Level->IsLevelLoaded())\n\t\t{\n\t\t\tFVector LevelLocation = FVector(0); // Assume origin or calculate based on design\n\t\t\tfloat Distance = FVector::Dist(PlayerLocation, LevelLocation);\n\t\t\tif (Distance > UnloadRadius)\n\t\t\t{\n\t\t\t\tLevel->SetShouldBeLoaded(false);\n\t\t\t\tLevel->SetShouldBeVisible(false);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Design an interactive tutorial system that adapts to player skill level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TutorialSystem.generated.h\"\n\nUCLASS()\nclass MYGAME_API ATutorialSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATutorialSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Tutorial\")\n\tfloat PlayerSkillLevel;\n\n\tUPROPERTY(EditAnywhere, Category = \"Tutorial\")\n\tTArray<FString> BeginnerTutorials;\n\n\tUPROPERTY(EditAnywhere, Category = \"Tutorial\")\n\tTArray<FString> IntermediateTutorials;\n\n\tUPROPERTY(EditAnywhere, Category = \"Tutorial\")\n\tTArray<FString> AdvancedTutorials;\n\n\tvoid DetermineTutorials();\n\n\tvoid DisplayTutorial(FString Tutorial);\n\n\tvoid UpdatePlayerSkillLevel();\n};\n```", "cpp_code": "```cpp\n#include \"TutorialSystem.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nATutorialSystem::ATutorialSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tPlayerSkillLevel = 0.0f;\n}\n\nvoid ATutorialSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tDetermineTutorials();\n}\n\nvoid ATutorialSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdatePlayerSkillLevel();\n}\n\nvoid ATutorialSystem::DetermineTutorials()\n{\n\tif (PlayerSkillLevel < 3.0f)\n\t{\n\t\tfor (const FString& Tutorial : BeginnerTutorials)\n\t\t{\n\t\t\tDisplayTutorial(Tutorial);\n\t\t}\n\t}\n\telse if (PlayerSkillLevel < 7.0f)\n\t{\n\t\tfor (const FString& Tutorial : IntermediateTutorials)\n\t\t{\n\t\t\tDisplayTutorial(Tutorial);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (const FString& Tutorial : AdvancedTutorials)\n\t\t{\n\t\t\tDisplayTutorial(Tutorial);\n\t\t}\n\t}\n}\n\nvoid ATutorialSystem::DisplayTutorial(FString Tutorial)\n{\n\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, Tutorial);\n}\n\nvoid ATutorialSystem::UpdatePlayerSkillLevel()\n{\n\t// Placeholder logic for updating player skill level\n\t// This should be replaced with actual game logic\n\tPlayerSkillLevel += FMath::RandRange(-0.1f, 0.1f);\n\tPlayerSkillLevel = FMath::Clamp(PlayerSkillLevel, 0.0f, 10.0f);\n}\n```"}
{"requirement": "Implement an advanced skin shader for realistic character rendering.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AdvancedSkinShader.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAdvancedSkinShader : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAAdvancedSkinShader();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"SkinShader\")\n\tUMaterialInstanceDynamic* SkinMaterialInstance;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"SkinShader\")\n\tUTexture* DiffuseTexture;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"SkinShader\")\n\tUTexture* NormalMap;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"SkinShader\")\n\tUTexture* SpecularMap;\n\n\tUFUNCTION(BlueprintCallable, Category = \"SkinShader\")\n\tvoid UpdateShaderParameters(float Roughness, float Specular, float Subsurface);\n};\n```", "cpp_code": "```cpp\n#include \"AdvancedSkinShader.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/Material.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAAdvancedSkinShader::AAdvancedSkinShader()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Load default material\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> Material(TEXT(\"Material'/Game/Materials/M_Skin'\"));\n\tif (Material.Succeeded())\n\t{\n\t\tSkinMaterialInstance = UMaterialInstanceDynamic::Create(Material.Object, this);\n\t}\n}\n\nvoid AAdvancedSkinShader::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (SkinMaterialInstance)\n\t{\n\t\tif (DiffuseTexture)\n\t\t{\n\t\t\tSkinMaterialInstance->SetTextureParameterValue(\"Diffuse\", DiffuseTexture);\n\t\t}\n\t\tif (NormalMap)\n\t\t{\n\t\t\tSkinMaterialInstance->SetTextureParameterValue(\"Normal\", NormalMap);\n\t\t}\n\t\tif (SpecularMap)\n\t\t{\n\t\t\tSkinMaterialInstance->SetTextureParameterValue(\"Specular\", SpecularMap);\n\t\t}\n\t}\n}\n\nvoid AAdvancedSkinShader::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update any runtime changes if necessary\n}\n\nvoid AAdvancedSkinShader::UpdateShaderParameters(float Roughness, float Specular, float Subsurface)\n{\n\tif (SkinMaterialInstance)\n\t{\n\t\tSkinMaterialInstance->SetScalarParameterValue(\"Roughness\", Roughness);\n\t\tSkinMaterialInstance->SetScalarParameterValue(\"Specular\", Specular);\n\t\tSkinMaterialInstance->SetScalarParameterValue(\"Subsurface\", Subsurface);\n\t}\n}\n```"}
{"requirement": "Create a teleportation system for fast travel between locations.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TeleportationSystem.generated.h\"\n\nUCLASS()\nclass MYGAME_API ATeleportationSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tATeleportationSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category = \"Teleportation\")\n\tvoid TeleportToLocation(const FVector& Destination);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Teleportation\")\n\tfloat TeleportCooldown;\n\n\tfloat LastTeleportTime;\n\n\tbool CanTeleport() const;\n};\n```", "cpp_code": "```cpp\n#include \"TeleportationSystem.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nATeleportationSystem::ATeleportationSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTeleportCooldown = 5.0f; // Cooldown in seconds\n\tLastTeleportTime = -TeleportCooldown; // Allow immediate teleport on start\n}\n\nvoid ATeleportationSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATeleportationSystem::TeleportToLocation(const FVector& Destination)\n{\n\tif (CanTeleport())\n\t{\n\t\tAActor* Owner = GetOwner();\n\t\tif (Owner)\n\t\t{\n\t\t\tOwner->SetActorLocation(Destination);\n\t\t\tLastTeleportTime = UGameplayStatics::GetRealTimeSeconds(GetWorld());\n\t\t}\n\t}\n}\n\nbool ATeleportationSystem::CanTeleport() const\n{\n\tfloat CurrentTime = UGameplayStatics::GetRealTimeSeconds(GetWorld());\n\treturn (CurrentTime - LastTeleportTime) >= TeleportCooldown;\n}\n```"}
{"requirement": "Develop a VR locomotion system with multiple comfort settings.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"VRLocomotionSystem.generated.h\"\n\nUENUM(BlueprintType)\nenum class EComfortSetting : uint8 {\n\tNone UMETA(DisplayName = \"None\"),\n\tSnapTurning UMETA(DisplayName = \"Snap Turning\"),\n\tSmoothTurning UMETA(DisplayName = \"Smooth Turning\"),\n\tTeleport UMETA(DisplayName = \"Teleport\")\n};\n\nUCLASS()\nclass VRPROJECT_API AVRLocomotionSystem : public APawn {\n\tGENERATED_BODY()\n\npublic:\n\tAVRLocomotionSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"VR Locomotion\")\n\tEComfortSetting ComfortSetting;\n\n\tUFUNCTION(BlueprintCallable, Category = \"VR Locomotion\")\n\tvoid SetComfortSetting(EComfortSetting NewSetting);\n\nprivate:\n\tvoid HandleLocomotion(float DeltaTime);\n\tvoid PerformSnapTurning();\n\tvoid PerformSmoothTurning(float DeltaTime);\n\tvoid PerformTeleport();\n};\n```", "cpp_code": "```cpp\n#include \"VRLocomotionSystem.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\nAVRLocomotionSystem::AVRLocomotionSystem() {\n\tPrimaryActorTick.bCanEverTick = true;\n\tComfortSetting = EComfortSetting::None;\n}\n\nvoid AVRLocomotionSystem::BeginPlay() {\n\tSuper::BeginPlay();\n}\n\nvoid AVRLocomotionSystem::Tick(float DeltaTime) {\n\tSuper::Tick(DeltaTime);\n\tHandleLocomotion(DeltaTime);\n}\n\nvoid AVRLocomotionSystem::SetComfortSetting(EComfortSetting NewSetting) {\n\tComfortSetting = NewSetting;\n}\n\nvoid AVRLocomotionSystem::HandleLocomotion(float DeltaTime) {\n\tswitch (ComfortSetting) {\n\t\tcase EComfortSetting::SnapTurning:\n\t\t\tPerformSnapTurning();\n\t\t\tbreak;\n\t\tcase EComfortSetting::SmoothTurning:\n\t\t\tPerformSmoothTurning(DeltaTime);\n\t\t\tbreak;\n\t\tcase EComfortSetting::Teleport:\n\t\t\tPerformTeleport();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n\nvoid AVRLocomotionSystem::PerformSnapTurning() {\n\t// Snap turning logic\n\tAPlayerController* PC = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PC) {\n\t\tFRotator NewRotation = PC->GetControlRotation();\n\t\tNewRotation.Yaw += 45.f; // Example snap angle\n\t\tPC->SetControlRotation(NewRotation);\n\t}\n}\n\nvoid AVRLocomotionSystem::PerformSmoothTurning(float DeltaTime) {\n\t// Smooth turning logic\n\tAPlayerController* PC = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PC) {\n\t\tFRotator NewRotation = PC->GetControlRotation();\n\t\tNewRotation.Yaw += 90.f * DeltaTime; // Example smooth turn speed\n\t\tPC->SetControlRotation(NewRotation);\n\t}\n}\n\nvoid AVRLocomotionSystem::PerformTeleport() {\n\t// Teleport logic\n\tAPlayerController* PC = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PC && PC->IsInputKeyDown(EKeys::T)) { // Example teleport input\n\t\tFVector TeleportLocation = PC->GetPawn()->GetActorLocation() + FVector(500.f, 0.f, 0.f); // Example teleport distance\n\t\tPC->GetPawn()->SetActorLocation(TeleportLocation);\n\t}\n}\n```"}
{"requirement": "Construct a narrative branching system with multiple endings.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"NarrativeBranchingSystem.generated.h\"\n\nUENUM(BlueprintType)\nenum class EStoryNodeOutcome : uint8 {\n\tNone UMETA(DisplayName = \"None\"),\n\tEndingA UMETA(DisplayName = \"Ending A\"),\n\tEndingB UMETA(DisplayName = \"Ending B\"),\n\tEndingC UMETA(DisplayName = \"Ending C\")\n};\n\nUSTRUCT(BlueprintType)\nstruct FStoryNode {\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString NodeDescription;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tTArray<int32> NextNodeIndices;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tEStoryNodeOutcome NodeOutcome;\n};\n\nUCLASS()\nclass YOURGAME_API ANarrativeBranchingSystem : public AActor {\n\tGENERATED_BODY()\n\npublic:\n\tANarrativeBranchingSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tTArray<FStoryNode> StoryNodes;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 CurrentNodeIndex;\n\n\tUFUNCTION(BlueprintCallable)\n\tvoid AdvanceStory(int32 ChoiceIndex);\n\n\tUFUNCTION(BlueprintCallable)\n\tEStoryNodeOutcome GetCurrentNodeOutcome() const;\n};\n```", "cpp_code": "```cpp\n#include \"NarrativeBranchingSystem.h\"\n\nANarrativeBranchingSystem::ANarrativeBranchingSystem() {\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentNodeIndex = 0;\n}\n\nvoid ANarrativeBranchingSystem::BeginPlay() {\n\tSuper::BeginPlay();\n\t// Initialize your story nodes here or in the editor\n}\n\nvoid ANarrativeBranchingSystem::Tick(float DeltaTime) {\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ANarrativeBranchingSystem::AdvanceStory(int32 ChoiceIndex) {\n\tif (StoryNodes.IsValidIndex(CurrentNodeIndex)) {\n\t\tconst FStoryNode& CurrentNode = StoryNodes[CurrentNodeIndex];\n\t\tif (CurrentNode.NextNodeIndices.IsValidIndex(ChoiceIndex)) {\n\t\t\tCurrentNodeIndex = CurrentNode.NextNodeIndices[ChoiceIndex];\n\t\t}\n\t}\n}\n\nEStoryNodeOutcome ANarrativeBranchingSystem::GetCurrentNodeOutcome() const {\n\tif (StoryNodes.IsValidIndex(CurrentNodeIndex)) {\n\t\treturn StoryNodes[CurrentNodeIndex].NodeOutcome;\n\t}\n\treturn EStoryNodeOutcome::None;\n}\n```"}
{"requirement": "Integrate a real-time motion capture system for character animations.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MotionCaptureActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMotionCaptureActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMotionCaptureActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Motion Capture\")\n\tvoid InitializeMotionCapture();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Motion Capture\")\n\tvoid UpdateCharacterAnimation();\n\nprivate:\n\tvoid ConnectToMotionCaptureSystem();\n\tvoid ProcessMotionCaptureData();\n\n\t// Add any necessary variables to store motion capture data\n\tFVector MocapPosition;\n\tFRotator MocapRotation;\n\t// Add more data as needed\n};\n```", "cpp_code": "```cpp\n#include \"MotionCaptureActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n\nAMotionCaptureActor::AMotionCaptureActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMotionCaptureActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitializeMotionCapture();\n}\n\nvoid AMotionCaptureActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateCharacterAnimation();\n}\n\nvoid AMotionCaptureActor::InitializeMotionCapture()\n{\n\tConnectToMotionCaptureSystem();\n\t// Additional initialization code\n}\n\nvoid AMotionCaptureActor::ConnectToMotionCaptureSystem()\n{\n\t// Code to connect to the motion capture system\n\t// This might involve setting up network connections or hardware interfacing\n}\n\nvoid AMotionCaptureActor::ProcessMotionCaptureData()\n{\n\t// Code to process incoming motion capture data\n\t// Update MocapPosition and MocapRotation with the latest data\n}\n\nvoid AMotionCaptureActor::UpdateCharacterAnimation()\n{\n\tProcessMotionCaptureData();\n\tif (USkeletalMeshComponent* SkeletalMesh = FindComponentByClass<USkeletalMeshComponent>())\n\t{\n\t\tSkeletalMesh->SetWorldLocation(MocapPosition);\n\t\tSkeletalMesh->SetWorldRotation(MocapRotation);\n\t\t// Update additional animation parameters as needed\n\t}\n}\n```"}
{"requirement": "Design a weather effect system that impacts gameplay, such as rain slowing movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WeatherEffectSystem.generated.h\"\n\nUENUM(BlueprintType)\nenum class EWeatherType : uint8\n{\n\tSunny UMETA(DisplayName = \"Sunny\"),\n\tRainy UMETA(DisplayName = \"Rainy\")\n};\n\nUCLASS()\nclass YOURPROJECT_API AWeatherEffectSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAWeatherEffectSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Weather\")\n\tEWeatherType CurrentWeather;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Weather\")\n\tfloat RainMovementSlowdown;\n\n\tvoid ApplyWeatherEffects();\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid SetWeather(EWeatherType NewWeather);\n};\n```", "cpp_code": "```cpp\n#include \"WeatherEffectSystem.h\"\n#include \"GameFramework/Character.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAWeatherEffectSystem::AWeatherEffectSystem()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCurrentWeather = EWeatherType::Sunny;\n\tRainMovementSlowdown = 0.5f; // 50% slowdown\n}\n\n// Called when the game starts or when spawned\nvoid AWeatherEffectSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AWeatherEffectSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tApplyWeatherEffects();\n}\n\nvoid AWeatherEffectSystem::ApplyWeatherEffects()\n{\n\tfor (TActorIterator<ACharacter> It(GetWorld()); It; ++It)\n\t{\n\t\tACharacter* Character = *It;\n\t\tif (CurrentWeather == EWeatherType::Rainy)\n\t\t{\n\t\t\tCharacter->GetCharacterMovement()->MaxWalkSpeed *= RainMovementSlowdown;\n\t\t}\n\t}\n}\n\nvoid AWeatherEffectSystem::SetWeather(EWeatherType NewWeather)\n{\n\tCurrentWeather = NewWeather;\n}\n```"}
{"requirement": "Create an in-game economy that dynamically adjusts based on player actions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicEconomy.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADynamicEconomy : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADynamicEconomy();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Economy\")\n\tvoid AdjustEconomyBasedOnPlayerActions();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Economy\")\n\tfloat CurrentMarketPrice;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Economy\")\n\tfloat Supply;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Economy\")\n\tfloat Demand;\n\n\tvoid UpdateMarketPrice();\n};\n```", "cpp_code": "```cpp\n#include \"DynamicEconomy.h\"\n\nADynamicEconomy::ADynamicEconomy()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentMarketPrice = 100.0f;\n\tSupply = 1000.0f;\n\tDemand = 1000.0f;\n}\n\nvoid ADynamicEconomy::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADynamicEconomy::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateMarketPrice();\n}\n\nvoid ADynamicEconomy::AdjustEconomyBasedOnPlayerActions()\n{\n\t// Example: Increase demand when players buy items\n\tDemand += 10.0f;\n\t// Example: Decrease supply when items are consumed\n\tSupply -= 5.0f;\n}\n\nvoid ADynamicEconomy::UpdateMarketPrice()\n{\n\tif (Supply > 0)\n\t{\n\t\tCurrentMarketPrice = (Demand / Supply) * 100.0f;\n\t}\n\telse\n\t{\n\t\tCurrentMarketPrice = 1000.0f; // Arbitrary high price when no supply\n\t}\n}\n```"}
{"requirement": "Implement a customizable control scheme for accessibility options.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"CustomizableControlScheme.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FControlScheme\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Controls\")\n\tFKey MoveForward;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Controls\")\n\tFKey MoveBackward;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Controls\")\n\tFKey MoveLeft;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Controls\")\n\tFKey MoveRight;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Controls\")\n\tFKey Jump;\n\n\tFControlScheme()\n\t\t: MoveForward(EKeys::W),\n\t\t  MoveBackward(EKeys::S),\n\t\t  MoveLeft(EKeys::A),\n\t\t  MoveRight(EKeys::D),\n\t\t  Jump(EKeys::SpaceBar)\n\t{}\n};\n\nUCLASS()\nclass YOURPROJECT_API ACustomizablePlayerController : public APlayerController\n{\n\tGENERATED_BODY()\n\npublic:\n\tACustomizablePlayerController();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Accessibility\")\n\tFControlScheme ControlScheme;\n\n\tvirtual void SetupInputComponent() override;\n\nprivate:\n\tvoid MoveForward(float Value);\n\tvoid MoveBackward(float Value);\n\tvoid MoveLeft(float Value);\n\tvoid MoveRight(float Value);\n\tvoid JumpAction();\n};\n```", "cpp_code": "```cpp\n#include \"CustomizableControlScheme.h\"\n#include \"GameFramework/Actor.h\"\n\nACustomizablePlayerController::ACustomizablePlayerController()\n{\n\t// Initialize any additional components if necessary\n}\n\nvoid ACustomizablePlayerController::SetupInputComponent()\n{\n\tSuper::SetupInputComponent();\n\n\tif(InputComponent)\n\t{\n\t\tInputComponent->BindAxisKey(ControlScheme.MoveForward, this, &ACustomizablePlayerController::MoveForward);\n\t\tInputComponent->BindAxisKey(ControlScheme.MoveBackward, this, &ACustomizablePlayerController::MoveBackward);\n\t\tInputComponent->BindAxisKey(ControlScheme.MoveLeft, this, &ACustomizablePlayerController::MoveLeft);\n\t\tInputComponent->BindAxisKey(ControlScheme.MoveRight, this, &ACustomizablePlayerController::MoveRight);\n\t\tInputComponent->BindActionKey(ControlScheme.Jump, IE_Pressed, this, &ACustomizablePlayerController::JumpAction);\n\t}\n}\n\nvoid ACustomizablePlayerController::MoveForward(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\t// Add movement in the forward direction\n\t\tGetPawn()->AddMovementInput(GetPawn()->GetActorForwardVector(), Value);\n\t}\n}\n\nvoid ACustomizablePlayerController::MoveBackward(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\t// Add movement in the backward direction\n\t\tGetPawn()->AddMovementInput(-GetPawn()->GetActorForwardVector(), Value);\n\t}\n}\n\nvoid ACustomizablePlayerController::MoveLeft(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\t// Add movement in the left direction\n\t\tGetPawn()->AddMovementInput(-GetPawn()->GetActorRightVector(), Value);\n\t}\n}\n\nvoid ACustomizablePlayerController::MoveRight(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\t// Add movement in the right direction\n\t\tGetPawn()->AddMovementInput(GetPawn()->GetActorRightVector(), Value);\n\t}\n}\n\nvoid ACustomizablePlayerController::JumpAction()\n{\n\t// Make the pawn jump\n\tGetPawn()->Jump();\n}\n```"}
{"requirement": "Develop a physics-based destruction system for environmental interactions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PhysicsDestructionSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APhysicsDestructionSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPhysicsDestructionSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Destruction\")\n\tvoid ApplyDestruction(const FVector& ImpactPoint, float ForceMagnitude);\n\nprivate:\n\tvoid SpawnDebris(const FVector& ImpactPoint);\n\n\tUPROPERTY(EditAnywhere, Category=\"Destruction\")\n\tTSubclassOf<AActor> DebrisClass;\n\n\tUPROPERTY(EditAnywhere, Category=\"Destruction\")\n\tfloat DebrisSpawnRadius;\n};\n```", "cpp_code": "```cpp\n#include \"PhysicsDestructionSystem.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\nAPhysicsDestructionSystem::APhysicsDestructionSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tDebrisSpawnRadius = 100.0f;\n}\n\nvoid APhysicsDestructionSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APhysicsDestructionSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APhysicsDestructionSystem::ApplyDestruction(const FVector& ImpactPoint, float ForceMagnitude)\n{\n\tSpawnDebris(ImpactPoint);\n\tTArray<AActor*> OverlappingActors;\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), AActor::StaticClass(), OverlappingActors);\n\tfor (AActor* Actor : OverlappingActors)\n\t{\n\t\tif (Actor && Actor->GetRootComponent())\n\t\t{\n\t\t\tFVector Direction = Actor->GetActorLocation() - ImpactPoint;\n\t\t\tDirection.Normalize();\n\t\t\tActor->GetRootComponent()->AddImpulse(Direction * ForceMagnitude, NAME_None, true);\n\t\t}\n\t}\n}\n\nvoid APhysicsDestructionSystem::SpawnDebris(const FVector& ImpactPoint)\n{\n\tif (DebrisClass)\n\t{\n\t\tfor (int i = 0; i < 10; ++i)\n\t\t{\n\t\t\tFVector RandomPoint = ImpactPoint + FMath::VRand() * DebrisSpawnRadius;\n\t\t\tGetWorld()->SpawnActor<AActor>(DebrisClass, RandomPoint, FRotator::ZeroRotator);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Construct a modular AI system that can be reused across different projects.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"AIController.h\"\n#include \"ModularAIComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UModularAIComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUModularAIComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"AI\")\n\tvoid InitializeAIController(AAIController* NewAIController);\n\n\tUFUNCTION(BlueprintCallable, Category=\"AI\")\n\tvoid SetBehaviorTree(UBehaviorTree* NewBehaviorTree);\n\n\tUFUNCTION(BlueprintCallable, Category=\"AI\")\n\tvoid StartAI();\n\n\tUFUNCTION(BlueprintCallable, Category=\"AI\")\n\tvoid StopAI();\n\nprivate:\n\tAAIController* AIController;\n\tUBehaviorTree* BehaviorTree;\n};\n```", "cpp_code": "```cpp\n#include \"ModularAIComponent.h\"\n#include \"BehaviorTree/BehaviorTree.h\"\n#include \"BehaviorTree/BlackboardComponent.h\"\n\nUModularAIComponent::UModularAIComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tAIController = nullptr;\n\tBehaviorTree = nullptr;\n}\n\nvoid UModularAIComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UModularAIComponent::InitializeAIController(AAIController* NewAIController)\n{\n\tAIController = NewAIController;\n}\n\nvoid UModularAIComponent::SetBehaviorTree(UBehaviorTree* NewBehaviorTree)\n{\n\tBehaviorTree = NewBehaviorTree;\n}\n\nvoid UModularAIComponent::StartAI()\n{\n\tif (AIController && BehaviorTree)\n\t{\n\t\tAIController->RunBehaviorTree(BehaviorTree);\n\t}\n}\n\nvoid UModularAIComponent::StopAI()\n{\n\tif (AIController)\n\t{\n\t\tAIController->BrainComponent->StopLogic(TEXT(\"AI Stopped\"));\n\t}\n}\n```"}
{"requirement": "Integrate a dynamic quest generation system for endless gameplay content.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"QuestGenerator.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FQuest\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Quest\")\n\tFString Title;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Quest\")\n\tFString Description;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Quest\")\n\tint32 DifficultyLevel;\n};\n\nUCLASS()\nclass YOURGAME_API AQuestGenerator : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAQuestGenerator();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Quest\")\n\tFQuest GenerateRandomQuest();\n\nprivate:\n\tFString GenerateRandomTitle() const;\n\tFString GenerateRandomDescription() const;\n\tint32 GenerateRandomDifficulty() const;\n};\n```", "cpp_code": "```cpp\n#include \"QuestGenerator.h\"\n#include \"Math/UnrealMathUtility.h\"\n\nAQuestGenerator::AQuestGenerator()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AQuestGenerator::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AQuestGenerator::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nFQuest AQuestGenerator::GenerateRandomQuest()\n{\n\tFQuest NewQuest;\n\tNewQuest.Title = GenerateRandomTitle();\n\tNewQuest.Description = GenerateRandomDescription();\n\tNewQuest.DifficultyLevel = GenerateRandomDifficulty();\n\treturn NewQuest;\n}\n\nFString AQuestGenerator::GenerateRandomTitle() const\n{\n\tTArray<FString> Titles = {TEXT(\"The Lost Artifact\"), TEXT(\"Rescue the Villager\"), TEXT(\"Defeat the Bandits\")};\n\tint32 Index = FMath::RandRange(0, Titles.Num() - 1);\n\treturn Titles[Index];\n}\n\nFString AQuestGenerator::GenerateRandomDescription() const\n{\n\tTArray<FString> Descriptions = {TEXT(\"Find the ancient relic in the forest.\"), TEXT(\"Save the villager captured by goblins.\"), TEXT(\"Eliminate the bandit leader in the mountains.\")};\n\tint32 Index = FMath::RandRange(0, Descriptions.Num() - 1);\n\treturn Descriptions[Index];\n}\n\nint32 AQuestGenerator::GenerateRandomDifficulty() const\n{\n\treturn FMath::RandRange(1, 10);\n}\n```"}
{"requirement": "Design a terrain deformation system for creating craters and other impacts.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TerrainDeformer.generated.h\"\n\nUCLASS()\nclass MYGAME_API ATerrainDeformer : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tATerrainDeformer();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Terrain\")\n\tvoid DeformTerrainAtLocation(FVector Location, float Radius, float Depth);\n\nprivate:\n\tvoid UpdateTerrainMesh();\n\n\tUPROPERTY(EditAnywhere, Category = \"Terrain\")\n\tUStaticMeshComponent* TerrainMesh;\n\n\tUPROPERTY(EditAnywhere, Category = \"Terrain\")\n\tclass UProceduralMeshComponent* ProceduralMesh;\n};\n```", "cpp_code": "```cpp\n#include \"TerrainDeformer.h\"\n#include \"ProceduralMeshComponent.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n\nATerrainDeformer::ATerrainDeformer()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTerrainMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"TerrainMesh\"));\n\tRootComponent = TerrainMesh;\n\n\tProceduralMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"ProceduralMesh\"));\n\tProceduralMesh->SetupAttachment(RootComponent);\n}\n\nvoid ATerrainDeformer::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATerrainDeformer::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATerrainDeformer::DeformTerrainAtLocation(FVector Location, float Radius, float Depth)\n{\n\t// Placeholder for actual deformation logic\n\t// This would involve modifying the vertex data of the ProceduralMesh\n\tTArray<FVector> Vertices;\n\tProceduralMesh->GetProcMeshSection(0)->ProcVertexBuffer;\n\tfor (FVector& Vertex : Vertices)\n\t{\n\t\tfloat Distance = FVector::Dist(Vertex, Location);\n\t\tif (Distance < Radius)\n\t\t{\n\t\t\tfloat ProportionalDepth = FMath::Lerp(0.0f, Depth, (Radius - Distance) / Radius);\n\t\t\tVertex.Z -= ProportionalDepth;\n\t\t}\n\t}\n\tProceduralMesh->UpdateMeshSection(0, Vertices, TArray<FVector>(), TArray<FVector2D>(), TArray<FColor>(), TArray<FProcMeshTangent>());\n\tUpdateTerrainMesh();\n}\n\nvoid ATerrainDeformer::UpdateTerrainMesh()\n{\n\t// Logic to update the visual representation of the mesh\n\t// Could involve recalculating normals, collision, etc.\n\tUKismetSystemLibrary::PrintString(this, TEXT(\"Terrain Updated\"), true, true, FLinearColor(0,1,0,1), 5.0f);\n}\n```"}
{"requirement": "Create a seamless multiplayer experience with drop-in, drop-out functionality.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"MultiplayerGameMode.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMultiplayerGameMode : public AGameModeBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMultiplayerGameMode();\n\nprotected:\n\tvirtual void PostLogin(APlayerController* NewPlayer) override;\n\tvirtual void Logout(AController* Exiting) override;\n};\n```", "cpp_code": "```cpp\n#include \"MultiplayerGameMode.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/PlayerState.h\"\n#include \"Engine/World.h\"\n\nAMultiplayerGameMode::AMultiplayerGameMode()\n{\n\t// Set default values\n\tbUseSeamlessTravel = true;\n}\n\nvoid AMultiplayerGameMode::PostLogin(APlayerController* NewPlayer)\n{\n\tSuper::PostLogin(NewPlayer);\n\n\t// Logic to handle new player joining, such as updating player count or broadcasting a message\n\tUE_LOG(LogTemp, Log, TEXT(\"Player %s has joined the game.\"), *NewPlayer->PlayerState->GetPlayerName());\n}\n\nvoid AMultiplayerGameMode::Logout(AController* Exiting)\n{\n\tSuper::Logout(Exiting);\n\n\t// Logic to handle player leaving, such as updating player count or broadcasting a message\n\tAPlayerState* PlayerState = Exiting->PlayerState;\n\tif (PlayerState)\n\t{\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Player %s has left the game.\"), *PlayerState->GetPlayerName());\n\t}\n}\n```"}
{"requirement": "Develop a character relationship system that affects dialogue and quests.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RelationshipSystem.generated.h\"\n\nUENUM(BlueprintType)\nenum class ERelationshipStatus : uint8 {\n\tNeutral UMETA(DisplayName = \"Neutral\"),\n\tFriendly UMETA(DisplayName = \"Friendly\"),\n\tHostile UMETA(DisplayName = \"Hostile\")\n};\n\nUSTRUCT(BlueprintType)\nstruct FCharacterRelationship {\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString CharacterName;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tERelationshipStatus RelationshipStatus;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 Affinity;\n};\n\nUCLASS()\nclass YOURGAME_API ARelationshipSystem : public AActor {\n\tGENERATED_BODY()\n\npublic:\n\tARelationshipSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tTMap<FString, FCharacterRelationship> CharacterRelationships;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Relationship\")\n\tvoid UpdateRelationship(const FString& CharacterName, int32 AffinityChange);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Relationship\")\n\tERelationshipStatus GetRelationshipStatus(const FString& CharacterName) const;\n};\n```", "cpp_code": "```cpp\n#include \"RelationshipSystem.h\"\n\nARelationshipSystem::ARelationshipSystem() {\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARelationshipSystem::BeginPlay() {\n\tSuper::BeginPlay();\n}\n\nvoid ARelationshipSystem::Tick(float DeltaTime) {\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARelationshipSystem::UpdateRelationship(const FString& CharacterName, int32 AffinityChange) {\n\tif (FCharacterRelationship* Relationship = CharacterRelationships.Find(CharacterName)) {\n\t\tRelationship->Affinity += AffinityChange;\n\n\t\tif (Relationship->Affinity >= 50) {\n\t\t\tRelationship->RelationshipStatus = ERelationshipStatus::Friendly;\n\t\t} else if (Relationship->Affinity <= -50) {\n\t\t\tRelationship->RelationshipStatus = ERelationshipStatus::Hostile;\n\t\t} else {\n\t\t\tRelationship->RelationshipStatus = ERelationshipStatus::Neutral;\n\t\t}\n\t}\n}\n\nERelationshipStatus ARelationshipSystem::GetRelationshipStatus(const FString& CharacterName) const {\n\tif (const FCharacterRelationship* Relationship = CharacterRelationships.Find(CharacterName)) {\n\t\treturn Relationship->RelationshipStatus;\n\t}\n\treturn ERelationshipStatus::Neutral;\n}\n```"}
{"requirement": "Implement a sound occlusion system for realistic audio experiences.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"SoundOcclusionComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API USoundOcclusionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUSoundOcclusionComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid UpdateOcclusion();\n\n\tUFUNCTION()\n\tfloat CalculateOcclusion(FVector SoundLocation, FVector ListenerLocation);\n\n\tUPROPERTY(EditAnywhere, Category = \"Audio\")\n\tfloat MaxOcclusionDistance;\n\n\tUPROPERTY(EditAnywhere, Category = \"Audio\")\n\tfloat OcclusionFadeSpeed;\n\n\tUPROPERTY(EditAnywhere, Category = \"Audio\")\n\tfloat OcclusionFactor;\n\n\tFVector LastListenerLocation;\n};\n```", "cpp_code": "```cpp\n#include \"SoundOcclusionComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Sound/SoundCue.h\"\n\nUSoundOcclusionComponent::USoundOcclusionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tMaxOcclusionDistance = 1000.0f;\n\tOcclusionFadeSpeed = 5.0f;\n\tOcclusionFactor = 0.5f;\n}\n\nvoid USoundOcclusionComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tLastListenerLocation = FVector::ZeroVector;\n}\n\nvoid USoundOcclusionComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tUpdateOcclusion();\n}\n\nvoid USoundOcclusionComponent::UpdateOcclusion()\n{\n\tAActor* Owner = GetOwner();\n\tif (!Owner) return;\n\n\tFVector ListenerLocation;\n\tUGameplayStatics::GetPlayerCameraManager(GetWorld(), 0)->GetCameraLocation();\n\n\tfloat CurrentOcclusion = CalculateOcclusion(Owner->GetActorLocation(), ListenerLocation);\n\n\t// Here you would update your audio component's occlusion settings\n\t// For example, if using a sound cue:\n\t// MyAudioComponent->SetVolumeMultiplier(FMath::Lerp(MyAudioComponent->VolumeMultiplier, CurrentOcclusion, OcclusionFadeSpeed * GetWorld()->DeltaTimeSeconds));\n\n\tLastListenerLocation = ListenerLocation;\n}\n\nfloat USoundOcclusionComponent::CalculateOcclusion(FVector SoundLocation, FVector ListenerLocation)\n{\n\tFHitResult HitResult;\n\tFCollisionQueryParams CollisionParams;\n\tCollisionParams.AddIgnoredActor(GetOwner());\n\n\tbool bHit = GetWorld()->LineTraceSingleByChannel(HitResult, SoundLocation, ListenerLocation, ECC_Visibility, CollisionParams);\n\n\tif (bHit && HitResult.Distance <= MaxOcclusionDistance)\n\t{\n\t\treturn OcclusionFactor;\n\t}\n\treturn 1.0f;\n}\n```"}
{"requirement": "Create a cinematic cutscene editor for designing in-game movies.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleManager.h\"\n#include \"ICinematicCutsceneEditor.h\"\n\nclass FCinematicCutsceneEditorModule : public ICinematicCutsceneEditor\n{\npublic:\n\tvirtual void StartupModule() override;\n\tvirtual void ShutdownModule() override;\n};\n\nclass ACinematicCutsceneActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACinematicCutsceneActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Cutscene\")\n\tvoid PlayCutscene();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Cutscene\")\n\tvoid StopCutscene();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Cutscene\")\n\tULevelSequence* CutsceneSequence;\n\n\tUPROPERTY()\n\tULevelSequencePlayer* SequencePlayer;\n};\n```", "cpp_code": "```cpp\n#include \"CinematicCutsceneEditor.h\"\n#include \"Modules/ModuleManager.h\"\n#include \"LevelSequence.h\"\n#include \"LevelSequencePlayer.h\"\n\nIMPLEMENT_MODULE(FCinematicCutsceneEditorModule, CinematicCutsceneEditor)\n\nvoid FCinematicCutsceneEditorModule::StartupModule()\n{\n\t// Startup logic for the module\n}\n\nvoid FCinematicCutsceneEditorModule::ShutdownModule()\n{\n\t// Shutdown logic for the module\n}\n}\n\nACinematicCutsceneActor::ACinematicCutsceneActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tCutsceneSequence = nullptr;\n\tSequencePlayer = nullptr;\n}\n\nvoid ACinematicCutsceneActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (CutsceneSequence)\n\t{\n\t\tFMovieSceneSequencePlaybackSettings Settings;\n\t\tSequencePlayer = ULevelSequencePlayer::CreateLevelSequencePlayer(GetWorld(), CutsceneSequence, Settings);\n\t}\n}\n\nvoid ACinematicCutsceneActor::PlayCutscene()\n{\n\tif (SequencePlayer)\n\t{\n\t\tSequencePlayer->Play();\n\t}\n}\n\nvoid ACinematicCutsceneActor::StopCutscene()\n{\n\tif (SequencePlayer)\n\t{\n\t\tSequencePlayer->Stop();\n\t}\n}\n```"}
{"requirement": "Design a time manipulation mechanic that affects gameplay and puzzles.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimeManipulationActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API ATimeManipulationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATimeManipulationActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Time manipulation methods\n\tUFUNCTION(BlueprintCallable, Category = \"TimeManipulation\")\n\tvoid SlowDownTime(float Factor);\n\n\tUFUNCTION(BlueprintCallable, Category = \"TimeManipulation\")\n\tvoid SpeedUpTime(float Factor);\n\n\tUFUNCTION(BlueprintCallable, Category = \"TimeManipulation\")\n\tvoid ResetTime();\n\nprivate:\n\tfloat OriginalTimeDilation;\n};\n```", "cpp_code": "```cpp\n#include \"TimeManipulationActor.h\"\n#include \"GameFramework/WorldSettings.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nATimeManipulationActor::ATimeManipulationActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tOriginalTimeDilation = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ATimeManipulationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tOriginalTimeDilation = GetWorld()->GetWorldSettings()->TimeDilation;\n}\n\n// Called every frame\nvoid ATimeManipulationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATimeManipulationActor::SlowDownTime(float Factor)\n{\n\tif (Factor > 0.0f && Factor < 1.0f)\n\t{\n\t\tGetWorld()->GetWorldSettings()->TimeDilation = OriginalTimeDilation * Factor;\n\t}\n}\n\nvoid ATimeManipulationActor::SpeedUpTime(float Factor)\n{\n\tif (Factor > 1.0f)\n\t{\n\t\tGetWorld()->GetWorldSettings()->TimeDilation = OriginalTimeDilation * Factor;\n\t}\n}\n\nvoid ATimeManipulationActor::ResetTime()\n{\n\tGetWorld()->GetWorldSettings()->TimeDilation = OriginalTimeDilation;\n}\n```"}
{"requirement": "Develop an adaptive AI difficulty system that adjusts to player skill.", "header_code": "```cpp\nUCLASS()\nclass YOURGAME_API AAdaptiveAIDifficultySystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAdaptiveAIDifficultySystem();\n\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid AdjustDifficultyBasedOnPlayerSkill();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tfloat PlayerSkillLevel;\n\tfloat AIDifficultyLevel;\n\n\tvoid UpdatePlayerSkillLevel();\n\tvoid UpdateAIDifficultyLevel();\n\tfloat CalculateNewDifficulty(float CurrentSkillLevel);\n};\n```", "cpp_code": "```cpp\n#include \"AdaptiveAIDifficultySystem.h\"\n#include \"GameFramework/Actor.h\"\n\nAAdaptiveAIDifficultySystem::AAdaptiveAIDifficultySystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tPlayerSkillLevel = 1.0f;\n\tAIDifficultyLevel = 1.0f;\n}\n\nvoid AAdaptiveAIDifficultySystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAdaptiveAIDifficultySystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tAdjustDifficultyBasedOnPlayerSkill();\n}\n\nvoid AAdaptiveAIDifficultySystem::AdjustDifficultyBasedOnPlayerSkill()\n{\n\tUpdatePlayerSkillLevel();\n\tUpdateAIDifficultyLevel();\n}\n\nvoid AAdaptiveAIDifficultySystem::UpdatePlayerSkillLevel()\n{\n\t// Logic to update the player's skill level based on game performance\n\t// This is a placeholder and should be replaced with actual game logic\n\tPlayerSkillLevel += FMath::FRandRange(-0.1f, 0.1f);\n\tPlayerSkillLevel = FMath::Clamp(PlayerSkillLevel, 0.0f, 10.0f);\n}\n\nvoid AAdaptiveAIDifficultySystem::UpdateAIDifficultyLevel()\n{\n\tAIDifficultyLevel = CalculateNewDifficulty(PlayerSkillLevel);\n}\n\nfloat AAdaptiveAIDifficultySystem::CalculateNewDifficulty(float CurrentSkillLevel)\n{\n\t// Calculate new AI difficulty based on player skill\n\t// This is a simple linear adjustment; can be replaced with more complex logic\n\treturn FMath::Clamp(CurrentSkillLevel, 0.0f, 10.0f);\n}\n```"}
{"requirement": "Construct a particle lighting system for more realistic special effects.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"ParticleLightingSystem.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UParticleLightingSystem : public UParticleSystemComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUParticleLightingSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Lighting\")\n\tfloat LightIntensity;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Lighting\")\n\tFColor LightColor;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Lighting\")\n\tvoid UpdateLighting();\n\nprivate:\n\tUPointLightComponent* ParticleLight;\n};\n```", "cpp_code": "```cpp\n#include \"ParticleLightingSystem.h\"\n#include \"Components/PointLightComponent.h\"\n\nUParticleLightingSystem::UParticleLightingSystem()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tLightIntensity = 500.0f;\n\tLightColor = FColor::White;\n\n\tParticleLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"ParticleLight\"));\n\tParticleLight->SetupAttachment(this);\n}\n\nvoid UParticleLightingSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tUpdateLighting();\n}\n\nvoid UParticleLightingSystem::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\t// Update light properties dynamically if needed\n}\n\nvoid UParticleLightingSystem::UpdateLighting()\n{\n\tif (ParticleLight)\n\t{\n\t\tParticleLight->SetIntensity(LightIntensity);\n\t\tParticleLight->SetLightColor(LightColor);\n\t}\n}\n```"}
{"requirement": "Integrate a voice recognition system for commanding AI companions.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VoiceRecognitionSystem.generated.h\"\n\nUCLASS()\nclass AVoiceRecognitionSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAVoiceRecognitionSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid ProcessVoiceCommand(const FString& Command);\n\nprivate:\n\tvoid InitializeVoiceRecognition();\n\tvoid ExecuteCommand(const FString& Command);\n\n\tUPROPERTY(EditAnywhere)\n\tTArray<FString> RecognizedCommands;\n};\n```", "cpp_code": "```cpp\n#include \"VoiceRecognitionSystem.h\"\n#include \"AIController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAVoiceRecognitionSystem::AVoiceRecognitionSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AVoiceRecognitionSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitializeVoiceRecognition();\n}\n\nvoid AVoiceRecognitionSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AVoiceRecognitionSystem::InitializeVoiceRecognition()\n{\n\t// Initialize your voice recognition system here\n\tRecognizedCommands.Add(TEXT(\"Follow\"));\n\tRecognizedCommands.Add(TEXT(\"Attack\"));\n\tRecognizedCommands.Add(TEXT(\"Defend\"));\n}\n\nvoid AVoiceRecognitionSystem::ProcessVoiceCommand(const FString& Command)\n{\n\tif (RecognizedCommands.Contains(Command))\n\t{\n\t\tExecuteCommand(Command);\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Unrecognized Command: %s\"), *Command);\n\t}\n}\n\nvoid AVoiceRecognitionSystem::ExecuteCommand(const FString& Command)\n{\n\tfor (TActorIterator<AAIController> It(GetWorld()); It; ++It)\n\t{\n\t\tAAIController* AIController = *It;\n\t\tif (AIController)\n\t\t{\n\t\t\tif (Command.Equals(TEXT(\"Follow\")))\n\t\t\t{\n\t\t\t\t// AI follow logic\n\t\t\t\tUE_LOG(LogTemp, Log, TEXT(\"AI Companion Following\"));\n\t\t\t}\n\t\t\telse if (Command.Equals(TEXT(\"Attack\")))\n\t\t\t{\n\t\t\t\t// AI attack logic\n\t\t\t\tUE_LOG(LogTemp, Log, TEXT(\"AI Companion Attacking\"));\n\t\t\t}\n\t\t\telse if (Command.Equals(TEXT(\"Defend\")))\n\t\t\t{\n\t\t\t\t// AI defend logic\n\t\t\t\tUE_LOG(LogTemp, Log, TEXT(\"AI Companion Defending\"));\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Design a modular weapon system with interchangeable parts.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ModularWeapon.generated.h\"\n\nUENUM(BlueprintType)\nenum class EWeaponPartType : uint8\n{\n\tBarrel UMETA(DisplayName = \"Barrel\"),\n\tScope UMETA(DisplayName = \"Scope\"),\n\tMagazine UMETA(DisplayName = \"Magazine\")\n};\n\nUCLASS()\nclass AModularWeapon : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAModularWeapon();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Method to attach a part to the weapon\n\tUFUNCTION(BlueprintCallable, Category = \"Weapon\")\n\tvoid AttachPart(EWeaponPartType PartType, AActor* Part);\n\nprivate:\n\tUPROPERTY()\n\tTMap<EWeaponPartType, AActor*> WeaponParts;\n};\n```", "cpp_code": "```cpp\n#include \"ModularWeapon.h\"\n\n// Sets default values\nAModularWeapon::AModularWeapon()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AModularWeapon::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AModularWeapon::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid AModularWeapon::AttachPart(EWeaponPartType PartType, AActor* Part)\n{\n\tif (WeaponParts.Contains(PartType))\n\t{\n\t\t// Detach previous part if it exists\n\t\tWeaponParts[PartType]->Destroy();\n\t}\n\n\t// Attach new part\n\tWeaponParts.Add(PartType, Part);\n\tPart->AttachToActor(this, FAttachmentTransformRules::KeepRelativeTransform);\n}\n```"}
{"requirement": "Create an environmental storytelling system with discoverable lore.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoreItem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ALoreItem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tALoreItem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Lore\")\n\tFString LoreTitle;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Lore\")\n\tFString LoreDescription;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Lore\")\n\tvoid DiscoverLore();\n\n\tUFUNCTION(BlueprintImplementableEvent, Category=\"Lore\")\n\tvoid OnLoreDiscovered();\n\nprivate:\n\tbool bIsDiscovered;\n};\n```", "cpp_code": "```cpp\n#include \"LoreItem.h\"\n#include \"Engine/World.h\"\n\nALoreItem::ALoreItem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsDiscovered = false;\n}\n\nvoid ALoreItem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALoreItem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ALoreItem::DiscoverLore()\n{\n\tif (!bIsDiscovered)\n\t{\n\t\tbIsDiscovered = true;\n\t\tOnLoreDiscovered();\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Lore Discovered: %s - %s\"), *LoreTitle, *LoreDescription);\n\t}\n}\n```"}
{"requirement": "Develop a real-time strategy game interface with unit selection and commands.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RTSUnitInterface.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ARTSUnitInterface : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARTSUnitInterface();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"RTS Unit\")\n\tvoid SelectUnit();\n\n\tUFUNCTION(BlueprintCallable, Category=\"RTS Unit\")\n\tvoid DeselectUnit();\n\n\tUFUNCTION(BlueprintCallable, Category=\"RTS Unit\")\n\tvoid MoveUnit(FVector TargetLocation);\n\nprivate:\n\tbool bIsSelected;\n};\n```", "cpp_code": "```cpp\n#include \"RTSUnitInterface.h\"\n\nARTSUnitInterface::ARTSUnitInterface()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsSelected = false;\n}\n\nvoid ARTSUnitInterface::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARTSUnitInterface::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARTSUnitInterface::SelectUnit()\n{\n\tbIsSelected = true;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Unit Selected\"));\n}\n\nvoid ARTSUnitInterface::DeselectUnit()\n{\n\tbIsSelected = false;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Unit Deselected\"));\n}\n\nvoid ARTSUnitInterface::MoveUnit(FVector TargetLocation)\n{\n\tif (bIsSelected)\n\t{\n\t\tSetActorLocation(TargetLocation);\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Unit Moved to Location: %s\"), *TargetLocation.ToString());\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Cannot move unit. Unit is not selected.\"));\n\t}\n}\n```"}
{"requirement": "Implement a dynamic content update system for periodically adding new features.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicContentUpdater.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ADynamicContentUpdater : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADynamicContentUpdater();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Timer handle for periodic updates\n\tFTimerHandle UpdateTimerHandle;\n\n\t// Function to check and apply new content\n\tvoid CheckAndUpdateContent();\n\n\t// Interval in seconds for checking updates\n\tUPROPERTY(EditAnywhere, Category = \"Update\")\n\tfloat UpdateInterval;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicContentUpdater.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nADynamicContentUpdater::ADynamicContentUpdater()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Default update interval to 60 seconds\n\tUpdateInterval = 60.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ADynamicContentUpdater::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Set timer to call CheckAndUpdateContent periodically\n\tGetWorld()->GetTimerManager().SetTimer(UpdateTimerHandle, this, &ADynamicContentUpdater::CheckAndUpdateContent, UpdateInterval, true);\n}\n\n// Called every frame\nvoid ADynamicContentUpdater::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Check and apply new content updates\nvoid ADynamicContentUpdater::CheckAndUpdateContent()\n{\n\t// Logic to check for new content updates and apply them\n\t// This could involve checking a server or local data source for new content\n\tUE_LOG(LogTemp, Warning, TEXT(\"Checking for new content updates...\"));\n\n\t// Example: Apply new features if available\n\t// if (NewContentAvailable()) {\n\t//\t ApplyNewContent();\n\t//\t UE_LOG(LogTemp, Warning, TEXT(\"New content has been applied.\"));\n\t// }\n}\n```"}
{"requirement": "Create an AI traffic system for simulating realistic urban environments.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AITrafficSystem.generated.h\"\n\nUCLASS()\nclass AITRAFFIC_API AAITrafficSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAITrafficSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Traffic\")\n\tfloat TrafficSpeed;\n\n\tUPROPERTY(EditAnywhere, Category = \"Traffic\")\n\tTArray<AActor*> TrafficWaypoints;\n\n\tvoid InitializeTraffic();\n\tvoid UpdateTraffic(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"AITrafficSystem.h\"\n#include \"Engine/World.h\"\n\nAAITrafficSystem::AAITrafficSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTrafficSpeed = 100.0f;\n}\n\nvoid AAITrafficSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitializeTraffic();\n}\n\nvoid AAITrafficSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateTraffic(DeltaTime);\n}\n\nvoid AAITrafficSystem::InitializeTraffic()\n{\n\t// Initialize traffic waypoints and other necessary components\n\t// For simplicity, assume waypoints are already set in TrafficWaypoints array\n}\n\nvoid AAITrafficSystem::UpdateTraffic(float DeltaTime)\n{\n\tfor (AActor* Vehicle : TrafficWaypoints)\n\t{\n\t\tif (Vehicle)\n\t\t{\n\t\t\tFVector CurrentLocation = Vehicle->GetActorLocation();\n\t\t\tFVector NextWaypoint = TrafficWaypoints[0]->GetActorLocation(); // Simplified for example\n\t\t\tFVector Direction = (NextWaypoint - CurrentLocation).GetSafeNormal();\n\t\t\tFVector NewLocation = CurrentLocation + Direction * TrafficSpeed * DeltaTime;\n\t\t\tVehicle->SetActorLocation(NewLocation);\n\n\t\t\t// Check if reached waypoint and update logic accordingly\n\t\t}\n\t}\n}\n```"}
{"requirement": "Design a user-generated content system for players to create and share levels.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LevelContentSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ALevelContentSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALevelContentSystem();\n\n\tUFUNCTION(BlueprintCallable, Category = \"UserContent\")\n\tvoid CreateLevel(FString LevelName);\n\n\tUFUNCTION(BlueprintCallable, Category = \"UserContent\")\n\tbool SaveLevel(FString LevelName);\n\n\tUFUNCTION(BlueprintCallable, Category = \"UserContent\")\n\tbool LoadLevel(FString LevelName);\n\n\tUFUNCTION(BlueprintCallable, Category = \"UserContent\")\n\tTArray<FString> GetAvailableLevels() const;\n\nprivate:\n\tFString GetLevelFilePath(FString LevelName) const;\n\n\tTArray<FString> AvailableLevels;\n};\n```", "cpp_code": "```cpp\n#include \"LevelContentSystem.h\"\n#include \"Misc/FileHelper.h\"\n#include \"Misc/Paths.h\"\n\nALevelContentSystem::ALevelContentSystem()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALevelContentSystem::CreateLevel(FString LevelName)\n{\n\t// Implementation to initialize a new level\n\t// This would involve setting up level data structures\n}\n\nbool ALevelContentSystem::SaveLevel(FString LevelName)\n{\n\tFString FilePath = GetLevelFilePath(LevelName);\n\tFString LevelData = TEXT(\"Level Data to be saved\"); // Serialize your actual level data\n\n\treturn FFileHelper::SaveStringToFile(LevelData, *FilePath);\n}\n\nbool ALevelContentSystem::LoadLevel(FString LevelName)\n{\n\tFString FilePath = GetLevelFilePath(LevelName);\n\tFString LoadedLevelData;\n\n\tif (FFileHelper::LoadFileToString(LoadedLevelData, *FilePath))\n\t{\n\t\t// Deserialize LoadedLevelData to your level data structures\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nTArray<FString> ALevelContentSystem::GetAvailableLevels() const\n{\n\tTArray<FString> Files;\n\tFString LevelDirectory = FPaths::ProjectSavedDir() + TEXT(\"Levels/\");\n\tIFileManager& FileManager = IFileManager::Get();\n\tFileManager.FindFiles(Files, *LevelDirectory, TEXT(\"*.lvl\"));\n\n\treturn Files;\n}\n\nFString ALevelContentSystem::GetLevelFilePath(FString LevelName) const\n{\n\treturn FPaths::ProjectSavedDir() + TEXT(\"Levels/\") + LevelName + TEXT(\".lvl\");\n}\n```"}
{"requirement": "Develop a real-time weather simulation based on actual geographic data.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WeatherSimulation.generated.h\"\n\nUCLASS()\nclass WEATHERSIMULATION_API AWeatherSimulation : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAWeatherSimulation();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to update weather based on geographic data\n\tvoid UpdateWeatherData();\n\nprivate:\n\t// Function to fetch real geographic weather data\n\tvoid FetchWeatherData();\n\n\t// Function to simulate weather effects in Unreal Engine\n\tvoid SimulateWeatherEffects();\n\n\t// Variables to store weather information\n\tfloat Temperature;\n\tfloat Humidity;\n\tFString WeatherCondition;\n};\n```", "cpp_code": "```cpp\n#include \"WeatherSimulation.h\"\n#include \"HttpModule.h\"\n#include \"Interfaces/IHttpResponse.h\"\n#include \"Json.h\"\n\nAWeatherSimulation::AWeatherSimulation()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AWeatherSimulation::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateWeatherData();\n}\n\nvoid AWeatherSimulation::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tSimulateWeatherEffects();\n}\n\nvoid AWeatherSimulation::UpdateWeatherData()\n{\n\tFetchWeatherData();\n}\n\nvoid AWeatherSimulation::FetchWeatherData()\n{\n\tFHttpModule* Http = &FHttpModule::Get();\n\tTSharedRef<IHttpRequest> Request = Http->CreateRequest();\n\tRequest->OnProcessRequestComplete().BindUObject(this, &AWeatherSimulation::OnWeatherDataReceived);\n\tRequest->SetURL(\"https://api.openweathermap.org/data/2.5/weather?q=YourCity&appid=YourAPIKey\");\n\tRequest->SetVerb(\"GET\");\n\tRequest->ProcessRequest();\n}\n\nvoid AWeatherSimulation::OnWeatherDataReceived(FHttpRequestPtr Request, FHttpResponsePtr Response, bool bWasSuccessful)\n{\n\tif (bWasSuccessful && Response.IsValid())\n\t{\n\t\tTSharedPtr<FJsonObject> JsonObject;\n\t\tTSharedRef<TJsonReader<>> Reader = TJsonReaderFactory<>::Create(Response->GetContentAsString());\n\n\t\tif (FJsonSerializer::Deserialize(Reader, JsonObject))\n\t\t{\n\t\t\tTemperature = JsonObject->GetObjectField(\"main\")->GetNumberField(\"temp\");\n\t\t\tHumidity = JsonObject->GetObjectField(\"main\")->GetNumberField(\"humidity\");\n\t\t\tWeatherCondition = JsonObject->GetArrayField(\"weather\")[0]->AsObject()->GetStringField(\"main\");\n\t\t}\n\t}\n}\n\nvoid AWeatherSimulation::SimulateWeatherEffects()\n{\n\t// Implement Unreal Engine weather effects based on Temperature, Humidity, and WeatherCondition\n\tUE_LOG(LogTemp, Log, TEXT(\"Temperature: %f, Humidity: %f, Condition: %s\"), Temperature, Humidity, *WeatherCondition);\n}\n```"}
{"requirement": "Construct a dynamic lighting system that changes based on time of day.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicLightingSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADynamicLightingSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADynamicLightingSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid UpdateLighting(float TimeOfDay);\n\n\tUPROPERTY(EditAnywhere, Category=\"Lighting\")\n\tfloat DawnTime;\n\n\tUPROPERTY(EditAnywhere, Category=\"Lighting\")\n\tfloat NoonTime;\n\n\tUPROPERTY(EditAnywhere, Category=\"Lighting\")\n\tfloat DuskTime;\n\n\tUPROPERTY(EditAnywhere, Category=\"Lighting\")\n\tfloat NightTime;\n\n\tUPROPERTY(EditAnywhere, Category=\"Lighting\")\n\tUDirectionalLightComponent* DirectionalLight;\n\n\tUPROPERTY(EditAnywhere, Category=\"Lighting\")\n\tUSkyLightComponent* SkyLight;\n\n\tfloat CurrentTimeOfDay;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicLightingSystem.h\"\n#include \"Components/DirectionalLightComponent.h\"\n#include \"Components/SkyLightComponent.h\"\n\nADynamicLightingSystem::ADynamicLightingSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tDirectionalLight = CreateDefaultSubobject<UDirectionalLightComponent>(TEXT(\"DirectionalLight\"));\n\tRootComponent = DirectionalLight;\n\n\tSkyLight = CreateDefaultSubobject<USkyLightComponent>(TEXT(\"SkyLight\"));\n\tSkyLight->SetupAttachment(RootComponent);\n\n\tDawnTime = 6.0f;\n\tNoonTime = 12.0f;\n\tDuskTime = 18.0f;\n\tNightTime = 24.0f;\n\tCurrentTimeOfDay = 0.0f;\n}\n\nvoid ADynamicLightingSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADynamicLightingSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tCurrentTimeOfDay += DeltaTime;\n\tif (CurrentTimeOfDay >= 24.0f)\n\t{\n\t\tCurrentTimeOfDay = 0.0f;\n\t}\n\n\tUpdateLighting(CurrentTimeOfDay);\n}\n\nvoid ADynamicLightingSystem::UpdateLighting(float TimeOfDay)\n{\n\tif (TimeOfDay >= DawnTime && TimeOfDay < NoonTime)\n\t{\n\t\t// Morning configuration\n\t\tDirectionalLight->SetIntensity(3.0f);\n\t\tSkyLight->SetIntensity(1.5f);\n\t}\n\telse if (TimeOfDay >= NoonTime && TimeOfDay < DuskTime)\n\t{\n\t\t// Afternoon configuration\n\t\tDirectionalLight->SetIntensity(4.0f);\n\t\tSkyLight->SetIntensity(2.0f);\n\t}\n\telse if (TimeOfDay >= DuskTime && TimeOfDay < NightTime)\n\t{\n\t\t// Evening configuration\n\t\tDirectionalLight->SetIntensity(1.0f);\n\t\tSkyLight->SetIntensity(0.5f);\n\t}\n\telse\n\t{\n\t\t// Night configuration\n\t\tDirectionalLight->SetIntensity(0.2f);\n\t\tSkyLight->SetIntensity(0.1f);\n\t}\n}\n```"}
{"requirement": "Integrate a voice command system for in-game actions and menu navigation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VoiceCommandSystem.generated.h\"\n\nUCLASS()\nclass MYGAME_API AVoiceCommandSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAVoiceCommandSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"VoiceCommands\")\n\tvoid ProcessVoiceCommand(const FString& Command);\n\nprivate:\n\tvoid ExecuteAction(const FString& Action);\n\tvoid NavigateMenu(const FString& MenuItem);\n\n\tTMap<FString, FString> VoiceCommandMap;\n};\n```", "cpp_code": "```cpp\n#include \"VoiceCommandSystem.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAVoiceCommandSystem::AVoiceCommandSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AVoiceCommandSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Initialize the voice command map with some example commands\n\tVoiceCommandMap.Add(\"jump\", \"Jump\");\n\tVoiceCommandMap.Add(\"shoot\", \"Fire\");\n\tVoiceCommandMap.Add(\"open inventory\", \"OpenInventory\");\n\tVoiceCommandMap.Add(\"go to settings\", \"OpenSettings\");\n}\n\nvoid AVoiceCommandSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AVoiceCommandSystem::ProcessVoiceCommand(const FString& Command)\n{\n\tif (VoiceCommandMap.Contains(Command))\n\t{\n\t\tFString Action = VoiceCommandMap[Command];\n\n\t\t// Check if the command is an in-game action or a menu navigation\n\t\tif (Action == \"Jump\" || Action == \"Fire\")\n\t\t{\n\t\t\tExecuteAction(Action);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNavigateMenu(Action);\n\t\t}\n\t}\n}\n\nvoid AVoiceCommandSystem::ExecuteAction(const FString& Action)\n{\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tif (Action == \"Jump\")\n\t\t{\n\t\t\tPlayerController->InputJump();\n\t\t}\n\t\telse if (Action == \"Fire\")\n\t\t{\n\t\t\tPlayerController->InputFire();\n\t\t}\n\t}\n}\n\nvoid AVoiceCommandSystem::NavigateMenu(const FString& MenuItem)\n{\n\tif (MenuItem == \"OpenInventory\")\n\t{\n\t\t// Code to open inventory menu\n\t}\n\telse if (MenuItem == \"OpenSettings\")\n\t{\n\t\t// Code to open settings menu\n\t}\n}\n```"}
{"requirement": "Design a procedural dungeon generation system for endless exploration.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DungeonGenerator.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ADungeonGenerator : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADungeonGenerator();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category = \"Dungeon Settings\")\n\tint32 MaxRooms;\n\n\tUPROPERTY(EditAnywhere, Category = \"Dungeon Settings\")\n\tfloat RoomSize;\n\nprivate:\n\tvoid GenerateDungeon();\n\tvoid GenerateRoom(const FVector& Location);\n\n\tTArray<FVector> RoomLocations;\n};\n```", "cpp_code": "```cpp\n#include \"DungeonGenerator.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nADungeonGenerator::ADungeonGenerator()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMaxRooms = 10;\n\tRoomSize = 400.0f;\n}\n\nvoid ADungeonGenerator::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGenerateDungeon();\n}\n\nvoid ADungeonGenerator::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADungeonGenerator::GenerateDungeon()\n{\n\tRoomLocations.Empty();\n\tFVector CurrentLocation = GetActorLocation();\n\tRoomLocations.Add(CurrentLocation);\n\n\tfor (int32 i = 1; i < MaxRooms; ++i)\n\t{\n\t\tFVector NewLocation = CurrentLocation;\n\t\tint32 Direction = FMath::RandRange(0, 3);\n\n\t\tswitch (Direction)\n\t\t{\n\t\tcase 0: // Up\n\t\t\tNewLocation.X += RoomSize;\n\t\t\tbreak;\n\t\tcase 1: // Down\n\t\t\tNewLocation.X -= RoomSize;\n\t\t\tbreak;\n\t\tcase 2: // Right\n\t\t\tNewLocation.Y += RoomSize;\n\t\t\tbreak;\n\t\tcase 3: // Left\n\t\t\tNewLocation.Y -= RoomSize;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!RoomLocations.Contains(NewLocation))\n\t\t{\n\t\t\tRoomLocations.Add(NewLocation);\n\t\t\tGenerateRoom(NewLocation);\n\t\t\tCurrentLocation = NewLocation;\n\t\t}\n\t}\n}\n\nvoid ADungeonGenerator::GenerateRoom(const FVector& Location)\n{\n\t// For demonstration, we draw a debug box for the room\n\tFColor RoomColor = FColor::MakeRandomColor();\n\tDrawDebugBox(GetWorld(), Location, FVector(RoomSize / 2), RoomColor, true, -1.0f, 0, 5.0f);\n\n\t// Spawn room actor or other room setup logic here\n}\n```"}
{"requirement": "Create a character customization system with real-time preview.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CharacterCustomizationSystem.generated.h\"\n\nUCLASS()\nclass MYGAME_API ACharacterCustomizationSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACharacterCustomizationSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Customization\")\n\tvoid CustomizeCharacter(FName PartName, FName OptionName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Customization\")\n\tvoid PreviewCharacter();\n\nprivate:\n\tUPROPERTY(EditDefaultsOnly, Category=\"Customization\")\n\tTMap<FName, TMap<FName, class UMeshComponent*>> CustomizationOptions;\n\n\tUPROPERTY(VisibleAnywhere, Category=\"Customization\")\n\tclass USkeletalMeshComponent* CharacterMesh;\n};\n```", "cpp_code": "```cpp\n#include \"CharacterCustomizationSystem.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n\nACharacterCustomizationSystem::ACharacterCustomizationSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCharacterMesh = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"CharacterMesh\"));\n\tRootComponent = CharacterMesh;\n}\n\nvoid ACharacterCustomizationSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACharacterCustomizationSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACharacterCustomizationSystem::CustomizeCharacter(FName PartName, FName OptionName)\n{\n\tif (CustomizationOptions.Contains(PartName))\n\t{\n\t\tTMap<FName, UMeshComponent*>& Options = CustomizationOptions[PartName];\n\t\tif (Options.Contains(OptionName))\n\t\t{\n\t\t\tUMeshComponent* SelectedOption = Options[OptionName];\n\t\t\tif (SelectedOption)\n\t\t\t{\n\t\t\t\tCharacterMesh->SetSkeletalMesh(Cast<USkeletalMesh>(SelectedOption));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ACharacterCustomizationSystem::PreviewCharacter()\n{\n\t// Logic to update the character preview in real-time\n\t// Could involve redrawing the character or updating the viewport\n}\n```"}
{"requirement": "Develop an in-game encyclopedia for tracking lore and character information.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EncyclopediaEntry.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FEncyclopediaEntry\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Encyclopedia\")\n\tFString Title;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Encyclopedia\")\n\tFString Description;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Encyclopedia\")\n\tFString Category;\n};\n\nUCLASS()\nclass YOURGAME_API AEncyclopedia : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAEncyclopedia();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Encyclopedia\")\n\tvoid AddEntry(const FEncyclopediaEntry& NewEntry);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Encyclopedia\")\n\tFEncyclopediaEntry GetEntryByTitle(const FString& Title) const;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Encyclopedia\")\n\tTArray<FEncyclopediaEntry> GetAllEntries() const;\n\nprivate:\n\tUPROPERTY()\n\tTArray<FEncyclopediaEntry> Entries;\n};\n```", "cpp_code": "```cpp\n#include \"Encyclopedia.h\"\n\nAEncyclopedia::AEncyclopedia()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AEncyclopedia::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AEncyclopedia::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AEncyclopedia::AddEntry(const FEncyclopediaEntry& NewEntry)\n{\n\tEntries.Add(NewEntry);\n}\n\nFEncyclopediaEntry AEncyclopedia::GetEntryByTitle(const FString& Title) const\n{\n\tfor (const FEncyclopediaEntry& Entry : Entries)\n\t{\n\t\tif (Entry.Title == Title)\n\t\t{\n\t\t\treturn Entry;\n\t\t}\n\t}\n\treturn FEncyclopediaEntry();\n}\n\nTArray<FEncyclopediaEntry> AEncyclopedia::GetAllEntries() const\n{\n\treturn Entries;\n}\n```"}
{"requirement": "Implement a multiplayer ranking system with leaderboards and achievements.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameStateBase.h\"\n#include \"MultiplayerRankingSystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FPlayerStats\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString PlayerName;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 Score;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tint32 Achievements;\n\n\tFPlayerStats() : PlayerName(TEXT(\"\")), Score(0), Achievements(0) {}\n};\n\nUCLASS()\nclass MYGAME_API AMultiplayerRankingSystem : public AGameStateBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMultiplayerRankingSystem();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Ranking\")\n\tvoid UpdatePlayerStats(const FString& PlayerName, int32 Score, int32 Achievements);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Ranking\")\n\tTArray<FPlayerStats> GetLeaderboard() const;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Achievements\")\n\tbool UnlockAchievement(const FString& PlayerName, int32 AchievementId);\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Ranking\")\n\tTArray<FPlayerStats> PlayerStats;\n\n\tUFUNCTION()\n\tvoid SortLeaderboard();\n};\n```", "cpp_code": "```cpp\n#include \"MultiplayerRankingSystem.h\"\n\nAMultiplayerRankingSystem::AMultiplayerRankingSystem()\n{\n\t// Initialize default values if needed\n}\n\nvoid AMultiplayerRankingSystem::UpdatePlayerStats(const FString& PlayerName, int32 Score, int32 Achievements)\n{\n\tFPlayerStats* ExistingPlayer = PlayerStats.FindByPredicate([PlayerName](const FPlayerStats& Stat)\n\t{\n\t\treturn Stat.PlayerName == PlayerName;\n\t});\n\n\tif (ExistingPlayer)\n\t{\n\t\tExistingPlayer->Score += Score;\n\t\tExistingPlayer->Achievements += Achievements;\n\t}\n\telse\n\t{\n\t\tFPlayerStats NewPlayer;\n\t\tNewPlayer.PlayerName = PlayerName;\n\t\tNewPlayer.Score = Score;\n\t\tNewPlayer.Achievements = Achievements;\n\t\tPlayerStats.Add(NewPlayer);\n\t}\n\n\tSortLeaderboard();\n}\n\nTArray<FPlayerStats> AMultiplayerRankingSystem::GetLeaderboard() const\n{\n\treturn PlayerStats;\n}\n\nbool AMultiplayerRankingSystem::UnlockAchievement(const FString& PlayerName, int32 AchievementId)\n{\n\tFPlayerStats* ExistingPlayer = PlayerStats.FindByPredicate([PlayerName](const FPlayerStats& Stat)\n\t{\n\t\treturn Stat.PlayerName == PlayerName;\n\t});\n\n\tif (ExistingPlayer)\n\t{\n\t\tExistingPlayer->Achievements |= (1 << AchievementId);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid AMultiplayerRankingSystem::SortLeaderboard()\n{\n\tPlayerStats.Sort([](const FPlayerStats& A, const FPlayerStats& B)\n\t{\n\t\treturn A.Score > B.Score;\n\t});\n}\n```"}
{"requirement": "Create a seamless transition system between different gameplay areas.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameplayTransitionSystem.generated.h\"\n\nUCLASS()\nclass MYGAME_API AGameplayTransitionSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAGameplayTransitionSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Transition\")\n\tvoid StartTransitionToArea(FName AreaName);\n\nprivate:\n\tvoid LoadArea(FName AreaName);\n\tvoid UnloadCurrentArea();\n\n\tFName CurrentArea;\n};\n```", "cpp_code": "```cpp\n#include \"GameplayTransitionSystem.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAGameplayTransitionSystem::AGameplayTransitionSystem()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AGameplayTransitionSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCurrentArea = NAME_None; // No area loaded initially\n}\n\n// Called every frame\nvoid AGameplayTransitionSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AGameplayTransitionSystem::StartTransitionToArea(FName AreaName)\n{\n\tif (CurrentArea != AreaName)\n\t{\n\t\tUnloadCurrentArea();\n\t\tLoadArea(AreaName);\n\t}\n}\n\nvoid AGameplayTransitionSystem::LoadArea(FName AreaName)\n{\n\t// Logic to load the new area\n\tUGameplayStatics::OpenLevel(this, AreaName);\n\tCurrentArea = AreaName;\n}\n\nvoid AGameplayTransitionSystem::UnloadCurrentArea()\n{\n\t// Logic to unload the current area if needed\n\t// This might be unnecessary if the engine handles it automatically\n}\n```"}
{"requirement": "Design a cooperative gameplay system with shared objectives and rewards.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CoopObjective.generated.h\"\n\nUCLASS()\nclass MYGAME_API ACoopObjective : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACoopObjective();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\n\t// Objective completion status\n\tbool bIsCompleted;\n\n\t// Objective progress\n\tint32 Progress;\n\n\t// Objective target\n\tint32 Target;\n\n\t// Reward for completing the objective\n\tint32 RewardPoints;\n\n\t// Function to handle objective progress\n\tvoid UpdateProgress(int32 Amount);\n\n\t// Function to check if objective is complete\n\tvoid CheckCompletion();\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to be called by players to contribute to the objective\n\tUFUNCTION(BlueprintCallable, Category=\"Objective\")\n\tvoid ContributeToObjective(int32 Amount);\n\n\t// Event triggered when the objective is completed\n\tUFUNCTION(BlueprintImplementableEvent, Category=\"Objective\")\n\tvoid OnObjectiveCompleted();\n};\n```", "cpp_code": "```cpp\n#include \"CoopObjective.h\"\n\n// Sets default values\nACoopObjective::ACoopObjective()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tbIsCompleted = false;\n\tProgress = 0;\n\tTarget = 100; // Example target value\n\tRewardPoints = 50; // Example reward value\n}\n\n// Called when the game starts or when spawned\nvoid ACoopObjective::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACoopObjective::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACoopObjective::ContributeToObjective(int32 Amount)\n{\n\tif (!bIsCompleted)\n\t{\n\t\tUpdateProgress(Amount);\n\t\tCheckCompletion();\n\t}\n}\n\nvoid ACoopObjective::UpdateProgress(int32 Amount)\n{\n\tProgress += Amount;\n\tif (Progress >= Target)\n\t{\n\t\tProgress = Target;\n\t}\n}\n\nvoid ACoopObjective::CheckCompletion()\n{\n\tif (Progress >= Target && !bIsCompleted)\n\t{\n\t\tbIsCompleted = true;\n\t\tOnObjectiveCompleted();\n\t\t// Distribute rewards to players\n\t\t// This could be expanded to interact with a player management system\n\t}\n}\n```"}
{"requirement": "Develop a branching quest system with multiple paths and outcomes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"QuestSystem.generated.h\"\n\nUENUM(BlueprintType)\nenum class EQuestStatus : uint8\n{\n\tNotStarted,\n\tInProgress,\n\tCompleted,\n\tFailed\n};\n\nUSTRUCT(BlueprintType)\nstruct FQuestPath\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tFString Description;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tTArray<FString> Outcomes;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\n\tTArray<FString> NextPaths;\n};\n\nUCLASS()\nclass MYGAME_API AQuestSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAQuestSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Quest\")\n\tvoid StartQuest(const FString& QuestID);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Quest\")\n\tvoid ProgressQuest(const FString& QuestID, const FString& PathID);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Quest\")\n\tEQuestStatus GetQuestStatus(const FString& QuestID) const;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tTMap<FString, EQuestStatus> QuestStatuses;\n\n\tUPROPERTY(EditAnywhere)\n\tTMap<FString, TArray<FQuestPath>> QuestPaths;\n};\n```", "cpp_code": "```cpp\n#include \"QuestSystem.h\"\n\nAQuestSystem::AQuestSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AQuestSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AQuestSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AQuestSystem::StartQuest(const FString& QuestID)\n{\n\tif (!QuestStatuses.Contains(QuestID))\n\t{\n\t\tQuestStatuses.Add(QuestID, EQuestStatus::InProgress);\n\t\t// Initialize quest paths if necessary\n\t}\n}\n\nvoid AQuestSystem::ProgressQuest(const FString& QuestID, const FString& PathID)\n{\n\tif (QuestStatuses.Contains(QuestID) && QuestStatuses[QuestID] == EQuestStatus::InProgress)\n\t{\n\t\tif (QuestPaths.Contains(QuestID))\n\t\t{\n\t\t\tfor (const FQuestPath& Path : QuestPaths[QuestID])\n\t\t\t{\n\t\t\t\tif (Path.Description == PathID)\n\t\t\t\t{\n\t\t\t\t\t// Handle outcomes and determine next paths\n\t\t\t\t\t// This logic can be expanded based on gameplay requirements\n\t\t\t\t\tQuestStatuses[QuestID] = EQuestStatus::Completed;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nEQuestStatus AQuestSystem::GetQuestStatus(const FString& QuestID) const\n{\n\tif (QuestStatuses.Contains(QuestID))\n\t{\n\t\treturn QuestStatuses[QuestID];\n\t}\n\treturn EQuestStatus::NotStarted;\n}\n```"}
{"requirement": "Construct an AI-driven wildlife system that behaves naturally in its environment.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WildlifeAI.generated.h\"\n\nUCLASS()\nclass AWildlifeAI : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAWildlifeAI();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tfloat MovementSpeed;\n\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tfloat DetectionRadius;\n\n\tUFUNCTION()\n\tvoid MoveToRandomLocation();\n\n\tUFUNCTION()\n\tvoid DetectThreats();\n};\n```", "cpp_code": "```cpp\n#include \"WildlifeAI.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAWildlifeAI::AWildlifeAI()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementSpeed = 200.0f;\n\tDetectionRadius = 500.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AWildlifeAI::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tMoveToRandomLocation();\n}\n\n// Called every frame\nvoid AWildlifeAI::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tDetectThreats();\n}\n\nvoid AWildlifeAI::MoveToRandomLocation()\n{\n\tFVector NewLocation = GetActorLocation() + FMath::VRand() * MovementSpeed;\n\tSetActorLocation(NewLocation);\n}\n\nvoid AWildlifeAI::DetectThreats()\n{\n\tTArray<AActor*> DetectedActors;\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), AActor::StaticClass(), DetectedActors);\n\n\tfor (AActor* Actor : DetectedActors)\n\t{\n\t\tfloat Distance = FVector::Dist(GetActorLocation(), Actor->GetActorLocation());\n\t\tif (Distance < DetectionRadius)\n\t\t{\n\t\t\t// Implement logic to react to threats\n\t\t}\n\t}\n}\n```"}
{"requirement": "Integrate a procedural texture generation system for realistic surfaces.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ProceduralTextureGenerator.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AProceduralTextureGenerator : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAProceduralTextureGenerator();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"ProceduralTexture\")\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"ProceduralTexture\")\n\tUTexture2D* GeneratedTexture;\n\n\tUFUNCTION(BlueprintCallable, Category = \"ProceduralTexture\")\n\tvoid GenerateTexture();\n};\n```", "cpp_code": "```cpp\n#include \"ProceduralTextureGenerator.h\"\n#include \"Engine/Texture2D.h\"\n#include \"Engine/World.h\"\n#include \"Materials/Material.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAProceduralTextureGenerator::AProceduralTextureGenerator()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> Material(TEXT(\"Material'/Game/Materials/YourMaterial.YourMaterial'\"));\n\tif (Material.Succeeded())\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(Material.Object, this);\n\t}\n}\n\nvoid AProceduralTextureGenerator::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (DynamicMaterialInstance)\n\t{\n\t\tGenerateTexture();\n\t}\n}\n\nvoid AProceduralTextureGenerator::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AProceduralTextureGenerator::GenerateTexture()\n{\n\tint32 Width = 512;\n\tint32 Height = 512;\n\tGeneratedTexture = UTexture2D::CreateTransient(Width, Height);\n\tFTexture2DMipMap& Mip = GeneratedTexture->PlatformData->Mips[0];\n\tFByteBulkData* RawImageData = &Mip.BulkData;\n\n\tuint8* TextureData = (uint8*)RawImageData->Lock(LOCK_READ_WRITE);\n\tfor (int32 Y = 0; Y < Height; Y++)\n\t{\n\t\tfor (int32 X = 0; X < Width; X++)\n\t\t{\n\t\t\tint32 Index = ((Y * Width) + X) * 4;\n\t\t\tTextureData[Index + 0] = FMath::Rand() % 256; // R\n\t\t\tTextureData[Index + 1] = FMath::Rand() % 256; // G\n\t\t\tTextureData[Index + 2] = FMath::Rand() % 256; // B\n\t\t\tTextureData[Index + 3] = 255; // A\n\t\t}\n\t}\n\tRawImageData->Unlock();\n\tGeneratedTexture->UpdateResource();\n\n\tif (DynamicMaterialInstance)\n\t{\n\t\tDynamicMaterialInstance->SetTextureParameterValue(FName(\"YourTextureParameter\"), GeneratedTexture);\n\t}\n}\n```"}
{"requirement": "Design a player feedback system for reporting bugs and suggesting features.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FeedbackSystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FPlayerFeedback\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(BlueprintReadWrite, Category = \"Feedback\")\n\tFString PlayerName;\n\n\tUPROPERTY(BlueprintReadWrite, Category = \"Feedback\")\n\tFString FeedbackType; // \"Bug\" or \"Feature\"\n\n\tUPROPERTY(BlueprintReadWrite, Category = \"Feedback\")\n\tFString Description;\n\n\tFPlayerFeedback() {}\n\n\tFPlayerFeedback(FString Name, FString Type, FString Desc)\n\t\t: PlayerName(Name), FeedbackType(Type), Description(Desc) {}\n};\n\nUCLASS()\nclass YOURPROJECT_API AFeedbackSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAFeedbackSystem();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Feedback\")\n\tvoid SubmitFeedback(FPlayerFeedback Feedback);\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tTArray<FPlayerFeedback> FeedbackList;\n};\n```", "cpp_code": "```cpp\n#include \"FeedbackSystem.h\"\n\nAFeedbackSystem::AFeedbackSystem()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AFeedbackSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AFeedbackSystem::SubmitFeedback(FPlayerFeedback Feedback)\n{\n\tFeedbackList.Add(Feedback);\n\tUE_LOG(LogTemp, Log, TEXT(\"Feedback received from %s: [%s] %s\"), *Feedback.PlayerName, *Feedback.FeedbackType, *Feedback.Description);\n\t// Additional code to save feedback to a file or send it to a server could be added here.\n}\n```"}
{"requirement": "Create a system for simulating seasonal changes in an open-world game.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SeasonalManager.generated.h\"\n\nUENUM(BlueprintType)\nenum class ESeason : uint8\n{\n\tSpring UMETA(DisplayName = \"Spring\"),\n\tSummer UMETA(DisplayName = \"Summer\"),\n\tAutumn UMETA(DisplayName = \"Autumn\"),\n\tWinter UMETA(DisplayName = \"Winter\")\n};\n\nUCLASS()\nclass MYGAME_API ASeasonalManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASeasonalManager();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Season\")\n\tESeason CurrentSeason;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Season\")\n\tfloat SeasonDuration;\n\nprivate:\n\tfloat SeasonTimer;\n\n\tvoid ChangeSeason();\n};\n```", "cpp_code": "```cpp\n#include \"SeasonalManager.h\"\n\nASeasonalManager::ASeasonalManager()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentSeason = ESeason::Spring;\n\tSeasonDuration = 60.0f; // Default duration for each season in seconds\n\tSeasonTimer = 0.0f;\n}\n\nvoid ASeasonalManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASeasonalManager::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tSeasonTimer += DeltaTime;\n\tif (SeasonTimer >= SeasonDuration)\n\t{\n\t\tChangeSeason();\n\t\tSeasonTimer = 0.0f;\n\t}\n}\n\nvoid ASeasonalManager::ChangeSeason()\n{\n\tswitch (CurrentSeason)\n\t{\n\tcase ESeason::Spring:\n\t\tCurrentSeason = ESeason::Summer;\n\t\tbreak;\n\tcase ESeason::Summer:\n\t\tCurrentSeason = ESeason::Autumn;\n\t\tbreak;\n\tcase ESeason::Autumn:\n\t\tCurrentSeason = ESeason::Winter;\n\t\tbreak;\n\tcase ESeason::Winter:\n\t\tCurrentSeason = ESeason::Spring;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t// Trigger any seasonal change effects here, e.g., altering environment visuals\n}\n```"}
{"requirement": "Develop a motion sickness reduction system for VR experiences.", "header_code": "```cpp\nUCLASS()\nclass VRPROJECT_API AMotionSicknessReductionSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMotionSicknessReductionSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid AdjustFOV(float DeltaTime);\n\tvoid StabilizeHorizon(float DeltaTime);\n\n\tUPROPERTY(EditAnywhere, Category = \"MotionSickness\")\n\tfloat TargetFOV;\n\n\tUPROPERTY(EditAnywhere, Category = \"MotionSickness\")\n\tfloat FOVChangeSpeed;\n\n\tUPROPERTY(EditAnywhere, Category = \"MotionSickness\")\n\tbool bStabilizeHorizon;\n};\n```", "cpp_code": "```cpp\n#include \"MotionSicknessReductionSystem.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Camera/CameraComponent.h\"\n\nAMotionSicknessReductionSystem::AMotionSicknessReductionSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTargetFOV = 90.0f;\n\tFOVChangeSpeed = 2.0f;\n\tbStabilizeHorizon = true;\n}\n\nvoid AMotionSicknessReductionSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMotionSicknessReductionSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tAdjustFOV(DeltaTime);\n\tif (bStabilizeHorizon)\n\t{\n\t\tStabilizeHorizon(DeltaTime);\n\t}\n}\n\nvoid AMotionSicknessReductionSystem::AdjustFOV(float DeltaTime)\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController && PlayerController->PlayerCameraManager)\n\t{\n\t\tfloat CurrentFOV = PlayerController->PlayerCameraManager->GetFOVAngle();\n\t\tfloat NewFOV = FMath::FInterpTo(CurrentFOV, TargetFOV, DeltaTime, FOVChangeSpeed);\n\t\tPlayerController->PlayerCameraManager->SetFOV(NewFOV);\n\t}\n}\n\nvoid AMotionSicknessReductionSystem::StabilizeHorizon(float DeltaTime)\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tFRotator ControlRotation = PlayerController->GetControlRotation();\n\t\tControlRotation.Roll = 0;\n\t\tPlayerController->SetControlRotation(ControlRotation);\n\t}\n}\n```"}
{"requirement": "Implement a physics-based vehicle handling system for a racing game.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"PhysicsVehicle.generated.h\"\n\nUCLASS()\nclass RACINGGAME_API APhysicsVehicle : public APawn\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this pawn's properties\n\tAPhysicsVehicle();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Movement functions\n\tvoid MoveForward(float Value);\n\tvoid MoveRight(float Value);\n\nprivate:\n\t// Vehicle properties\n\tUPROPERTY(EditAnywhere, Category=\"Vehicle\")\n\tfloat MaxSpeed;\n\n\tUPROPERTY(EditAnywhere, Category=\"Vehicle\")\n\tfloat Acceleration;\n\n\tUPROPERTY(EditAnywhere, Category=\"Vehicle\")\n\tfloat TurnSpeed;\n\n\t// Current speed\n\tfloat CurrentSpeed;\n\n\t// Current turn rate\n\tfloat CurrentTurnRate;\n};\n```", "cpp_code": "```cpp\n#include \"PhysicsVehicle.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAPhysicsVehicle::APhysicsVehicle()\n{\n\t// Set this pawn to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize defaults\n\tMaxSpeed = 1200.0f;\n\tAcceleration = 500.0f;\n\tTurnSpeed = 100.0f;\n\tCurrentSpeed = 0.0f;\n\tCurrentTurnRate = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid APhysicsVehicle::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APhysicsVehicle::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update vehicle speed and position\n\tFVector ForwardVector = GetActorForwardVector();\n\tFVector NewLocation = GetActorLocation() + (ForwardVector * CurrentSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n\n\t// Update vehicle rotation\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += CurrentTurnRate * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n\n// Called to bind functionality to input\nvoid APhysicsVehicle::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &APhysicsVehicle::MoveForward);\n\tPlayerInputComponent->BindAxis(\"MoveRight\", this, &APhysicsVehicle::MoveRight);\n}\n\nvoid APhysicsVehicle::MoveForward(float Value)\n{\n\t// Accelerate the vehicle\n\tCurrentSpeed = FMath::Clamp(CurrentSpeed + (Value * Acceleration * GetWorld()->DeltaTimeSeconds), 0.0f, MaxSpeed);\n}\n\nvoid APhysicsVehicle::MoveRight(float Value)\n{\n\t// Turn the vehicle\n\tCurrentTurnRate = Value * TurnSpeed;\n}\n```"}
{"requirement": "Create an object interaction system for picking up and using items.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ItemInteractionSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AItemInteractionSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAItemInteractionSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Item Interaction\")\n\tvoid PickUpItem(AActor* Item);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Item Interaction\")\n\tvoid UseItem(AActor* Item);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Item Interaction\")\n\tTArray<AActor*> Inventory;\n};\n```", "cpp_code": "```cpp\n#include \"ItemInteractionSystem.h\"\n#include \"GameFramework/Actor.h\"\n\nAItemInteractionSystem::AItemInteractionSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AItemInteractionSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AItemInteractionSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AItemInteractionSystem::PickUpItem(AActor* Item)\n{\n\tif (Item)\n\t{\n\t\tInventory.Add(Item);\n\t\tItem->SetActorHiddenInGame(true);\n\t\tItem->SetActorEnableCollision(false);\n\t\tItem->SetActorTickEnabled(false);\n\t}\n}\n\nvoid AItemInteractionSystem::UseItem(AActor* Item)\n{\n\tif (Item && Inventory.Contains(Item))\n\t{\n\t\t// Implement the logic for using the item\n\t\tInventory.Remove(Item);\n\t\tItem->SetActorHiddenInGame(false);\n\t\tItem->SetActorEnableCollision(true);\n\t\tItem->SetActorTickEnabled(true);\n\t}\n}\n```"}
{"requirement": "Design a multi-tiered character progression system with unique abilities.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"ProgressionCharacter.generated.h\"\n\nUENUM(BlueprintType)\nenum class ETierLevel : uint8 {\n\tTier1 UMETA(DisplayName = \"Tier 1\"),\n\tTier2 UMETA(DisplayName = \"Tier 2\"),\n\tTier3 UMETA(DisplayName = \"Tier 3\")\n};\n\nUCLASS()\nclass MYGAME_API AProgressionCharacter : public ACharacter {\n\tGENERATED_BODY()\n\npublic:\n\tAProgressionCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Progression\")\n\tETierLevel CurrentTier;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Abilities\")\n\tvoid ActivateAbility();\n\nprivate:\n\tvoid InitializeAbilities();\n\tvoid Tier1Abilities();\n\tvoid Tier2Abilities();\n\tvoid Tier3Abilities();\n};\n```", "cpp_code": "```cpp\n#include \"ProgressionCharacter.h\"\n\nAProgressionCharacter::AProgressionCharacter() {\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentTier = ETierLevel::Tier1;\n\tInitializeAbilities();\n}\n\nvoid AProgressionCharacter::BeginPlay() {\n\tSuper::BeginPlay();\n}\n\nvoid AProgressionCharacter::Tick(float DeltaTime) {\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AProgressionCharacter::ActivateAbility() {\n\tswitch (CurrentTier) {\n\t\tcase ETierLevel::Tier1:\n\t\t\tTier1Abilities();\n\t\t\tbreak;\n\t\tcase ETierLevel::Tier2:\n\t\t\tTier2Abilities();\n\t\t\tbreak;\n\t\tcase ETierLevel::Tier3:\n\t\t\tTier3Abilities();\n\t\t\tbreak;\n\t}\n}\n\nvoid AProgressionCharacter::InitializeAbilities() {\n\t// Initialize abilities based on tier\n}\n\nvoid AProgressionCharacter::Tier1Abilities() {\n\t// Implement Tier 1 abilities\n\tUE_LOG(LogTemp, Warning, TEXT(\"Tier 1 Ability Activated\"));\n}\n\nvoid AProgressionCharacter::Tier2Abilities() {\n\t// Implement Tier 2 abilities\n\tUE_LOG(LogTemp, Warning, TEXT(\"Tier 2 Ability Activated\"));\n}\n\nvoid AProgressionCharacter::Tier3Abilities() {\n\t// Implement Tier 3 abilities\n\tUE_LOG(LogTemp, Warning, TEXT(\"Tier 3 Ability Activated\"));\n}\n```"}
{"requirement": "Develop a virtual pet system with needs and interactions with the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VirtualPet.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVirtualPet : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tAVirtualPet();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Pet Needs\")\n\tfloat Hunger;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Pet Needs\")\n\tfloat Thirst;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Pet Needs\")\n\tfloat Happiness;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Pet Interactions\")\n\tvoid FeedPet(float FoodAmount);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Pet Interactions\")\n\tvoid GiveWater(float WaterAmount);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Pet Interactions\")\n\tvoid PlayWithPet(float PlayTime);\n\nprivate:\n\tvoid UpdateNeeds(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"VirtualPet.h\"\n\nAVirtualPet::AVirtualPet()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHunger = 100.0f;\n\tThirst = 100.0f;\n\tHappiness = 100.0f;\n}\n\nvoid AVirtualPet::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AVirtualPet::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateNeeds(DeltaTime);\n}\n\nvoid AVirtualPet::UpdateNeeds(float DeltaTime)\n{\n\tHunger -= DeltaTime * 0.5f;\n\tThirst -= DeltaTime * 0.5f;\n\tHappiness -= DeltaTime * 0.2f;\n\n\tHunger = FMath::Clamp(Hunger, 0.0f, 100.0f);\n\tThirst = FMath::Clamp(Thirst, 0.0f, 100.0f);\n\tHappiness = FMath::Clamp(Happiness, 0.0f, 100.0f);\n}\n\nvoid AVirtualPet::FeedPet(float FoodAmount)\n{\n\tHunger += FoodAmount;\n\tHunger = FMath::Clamp(Hunger, 0.0f, 100.0f);\n}\n\nvoid AVirtualPet::GiveWater(float WaterAmount)\n{\n\tThirst += WaterAmount;\n\tThirst = FMath::Clamp(Thirst, 0.0f, 100.0f);\n}\n\nvoid AVirtualPet::PlayWithPet(float PlayTime)\n{\n\tHappiness += PlayTime * 5.0f;\n\tHappiness = FMath::Clamp(Happiness, 0.0f, 100.0f);\n}\n```"}
{"requirement": "Construct a real-time team chat system with text and voice support.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Voice/Public/VoiceModule.h\"\n#include \"Sockets.h\"\n#include \"Networking.h\"\n#include \"TeamChatSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATeamChatSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATeamChatSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Chat\")\n\tvoid SendTextMessage(const FString& Message);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Chat\")\n\tvoid StartVoiceTransmission();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Chat\")\n\tvoid StopVoiceTransmission();\n\nprivate:\n\tvoid InitializeSocket();\n\tvoid ProcessIncomingMessages();\n\tvoid ProcessIncomingVoiceData();\n\n\tFSocket* ChatSocket;\n\tFVoiceModule* VoiceModule;\n\tTArray<uint8> VoiceDataBuffer;\n};\n```", "cpp_code": "```cpp\n#include \"TeamChatSystem.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n#include \"Voice/Public/VoiceCapture.h\"\n#include \"Voice/Public/VoicePacketBuffer.h\"\n#include \"Sockets.h\"\n#include \"SocketSubsystem.h\"\n\nATeamChatSystem::ATeamChatSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tChatSocket = nullptr;\n\tVoiceModule = &FVoiceModule::Get();\n}\n\nvoid ATeamChatSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitializeSocket();\n}\n\nvoid ATeamChatSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tProcessIncomingMessages();\n\tProcessIncomingVoiceData();\n}\n\nvoid ATeamChatSystem::InitializeSocket()\n{\n\tISocketSubsystem* SocketSubsystem = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM);\n\tChatSocket = SocketSubsystem->CreateSocket(NAME_Stream, TEXT(\"ChatSocket\"), false);\n\t// Setup socket connection here (e.g., IP and port)\n}\n\nvoid ATeamChatSystem::SendTextMessage(const FString& Message)\n{\n\tif (ChatSocket)\n\t{\n\t\tTArray<uint8> Data;\n\t\tFMemoryWriter Writer(Data);\n\t\tWriter << Message;\n\n\t\tint32 BytesSent;\n\t\tChatSocket->Send(Data.GetData(), Data.Num(), BytesSent);\n\t}\n}\n\nvoid ATeamChatSystem::StartVoiceTransmission()\n{\n\tif (VoiceModule)\n\t{\n\t\tTSharedPtr<IVoiceCapture> VoiceCapture = VoiceModule->CreateVoiceCapture();\n\t\tVoiceCapture->Start();\n\t\t// Voice data capturing logic\n\t}\n}\n\nvoid ATeamChatSystem::StopVoiceTransmission()\n{\n\tif (VoiceModule)\n\t{\n\t\tTSharedPtr<IVoiceCapture> VoiceCapture = VoiceModule->CreateVoiceCapture();\n\t\tVoiceCapture->Stop();\n\t}\n}\n\nvoid ATeamChatSystem::ProcessIncomingMessages()\n{\n\tif (ChatSocket)\n\t{\n\t\tTArray<uint8> ReceivedData;\n\t\tuint32 Size;\n\t\twhile (ChatSocket->HasPendingData(Size))\n\t\t{\n\t\t\tReceivedData.SetNumUninitialized(FMath::Min(Size, 65507u));\n\t\t\tint32 Read = 0;\n\t\t\tChatSocket->Recv(ReceivedData.GetData(), ReceivedData.Num(), Read);\n\t\t\t// Process the received text message\n\t\t}\n\t}\n}\n\nvoid ATeamChatSystem::ProcessIncomingVoiceData()\n{\n\t// Process voice data received\n\tif (!VoiceDataBuffer.IsEmpty())\n\t{\n\t\t// Handle voice data\n\t}\n}\n```"}
{"requirement": "Create a basic Actor class that rotates continuously using the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize rotation speed\n\tRotationSpeed = FRotator(0.0f, 45.0f, 0.0f); // Rotating 45 degrees per second on the Yaw (Z-axis)\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Rotate actor\n\tAddActorLocalRotation(RotationSpeed * DeltaTime);\n}\n```"}
{"requirement": "Implement a UMG widget that displays a player's health percentage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UHealthWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UHealthWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Health\")\n\tvoid UpdateHealth(float HealthPercentage);\n\nprotected:\n\tUPROPERTY(BlueprintReadOnly, meta=(BindWidget))\n\tclass UProgressBar* HealthProgressBar;\n};\n```", "cpp_code": "```cpp\n#include \"UHealthWidget.h\"\n#include \"Components/ProgressBar.h\"\n\nvoid UHealthWidget::UpdateHealth(float HealthPercentage)\n{\n\tif (HealthProgressBar)\n\t{\n\t\tHealthProgressBar->SetPercent(HealthPercentage);\n\t}\n}\n```"}
{"requirement": "Develop a simple AI Controller that moves an AI character to a random location within a given radius.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"AICharacterController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAICharacterController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAICharacterController();\n\n\tvirtual void BeginPlay() override;\n\nprotected:\n\tUPROPERTY(EditAnywhere, Category=\"AI\")\n\tfloat MoveRadius;\n\nprivate:\n\tvoid MoveToRandomLocation();\n};\n```", "cpp_code": "```cpp\n#include \"AICharacterController.h\"\n#include \"NavigationSystem.h\"\n#include \"GameFramework/Actor.h\"\n\nAAICharacterController::AAICharacterController()\n{\n\tMoveRadius = 1000.0f; // Default radius\n}\n\nvoid AAICharacterController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tMoveToRandomLocation();\n}\n\nvoid AAICharacterController::MoveToRandomLocation()\n{\n\tif (AActor* ControlledPawn = GetPawn())\n\t{\n\t\tFVector Origin = ControlledPawn->GetActorLocation();\n\t\tFVector RandomPoint;\n\t\tUNavigationSystemV1* NavSystem = FNavigationSystem::GetCurrent<UNavigationSystemV1>(this);\n\n\t\tif (NavSystem && NavSystem->GetRandomPointInNavigableRadius(Origin, MoveRadius, RandomPoint))\n\t\t{\n\t\t\tMoveToLocation(RandomPoint);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor class that changes color upon collision with another Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to change color\n\tUFUNCTION()\n\tvoid ChangeColor();\n\n\t// Called when there is a collision\n\tUFUNCTION()\n\tvoid OnCollision(AActor* SelfActor, AActor* OtherActor, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY()\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAColorChangingActor::AColorChangingActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set up collision handling\n\tMeshComponent->OnComponentHit.AddDynamic(this, &AColorChangingActor::OnCollision);\n\n\t// Find and set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Create a dynamic material instance\n\tDynamicMaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AColorChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AColorChangingActor::ChangeColor()\n{\n\tif (DynamicMaterialInstance)\n\t{\n\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\tDynamicMaterialInstance->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t}\n}\n\nvoid AColorChangingActor::OnCollision(AActor* SelfActor, AActor* OtherActor, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tChangeColor();\n}\n```"}
{"requirement": "Implement a BlueprintCallable function in an Actor class to reset its position.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PositionResetActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APositionResetActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPositionResetActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Position\")\n\tvoid ResetPosition();\n\nprotected:\n\tFVector InitialPosition;\n\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"PositionResetActor.h\"\n\n// Sets default values\nAPositionResetActor::APositionResetActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid APositionResetActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Store the initial position of the actor\n\tInitialPosition = GetActorLocation();\n}\n\nvoid APositionResetActor::ResetPosition()\n{\n\t// Set the actor's position back to the initial position\n\tSetActorLocation(InitialPosition);\n}\n```"}
{"requirement": "Create a static mesh component that scales up when the player presses a specific input key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleMeshOnInputActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AScaleMeshOnInputActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScaleMeshOnInputActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUFUNCTION()\n\tvoid ScaleUpMesh();\n\n\tFVector InitialScale;\n\tFVector TargetScale;\n\tfloat ScaleFactor;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleMeshOnInputActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"ConstructorHelpers.h\"\n\nAScaleMeshOnInputActor::AScaleMeshOnInputActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tInitialScale = FVector(1.0f, 1.0f, 1.0f);\n\tTargetScale = FVector(2.0f, 2.0f, 2.0f);\n\tScaleFactor = 1.1f;\n}\n\nvoid AScaleMeshOnInputActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tStaticMeshComponent->SetWorldScale3D(InitialScale);\n}\n\nvoid AScaleMeshOnInputActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScaleMeshOnInputActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ScaleUp\", IE_Pressed, this, &AScaleMeshOnInputActor::ScaleUpMesh);\n}\n\nvoid AScaleMeshOnInputActor::ScaleUpMesh()\n{\n\tFVector CurrentScale = StaticMeshComponent->GetComponentScale();\n\tFVector NewScale = CurrentScale * ScaleFactor;\n\tif (NewScale.X <= TargetScale.X && NewScale.Y <= TargetScale.Y && NewScale.Z <= TargetScale.Z)\n\t{\n\t\tStaticMeshComponent->SetWorldScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Develop a class that plays a sound when overlapping with a specific trigger volume.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/BoxComponent.h\"\n#include \"SoundTriggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundTriggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundTriggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUBoxComponent* TriggerVolume;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"SoundTriggerActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundTriggerActor::ASoundTriggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n\tRootComponent = TriggerVolume;\n\tTriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &ASoundTriggerActor::OnOverlapBegin);\n}\n\nvoid ASoundTriggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundTriggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundTriggerActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (SoundToPlay && OtherActor != this)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Implement an Actor that spawns another Actor at a specified location upon a player's input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpawnerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpawnerActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  ASpawnerActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\n  virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\nprivate:\n  UPROPERTY(EditAnywhere, Category = \"Spawning\")\n  TSubclassOf<AActor> ActorToSpawn;\n\n  UPROPERTY(EditAnywhere, Category = \"Spawning\")\n  FVector SpawnLocation;\n\n  void SpawnActor();\n};\n```", "cpp_code": "```cpp\n#include \"SpawnerActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\nASpawnerActor::ASpawnerActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASpawnerActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid ASpawnerActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid ASpawnerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n  Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n  if (PlayerInputComponent)\n  {\n\tPlayerInputComponent->BindAction(\"Spawn\", IE_Pressed, this, &ASpawnerActor::SpawnActor);\n  }\n}\n\nvoid ASpawnerActor::SpawnActor()\n{\n  if (ActorToSpawn)\n  {\n\tFActorSpawnParameters SpawnParams;\n\tGetWorld()->SpawnActor<AActor>(ActorToSpawn, SpawnLocation, FRotator::ZeroRotator, SpawnParams);\n  }\n}\n```"}
{"requirement": "Create a UMG button widget that changes text when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UButtonTextWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UButtonTextWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUButtonTextWidget(const FObjectInitializer& ObjectInitializer);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnButtonClicked();\n\n\tUPROPERTY(meta = (BindWidget))\n\tclass UButton* MyButton;\n\n\tUPROPERTY(meta = (BindWidget))\n\tclass UTextBlock* MyTextBlock;\n\n\tbool bIsFirstText;\n};\n```", "cpp_code": "```cpp\n#include \"UButtonTextWidget.h\"\n#include \"Components/Button.h\"\n#include \"Components/TextBlock.h\"\n\nUButtonTextWidget::UButtonTextWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer), bIsFirstText(true)\n{\n}\n\nvoid UButtonTextWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\n\tif (MyButton)\n\t{\n\t\tMyButton->OnClicked.AddDynamic(this, &UButtonTextWidget::OnButtonClicked);\n\t}\n}\n\nvoid UButtonTextWidget::OnButtonClicked()\n{\n\tif (MyTextBlock)\n\t{\n\t\tif (bIsFirstText)\n\t\t{\n\t\t\tMyTextBlock->SetText(FText::FromString(\"Second Text\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMyTextBlock->SetText(FText::FromString(\"First Text\"));\n\t\t}\n\t\tbIsFirstText = !bIsFirstText;\n\t}\n}\n```"}
{"requirement": "Develop a class with a UPROPERTY that allows setting the Actor's movement speed from the editor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AMovementSpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovementSpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMovementSpeedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"AMovementSpeedActor.h\"\n\nAMovementSpeedActor::AMovementSpeedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementSpeed = 600.f; // Default movement speed\n}\n\nvoid AMovementSpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMovementSpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t// Implementation for moving the actor using MovementSpeed can be added here\n}\n```"}
{"requirement": "Implement a simple networking function to replicate the Actor's location across clients.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReplicatedActor.generated.h\"\n\nUCLASS()\nclass AReplicatedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAReplicatedActor();\n\nprotected:\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n\nprivate:\n\tUPROPERTY(ReplicatedUsing=OnRep_ReplicatedLocation)\n\tFVector ReplicatedLocation;\n\n\tUFUNCTION()\n\tvoid OnRep_ReplicatedLocation();\n\n\tvoid SetActorLocationFromReplicated();\n};\n```", "cpp_code": "```cpp\n#include \"ReplicatedActor.h\"\n#include \"Net/UnrealNetwork.h\"\n\nAReplicatedActor::AReplicatedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbReplicates = true;\n}\n\nvoid AReplicatedActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AReplicatedActor, ReplicatedLocation);\n}\n\nvoid AReplicatedActor::OnRep_ReplicatedLocation()\n{\n\tSetActorLocationFromReplicated();\n}\n\nvoid AReplicatedActor::SetActorLocationFromReplicated()\n{\n\tSetActorLocation(ReplicatedLocation);\n}\n```"}
{"requirement": "Create an Actor that follows the player's location using a simple movement function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FollowPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AFollowPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAFollowPlayerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"FollowPlayerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAFollowPlayerActor::AFollowPlayerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementSpeed = 200.0f; // Default movement speed\n}\n\n// Called when the game starts or when spawned\nvoid AFollowPlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AFollowPlayerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tAActor* PlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n\tif (PlayerActor)\n\t{\n\t\tFVector Direction = PlayerActor->GetActorLocation() - GetActorLocation();\n\t\tDirection.Normalize();\n\n\t\tFVector NewLocation = GetActorLocation() + (Direction * MovementSpeed * DeltaTime);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Implement a skeletal mesh component that plays an animation montage on input action.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimMontage.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"UPlayMontageActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APlayMontageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPlayMontageActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tclass USkeletalMeshComponent* SkeletalMeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Animation\", meta = (AllowPrivateAccess = \"true\"))\n\tUAnimMontage* AnimationMontage;\n\n\tvoid PlayAnimationMontage();\n};\n```", "cpp_code": "```cpp\n#include \"UPlayMontageActor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/InputSettings.h\"\n\nAPlayMontageActor::APlayMontageActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n}\n\nvoid APlayMontageActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APlayMontageActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APlayMontageActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"PlayMontage\", IE_Pressed, this, &APlayMontageActor::PlayAnimationMontage);\n}\n\nvoid APlayMontageActor::PlayAnimationMontage()\n{\n\tif (AnimationMontage && SkeletalMeshComponent)\n\t{\n\t\tUAnimInstance* AnimInstance = SkeletalMeshComponent->GetAnimInstance();\n\t\tif (AnimInstance)\n\t\t{\n\t\t\tAnimInstance->Montage_Play(AnimationMontage);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor that toggles its visibility when a specific key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AToggleVisibilityActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  AToggleVisibilityActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  // Setup player input\n  virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n  // Function to toggle visibility\n  void ToggleVisibility();\n\n  UPROPERTY(VisibleAnywhere)\n  UStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Create and set static mesh component\n  MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n  RootComponent = MeshComponent;\n\n  // Set default mesh (assuming \"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\" exists in the project)\n  static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n  if (MeshAsset.Succeeded())\n  {\n\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n  }\n}\n\n// Called when the game starts or when spawned\nvoid AToggleVisibilityActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n  Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n  if (PlayerInputComponent)\n  {\n\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleVisibilityActor::ToggleVisibility);\n  }\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n  if (MeshComponent)\n  {\n\tbool bIsVisible = MeshComponent->IsVisible();\n\tMeshComponent->SetVisibility(!bIsVisible);\n  }\n}\n```"}
{"requirement": "Develop a class that logs a message to the console every second using the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tALoggingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tfloat TimeAccumulator;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n#include \"Engine/Engine.h\"\n\nALoggingActor::ALoggingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTimeAccumulator = 0.0f;\n}\n\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeAccumulator += DeltaTime;\n\tif (TimeAccumulator >= 1.0f)\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Green, TEXT(\"Logging message every second\"));\n\t\t}\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION that changes the material of an Actor when called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAChangeMaterialActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Material\")\n\tvoid ChangeMaterial(UMaterialInterface* NewMaterial);\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAChangeMaterialActor::AChangeMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Optionally set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AChangeMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialActor::ChangeMaterial(UMaterialInterface* NewMaterial)\n{\n\tif (NewMaterial && MeshComponent)\n\t{\n\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a collision component that triggers an event when overlapped.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACollisionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* CollisionComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\nACollisionActor::ACollisionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tRootComponent = CollisionComponent;\n\tCollisionComponent->SetCollisionProfileName(\"Trigger\");\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionActor::OnOverlapBegin);\n}\n\nvoid ACollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Overlap Begin\"));\n\t\t}\n\t}\n}\n```"}
{"requirement": "Develop a class with a BlueprintCallable function to increase the score by a specified amount.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreManager.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScoreManager();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid IncreaseScore(int32 Amount);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Score\", meta=(AllowPrivateAccess = \"true\"))\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreManager.h\"\n\n// Sets default values\nAScoreManager::AScoreManager()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tScore = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AScoreManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScoreManager::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScoreManager::IncreaseScore(int32 Amount)\n{\n\tScore += Amount;\n}\n```"}
{"requirement": "Implement a simple AI Controller that makes an AI character patrol between two points.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"PatrolAIController.generated.h\"\n\nUCLASS()\nclass APawnPatrol : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPawnPatrol();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid MoveToNextPatrolPoint();\n\n\tUPROPERTY(EditAnywhere, Category=\"Patrol\")\n\tAActor* PatrolPoint1;\n\n\tUPROPERTY(EditAnywhere, Category=\"Patrol\")\n\tAActor* PatrolPoint2;\n\n\tAActor* CurrentPatrolPoint;\n};\n```", "cpp_code": "```cpp\n#include \"PatrolAIController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Actor.h\"\n\nAPawnPatrol::APawnPatrol()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APawnPatrol::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCurrentPatrolPoint = PatrolPoint1;\n\tMoveToNextPatrolPoint();\n}\n\nvoid APawnPatrol::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!CurrentPatrolPoint) return;\n\n\tconst FVector DistanceToGoal = GetPawn()->GetActorLocation() - CurrentPatrolPoint->GetActorLocation();\n\tif (DistanceToGoal.Size() < 100.0f)\n\t{\n\t\tMoveToNextPatrolPoint();\n\t}\n}\n\nvoid APawnPatrol::MoveToNextPatrolPoint()\n{\n\tif (CurrentPatrolPoint == PatrolPoint1)\n\t{\n\t\tCurrentPatrolPoint = PatrolPoint2;\n\t}\n\telse\n\t{\n\t\tCurrentPatrolPoint = PatrolPoint1;\n\t}\n\tMoveToActor(CurrentPatrolPoint, -1.0f);\n}\n```"}
{"requirement": "Create a class that prints the player's current location to the screen every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"APlayerLocationPrinter.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APlayerLocationPrinter : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPlayerLocationPrinter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"APlayerLocationPrinter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"Engine/Engine.h\"\n\nAPlayerLocationPrinter::APlayerLocationPrinter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APlayerLocationPrinter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APlayerLocationPrinter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tif (APawn* PlayerPawn = PlayerController->GetPawn())\n\t\t{\n\t\t\tFVector PlayerLocation = PlayerPawn->GetActorLocation();\n\t\t\tif (GEngine)\n\t\t\t{\n\t\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Player Location: %s\"), *PlayerLocation.ToString()));\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement an Actor that moves upwards continuously and resets position once reaching a certain height.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat MoveSpeed;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MaxHeight;\n\n\tFVector InitialPosition;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMoveSpeed = 100.0f; // Default speed\n\tMaxHeight = 1000.0f; // Default max height\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialPosition = GetActorLocation();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation();\n\tNewLocation.Z += MoveSpeed * DeltaTime;\n\n\tif (NewLocation.Z >= InitialPosition.Z + MaxHeight)\n\t{\n\t\tNewLocation.Z = InitialPosition.Z;\n\t}\n\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a UMG slider widget that adjusts the volume of background music.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"USliderVolumeWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API USliderVolumeWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tvirtual void NativeConstruct() override;\n\nprotected:\n\tUPROPERTY(meta = (BindWidget))\n\tclass USlider* VolumeSlider;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnVolumeSliderChanged(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"USliderVolumeWidget.h\"\n#include \"Components/Slider.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Sound/SoundMix.h\"\n#include \"Sound/SoundClass.h\"\n\nvoid USliderVolumeWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\n\tif (VolumeSlider)\n\t{\n\t\tVolumeSlider->OnValueChanged.AddDynamic(this, &USliderVolumeWidget::OnVolumeSliderChanged);\n\t\tfloat CurrentVolume = UGameplayStatics::GetSoundClassVolume(UGameplayStatics::GetSoundClassFromName(\"Master\"));\n\t\tVolumeSlider->SetValue(CurrentVolume);\n\t}\n}\n\nvoid USliderVolumeWidget::OnVolumeSliderChanged(float Value)\n{\n\tUGameplayStatics::SetSoundClassVolume(UGameplayStatics::GetSoundClassFromName(\"Master\"), Value);\n}\n```"}
{"requirement": "Develop a class that changes the Actor's scale based on the player's velocity.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/Character.h\"\n#include \"ScaleWithVelocityActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AScaleWithVelocityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScaleWithVelocityActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tACharacter* PlayerCharacter;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat ScaleFactor;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleWithVelocityActor.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAScaleWithVelocityActor::AScaleWithVelocityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScaleFactor = 0.01f;\n}\n\nvoid AScaleWithVelocityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);\n}\n\nvoid AScaleWithVelocityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerCharacter)\n\t{\n\t\tFVector Velocity = PlayerCharacter->GetVelocity();\n\t\tfloat Speed = Velocity.Size();\n\t\tFVector NewScale = FVector::OneVector + Speed * ScaleFactor * FVector::OneVector;\n\t\tSetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function that destroys the Actor after a delay.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DestroyAfterDelayActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADestroyAfterDelayActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tADestroyAfterDelayActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Custom\")\n\tvoid DestroyActorAfterDelay(float DelayInSeconds);\n\nprivate:\n\tvoid PerformDestroy();\n};\n```", "cpp_code": "```cpp\n#include \"DestroyAfterDelayActor.h\"\n#include \"TimerManager.h\"\n\nADestroyAfterDelayActor::ADestroyAfterDelayActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ADestroyAfterDelayActor::DestroyActorAfterDelay(float DelayInSeconds)\n{\n\tif (DelayInSeconds > 0.0f)\n\t{\n\t\tGetWorldTimerManager().SetTimerForNextTick([this, DelayInSeconds]() {\n\t\t\tGetWorldTimerManager().SetTimerForNextTick([this]() {\n\t\t\t\tPerformDestroy();\n\t\t\t});\n\t\t});\n\t}\n\telse\n\t{\n\t\tPerformDestroy();\n\t}\n}\n\nvoid ADestroyAfterDelayActor::PerformDestroy()\n{\n\tDestroy();\n}\n```"}
{"requirement": "Create an Actor with a timer that triggers an event every 3 seconds.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyTimedActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyTimedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyTimedActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\t// Timer handle for the recurring event\n\tFTimerHandle TimerHandle;\n\n\t// Function to be called every 3 seconds\n\tvoid OnTimerTick();\n};\n```", "cpp_code": "```cpp\n#include \"MyTimedActor.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nAMyTimedActor::AMyTimedActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid AMyTimedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Set a timer to call OnTimerTick every 3 seconds\n\tGetWorldTimerManager().SetTimer(TimerHandle, this, &AMyTimedActor::OnTimerTick, 3.0f, true);\n}\n\n// Function to be called every 3 seconds\nvoid AMyTimedActor::OnTimerTick()\n{\n\t// Log or perform any action here\n\tUE_LOG(LogTemp, Warning, TEXT(\"Timer ticked!\"));\n}\n```"}
{"requirement": "Develop a class that changes the camera's field of view when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FOVChanger.generated.h\"\n\nUCLASS()\nclass AFOVChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFOVChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Input function to change FOV\n\tvoid ChangeFOV();\n\n\t// Camera Component\n\tUPROPERTY(VisibleAnywhere)\n\tclass UCameraComponent* CameraComponent;\n\n\t// Field of View values\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"FOV\")\n\tfloat DefaultFOV;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"FOV\")\n\tfloat ZoomedFOV;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"FOV\")\n\tfloat FOVChangeSpeed;\n\nprivate:\n\t// Flag to check if zoomed in\n\tbool bIsZoomedIn;\n};\n```", "cpp_code": "```cpp\n#include \"FOVChanger.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAFOVChanger::AFOVChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Camera Component\n\tCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"CameraComponent\"));\n\tRootComponent = CameraComponent;\n\n\t// Initialize FOV values\n\tDefaultFOV = 90.0f;\n\tZoomedFOV = 60.0f;\n\tFOVChangeSpeed = 20.0f;\n\n\t// Start not zoomed in\n\tbIsZoomedIn = false;\n}\n\nvoid AFOVChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCameraComponent->FieldOfView = DefaultFOV;\n}\n\nvoid AFOVChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat TargetFOV = bIsZoomedIn ? ZoomedFOV : DefaultFOV;\n\tCameraComponent->FieldOfView = FMath::FInterpTo(CameraComponent->FieldOfView, TargetFOV, DeltaTime, FOVChangeSpeed);\n}\n\nvoid AFOVChanger::ChangeFOV()\n{\n\tbIsZoomedIn = !bIsZoomedIn;\n}\n\nvoid AFOVChanger::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ChangeFOV\", IE_Pressed, this, &AFOVChanger::ChangeFOV);\n}\n```"}
{"requirement": "Implement an Actor that spawns particles upon destruction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"Particles/ParticleEmitter.h\"\n#include \"MyParticleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyParticleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyParticleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\n\t// Particle system to spawn upon destruction\n\tUPROPERTY(EditAnywhere, Category = \"Effects\")\n\tUParticleSystem* DestructionParticles;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle destruction\n\tvirtual void Destroyed() override;\n};\n```", "cpp_code": "```cpp\n#include \"MyParticleActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAMyParticleActor::AMyParticleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyParticleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyParticleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle destruction\nvoid AMyParticleActor::Destroyed()\n{\n\tSuper::Destroyed();\n\n\tif(DestructionParticles)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), DestructionParticles, GetActorLocation(), GetActorRotation());\n\t}\n}\n```"}
{"requirement": "Create an Actor that plays a sound when clicked in the game world.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"SoundPlayingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundPlayingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void NotifyActorOnClicked(FKey ButtonPressed) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUSoundBase* ClickSound;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SoundPlayingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Sound/SoundBase.h\"\n\nASoundPlayingActor::ASoundPlayingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n}\n\nvoid ASoundPlayingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundPlayingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundPlayingActor::NotifyActorOnClicked(FKey ButtonPressed)\n{\n\tSuper::NotifyActorOnClicked(ButtonPressed);\n\n\tif (ClickSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, ClickSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Develop a class that gradually increases the player's speed over time using the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedIncreaseActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedIncreaseActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedIncreaseActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat InitialSpeed;\n\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat SpeedIncreaseRate;\n\n\tfloat CurrentSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedIncreaseActor.h\"\n\nASpeedIncreaseActor::ASpeedIncreaseActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tInitialSpeed = 600.0f; // Default initial speed\n\tSpeedIncreaseRate = 50.0f; // Default speed increase rate per second\n\tCurrentSpeed = InitialSpeed;\n}\n\nvoid ASpeedIncreaseActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCurrentSpeed = InitialSpeed;\n}\n\nvoid ASpeedIncreaseActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tCurrentSpeed += SpeedIncreaseRate * DeltaTime;\n\t// Use CurrentSpeed to affect player movement\n}\n```"}
{"requirement": "Implement a simple networking function to replicate the Actor's rotation across clients.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"NetworkingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ANetworkingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tANetworkingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to replicate rotation\n\tUFUNCTION()\n\tvoid OnRep_Rotation();\n\n\t// Replicated property for rotation\n\tUPROPERTY(ReplicatedUsing = OnRep_Rotation)\n\tFRotator ActorRotation;\n\n\t// Function to get replication properties\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n};\n```", "cpp_code": "```cpp\n#include \"NetworkingActor.h\"\n#include \"Net/UnrealNetwork.h\"\n\n// Sets default values\nANetworkingActor::ANetworkingActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Enable replication\n\tbReplicates = true;\n}\n\n// Called when the game starts or when spawned\nvoid ANetworkingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ANetworkingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update ActorRotation with the current rotation\n\tif (HasAuthority())\n\t{\n\t\tActorRotation = GetActorRotation();\n\t}\n}\n\nvoid ANetworkingActor::OnRep_Rotation()\n{\n\t// Set the actor's rotation to the replicated rotation\n\tSetActorRotation(ActorRotation);\n}\n\nvoid ANetworkingActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\t// Replicate ActorRotation\n\tDOREPLIFETIME(ANetworkingActor, ActorRotation);\n}\n```"}
{"requirement": "Create an Actor that changes its material color when an overlapping Actor is detected.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"ColorChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Box component for detecting overlaps\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* OverlapComponent;\n\n\t// Material to change to when overlapping\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\n\t// Function to handle overlap events\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAColorChangingActor::AColorChangingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Mesh Component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Create Overlap Component\n\tOverlapComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"OverlapComponent\"));\n\tOverlapComponent->SetupAttachment(RootComponent);\n\tOverlapComponent->OnComponentBeginOverlap.AddDynamic(this, &AColorChangingActor::OnOverlapBegin);\n\n\t// Set up a static mesh for the MeshComponent\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Create a dynamic material instance\n\tif (MeshComponent->GetMaterial(0) != nullptr)\n\t{\n\t\tDynamicMaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t}\n}\n\n// Called every frame\nvoid AColorChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle overlap events\nvoid AColorChangingActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (DynamicMaterialInstance)\n\t{\n\t\t// Change color to red when overlapping\n\t\tDynamicMaterialInstance->SetVectorParameterValue(FName(\"Color\"), FLinearColor::Red);\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION that toggles the Actor's physics simulation on and off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TogglePhysicsActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATogglePhysicsActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATogglePhysicsActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Physics\")\n\tvoid TogglePhysics();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"TogglePhysicsActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nATogglePhysicsActor::ATogglePhysicsActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ATogglePhysicsActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATogglePhysicsActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATogglePhysicsActor::TogglePhysics()\n{\n\tif (MeshComponent)\n\t{\n\t\tbool bIsSimulating = MeshComponent->IsSimulatingPhysics();\n\t\tMeshComponent->SetSimulatePhysics(!bIsSimulating);\n\t}\n}\n```"}
{"requirement": "Create a class that logs a custom message when a specific input key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALoggingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tvoid LogCustomMessage();\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nALoggingActor::ALoggingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ALoggingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"LogKey\", IE_Pressed, this, &ALoggingActor::LogCustomMessage);\n}\n\nvoid ALoggingActor::LogCustomMessage()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Custom message logged!\"));\n\t}\n}\n```"}
{"requirement": "Develop an Actor with a collision component that applies a force to overlapping Actors.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ForceApplyingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AForceApplyingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAForceApplyingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprotected:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* CollisionComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat ForceStrength;\n};\n```", "cpp_code": "```cpp\n#include \"ForceApplyingActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nAForceApplyingActor::AForceApplyingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComponent->SetupAttachment(RootComponent);\n\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AForceApplyingActor::OnOverlapBegin);\n\n\tForceStrength = 1000.0f;\n}\n\nvoid AForceApplyingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AForceApplyingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AForceApplyingActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUPrimitiveComponent* OtherPrimitiveComponent = Cast<UPrimitiveComponent>(OtherComp);\n\t\tif (OtherPrimitiveComponent && OtherPrimitiveComponent->IsSimulatingPhysics())\n\t\t{\n\t\t\tFVector Direction = OtherActor->GetActorLocation() - GetActorLocation();\n\t\t\tDirection.Normalize();\n\t\t\tOtherPrimitiveComponent->AddForce(Direction * ForceStrength);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to teleport the Actor to a random location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomTeleportActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ARandomTeleportActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARandomTeleportActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Teleport\")\n\tvoid TeleportToRandomLocation();\n};\n```", "cpp_code": "```cpp\n#include \"RandomTeleportActor.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n#include \"GameFramework/Actor.h\"\n\nARandomTeleportActor::ARandomTeleportActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARandomTeleportActor::TeleportToRandomLocation()\n{\n\tif (GetWorld())\n\t{\n\t\tFVector RandomLocation = UKismetMathLibrary::RandomPointInBoundingBox(FVector(0.0f, 0.0f, 0.0f), FVector(1000.0f, 1000.0f, 500.0f));\n\t\tSetActorLocation(RandomLocation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a skeletal mesh that plays a looping animation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"MyAnimatedActor.generated.h\"\n\nUCLASS()\nclass AMyAnimatedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMyAnimatedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Animation\", meta = (AllowPrivateAccess = \"true\"))\n\tUAnimSequence* LoopingAnimation;\n};\n```", "cpp_code": "```cpp\n#include \"MyAnimatedActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyAnimatedActor::AMyAnimatedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<USkeletalMesh> SkeletalMesh(TEXT(\"/Game/Path/To/Your/SkeletalMesh.SkeletalMesh\"));\n\tif (SkeletalMesh.Succeeded())\n\t{\n\t\tSkeletalMeshComponent->SetSkeletalMesh(SkeletalMesh.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UAnimSequence> AnimSequence(TEXT(\"/Game/Path/To/Your/Animation.Animation\"));\n\tif (AnimSequence.Succeeded())\n\t{\n\t\tLoopingAnimation = AnimSequence.Object;\n\t}\n}\n\nvoid AMyAnimatedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (LoopingAnimation)\n\t{\n\t\tSkeletalMeshComponent->PlayAnimation(LoopingAnimation, true);\n\t}\n}\n\nvoid AMyAnimatedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Develop a class that reverses the Actor's movement direction when reaching a boundary.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReversibleActor.generated.h\"\n\nUCLASS()\nclass AReversibleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAReversibleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat MovementSpeed;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector MovementDirection;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector BoundaryMin;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector BoundaryMax;\n\n\tvoid ReverseDirectionIfNecessary();\n};\n```", "cpp_code": "```cpp\n#include \"ReversibleActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAReversibleActor::AReversibleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementSpeed = 100.0f;\n\tMovementDirection = FVector(1.0f, 0.0f, 0.0f);\n\tBoundaryMin = FVector(-500.0f, -500.0f, 0.0f);\n\tBoundaryMax = FVector(500.0f, 500.0f, 0.0f);\n}\n\nvoid AReversibleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AReversibleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFVector NewLocation = GetActorLocation() + (MovementDirection * MovementSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n\tReverseDirectionIfNecessary();\n}\n\nvoid AReversibleActor::ReverseDirectionIfNecessary()\n{\n\tFVector CurrentLocation = GetActorLocation();\n\tif (CurrentLocation.X <= BoundaryMin.X || CurrentLocation.X >= BoundaryMax.X)\n\t{\n\t\tMovementDirection.X *= -1;\n\t}\n\tif (CurrentLocation.Y <= BoundaryMin.Y || CurrentLocation.Y >= BoundaryMax.Y)\n\t{\n\t\tMovementDirection.Y *= -1;\n\t}\n}\n```"}
{"requirement": "Implement a UMG widget that displays the player's current score.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"ScoreWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API UScoreWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUScoreWidget(const FObjectInitializer& ObjectInitializer);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Score\")\n\tvoid UpdateScore(int32 NewScore);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UTextBlock* ScoreText;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreWidget.h\"\n#include \"Components/TextBlock.h\"\n\nUScoreWidget::UScoreWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UScoreWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\n\t// Initialize the score display if necessary\n\tif (ScoreText)\n\t{\n\t\tScoreText->SetText(FText::FromString(\"Score: 0\"));\n\t}\n}\n\nvoid UScoreWidget::UpdateScore(int32 NewScore)\n{\n\tif (ScoreText)\n\t{\n\t\tScoreText->SetText(FText::Format(NSLOCTEXT(\"ScoreNamespace\", \"ScoreFormat\", \"Score: {0}\"), FText::AsNumber(NewScore)));\n\t}\n}\n```"}
{"requirement": "Create an Actor with a timeline component to animate its position over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"AnimatedPositionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAnimatedPositionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAnimatedPositionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUTimelineComponent* TimelineComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* PositionCurve;\n\n\tFOnTimelineFloat InterpFunction;\n\n\tUFUNCTION()\n\tvoid HandleProgress(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"AnimatedPositionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAAnimatedPositionActor::AAnimatedPositionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tTimelineComponent = CreateDefaultSubobject<UTimelineComponent>(TEXT(\"TimelineComponent\"));\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UCurveFloat> CurveAsset(TEXT(\"/Game/Path/To/Your/Curve.Curve\"));\n\tif (CurveAsset.Succeeded())\n\t{\n\t\tPositionCurve = CurveAsset.Object;\n\t}\n}\n\nvoid AAnimatedPositionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (PositionCurve)\n\t{\n\t\tInterpFunction.BindUFunction(this, FName(\"HandleProgress\"));\n\t\tTimelineComponent->AddInterpFloat(PositionCurve, InterpFunction);\n\t\tTimelineComponent->SetLooping(false);\n\t\tTimelineComponent->PlayFromStart();\n\t}\n}\n\nvoid AAnimatedPositionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tTimelineComponent->TickComponent(DeltaTime, ELevelTick::LEVELTICK_TimeOnly, nullptr);\n}\n\nvoid AAnimatedPositionActor::HandleProgress(float Value)\n{\n\tFVector NewLocation = FMath::Lerp(FVector(0.0f, 0.0f, 0.0f), FVector(100.0f, 0.0f, 0.0f), Value);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Develop a UFUNCTION that broadcasts a custom event when called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomEventBroadcaster.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnCustomEvent);\n\nUCLASS()\nclass YOURPROJECT_API ACustomEventBroadcaster : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomEventBroadcaster();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"CustomEvent\")\n\tvoid BroadcastCustomEvent();\n\n\tUPROPERTY(BlueprintAssignable, Category=\"CustomEvent\")\n\tFOnCustomEvent OnCustomEvent;\n};\n```", "cpp_code": "```cpp\n#include \"CustomEventBroadcaster.h\"\n\n// Sets default values\nACustomEventBroadcaster::ACustomEventBroadcaster()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomEventBroadcaster::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACustomEventBroadcaster::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACustomEventBroadcaster::BroadcastCustomEvent()\n{\n\tOnCustomEvent.Broadcast();\n}\n```"}
{"requirement": "Implement a class that increases the player's health when a specific input is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthIncreasingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthIncreasingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAHealthIncreasingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat Health;\n\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat HealthIncreaseAmount;\n\n\tvoid IncreaseHealth();\n};\n```", "cpp_code": "```cpp\n#include \"HealthIncreasingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAHealthIncreasingActor::AHealthIncreasingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tHealth = 100.0f;\n\tHealthIncreaseAmount = 10.0f;\n}\n\nvoid AHealthIncreasingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthIncreasingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHealthIncreasingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"IncreaseHealth\", IE_Pressed, this, &AHealthIncreasingActor::IncreaseHealth);\n}\n\nvoid AHealthIncreasingActor::IncreaseHealth()\n{\n\tHealth += HealthIncreaseAmount;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Health increased to: %f\"), Health);\n}\n```"}
{"requirement": "Create an Actor that rotates towards the player's location when in range.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationRange;\n\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Actor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 90.0f;\n\tRotationRange = 1000.0f;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tif (PlayerActor)\n\t{\n\t\tFVector ToPlayer = PlayerActor->GetActorLocation() - GetActorLocation();\n\t\tif (ToPlayer.Size() <= RotationRange)\n\t\t{\n\t\t\tFRotator TargetRotation = ToPlayer.Rotation();\n\t\t\tFRotator CurrentRotation = GetActorRotation();\n\t\t\tFRotator NewRotation = FMath::RInterpTo(CurrentRotation, TargetRotation, DeltaTime, RotationSpeed);\n\t\t\tSetActorRotation(NewRotation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to toggle the Actor's visibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleVisibilityActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visibility\")\n\tvoid ToggleVisibility();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tSetActorHiddenInGame(!bHidden);\n}\n```"}
{"requirement": "Create a static mesh component that changes size based on the player's input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UStaticMeshScaler.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AUStaticMeshScaler : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAUStaticMeshScaler();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Function to increase size\n\tvoid IncreaseSize();\n\n\t// Function to decrease size\n\tvoid DecreaseSize();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tfloat ScaleStep;\n};\n```", "cpp_code": "```cpp\n#include \"UStaticMeshScaler.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"GameFramework/InputSettings.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAUStaticMeshScaler::AUStaticMeshScaler()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Find and set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.MeshName\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tScaleStep = 0.1f;\n}\n\n// Called when the game starts or when spawned\nvoid AUStaticMeshScaler::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AUStaticMeshScaler::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AUStaticMeshScaler::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"IncreaseSize\", IE_Pressed, this, &AUStaticMeshScaler::IncreaseSize);\n\tPlayerInputComponent->BindAction(\"DecreaseSize\", IE_Pressed, this, &AUStaticMeshScaler::DecreaseSize);\n}\n\nvoid AUStaticMeshScaler::IncreaseSize()\n{\n\tFVector NewScale = StaticMeshComponent->GetComponentScale();\n\tNewScale += FVector(ScaleStep);\n\tStaticMeshComponent->SetWorldScale3D(NewScale);\n}\n\nvoid AUStaticMeshScaler::DecreaseSize()\n{\n\tFVector NewScale = StaticMeshComponent->GetComponentScale();\n\tNewScale -= FVector(ScaleStep);\n\tStaticMeshComponent->SetWorldScale3D(NewScale);\n}\n```"}
{"requirement": "Develop a class that changes the Actor's material to a random color every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomColorActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARandomColorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid ChangeMaterialColor();\n};\n```", "cpp_code": "```cpp\n#include \"RandomColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nARandomColorActor::ARandomColorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ARandomColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARandomColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tChangeMaterialColor();\n}\n\nvoid ARandomColorActor::ChangeMaterialColor()\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tFLinearColor RandomColor = FLinearColor::MakeRandomColor();\n\t\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), RandomColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement an Actor that plays a sound at a random interval.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundPlayingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASoundPlayingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* SoundToPlay;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tfloat MinInterval;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tfloat MaxInterval;\n\n\tFTimerHandle TimerHandle;\n\n\tvoid PlaySound();\n\tvoid SetRandomInterval();\n};\n```", "cpp_code": "```cpp\n#include \"SoundPlayingActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"TimerManager.h\"\n\nASoundPlayingActor::ASoundPlayingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tMinInterval = 1.0f;\n\tMaxInterval = 5.0f;\n}\n\nvoid ASoundPlayingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetRandomInterval();\n}\n\nvoid ASoundPlayingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundPlayingActor::PlaySound()\n{\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n\tSetRandomInterval();\n}\n\nvoid ASoundPlayingActor::SetRandomInterval()\n{\n\tfloat Interval = FMath::FRandRange(MinInterval, MaxInterval);\n\tGetWorldTimerManager().SetTimer(TimerHandle, this, &ASoundPlayingActor::PlaySound, Interval, false);\n}\n```"}
{"requirement": "Create a UMG widget that shows a message when the game starts.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UMessageWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API UMessageWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"UI\")\n\tvoid ShowMessage();\n};\n```", "cpp_code": "```cpp\n#include \"UMessageWidget.h\"\n#include \"Components/TextBlock.h\"\n#include \"Blueprint/WidgetTree.h\"\n\nvoid UMessageWidget::ShowMessage()\n{\n\tif (UTextBlock* TextBlock = WidgetTree->FindWidget<UTextBlock>(TEXT(\"MessageTextBlock\")))\n\t{\n\t\tTextBlock->SetText(FText::FromString(TEXT(\"Game Started!\")));\n\t}\n}\n```"}
{"requirement": "Develop a class that spawns a projectile when the player presses a button.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ProjectileSpawner.generated.h\"\n\nclass AProjectile;\n\nUCLASS()\nclass MYGAME_API AProjectileSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAProjectileSpawner();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid SpawnProjectile();\n\n\tUPROPERTY(EditAnywhere, Category=\"Spawning\")\n\tTSubclassOf<AProjectile> ProjectileClass;\n};\n```", "cpp_code": "```cpp\n#include \"ProjectileSpawner.h\"\n#include \"Projectile.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\nAProjectileSpawner::AProjectileSpawner()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AProjectileSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AProjectileSpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AProjectileSpawner::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tif(PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"SpawnProjectile\", IE_Pressed, this, &AProjectileSpawner::SpawnProjectile);\n\t}\n}\n\nvoid AProjectileSpawner::SpawnProjectile()\n{\n\tif(ProjectileClass)\n\t{\n\t\tUWorld* World = GetWorld();\n\t\tif(World)\n\t\t{\n\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\tSpawnParams.Owner = this;\n\t\t\tSpawnParams.Instigator = GetInstigator();\n\n\t\t\tFVector SpawnLocation = GetActorLocation();\n\t\t\tFRotator SpawnRotation = GetActorRotation();\n\n\t\t\tAProjectile* Projectile = World->SpawnActor<AProjectile>(ProjectileClass, SpawnLocation, SpawnRotation, SpawnParams);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a simple AI Controller that makes an AI character follow the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"APlayerFollowAIController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APlayerFollowAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPlayerFollowAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAPawn* PlayerPawn;\n};\n```", "cpp_code": "```cpp\n#include \"APlayerFollowAIController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Character.h\"\n\nAPlayerFollowAIController::APlayerFollowAIController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APlayerFollowAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid APlayerFollowAIController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerPawn)\n\t{\n\t\tMoveToActor(PlayerPawn, 5.0f);\n\t}\n}\n```"}
{"requirement": "Create an Actor that boosts the player's speed when near it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedBoostActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedBoostActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpeedBoostActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat SpeedBoostAmount;\n\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat BoostRadius;\n\n\tvoid BoostPlayerSpeed();\n};\n```", "cpp_code": "```cpp\n#include \"SpeedBoostActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Character.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASpeedBoostActor::ASpeedBoostActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tSpeedBoostAmount = 600.0f;\n\tBoostRadius = 500.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASpeedBoostActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpeedBoostActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tBoostPlayerSpeed();\n}\n\nvoid ASpeedBoostActor::BoostPlayerSpeed()\n{\n\tACharacter* PlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);\n\tif (PlayerCharacter)\n\t{\n\t\tfloat DistanceToPlayer = FVector::Dist(PlayerCharacter->GetActorLocation(), GetActorLocation());\n\t\tif (DistanceToPlayer <= BoostRadius)\n\t\t{\n\t\t\tPlayerCharacter->GetCharacterMovement()->MaxWalkSpeed += SpeedBoostAmount;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION that resets the player's score.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PlayerScoreManager.generated.h\"\n\nUCLASS()\nclass MYGAME_API APlayerScoreManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAPlayerScoreManager();\n\n\t// Function to reset player's score\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid ResetPlayerScore();\n\nprotected:\n\t// Player's score\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Score\")\n\tint32 PlayerScore;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerScoreManager.h\"\n\n// Sets default values\nAPlayerScoreManager::APlayerScoreManager()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize player's score\n\tPlayerScore = 0;\n}\n\nvoid APlayerScoreManager::ResetPlayerScore()\n{\n\tPlayerScore = 0;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Player's score has been reset.\"));\n}\n```"}
{"requirement": "Create an Actor with a collision component that destroys itself on impact.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionDestroyActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionDestroyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tACollisionDestroyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* CollisionComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionDestroyActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nACollisionDestroyActor::ACollisionDestroyActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set collision component\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\t// Register overlap event\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionDestroyActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionDestroyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACollisionDestroyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ACollisionDestroyActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\t// Destroy the actor when overlapping with another actor\n\t\tDestroy();\n\t}\n}\n```"}
{"requirement": "Develop a class that changes the Actor's texture when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TextureChangerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tATextureChangerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY()\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tUPROPERTY(EditAnywhere, Category=\"Textures\")\n\tUTexture* NewTexture;\n\n\tvoid ChangeTexture();\n};\n```", "cpp_code": "```cpp\n#include \"TextureChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"Engine/Texture.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nATextureChangerActor::ATextureChangerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/StarterContent/Materials/M_Brick_Clay_New.M_Brick_Clay_New\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterial = UMaterialInstanceDynamic::Create(MaterialAsset.Object, MeshComponent);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterial);\n\t}\n\n\tNewTexture = nullptr;\n}\n\nvoid ATextureChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATextureChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATextureChangerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ChangeTexture\", IE_Pressed, this, &ATextureChangerActor::ChangeTexture);\n}\n\nvoid ATextureChangerActor::ChangeTexture()\n{\n\tif (DynamicMaterial && NewTexture)\n\t{\n\t\tDynamicMaterial->SetTextureParameterValue(FName(\"Texture\"), NewTexture);\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to switch between two animations.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"AnimationSwitcher.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AAnimationSwitcher : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAnimationSwitcher();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Animation\")\n\tvoid SwitchAnimation();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tUAnimSequence* Animation1;\n\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tUAnimSequence* Animation2;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUAnimSequence* CurrentAnimation;\n};\n```", "cpp_code": "```cpp\n#include \"AnimationSwitcher.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Animation/AnimSequence.h\"\n\nAAnimationSwitcher::AAnimationSwitcher()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UAnimSequence> Anim1(TEXT(\"/Game/Path/To/Animation1.Animation1\"));\n\tstatic ConstructorHelpers::FObjectFinder<UAnimSequence> Anim2(TEXT(\"/Game/Path/To/Animation2.Animation2\"));\n\n\tif (Anim1.Succeeded())\n\t{\n\t\tAnimation1 = Anim1.Object;\n\t}\n\n\tif (Anim2.Succeeded())\n\t{\n\t\tAnimation2 = Anim2.Object;\n\t}\n\n\tCurrentAnimation = Animation1;\n}\n\nvoid AAnimationSwitcher::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAnimationSwitcher::SwitchAnimation()\n{\n\tif (CurrentAnimation == Animation1)\n\t{\n\t\tCurrentAnimation = Animation2;\n\t}\n\telse\n\t{\n\t\tCurrentAnimation = Animation1;\n\t}\n\n\t// Assuming there's an animation component or similar to apply the animation\n\t// MeshComponent->PlayAnimation(CurrentAnimation, false); // Example\n}\n```"}
{"requirement": "Create a class that logs the time passed since the game started every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"ATimeLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATimeLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATimeLoggerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\t// Timer handle for logging\n\tFTimerHandle LogTimeTimerHandle;\n\n\t// Function to log time since start\n\tvoid LogTimeSinceStart();\n};\n```", "cpp_code": "```cpp\n#include \"ATimeLoggerActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nATimeLoggerActor::ATimeLoggerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid ATimeLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Start a timer to log every second\n\tGetWorld()->GetTimerManager().SetTimer(LogTimeTimerHandle, this, &ATimeLoggerActor::LogTimeSinceStart, 1.0f, true);\n}\n\nvoid ATimeLoggerActor::LogTimeSinceStart()\n{\n\tfloat TimeSinceStart = GetWorld()->GetTimeSeconds();\n\tUE_LOG(LogTemp, Log, TEXT(\"Time since start: %f seconds\"), TimeSinceStart);\n}\n```"}
{"requirement": "Develop an Actor that turns red when health is below a threshold.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAHealthActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Health\")\n\tfloat Health;\n\n\tUPROPERTY(EditAnywhere, Category = \"Health\")\n\tfloat HealthThreshold;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid UpdateColorBasedOnHealth();\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAHealthActor::AHealthActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/Path/To/Your/StaticMesh.StaticMesh'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tHealth = 100.0f;\n\tHealthThreshold = 50.0f;\n}\n\nvoid AHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateColorBasedOnHealth();\n}\n\nvoid AHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateColorBasedOnHealth();\n}\n\nvoid AHealthActor::UpdateColorBasedOnHealth()\n{\n\tif (Health < HealthThreshold)\n\t{\n\t\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"Color\"), FLinearColor::Red);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"Color\"), FLinearColor::White);\n\t}\n}\n```"}
{"requirement": "Implement a simple networking function to replicate the Actor's scale across clients.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"AScaleReplicator.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleReplicator : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScaleReplicator();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, ReplicatedUsing=OnRep_Scale)\n\tFVector ActorScale;\n\n\tUFUNCTION()\n\tvoid OnRep_Scale();\n\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n};\n```", "cpp_code": "```cpp\n#include \"AScaleReplicator.h\"\n#include \"Net/UnrealNetwork.h\"\n\nAScaleReplicator::AScaleReplicator()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbReplicates = true;\n}\n\nvoid AScaleReplicator::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScaleReplicator::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScaleReplicator::OnRep_Scale()\n{\n\tSetActorScale3D(ActorScale);\n}\n\nvoid AScaleReplicator::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AScaleReplicator, ActorScale);\n}\n```"}
{"requirement": "Create an Actor that moves in a circular path using a timeline.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"CircularPathActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACircularPathActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACircularPathActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid HandleProgress(float Value);\n\n\tUPROPERTY(EditAnywhere, Category=\"Circular Movement\")\n\tfloat Radius;\n\n\tUPROPERTY(EditAnywhere, Category=\"Circular Movement\")\n\tfloat Speed;\n\n\tFTimeline CircleTimeline;\n\n\tFVector StartLocation;\n\n\tFOnTimelineFloat ProgressFunction;\n\n\tUPROPERTY()\n\tUTimelineComponent* TimelineComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CircularPathActor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nACircularPathActor::ACircularPathActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRadius = 300.0f;\n\tSpeed = 1.0f;\n\n\tTimelineComponent = CreateDefaultSubobject<UTimelineComponent>(TEXT(\"TimelineComponent\"));\n}\n\nvoid ACircularPathActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tStartLocation = GetActorLocation();\n\n\tif (TimelineComponent)\n\t{\n\t\tProgressFunction.BindUFunction(this, FName(\"HandleProgress\"));\n\t\tTimelineComponent->AddInterpFloat(CircleTimeline, ProgressFunction);\n\t\tTimelineComponent->SetLooping(true);\n\t\tTimelineComponent->SetPlayRate(Speed);\n\t\tTimelineComponent->PlayFromStart();\n\t}\n}\n\nvoid ACircularPathActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TimelineComponent)\n\t{\n\t\tTimelineComponent->TickComponent(DeltaTime, ELevelTick::LEVELTICK_TimeOnly, nullptr);\n\t}\n}\n\nvoid ACircularPathActor::HandleProgress(float Value)\n{\n\tfloat Angle = Value * 2.0f * PI;\n\tFVector NewLocation = StartLocation;\n\tNewLocation.X += Radius * FMath::Cos(Angle);\n\tNewLocation.Y += Radius * FMath::Sin(Angle);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Implement a UMG button widget that pauses the game when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UPauseGameWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UPauseGameWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Game\")\n\tvoid OnPauseButtonClicked();\n};\n```", "cpp_code": "```cpp\n#include \"UPauseGameWidget.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nvoid UPauseGameWidget::OnPauseButtonClicked()\n{\n\tUWorld* World = GetWorld();\n\tif (World)\n\t{\n\t\tAPlayerController* PlayerController = World->GetFirstPlayerController();\n\t\tif (PlayerController)\n\t\t{\n\t\t\tbool bIsPaused = UGameplayStatics::IsGamePaused(World);\n\t\t\tUGameplayStatics::SetGamePaused(World, !bIsPaused);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor that emits light based on its proximity to the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ProximityLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AProximityLightActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAProximityLightActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUPointLightComponent* PointLight;\n\n\tUPROPERTY(EditAnywhere, Category=\"Light\")\n\tfloat MaxLightIntensity;\n\n\tUPROPERTY(EditAnywhere, Category=\"Light\")\n\tfloat ActivationRadius;\n\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"ProximityLightActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAProximityLightActor::AProximityLightActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tPointLight->SetupAttachment(RootComponent);\n\n\tMaxLightIntensity = 3000.0f;\n\tActivationRadius = 500.0f;\n}\n\nvoid AProximityLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid AProximityLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerActor)\n\t{\n\t\tfloat DistanceToPlayer = FVector::Dist(PlayerActor->GetActorLocation(), GetActorLocation());\n\t\tif (DistanceToPlayer <= ActivationRadius)\n\t\t{\n\t\t\tfloat Intensity = FMath::Lerp(0.0f, MaxLightIntensity, 1.0f - (DistanceToPlayer / ActivationRadius));\n\t\t\tPointLight->SetIntensity(Intensity);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPointLight->SetIntensity(0.0f);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Develop a class that applies a random rotation to itself every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomRotatorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomRotatorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARandomRotatorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ApplyRandomRotation();\n\n\tFTimerHandle TimerHandle_RandomRotation;\n};\n```", "cpp_code": "```cpp\n#include \"RandomRotatorActor.h\"\n#include \"TimerManager.h\"\n\nARandomRotatorActor::ARandomRotatorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARandomRotatorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGetWorldTimerManager().SetTimer(TimerHandle_RandomRotation, this, &ARandomRotatorActor::ApplyRandomRotation, 1.0f, true);\n}\n\nvoid ARandomRotatorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARandomRotatorActor::ApplyRandomRotation()\n{\n\tFRotator NewRotation = FRotator(FMath::FRandRange(0.0f, 360.0f), FMath::FRandRange(0.0f, 360.0f), FMath::FRandRange(0.0f, 360.0f));\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a BlueprintCallable function that spawns a decoy Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DecoySpawner.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADecoySpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADecoySpawner();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Decoy\")\n\tvoid SpawnDecoy();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditDefaultsOnly, Category = \"Decoy\")\n\tTSubclassOf<AActor> DecoyClass;\n};\n```", "cpp_code": "```cpp\n#include \"DecoySpawner.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nADecoySpawner::ADecoySpawner()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Find the Decoy class in the content browser\n\tstatic ConstructorHelpers::FClassFinder<AActor> DecoyBPClass(TEXT(\"/Game/Blueprints/BP_Decoy\"));\n\tif (DecoyBPClass.Class != NULL)\n\t{\n\t\tDecoyClass = DecoyBPClass.Class;\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ADecoySpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADecoySpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADecoySpawner::SpawnDecoy()\n{\n\tif (DecoyClass != nullptr)\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tGetWorld()->SpawnActor<AActor>(DecoyClass, GetActorLocation(), GetActorRotation(), SpawnParams);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh that changes material on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialSwitcherActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialSwitcherActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMaterialSwitcherActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnMeshHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialSwitcherActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMaterialSwitcherActor::AMaterialSwitcherActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Find and set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetNotifyRigidBodyCollision(true);\n\tMeshComponent->OnComponentHit.AddDynamic(this, &AMaterialSwitcherActor::OnMeshHit);\n}\n\n// Called when the game starts or when spawned\nvoid AMaterialSwitcherActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n}\n\n// Called every frame\nvoid AMaterialSwitcherActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid AMaterialSwitcherActor::OnMeshHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (NewMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Develop a class that logs the Actor's velocity to the screen.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VelocityLoggerActor.generated.h\"\n\nUCLASS()\nclass AVelocityLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAVelocityLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"VelocityLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAVelocityLoggerActor::AVelocityLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AVelocityLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AVelocityLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector Velocity = GetVelocity();\n\tFString VelocityString = Velocity.ToString();\n\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Velocity: %s\"), *VelocityString));\n}\n```"}
{"requirement": "Implement a UFUNCTION to change the Actor's scale dynamically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicScaler.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADynamicScaler : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADynamicScaler();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Transformation\")\n\tvoid ChangeScale(FVector NewScale);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicScaler.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nADynamicScaler::ADynamicScaler()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ADynamicScaler::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADynamicScaler::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADynamicScaler::ChangeScale(FVector NewScale)\n{\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a simple AI Controller to make an AI character idle when the player is far.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"AICharacterController.generated.h\"\n\nUCLASS()\nclass AAICharacterController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAICharacterController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaSeconds) override;\n\nprivate:\n\tAPawn* PlayerPawn;\n\tfloat IdleDistanceThreshold;\n};\n```", "cpp_code": "```cpp\n#include \"AICharacterController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAAICharacterController::AAICharacterController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tIdleDistanceThreshold = 1000.0f; // Set an arbitrary distance threshold\n}\n\nvoid AAICharacterController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid AAICharacterController::Tick(float DeltaSeconds)\n{\n\tSuper::Tick(DeltaSeconds);\n\n\tif (!PlayerPawn)\n\t{\n\t\treturn;\n\t}\n\n\tAPawn* ControlledPawn = GetPawn();\n\tif (!ControlledPawn)\n\t{\n\t\treturn;\n\t}\n\n\tfloat DistanceToPlayer = FVector::Dist(PlayerPawn->GetActorLocation(), ControlledPawn->GetActorLocation());\n\n\tif (DistanceToPlayer > IdleDistanceThreshold)\n\t{\n\t\t// Idle behavior\n\t\tControlledPawn->GetMovementComponent()->StopMovementImmediately();\n\t}\n\telse\n\t{\n\t\t// Implement chasing or other behavior here\n\t}\n}\n```"}
{"requirement": "Develop a class that prints a random joke from an array each time a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomJokeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomJokeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARandomJokeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input bindings\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid PrintRandomJoke();\n\n\tUPROPERTY()\n\tTArray<FString> Jokes;\n};\n```", "cpp_code": "```cpp\n#include \"RandomJokeActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nARandomJokeActor::ARandomJokeActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize jokes\n\tJokes.Add(TEXT(\"Why don't scientists trust atoms? Because they make up everything!\"));\n\tJokes.Add(TEXT(\"What do you get when you cross a snowman and a vampire? Frostbite.\"));\n\tJokes.Add(TEXT(\"Why was the math book sad? Because it had too many problems.\"));\n}\n\n// Called when the game starts or when spawned\nvoid ARandomJokeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARandomJokeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input bindings\nvoid ARandomJokeActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"PrintJoke\", IE_Pressed, this, &ARandomJokeActor::PrintRandomJoke);\n}\n\nvoid ARandomJokeActor::PrintRandomJoke()\n{\n\tif (Jokes.Num() > 0)\n\t{\n\t\tint32 RandomIndex = FMath::RandRange(0, Jokes.Num() - 1);\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Yellow, Jokes[RandomIndex]);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement an Actor that scales down over time and destroys itself when too small.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat ScaleDownRate;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat MinimumScale;\n\n\tvoid CheckAndDestroy();\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tScaleDownRate = 0.1f;\n\tMinimumScale = 0.1f;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewScale = GetActorScale3D() - FVector(ScaleDownRate * DeltaTime);\n\tSetActorScale3D(NewScale);\n\n\tCheckAndDestroy();\n}\n\nvoid AScalingActor::CheckAndDestroy()\n{\n\tif (GetActorScale3D().X <= MinimumScale || GetActorScale3D().Y <= MinimumScale || GetActorScale3D().Z <= MinimumScale)\n\t{\n\t\tDestroy();\n\t}\n}\n```"}
{"requirement": "Create a UMG widget that displays a countdown timer.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UMGCountdownWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UUMGCountdownWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUUMGCountdownWidget(const FObjectInitializer& ObjectInitializer);\n\n\tvirtual void NativeConstruct() override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Countdown\")\n\tvoid StartCountdown(float CountdownTime);\n\nprivate:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UTextBlock* CountdownText;\n\n\tFTimerHandle CountdownTimerHandle;\n\tfloat RemainingTime;\n\n\tvoid UpdateTimerDisplay();\n\tvoid CountdownHasFinished();\n};\n```", "cpp_code": "```cpp\n#include \"UMGCountdownWidget.h\"\n#include \"Components/TextBlock.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n\nUUMGCountdownWidget::UUMGCountdownWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UUMGCountdownWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\t// Initialize widget components here\n}\n\nvoid UUMGCountdownWidget::StartCountdown(float CountdownTime)\n{\n\tRemainingTime = CountdownTime;\n\tUpdateTimerDisplay();\n\tGetWorld()->GetTimerManager().SetTimer(CountdownTimerHandle, this, &UUMGCountdownWidget::UpdateTimerDisplay, 1.0f, true);\n}\n\nvoid UUMGCountdownWidget::UpdateTimerDisplay()\n{\n\tif (RemainingTime < 1)\n\t{\n\t\tCountdownHasFinished();\n\t}\n\telse\n\t{\n\t\t--RemainingTime;\n\t\tif (CountdownText)\n\t\t{\n\t\t\tCountdownText->SetText(FText::AsNumber(FMath::CeilToInt(RemainingTime)));\n\t\t}\n\t}\n}\n\nvoid UUMGCountdownWidget::CountdownHasFinished()\n{\n\tGetWorld()->GetTimerManager().ClearTimer(CountdownTimerHandle);\n\tif (CountdownText)\n\t{\n\t\tCountdownText->SetText(FText::FromString(TEXT(\"Time's Up!\")));\n\t}\n}\n```"}
{"requirement": "Implement a class to toggle between different camera perspectives.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CameraToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACameraToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACameraToggleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid ToggleCameraPerspective();\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tTArray<UCameraComponent*> CameraComponents;\n\t\n\tint32 CurrentCameraIndex;\n};\n```", "cpp_code": "```cpp\n#include \"CameraToggleActor.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nACameraToggleActor::ACameraToggleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCurrentCameraIndex = 0;\n\n\t// Example setup for multiple cameras\n\tUCameraComponent* FirstCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FirstCamera\"));\n\tFirstCamera->SetupAttachment(RootComponent);\n\tCameraComponents.Add(FirstCamera);\n\n\tUCameraComponent* SecondCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"SecondCamera\"));\n\tSecondCamera->SetupAttachment(RootComponent);\n\tCameraComponents.Add(SecondCamera);\n}\n\n// Called when the game starts or when spawned\nvoid ACameraToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (CameraComponents.Num() > 0)\n\t{\n\t\tfor (int32 i = 0; i < CameraComponents.Num(); ++i)\n\t\t{\n\t\t\tCameraComponents[i]->SetActive(i == CurrentCameraIndex);\n\t\t}\n\t}\n}\n\n// Called every frame\nvoid ACameraToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACameraToggleActor::ToggleCameraPerspective()\n{\n\tif (CameraComponents.Num() > 0)\n\t{\n\t\tCameraComponents[CurrentCameraIndex]->SetActive(false);\n\t\tCurrentCameraIndex = (CurrentCameraIndex + 1) % CameraComponents.Num();\n\t\tCameraComponents[CurrentCameraIndex]->SetActive(true);\n\t}\n}\n```"}
{"requirement": "Create an Actor that automatically moves forward and bounces off walls.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AutoMoveActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AAutoMoveActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAAutoMoveActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat MoveSpeed;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector MoveDirection;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult& Hit);\n\n};\n```", "cpp_code": "```cpp\n#include \"AutoMoveActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAAutoMoveActor::AAutoMoveActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMoveSpeed = 200.0f;\n\tMoveDirection = FVector(1.0f, 0.0f, 0.0f);\n\n\tMeshComponent->OnComponentHit.AddDynamic(this, &AAutoMoveActor::OnHit);\n}\n\nvoid AAutoMoveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAutoMoveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation() + (MoveDirection * MoveSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n\nvoid AAutoMoveActor::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tMoveDirection = FVector::Reflect(MoveDirection, Hit.Normal);\n}\n```"}
{"requirement": "Develop a class that changes the background music when a specific location is reached.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"LocationMusicChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALocationMusicChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALocationMusicChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category = \"Music\")\n\tUSoundCue* NewBackgroundMusic;\n\n\tUPROPERTY(EditAnywhere, Category = \"Location\")\n\tFVector TargetLocation;\n\n\tUPROPERTY(EditAnywhere, Category = \"Location\")\n\tfloat TriggerRadius;\n\nprivate:\n\tvoid ChangeMusic();\n\tbool IsPlayerInTargetLocation() const;\n};\n```", "cpp_code": "```cpp\n#include \"LocationMusicChanger.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Sound/SoundCue.h\"\n\nALocationMusicChanger::ALocationMusicChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTriggerRadius = 500.0f;  // Default radius\n}\n\nvoid ALocationMusicChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALocationMusicChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (IsPlayerInTargetLocation())\n\t{\n\t\tChangeMusic();\n\t}\n}\n\nvoid ALocationMusicChanger::ChangeMusic()\n{\n\tif (NewBackgroundMusic)\n\t{\n\t\tUGameplayStatics::PlaySound2D(this, NewBackgroundMusic);\n\t}\n}\n\nbool ALocationMusicChanger::IsPlayerInTargetLocation() const\n{\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tAPawn* PlayerPawn = PlayerController->GetPawn();\n\t\tif (PlayerPawn)\n\t\t{\n\t\t\tFVector PlayerLocation = PlayerPawn->GetActorLocation();\n\t\t\tfloat Distance = FVector::Dist(PlayerLocation, TargetLocation);\n\t\t\treturn Distance <= TriggerRadius;\n\t\t}\n\t}\n\treturn false;\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to reset the level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LevelResetter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ALevelResetter : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALevelResetter();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Level\")\n\tvoid ResetLevel();\n};\n```", "cpp_code": "```cpp\n#include \"LevelResetter.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nALevelResetter::ALevelResetter()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALevelResetter::ResetLevel()\n{\n\tUWorld* World = GetWorld();\n\tif (World)\n\t{\n\t\tFName CurrentLevelName = *UGameplayStatics::GetCurrentLevelName(World);\n\t\tUGameplayStatics::OpenLevel(World, CurrentLevelName);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a rotating component that can be started and stopped.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Rotation\")\n\tvoid StartRotation();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Rotation\")\n\tvoid StopRotation();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationSpeed;\n\n\tbool bIsRotating;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"ConstructorHelpers.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRotationSpeed = FRotator(0.f, 180.f, 0.f);\n\tbIsRotating = false;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsRotating)\n\t{\n\t\tFRotator NewRotation = GetActorRotation() + (RotationSpeed * DeltaTime);\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n\nvoid ARotatingActor::StartRotation()\n{\n\tbIsRotating = true;\n}\n\nvoid ARotatingActor::StopRotation()\n{\n\tbIsRotating = false;\n}\n```"}
{"requirement": "Develop a class that spawns a random item from a list on pressing a key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomItemSpawner.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ARandomItemSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARandomItemSpawner();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Spawning\")\n\tTArray<TSubclassOf<AActor>> ItemClasses;\n\n\tUFUNCTION()\n\tvoid SpawnRandomItem();\n};\n```", "cpp_code": "```cpp\n#include \"RandomItemSpawner.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nARandomItemSpawner::ARandomItemSpawner()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARandomItemSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARandomItemSpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARandomItemSpawner::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"SpawnItem\", IE_Pressed, this, &ARandomItemSpawner::SpawnRandomItem);\n}\n\nvoid ARandomItemSpawner::SpawnRandomItem()\n{\n\tif (ItemClasses.Num() > 0)\n\t{\n\t\tint32 RandomIndex = FMath::RandRange(0, ItemClasses.Num() - 1);\n\t\tTSubclassOf<AActor> ItemToSpawn = ItemClasses[RandomIndex];\n\n\t\tif (ItemToSpawn)\n\t\t{\n\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\tGetWorld()->SpawnActor<AActor>(ItemToSpawn, GetActorLocation(), FRotator::ZeroRotator, SpawnParams);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a UMG widget that displays a loading bar.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"ULoadingBarWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ULoadingBarWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tULoadingBarWidget(const FObjectInitializer& ObjectInitializer);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Loading\")\n\tvoid SetLoadingProgress(float Progress);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UProgressBar* LoadingProgressBar;\n};\n```", "cpp_code": "```cpp\n#include \"ULoadingBarWidget.h\"\n#include \"Components/ProgressBar.h\"\n\nULoadingBarWidget::ULoadingBarWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid ULoadingBarWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\t// You can initialize your widget here\n}\n\nvoid ULoadingBarWidget::SetLoadingProgress(float Progress)\n{\n\tif (LoadingProgressBar)\n\t{\n\t\tLoadingProgressBar->SetPercent(Progress);\n\t}\n}\n```"}
{"requirement": "Create a class that logs the player's score to the console.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScoreLogger();\n\n\t// Logs the player's score\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid LogScore(int32 PlayerScore);\n};\n```", "cpp_code": "```cpp\n#include \"ScoreLogger.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAScoreLogger::AScoreLogger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AScoreLogger::LogScore(int32 PlayerScore)\n{\n\tif (GEngine)\n\t{\n\t\tFString ScoreMessage = FString::Printf(TEXT(\"Player Score: %d\"), PlayerScore);\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, ScoreMessage);\n\t}\n}\n```"}
{"requirement": "Develop an Actor with a timeline that changes its opacity over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"OpacityChangingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AOpacityChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tAOpacityChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tFTimeline OpacityTimeline;\n\n\tUFUNCTION()\n\tvoid HandleOpacityChange(float Value);\n\n\tUFUNCTION()\n\tvoid OnTimelineFinished();\n\n\tUPROPERTY(EditAnywhere, Category = \"Timeline\")\n\tUCurveFloat* OpacityCurve;\n};\n```", "cpp_code": "```cpp\n#include \"OpacityChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n\nAOpacityChangingActor::AOpacityChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AOpacityChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (OpacityCurve)\n\t{\n\t\tFOnTimelineFloat TimelineCallback;\n\t\tTimelineCallback.BindUFunction(this, FName(\"HandleOpacityChange\"));\n\n\t\tFOnTimelineEventStatic TimelineFinishedCallback;\n\t\tTimelineFinishedCallback.BindUFunction(this, FName(\"OnTimelineFinished\"));\n\n\t\tOpacityTimeline.AddInterpFloat(OpacityCurve, TimelineCallback);\n\t\tOpacityTimeline.SetTimelineFinishedFunc(TimelineFinishedCallback);\n\t\tOpacityTimeline.SetLooping(false);\n\t\tOpacityTimeline.PlayFromStart();\n\t}\n}\n\nvoid AOpacityChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tOpacityTimeline.TickTimeline(DeltaTime);\n}\n\nvoid AOpacityChangingActor::HandleOpacityChange(float Value)\n{\n\tFLinearColor NewColor = MeshComponent->GetMaterial(0)->GetVectorParameterValue(FName(\"BaseColor\"));\n\tNewColor.A = Value;\n\tMeshComponent->SetVectorParameterValueOnMaterials(FName(\"BaseColor\"), NewColor);\n}\n\nvoid AOpacityChangingActor::OnTimelineFinished()\n{\n\t// Handle the end of the timeline\n}\n```"}
{"requirement": "Implement a UFUNCTION to reverse the Actor's direction instantaneously.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReverseDirectionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AReverseDirectionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAReverseDirectionActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid ReverseDirection();\n};\n```", "cpp_code": "```cpp\n#include \"ReverseDirectionActor.h\"\n\n// Sets default values\nAReverseDirectionActor::AReverseDirectionActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AReverseDirectionActor::ReverseDirection()\n{\n\tFVector CurrentVelocity = GetVelocity();\n\tFVector ReversedVelocity = -CurrentVelocity;\n\tGetRootComponent()->ComponentVelocity = ReversedVelocity;\n}\n```"}
{"requirement": "Create an Actor that plays a victory sound when the player wins.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VictorySoundActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AVictorySoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAVictorySoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to play victory sound\n\tUFUNCTION(BlueprintCallable, Category=\"Victory\")\n\tvoid PlayVictorySound();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Audio\")\n\tUSoundBase* VictorySound;\n};\n```", "cpp_code": "```cpp\n#include \"VictorySoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAVictorySoundActor::AVictorySoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the VictorySound\n\tVictorySound = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid AVictorySoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AVictorySoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AVictorySoundActor::PlayVictorySound()\n{\n\tif (VictorySound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, VictorySound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Implement a simple AI Controller to patrol between dynamic waypoints.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PatrolAIController.generated.h\"\n\nUCLASS()\nclass APatrolAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPatrolAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid MoveToNextWaypoint();\n\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tTArray<AActor*> PatrolWaypoints;\n\n\tint32 CurrentWaypointIndex;\n};\n```", "cpp_code": "```cpp\n#include \"PatrolAIController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Actor.h\"\n\nAPatrolAIController::APatrolAIController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentWaypointIndex = 0;\n}\n\nvoid APatrolAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Optionally find waypoints dynamically at runtime\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), AActor::StaticClass(), PatrolWaypoints);\n\n\tif (PatrolWaypoints.Num() > 0)\n\t{\n\t\tMoveToNextWaypoint();\n\t}\n}\n\nvoid APatrolAIController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (GetPawn() && PatrolWaypoints.Num() > 0)\n\t{\n\t\tfloat DistanceToWaypoint = FVector::Dist(GetPawn()->GetActorLocation(), PatrolWaypoints[CurrentWaypointIndex]->GetActorLocation());\n\n\t\tif (DistanceToWaypoint < 100.0f) // close enough to the waypoint\n\t\t{\n\t\t\tMoveToNextWaypoint();\n\t\t}\n\t}\n}\n\nvoid APatrolAIController::MoveToNextWaypoint()\n{\n\tif (PatrolWaypoints.Num() == 0)\n\t{\n\t\treturn;\n\t}\n\n\tMoveToActor(PatrolWaypoints[CurrentWaypointIndex]);\n\n\tCurrentWaypointIndex = (CurrentWaypointIndex + 1) % PatrolWaypoints.Num();\n}\n```"}
{"requirement": "Create a class that increases a counter every time a specific input is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CounterActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACounterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACounterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Counter variable\n\tUPROPERTY(VisibleAnywhere, Category = \"Counter\")\n\tint32 Counter;\n\n\t// Function to increase the counter\n\tvoid IncreaseCounter();\n};\n```", "cpp_code": "```cpp\n#include \"CounterActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nACounterActor::ACounterActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize counter\n\tCounter = 0;\n}\n\n// Called when the game starts or when spawned\nvoid ACounterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACounterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid ACounterActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind IncreaseCounter function to \"IncreaseCounter\" action\n\tPlayerInputComponent->BindAction(\"IncreaseCounter\", IE_Pressed, this, &ACounterActor::IncreaseCounter);\n}\n\n// Function to increase the counter\nvoid ACounterActor::IncreaseCounter()\n{\n\tCounter++;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Counter: %d\"), Counter);\n}\n```"}
{"requirement": "Develop an Actor that changes its texture based on the time of day.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimedTextureActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATimedTextureActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATimedTextureActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Textures\")\n\tUTexture* MorningTexture;\n\n\tUPROPERTY(EditAnywhere, Category = \"Textures\")\n\tUTexture* AfternoonTexture;\n\n\tUPROPERTY(EditAnywhere, Category = \"Textures\")\n\tUTexture* EveningTexture;\n\n\tvoid UpdateTextureBasedOnTimeOfDay();\n};\n```", "cpp_code": "```cpp\n#include \"TimedTextureActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Texture.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nATimedTextureActor::ATimedTextureActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ATimedTextureActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateTextureBasedOnTimeOfDay();\n}\n\n// Called every frame\nvoid ATimedTextureActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateTextureBasedOnTimeOfDay();\n}\n\nvoid ATimedTextureActor::UpdateTextureBasedOnTimeOfDay()\n{\n\tfloat CurrentHour = UGameplayStatics::GetTimeSeconds(GetWorld()) / 3600.0f;\n\tUTexture* NewTexture = nullptr;\n\n\tif (CurrentHour >= 6.0f && CurrentHour < 12.0f)\n\t{\n\t\tNewTexture = MorningTexture;\n\t}\n\telse if (CurrentHour >= 12.0f && CurrentHour < 18.0f)\n\t{\n\t\tNewTexture = AfternoonTexture;\n\t}\n\telse\n\t{\n\t\tNewTexture = EveningTexture;\n\t}\n\n\tif (NewTexture)\n\t{\n\t\tMeshComponent->SetMaterial(0, UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this));\n\t\tUMaterialInstanceDynamic* DynMaterial = Cast<UMaterialInstanceDynamic>(MeshComponent->GetMaterial(0));\n\t\tif (DynMaterial)\n\t\t{\n\t\t\tDynMaterial->SetTextureParameterValue(TEXT(\"Texture\"), NewTexture);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function that switches the Actor's material to a different texture.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SwitchMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASwitchMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASwitchMaterialActor();\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Material\")\n\tvoid SwitchMaterial(UTexture* NewTexture);\n};\n```", "cpp_code": "```cpp\n#include \"SwitchMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nASwitchMaterialActor::ASwitchMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ASwitchMaterialActor::SwitchMaterial(UTexture* NewTexture)\n{\n\tif (!NewTexture)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"SwitchMaterial called with a null texture.\"));\n\t\treturn;\n\t}\n\n\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\tif (DynamicMaterial)\n\t{\n\t\tDynamicMaterial->SetTextureParameterValue(FName(\"TextureParameter\"), NewTexture);\n\t}\n}\n```"}
{"requirement": "Create an Actor that plays a unique sound on spawn.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Components/AudioComponent.h\"\n#include \"UniqueSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AUniqueSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAUniqueSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Sound component to play the sound\n\tUPROPERTY(EditAnywhere, Category=\"Sound\")\n\tUSoundBase* SpawnSound;\n\n\t// Audio component\n\tUPROPERTY(VisibleAnywhere, Category=\"Sound\")\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"UniqueSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAUniqueSoundActor::AUniqueSoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// Create audio component and attach to root\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n}\n\n// Called when the game starts or when spawned\nvoid AUniqueSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Play the sound if it's set\n\tif (SpawnSound)\n\t{\n\t\tAudioComponent->SetSound(SpawnSound);\n\t\tAudioComponent->Play();\n\t}\n}\n```"}
{"requirement": "Develop a class that logs when an Actor enters and exits a trigger volume.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"LoggingTriggerVolume.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingTriggerVolume : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tALoggingTriggerVolume();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* TriggerVolume;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n};\n```", "cpp_code": "```cpp\n#include \"LoggingTriggerVolume.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n\n// Sets default values\nALoggingTriggerVolume::ALoggingTriggerVolume()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t // Create the trigger volume\n\t TriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n\t RootComponent = TriggerVolume;\n\n\t // Bind events\n\t TriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &ALoggingTriggerVolume::OnOverlapBegin);\n\t TriggerVolume->OnComponentEndOverlap.AddDynamic(this, &ALoggingTriggerVolume::OnOverlapEnd);\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingTriggerVolume::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ALoggingTriggerVolume::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ALoggingTriggerVolume::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s has entered the trigger volume\"), *OtherActor->GetName());\n\t}\n}\n\nvoid ALoggingTriggerVolume::OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s has exited the trigger volume\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Implement a UMG widget that acts as an on-screen joystick for character movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UJoystickWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UJoystickWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUJoystickWidget(const FObjectInitializer& ObjectInitializer);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UImage* JoystickBackground;\n\n\tUPROPERTY(meta = (BindWidget))\n\tclass UImage* JoystickThumb;\n\n\tFVector2D InitialPosition;\n\n\tUFUNCTION()\n\tvoid OnTouchStarted(ETouchIndex::Type FingerIndex, FVector Location);\n\n\tUFUNCTION()\n\tvoid OnTouchMoved(ETouchIndex::Type FingerIndex, FVector Location);\n\n\tUFUNCTION()\n\tvoid OnTouchEnded(ETouchIndex::Type FingerIndex, FVector Location);\n\n\tvoid UpdateJoystickPosition(FVector2D TouchPosition);\n};\n```", "cpp_code": "```cpp\n#include \"UJoystickWidget.h\"\n#include \"Components/Image.h\"\n#include \"Blueprint/WidgetTree.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n#include \"Components/CanvasPanelSlot.h\"\n\nUJoystickWidget::UJoystickWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UJoystickWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\t\n\t// Bind touch events\n\tif (JoystickBackground)\n\t{\n\t\tJoystickBackground->OnMouseButtonDownEvent.BindUFunction(this, FName(\"OnTouchStarted\"));\n\t\tJoystickBackground->OnMouseMoveEvent.BindUFunction(this, FName(\"OnTouchMoved\"));\n\t\tJoystickBackground->OnMouseButtonUpEvent.BindUFunction(this, FName(\"OnTouchEnded\"));\n\t}\n\n\tif (JoystickThumb)\n\t{\n\t\tInitialPosition = JoystickThumb->Slot->AsCanvasSlot()->GetPosition();\n\t}\n}\n\nvoid UJoystickWidget::OnTouchStarted(ETouchIndex::Type FingerIndex, FVector Location)\n{\n\tUpdateJoystickPosition(FVector2D(Location.X, Location.Y));\n}\n\nvoid UJoystickWidget::OnTouchMoved(ETouchIndex::Type FingerIndex, FVector Location)\n{\n\tUpdateJoystickPosition(FVector2D(Location.X, Location.Y));\n}\n\nvoid UJoystickWidget::OnTouchEnded(ETouchIndex::Type FingerIndex, FVector Location)\n{\n\t// Reset thumb position\n\tif (JoystickThumb)\n\t{\n\t\tJoystickThumb->Slot->AsCanvasSlot()->SetPosition(InitialPosition);\n\t}\n}\n\nvoid UJoystickWidget::UpdateJoystickPosition(FVector2D TouchPosition)\n{\n\tif (JoystickThumb)\n\t{\n\t\tFVector2D DeltaPosition = TouchPosition - InitialPosition;\n\t\t// Clamp the movement\n\t\tDeltaPosition = UKismetMathLibrary::ClampVector2DSize(DeltaPosition, 0, 100);\n\n\t\tJoystickThumb->Slot->AsCanvasSlot()->SetPosition(InitialPosition + DeltaPosition);\n\n\t\t// Here you would typically send the DeltaPosition to your character or player controller\n\t}\n}\n```"}
{"requirement": "Create an Actor that applies a temporary speed boost to the player on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedBoostActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API ASpeedBoostActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpeedBoostActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"SpeedBoost\")\n\tfloat SpeedBoostAmount;\n\n\tUPROPERTY(EditAnywhere, Category=\"SpeedBoost\")\n\tfloat BoostDuration;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor,\n\t\t\t\t\t\tclass UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,\n\t\t\t\t\t\tbool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"SpeedBoostActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"TimerManager.h\"\n\nASpeedBoostActor::ASpeedBoostActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\tMeshComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ASpeedBoostActor::OnOverlapBegin);\n\n\tSpeedBoostAmount = 600.0f; // Example boost amount\n\tBoostDuration = 5.0f; // Example duration in seconds\n}\n\nvoid ASpeedBoostActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpeedBoostActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpeedBoostActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor,\n\t\t\t\t\t\t\t\t\t  UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,\n\t\t\t\t\t\t\t\t\t  bool bFromSweep, const FHitResult & SweepResult)\n{\n\tACharacter* Character = Cast<ACharacter>(OtherActor);\n\tif (Character)\n\t{\n\t\tUCharacterMovementComponent* MovementComponent = Character->GetCharacterMovement();\n\t\tif (MovementComponent)\n\t\t{\n\t\t\tMovementComponent->MaxWalkSpeed += SpeedBoostAmount;\n\n\t\t\tFTimerHandle TimerHandle;\n\t\t\tGetWorld()->GetTimerManager().SetTimer(TimerHandle, [=]() {\n\t\t\t\tMovementComponent->MaxWalkSpeed -= SpeedBoostAmount;\n\t\t\t}, BoostDuration, false);\n\n\t\t\tDestroy(); // Destroy the boost actor after applying the effect\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION that changes the Actor's material to indicate damage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"DamageableActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADamageableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADamageableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Damage\")\n\tvoid ChangeMaterialToIndicateDamage(UMaterialInterface* DamageMaterial);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Damage\")\n\tUMaterialInterface* OriginalMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"DamageableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nADamageableActor::ADamageableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Geometry/Meshes/YourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialAsset(TEXT(\"/Game/Materials/YourMaterial.YourMaterial\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tOriginalMaterial = MaterialAsset.Object;\n\t\tMeshComponent->SetMaterial(0, OriginalMaterial);\n\t}\n}\n\nvoid ADamageableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADamageableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADamageableActor::ChangeMaterialToIndicateDamage(UMaterialInterface* DamageMaterial)\n{\n\tif (DamageMaterial && MeshComponent)\n\t{\n\t\tMeshComponent->SetMaterial(0, DamageMaterial);\n\t}\n}\n```"}
{"requirement": "Create a class that rotates the Actor towards the player's camera view.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotateTowardsCameraActor.generated.h\"\n\nUCLASS()\nclass ARotateTowardsCameraActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotateTowardsCameraActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid RotateTowardsCamera();\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"RotateTowardsCameraActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Camera/PlayerCameraManager.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\n// Sets default values\nARotateTowardsCameraActor::ARotateTowardsCameraActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ARotateTowardsCameraActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotateTowardsCameraActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRotateTowardsCamera();\n}\n\nvoid ARotateTowardsCameraActor::RotateTowardsCamera()\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tAPlayerCameraManager* CameraManager = PlayerController->PlayerCameraManager;\n\t\tif (CameraManager)\n\t\t{\n\t\t\tFVector ActorLocation = GetActorLocation();\n\t\t\tFVector CameraLocation = CameraManager->GetCameraLocation();\n\t\t\tFRotator LookAtRotation = UKismetMathLibrary::FindLookAtRotation(ActorLocation, CameraLocation);\n\t\t\tSetActorRotation(LookAtRotation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Develop an Actor with a timeline to animate its rotation smoothly.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* RotationCurve;\n\n\tFTimeline RotationTimeline;\n\n\tUFUNCTION()\n\tvoid HandleRotationProgress(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (RotationCurve)\n\t{\n\t\tFOnTimelineFloat RotationProgress;\n\t\tRotationProgress.BindUFunction(this, FName(\"HandleRotationProgress\"));\n\t\tRotationTimeline.AddInterpFloat(RotationCurve, RotationProgress);\n\t\tRotationTimeline.SetLooping(true);\n\t\tRotationTimeline.PlayFromStart();\n\t}\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRotationTimeline.TickTimeline(DeltaTime);\n}\n\nvoid ARotatingActor::HandleRotationProgress(float Value)\n{\n\tFRotator NewRotation = FRotator(0.f, Value * 360.f, 0.f);\n\tMeshComponent->SetRelativeRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a simple networking function to replicate the Actor's visibility state.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"AReplicatedVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AReplicatedVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAReplicatedVisibilityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid SetActorVisibility(bool bVisible);\n\n\tUFUNCTION(NetMulticast, Reliable)\n\tvoid Multicast_SetActorVisibility(bool bVisible);\n\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n\nprivate:\n\tUPROPERTY(ReplicatedUsing = OnRep_VisibilityChanged)\n\tbool bIsVisible;\n\n\tUFUNCTION()\n\tvoid OnRep_VisibilityChanged();\n};\n```", "cpp_code": "```cpp\n#include \"AReplicatedVisibilityActor.h\"\n\n// Sets default values\nAReplicatedVisibilityActor::AReplicatedVisibilityActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tbReplicates = true;\n\tbIsVisible = true;\n}\n\n// Called when the game starts or when spawned\nvoid AReplicatedVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AReplicatedVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AReplicatedVisibilityActor::SetActorVisibility(bool bVisible)\n{\n\tif (HasAuthority())\n\t{\n\t\tbIsVisible = bVisible;\n\t\tMulticast_SetActorVisibility(bIsVisible);\n\t}\n}\n\nvoid AReplicatedVisibilityActor::Multicast_SetActorVisibility_Implementation(bool bVisible)\n{\n\tSetActorHiddenInGame(!bVisible);\n}\n\nvoid AReplicatedVisibilityActor::OnRep_VisibilityChanged()\n{\n\tSetActorHiddenInGame(!bIsVisible);\n}\n\nvoid AReplicatedVisibilityActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AReplicatedVisibilityActor, bIsVisible);\n}\n```"}
{"requirement": "Create an Actor that changes its material when touched by the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMaterialOnTouchActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMaterialOnTouchActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAChangeMaterialOnTouchActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Materials\")\n\tUMaterialInterface* NewMaterial;\n\n\tUFUNCTION()\n\tvoid OnPlayerTouch(class UPrimitiveComponent* TouchedComponent, AActor* OtherActor, \n\t\t\t\t\t  UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, \n\t\t\t\t\t  const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialOnTouchActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"ConstructorHelpers.h\"\n\nAChangeMaterialOnTouchActor::AChangeMaterialOnTouchActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AChangeMaterialOnTouchActor::OnPlayerTouch);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AChangeMaterialOnTouchActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMaterialOnTouchActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialOnTouchActor::OnPlayerTouch(UPrimitiveComponent* TouchedComponent, AActor* OtherActor, \n\t\t\t\t\t\t\t\t\t\t\t\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, \n\t\t\t\t\t\t\t\t\t\t\t\tconst FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor != this && NewMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to reset the Actor's scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetScaleActor.generated.h\"\n\nUCLASS()\nclass AResetScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAResetScaleActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Scale\")\n\tvoid ResetScale();\n};\n```", "cpp_code": "```cpp\n#include \"ResetScaleActor.h\"\n\n// Sets default values\nAResetScaleActor::AResetScaleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetScaleActor::ResetScale()\n{\n\tSetActorScale3D(FVector(1.0f, 1.0f, 1.0f));\n}\n```"}
{"requirement": "Create a class that logs a warning message when the player is low on health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LowHealthLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALowHealthLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALowHealthLogger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid CheckHealth();\n\n\tUPROPERTY(EditAnywhere, Category = \"Health\")\n\tfloat Health;\n\n\tUPROPERTY(EditAnywhere, Category = \"Health\")\n\tfloat LowHealthThreshold;\n};\n```", "cpp_code": "```cpp\n#include \"LowHealthLogger.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nALowHealthLogger::ALowHealthLogger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHealth = 100.0f;\n\tLowHealthThreshold = 25.0f;\n}\n\nvoid ALowHealthLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALowHealthLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tCheckHealth();\n}\n\nvoid ALowHealthLogger::CheckHealth()\n{\n\tif (Health < LowHealthThreshold)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Player is low on health!\"));\n\t}\n}\n```"}
{"requirement": "Develop an Actor that moves towards a target point when spawned.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tFVector TargetLocation;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MoveSpeed;\n\n\tFVector StartLocation;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMoveSpeed = 100.0f;\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartLocation = GetActorLocation();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (FVector::Dist(StartLocation, TargetLocation) > KINDA_SMALL_NUMBER)\n\t{\n\t\tFVector Direction = (TargetLocation - StartLocation).GetSafeNormal();\n\t\tFVector NewLocation = GetActorLocation() + Direction * MoveSpeed * DeltaTime;\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Implement a UMG widget that acts as a virtual health bar.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UHealthBarWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UHealthBarWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Health\")\n\tvoid SetHealthPercentage(float HealthPercent);\n\nprotected:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UProgressBar* HealthBar;\n};\n```", "cpp_code": "```cpp\n#include \"UHealthBarWidget.h\"\n#include \"Components/ProgressBar.h\"\n\nvoid UHealthBarWidget::SetHealthPercentage(float HealthPercent)\n{\n\tif (HealthBar)\n\t{\n\t\tHealthBar->SetPercent(HealthPercent);\n\t}\n}\n```"}
{"requirement": "Create an Actor that changes its material color periodically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AColorChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAColorChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tFTimerHandle ColorChangeTimerHandle;\n\n\tvoid ChangeColor();\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nAColorChangingActor::AColorChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/StarterContent/Materials/M_Basic_Wall.M_Basic_Wall\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterial = UMaterialInstanceDynamic::Create(MaterialAsset.Object, MeshComponent);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterial);\n\t}\n}\n\nvoid AColorChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGetWorldTimerManager().SetTimer(ColorChangeTimerHandle, this, &AColorChangingActor::ChangeColor, 1.0f, true);\n}\n\nvoid AColorChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AColorChangingActor::ChangeColor()\n{\n\tif (DynamicMaterial)\n\t{\n\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t}\n}\n```"}
{"requirement": "Develop a class that uses a timer to call a function every 5 seconds.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"ATimerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATimerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATimerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\t// Function to be called by the timer\n\tvoid TimerFunction();\n\n\t// Timer handle\n\tFTimerHandle TimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"ATimerActor.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nATimerActor::ATimerActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid ATimerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Set the timer to call TimerFunction every 5 seconds\n\tGetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &ATimerActor::TimerFunction, 5.0f, true);\n}\n\n// Function to be called by the timer\nvoid ATimerActor::TimerFunction()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"TimerFunction called\"));\n}\n```"}
{"requirement": "Implement a UFUNCTION to set a new target location for the Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TargetActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATargetActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATargetActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid SetNewTargetLocation(FVector NewLocation);\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector TargetLocation;\n};\n```", "cpp_code": "```cpp\n#include \"TargetActor.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nATargetActor::ATargetActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ATargetActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATargetActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Logic to move towards the target location can be implemented here\n}\n\nvoid ATargetActor::SetNewTargetLocation(FVector NewLocation)\n{\n\tTargetLocation = NewLocation;\n\t// Additional logic to handle the new target location can be implemented here\n}\n```"}
{"requirement": "Create an Actor with a collision component that spawns particles upon overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Components/BoxComponent.h\"\n#include \"AParticleSpawner.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AParticleSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAParticleSpawner();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Box Collision Component\n\tUPROPERTY(VisibleAnywhere, Category = \"Collision\")\n\tUBoxComponent* CollisionBox;\n\n\t// Particle System to spawn\n\tUPROPERTY(EditAnywhere, Category = \"Effects\")\n\tUParticleSystem* ParticleEffect;\n\n\t// Handle overlap event\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"AParticleSpawner.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAParticleSpawner::AParticleSpawner()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the Box Component\n\tCollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionBox\"));\n\tRootComponent = CollisionBox;\n\n\t// Set up the collision box\n\tCollisionBox->SetCollisionProfileName(TEXT(\"Trigger\"));\n\tCollisionBox->OnComponentBeginOverlap.AddDynamic(this, &AParticleSpawner::OnOverlapBegin);\n\n\t// Initialize the Particle System\n\tParticleEffect = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid AParticleSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AParticleSpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Handle the overlap event\nvoid AParticleSpawner::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (ParticleEffect && OtherActor != this)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ParticleEffect, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Implement a UMG button widget that exits the game when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"MyExitButtonWidget.generated.h\"\n\nUCLASS()\nclass UMyExitButtonWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"UI\")\n\tvoid OnExitButtonClicked();\n};\n```", "cpp_code": "```cpp\n#include \"MyExitButtonWidget.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nvoid UMyExitButtonWidget::OnExitButtonClicked()\n{\n\tUGameplayStatics::GetPlayerController(GetWorld(), 0)->ConsoleCommand(TEXT(\"quit\"));\n}\n```"}
{"requirement": "Create an Actor that plays a sound on each collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundCollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundCollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundCollisionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* CollisionSound;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"SoundCollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASoundCollisionActor::ASoundCollisionActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set up collision\n\tMeshComponent->SetNotifyRigidBodyCollision(true);\n\tMeshComponent->BodyInstance.SetCollisionProfileName(\"BlockAll\");\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ASoundCollisionActor::OnHit);\n\n\t// Find and assign a default mesh, if desired\n\t// static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Mesh.MeshName\"));\n\t// if (MeshAsset.Succeeded()) {\n\t//\t MeshComponent->SetStaticMesh(MeshAsset.Object);\n\t// }\n}\n\n// Called when the game starts or when spawned\nvoid ASoundCollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASoundCollisionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundCollisionActor::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (CollisionSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, CollisionSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Develop a class that logs the Actor's world position every frame.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogPositionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALogPositionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALogPositionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"LogPositionActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\n// Sets default values\nALogPositionActor::ALogPositionActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALogPositionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALogPositionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector ActorLocation = GetActorLocation();\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor's World Position: %s\"), *ActorLocation.ToString());\n}\n```"}
{"requirement": "Implement a simple networking function to replicate a score variable.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReplicatedScoreActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AReplicatedScoreActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAReplicatedScoreActor();\n\nprotected:\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n\nprivate:\n\tUPROPERTY(Replicated, VisibleAnywhere, Category=\"Score\")\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"ReplicatedScoreActor.h\"\n#include \"Net/UnrealNetwork.h\"\n\nAReplicatedScoreActor::AReplicatedScoreActor()\n{\n\t// Enable replication for this actor\n\tbReplicates = true;\n\t\n\t// Initialize score\n\tScore = 0;\n}\n\nvoid AReplicatedScoreActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AReplicatedScoreActor, Score);\n}\n```"}
{"requirement": "Create a class that changes the Actor's appearance based on health levels.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AppearanceChangerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAppearanceChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAAppearanceChangerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Changes appearance based on health\n\tvoid UpdateAppearance();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Health\")\n\tfloat Health;\n\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Health thresholds for appearance change\n\tUPROPERTY(EditAnywhere, Category = \"Appearance\")\n\tTArray<UStaticMesh*> HealthMeshes;\n};\n```", "cpp_code": "```cpp\n#include \"AppearanceChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAAppearanceChangerActor::AAppearanceChangerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Initialize health\n\tHealth = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AAppearanceChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AAppearanceChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tUpdateAppearance();\n}\n\nvoid AAppearanceChangerActor::UpdateAppearance()\n{\n\tif (HealthMeshes.Num() == 0) return;\n\n\tint32 MeshIndex = FMath::Clamp(static_cast<int32>((100.0f - Health) / 100.0f * HealthMeshes.Num()), 0, HealthMeshes.Num() - 1);\n\n\tif (MeshComponent && HealthMeshes[MeshIndex])\n\t{\n\t\tMeshComponent->SetStaticMesh(HealthMeshes[MeshIndex]);\n\t}\n}\n```"}
{"requirement": "Develop an Actor with a timeline to animate its scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"ScaleTimelineActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleTimelineActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScaleTimelineActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid HandleScaleProgress(float Value);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* ScaleCurve;\n\n\tFTimeline ScaleTimeline;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleTimelineActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\nAScaleTimelineActor::AScaleTimelineActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AScaleTimelineActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (ScaleCurve)\n\t{\n\t\tFOnTimelineFloat ProgressFunction;\n\t\tProgressFunction.BindUFunction(this, FName(\"HandleScaleProgress\"));\n\n\t\tScaleTimeline.AddInterpFloat(ScaleCurve, ProgressFunction);\n\t\tScaleTimeline.SetLooping(false);\n\t\tScaleTimeline.PlayFromStart();\n\t}\n}\n\nvoid AScaleTimelineActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tScaleTimeline.TickTimeline(DeltaTime);\n}\n\nvoid AScaleTimelineActor::HandleScaleProgress(float Value)\n{\n\tFVector NewScale = FMath::Lerp(FVector(1.0f, 1.0f, 1.0f), FVector(2.0f, 2.0f, 2.0f), Value);\n\tMeshComponent->SetWorldScale3D(NewScale);\n}\n```"}
{"requirement": "Implement a UFUNCTION to teleport the Actor to a specific location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TeleportingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ATeleportingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATeleportingActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Teleport\")\n\tvoid TeleportToLocation(const FVector& NewLocation);\n};\n```", "cpp_code": "```cpp\n#include \"TeleportingActor.h\"\n\nATeleportingActor::ATeleportingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ATeleportingActor::TeleportToLocation(const FVector& NewLocation)\n{\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an Actor that follows the player within a specific radius.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FollowPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFollowPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFollowPlayerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Follow\")\n\tfloat FollowRadius;\n\n\tUPROPERTY(EditAnywhere, Category=\"Follow\")\n\tfloat MoveSpeed;\n\n\tAActor* PlayerActor;\n\n\tvoid FollowPlayer();\n};\n```", "cpp_code": "```cpp\n#include \"FollowPlayerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAFollowPlayerActor::AFollowPlayerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tFollowRadius = 500.0f;\n\tMoveSpeed = 200.0f;\n\tPlayerActor = nullptr;\n}\n\nvoid AFollowPlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid AFollowPlayerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFollowPlayer();\n}\n\nvoid AFollowPlayerActor::FollowPlayer()\n{\n\tif (!PlayerActor) return;\n\n\tFVector Direction = PlayerActor->GetActorLocation() - GetActorLocation();\n\tfloat DistanceToPlayer = Direction.Size();\n\n\tif (DistanceToPlayer > FollowRadius)\n\t{\n\t\tDirection.Normalize();\n\t\tFVector NewLocation = GetActorLocation() + Direction * MoveSpeed * GetWorld()->GetDeltaSeconds();\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to add a specified amount of health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAHealthActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Health\")\n\tvoid AddHealth(float HealthAmount);\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Health\", meta = (AllowPrivateAccess = \"true\"))\n\tfloat CurrentHealth;\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n\nAHealthActor::AHealthActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentHealth = 100.0f;\n}\n\nvoid AHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHealthActor::AddHealth(float HealthAmount)\n{\n\tCurrentHealth += HealthAmount;\n\t// Clamp current health to a maximum value if required\n\t// CurrentHealth = FMath::Clamp(CurrentHealth, 0.0f, MaxHealth);\n}\n```"}
{"requirement": "Create a UMG widget that shows the player's current ammo.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UAmmoWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UUAmmoWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintImplementableEvent, Category = \"Ammo\")\n\tvoid UpdateAmmoDisplay(int32 CurrentAmmo);\n};\n```", "cpp_code": "```cpp\n#include \"UAmmoWidget.h\"\n\n// The functionality of updating the widget will be handled in Blueprint using the UpdateAmmoDisplay function.\n```"}
{"requirement": "Develop a class that changes the Actor's texture when a signal is received.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TextureChangerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tATextureChangerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid ChangeTexture(UTexture* NewTexture);\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Materials\")\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"TextureChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Texture.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nATextureChangerActor::ATextureChangerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/YourStaticMeshPath.YourStaticMeshPath\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/YourMaterialPath.YourMaterialPath\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MaterialAsset.Object, MeshComponent);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ATextureChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATextureChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATextureChangerActor::ChangeTexture(UTexture* NewTexture)\n{\n\tif (DynamicMaterialInstance && NewTexture)\n\t{\n\t\tDynamicMaterialInstance->SetTextureParameterValue(FName(\"TextureParameter\"), NewTexture);\n\t}\n}\n```"}
{"requirement": "Implement an Actor that emits a sound cue when health is below a certain level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"HealthSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthSoundActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AHealthSoundActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  UPROPERTY(EditAnywhere, Category=\"Health\")\n  float Health;\n\n  UPROPERTY(EditAnywhere, Category=\"Health\")\n  float HealthThreshold;\n\n  UPROPERTY(EditAnywhere, Category=\"Sound\")\n  USoundCue* SoundCue;\n\n  UPROPERTY(VisibleAnywhere, Category=\"Sound\")\n  UAudioComponent* AudioComponent;\n\n  void CheckHealth();\n};\n```", "cpp_code": "```cpp\n#include \"HealthSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n\nAHealthSoundActor::AHealthSoundActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n\n  Health = 100.0f;\n  HealthThreshold = 50.0f;\n\n  AudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n  AudioComponent->bAutoActivate = false;\n  RootComponent = AudioComponent;\n}\n\nvoid AHealthSoundActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AHealthSoundActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n  CheckHealth();\n}\n\nvoid AHealthSoundActor::CheckHealth()\n{\n  if (Health < HealthThreshold && SoundCue && !AudioComponent->IsPlaying())\n  {\n\tAudioComponent->SetSound(SoundCue);\n\tAudioComponent->Play();\n  }\n}\n```"}
{"requirement": "Create an Actor with a static mesh that changes color on interaction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InteractiveColorChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AInteractiveColorChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAInteractiveColorChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle interaction\n\tUFUNCTION()\n\tvoid OnInteract();\n\n\t// Static Mesh Component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\nprivate:\n\t// Helper function to change color\n\tvoid ChangeColor();\n};\n```", "cpp_code": "```cpp\n#include \"InteractiveColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAInteractiveColorChangeActor::AInteractiveColorChangeActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Static Mesh Component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AInteractiveColorChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AInteractiveColorChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle interaction\nvoid AInteractiveColorChangeActor::OnInteract()\n{\n\tChangeColor();\n}\n\n// Helper function to change color\nvoid AInteractiveColorChangeActor::ChangeColor()\n{\n\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\tif (DynamicMaterial)\n\t{\n\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", NewColor);\n\t}\n}\n```"}
{"requirement": "Develop a class that logs a message when overlapping with a specific object type.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOverlapLogger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLogger.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapLogger::AOverlapLogger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapLogger::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapLogger::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this))\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Overlapping with: %s\"), *OtherActor->GetName()));\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION to initiate a power-up effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PowerUpActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APowerUpActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPowerUpActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"PowerUp\")\n\tvoid ActivatePowerUp();\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat PowerUpDuration;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"PowerUpActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAPowerUpActor::APowerUpActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set the mesh (assuming you have a StaticMesh'/Game/Path/To/Your/Mesh.Mesh' asset)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/Path/To/Your/Mesh.Mesh'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Initialize power-up duration\n\tPowerUpDuration = 5.0f;\n}\n\n// Called when the game starts or when spawned\nvoid APowerUpActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APowerUpActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APowerUpActor::ActivatePowerUp()\n{\n\t// Logic to activate the power-up effect\n\tUE_LOG(LogTemp, Warning, TEXT(\"Power-up activated for %f seconds!\"), PowerUpDuration);\n\t// Additional effect logic here\n}\n```"}
{"requirement": "Create a simple AI Controller to make an AI character avoid the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"AAvoidPlayerAIController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAvoidPlayerAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAvoidPlayerAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaSeconds) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tfloat AvoidanceRadius = 300.0f;\n};\n```", "cpp_code": "```cpp\n#include \"AAvoidPlayerAIController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAAvoidPlayerAIController::AAvoidPlayerAIController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AAvoidPlayerAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAvoidPlayerAIController::Tick(float DeltaSeconds)\n{\n\tSuper::Tick(DeltaSeconds);\n\n\tAPawn* ControlledPawn = GetPawn();\n\tif (!ControlledPawn) return;\n\n\tAPawn* PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n\tif (!PlayerPawn) return;\n\n\tFVector DistanceToPlayer = ControlledPawn->GetActorLocation() - PlayerPawn->GetActorLocation();\n\tif (DistanceToPlayer.Size() < AvoidanceRadius)\n\t{\n\t\tFVector AwayFromPlayer = DistanceToPlayer.GetSafeNormal();\n\t\tFVector NewLocation = ControlledPawn->GetActorLocation() + AwayFromPlayer * 100.0f * DeltaSeconds;\n\t\tControlledPawn->SetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Develop an Actor that scales based on a given multiplier.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScalableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Scaling\")\n\tfloat ScaleMultiplier;\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid UpdateScale();\n};\n```", "cpp_code": "```cpp\n#include \"ScalableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAScalableActor::AScalableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t\tMeshComponent->SetRelativeScale3D(FVector(1.0f, 1.0f, 1.0f));\n\t}\n\n\tScaleMultiplier = 1.0f;\n}\n\nvoid AScalableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateScale();\n}\n\nvoid AScalableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t// Call UpdateScale if needed\n}\n\nvoid AScalableActor::UpdateScale()\n{\n\tFVector NewScale = FVector(ScaleMultiplier);\n\tMeshComponent->SetWorldScale3D(NewScale);\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to trigger an explosion effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ExplosionEffectActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AExplosionEffectActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAExplosionEffectActor();\n\n\t// BlueprintCallable function to trigger the explosion effect\n\tUFUNCTION(BlueprintCallable, Category=\"Explosion\")\n\tvoid TriggerExplosion();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ExplosionEffectActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAExplosionEffectActor::AExplosionEffectActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Optionally, set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AExplosionEffectActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AExplosionEffectActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// BlueprintCallable function to trigger the explosion effect\nvoid AExplosionEffectActor::TriggerExplosion()\n{\n\t// Implement your explosion logic here\n\tUE_LOG(LogTemp, Warning, TEXT(\"Explosion triggered!\"));\n\t// Example: Spawn particle system, play sound, etc.\n}\n```"}
{"requirement": "Create an Actor with a collision component that triggers a visual effect on contact.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/SphereComponent.h\"\n#include \"VisualEffectTriggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVisualEffectTriggerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAVisualEffectTriggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUSphereComponent* CollisionComponent;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"VisualEffectTriggerActor.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAVisualEffectTriggerActor::AVisualEffectTriggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\tCollisionComponent->InitSphereRadius(100.0f);\n\tCollisionComponent->SetCollisionProfileName(TEXT(\"Trigger\"));\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AVisualEffectTriggerActor::OnOverlapBegin);\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComponent->SetupAttachment(RootComponent);\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AVisualEffectTriggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AVisualEffectTriggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AVisualEffectTriggerActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor != this && OtherComp)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), YourVisualEffect, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Develop a class that resets the game score when the player presses a key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreResetActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AScoreResetActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScoreResetActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to reset the game score\n\tvoid ResetScore();\n\n\t// The score variable\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreResetActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAScoreResetActor::AScoreResetActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the score to some default value\n\tScore = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AScoreResetActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScoreResetActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid AScoreResetActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"ResetScore\", IE_Pressed, this, &AScoreResetActor::ResetScore);\n\t}\n}\n\n// Function to reset the game score\nvoid AScoreResetActor::ResetScore()\n{\n\tScore = 0;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Score has been reset.\"));\n}\n```"}
{"requirement": "Implement a UMG widget that acts as a mini-map.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UMiniMapWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UUMiniMapWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUUMiniMapWidget(const FObjectInitializer& ObjectInitializer);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UImage* MiniMapImage;\n};\n```", "cpp_code": "```cpp\n#include \"UMiniMapWidget.h\"\n#include \"Components/Image.h\"\n\nUUMiniMapWidget::UUMiniMapWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UUMiniMapWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\n\t// Ensure MiniMapImage is valid and do any custom initialization here\n\tif (MiniMapImage)\n\t{\n\t\t// Set up the mini-map image here, e.g. setting a texture\n\t}\n}\n```"}
{"requirement": "Create an Actor that can be possessed by the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"PlayerPossessableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APlayerPossessableActor : public APawn\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this pawn's properties\n\tAPlayerPossessableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Static mesh component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Mesh\", meta=(AllowPrivateAccess=\"true\"))\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerPossessableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAPlayerPossessableActor::APlayerPossessableActor()\n{\n\t// Set this pawn to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid APlayerPossessableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APlayerPossessableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid APlayerPossessableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind input actions and axes here\n}\n```"}
{"requirement": "Develop a class that logs the elapsed time since the game started.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ElapsedTimeLogger.generated.h\"\n\nUCLASS()\nclass AElapsedTimeLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAElapsedTimeLogger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tfloat StartTime;\n};\n```", "cpp_code": "```cpp\n#include \"ElapsedTimeLogger.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAElapsedTimeLogger::AElapsedTimeLogger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AElapsedTimeLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tStartTime = GetWorld()->GetTimeSeconds();\n}\n\n// Called every frame\nvoid AElapsedTimeLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat ElapsedTime = GetWorld()->GetTimeSeconds() - StartTime;\n\tUE_LOG(LogTemp, Log, TEXT(\"Elapsed Time: %f seconds\"), ElapsedTime);\n}\n```"}
{"requirement": "Implement a UFUNCTION to toggle the Actor's light component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"ToggleLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleLightActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Light\")\n\tvoid ToggleLight();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUPointLightComponent* PointLightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nAToggleLightActor::AToggleLightActor()\n{\n\t// Create and attach the light component\n\tPointLightComponent = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLightComponent\"));\n\tRootComponent = PointLightComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleLightActor::ToggleLight()\n{\n\tif (PointLightComponent)\n\t{\n\t\tPointLightComponent->ToggleVisibility();\n\t}\n}\n```"}
{"requirement": "Create an Actor that moves along a path defined by waypoints.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WaypointPathActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWaypointPathActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAWaypointPathActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Path\")\n\tTArray<AActor*> Waypoints;\n\n\tint32 CurrentWaypointIndex;\n\n\tUPROPERTY(EditAnywhere, Category=\"Path\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"WaypointPathActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAWaypointPathActor::AWaypointPathActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCurrentWaypointIndex = 0;\n\tMovementSpeed = 100.0f; // Default speed\n}\n\n// Called when the game starts or when spawned\nvoid AWaypointPathActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Ensure there are waypoints defined\n\tif (Waypoints.Num() == 0)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"No waypoints defined for %s\"), *GetName());\n\t}\n}\n\n// Called every frame\nvoid AWaypointPathActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (Waypoints.Num() == 0)\n\t{\n\t\treturn;\n\t}\n\n\tif (CurrentWaypointIndex < Waypoints.Num())\n\t{\n\t\tAActor* CurrentWaypoint = Waypoints[CurrentWaypointIndex];\n\t\tFVector Direction = (CurrentWaypoint->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n\t\tFVector NewLocation = GetActorLocation() + Direction * MovementSpeed * DeltaTime;\n\n\t\tSetActorLocation(NewLocation);\n\n\t\tif (FVector::Dist(GetActorLocation(), CurrentWaypoint->GetActorLocation()) < 10.0f)\n\t\t{\n\t\t\tCurrentWaypointIndex++;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a simple AI Controller to have an AI character flee when damaged.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"AFleeAIController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFleeAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFleeAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnTakeDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy, AActor* DamageCauser);\n\nprivate:\n\tFVector CalculateFleeDirection();\n\tvoid MoveInFleeDirection();\n\n\tFVector FleeDirection;\n\tbool bShouldFlee;\n};\n```", "cpp_code": "```cpp\n#include \"AFleeAIController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"NavigationSystem.h\"\n#include \"AI/Navigation/NavigationPath.h\"\n\nAFleeAIController::AFleeAIController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbShouldFlee = false;\n}\n\nvoid AFleeAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (GetPawn())\n\t{\n\t\tGetPawn()->OnTakeAnyDamage.AddDynamic(this, &AFleeAIController::OnTakeDamage);\n\t}\n}\n\nvoid AFleeAIController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tif (bShouldFlee)\n\t{\n\t\tMoveInFleeDirection();\n\t}\n}\n\nvoid AFleeAIController::OnTakeDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy, AActor* DamageCauser)\n{\n\tFleeDirection = CalculateFleeDirection();\n\tbShouldFlee = true;\n}\n\nFVector AFleeAIController::CalculateFleeDirection()\n{\n\tif (AActor* Pawn = GetPawn())\n\t{\n\t\tFVector FleeDirection = Pawn->GetActorLocation() - UGameplayStatics::GetPlayerPawn(GetWorld(), 0)->GetActorLocation();\n\t\tFleeDirection.Normalize();\n\t\treturn FleeDirection;\n\t}\n\treturn FVector::ZeroVector;\n}\n\nvoid AFleeAIController::MoveInFleeDirection()\n{\n\tif (AActor* Pawn = GetPawn())\n\t{\n\t\tFVector NewLocation = Pawn->GetActorLocation() + FleeDirection * 100.0f; // Move 100 units away\n\t\tUNavigationSystemV1* NavSystem = UNavigationSystemV1::GetCurrent(GetWorld());\n\t\tif (NavSystem)\n\t\t{\n\t\t\tFNavLocation NavLocation;\n\t\t\tif (NavSystem->ProjectPointToNavigation(NewLocation, NavLocation))\n\t\t\t{\n\t\t\t\tMoveToLocation(NavLocation.Location);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a class that changes the Actor's material when health is restored.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"HealthRestoredActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthRestoredActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAHealthRestoredActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Health\")\n\tvoid RestoreHealth(float HealthAmount);\n\nprivate:\n\tvoid ChangeMaterial();\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Materials\")\n\tUMaterialInterface* RestoredMaterial;\n\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat CurrentHealth;\n\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat MaxHealth;\n};\n```", "cpp_code": "```cpp\n#include \"HealthRestoredActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAHealthRestoredActor::AHealthRestoredActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tCurrentHealth = 100.0f;\n\tMaxHealth = 100.0f;\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialAsset(TEXT(\"/Game/Path/To/Material.Material\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tRestoredMaterial = MaterialAsset.Object;\n\t}\n}\n\nvoid AHealthRestoredActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthRestoredActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHealthRestoredActor::RestoreHealth(float HealthAmount)\n{\n\tCurrentHealth = FMath::Clamp(CurrentHealth + HealthAmount, 0.0f, MaxHealth);\n\tif (HealthAmount > 0 && CurrentHealth == MaxHealth)\n\t{\n\t\tChangeMaterial();\n\t}\n}\n\nvoid AHealthRestoredActor::ChangeMaterial()\n{\n\tif (MeshComponent && RestoredMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, RestoredMaterial);\n\t}\n}\n```"}
{"requirement": "Develop an Actor that plays a sound on each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundTickActor.generated.h\"\n\nUCLASS()\nclass ASoundTickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundTickActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"SoundTickActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundTickActor::ASoundTickActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundTickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASoundTickActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to change the Actor's movement speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeSpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeSpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAChangeSpeedActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MovementSpeed;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid SetMovementSpeed(float NewSpeed);\n};\n```", "cpp_code": "```cpp\n#include \"ChangeSpeedActor.h\"\n\n// Sets default values\nAChangeSpeedActor::AChangeSpeedActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t MovementSpeed = 600.0f; // Default speed value\n}\n\n// Called when the game starts or when spawned\nvoid AChangeSpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AChangeSpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid AChangeSpeedActor::SetMovementSpeed(float NewSpeed)\n{\n\tMovementSpeed = NewSpeed;\n}\n```"}
{"requirement": "Create an Actor with a timeline to animate its material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"MaterialTimelineActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialTimelineActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialTimelineActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* Mesh;\n\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tFTimeline MaterialTimeline;\n\n\tUFUNCTION()\n\tvoid HandleTimelineProgress(float Value);\n\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* CurveFloat;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialTimelineActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nAMaterialTimelineActor::AMaterialTimelineActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh\"));\n\tRootComponent = Mesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMesh->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AMaterialTimelineActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Mesh->GetMaterial(0))\n\t{\n\t\tDynamicMaterial = UMaterialInstanceDynamic::Create(Mesh->GetMaterial(0), this);\n\t\tMesh->SetMaterial(0, DynamicMaterial);\n\t}\n\n\tif (CurveFloat)\n\t{\n\t\tFOnTimelineFloat ProgressFunction;\n\t\tProgressFunction.BindUFunction(this, FName(\"HandleTimelineProgress\"));\n\t\tMaterialTimeline.AddInterpFloat(CurveFloat, ProgressFunction);\n\t\tMaterialTimeline.SetLooping(true);\n\t\tMaterialTimeline.PlayFromStart();\n\t}\n}\n\nvoid AMaterialTimelineActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tMaterialTimeline.TickTimeline(DeltaTime);\n}\n\nvoid AMaterialTimelineActor::HandleTimelineProgress(float Value)\n{\n\tif (DynamicMaterial)\n\t{\n\t\tDynamicMaterial->SetScalarParameterValue(FName(\"YourParameter\"), Value);\n\t}\n}\n```"}
{"requirement": "Develop a class that destroys the Actor when its health reaches zero.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthDestroyActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthDestroyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHealthDestroyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnHealthChanged();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat Health;\n\n\tvoid CheckHealth();\n};\n```", "cpp_code": "```cpp\n#include \"HealthDestroyActor.h\"\n\n// Sets default values\nAHealthDestroyActor::AHealthDestroyActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tHealth = 100.f; // Initial health value\n}\n\n// Called when the game starts or when spawned\nvoid AHealthDestroyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AHealthDestroyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tCheckHealth();\n}\n\nvoid AHealthDestroyActor::OnHealthChanged()\n{\n\tif (Health <= 0)\n\t{\n\t\tDestroy();\n\t}\n}\n\nvoid AHealthDestroyActor::CheckHealth()\n{\n\tOnHealthChanged();\n}\n```"}
{"requirement": "Implement a UMG button widget that submits the player's name.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UPlayerNameSubmitWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UPlayerNameSubmitWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPlayerNameSubmitWidget(const FObjectInitializer& ObjectInitializer);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnSubmitButtonClicked();\n\n\tUPROPERTY(meta = (BindWidget))\n\tclass UButton* SubmitButton;\n\n\tUPROPERTY(meta = (BindWidget))\n\tclass UEditableTextBox* NameTextBox;\n};\n```", "cpp_code": "```cpp\n#include \"UPlayerNameSubmitWidget.h\"\n#include \"Components/Button.h\"\n#include \"Components/EditableTextBox.h\"\n\nUPlayerNameSubmitWidget::UPlayerNameSubmitWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UPlayerNameSubmitWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\n\tif (SubmitButton)\n\t{\n\t\tSubmitButton->OnClicked.AddDynamic(this, &UPlayerNameSubmitWidget::OnSubmitButtonClicked);\n\t}\n}\n\nvoid UPlayerNameSubmitWidget::OnSubmitButtonClicked()\n{\n\tif (NameTextBox)\n\t{\n\t\tFString PlayerName = NameTextBox->GetText().ToString();\n\t\t// Handle the submission of the player's name\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Player Name Submitted: %s\"), *PlayerName);\n\t}\n}\n```"}
{"requirement": "Create an Actor that rotates based on mouse movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseControlledRotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMouseControlledRotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMouseControlledRotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input components\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Handle Mouse Input\n\tvoid HandleMouseInput(float AxisValue);\n\n\t// Rotation speed\n\tUPROPERTY(EditAnywhere, Category = \"Rotation\")\n\tfloat RotationSpeed;\n\n\t// Static Mesh\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMesh;\n};\n```", "cpp_code": "```cpp\n#include \"MouseControlledRotatingActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAMouseControlledRotatingActor::AMouseControlledRotatingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize rotation speed\n\tRotationSpeed = 100.0f;\n\n\t// Create Static Mesh Component\n\tStaticMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMesh\"));\n\tRootComponent = StaticMesh;\n\n\t// Optionally set a default mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMesh->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMouseControlledRotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMouseControlledRotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input components\nvoid AMouseControlledRotatingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"Turn\", this, &AMouseControlledRotatingActor::HandleMouseInput);\n}\n\n// Handle Mouse Input\nvoid AMouseControlledRotatingActor::HandleMouseInput(float AxisValue)\n{\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += AxisValue * RotationSpeed * GetWorld()->GetDeltaSeconds();\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a simple networking function to replicate an Actor's animation state.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AnimationReplicationActor.generated.h\"\n\nUCLASS()\nclass AAnimationReplicationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAnimationReplicationActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Animation\")\n\tvoid SetAnimationState(float NewState);\n\n\tUFUNCTION(Server, Reliable, WithValidation)\n\tvoid ServerSetAnimationState(float NewState);\n\n\tUPROPERTY(ReplicatedUsing=OnRep_AnimationState, VisibleAnywhere, BlueprintReadOnly, Category=\"Animation\")\n\tfloat AnimationState;\n\n\tUFUNCTION()\n\tvoid OnRep_AnimationState();\n\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n};\n```", "cpp_code": "```cpp\n#include \"AnimationReplicationActor.h\"\n#include \"Net/UnrealNetwork.h\"\n\nAAnimationReplicationActor::AAnimationReplicationActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbReplicates = true;\n}\n\nvoid AAnimationReplicationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAnimationReplicationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AAnimationReplicationActor::SetAnimationState(float NewState)\n{\n\tif (HasAuthority())\n\t{\n\t\tAnimationState = NewState;\n\t\tOnRep_AnimationState();\n\t}\n\telse\n\t{\n\t\tServerSetAnimationState(NewState);\n\t}\n}\n\nvoid AAnimationReplicationActor::ServerSetAnimationState_Implementation(float NewState)\n{\n\tSetAnimationState(NewState);\n}\n\nbool AAnimationReplicationActor::ServerSetAnimationState_Validate(float NewState)\n{\n\treturn true;\n}\n\nvoid AAnimationReplicationActor::OnRep_AnimationState()\n{\n\t// Handle animation state change on clients\n}\n\nvoid AAnimationReplicationActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AAnimationReplicationActor, AnimationState);\n}\n```"}
{"requirement": "Create a class that scales the Actor randomly when initialized.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomScaleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tARandomScaleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tvoid RandomizeScale();\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector MinScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector MaxScale;\n};\n```", "cpp_code": "```cpp\n#include \"RandomScaleActor.h\"\n#include \"Math/UnrealMathUtility.h\"\n\n// Sets default values\nARandomScaleActor::ARandomScaleActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// Initialize default scale range\n\tMinScale = FVector(0.5f, 0.5f, 0.5f);\n\tMaxScale = FVector(2.0f, 2.0f, 2.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ARandomScaleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tRandomizeScale();\n}\n\nvoid ARandomScaleActor::RandomizeScale()\n{\n\tfloat RandomX = FMath::FRandRange(MinScale.X, MaxScale.X);\n\tfloat RandomY = FMath::FRandRange(MinScale.Y, MaxScale.Y);\n\tfloat RandomZ = FMath::FRandRange(MinScale.Z, MaxScale.Z);\n\tFVector NewScale = FVector(RandomX, RandomY, RandomZ);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Develop an Actor with a collision component to detect specific overlapping objects.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Collision component\n\tUPROPERTY(VisibleAnywhere, Category = \"Collision\")\n\tUBoxComponent* CollisionComponent;\n\n\t// Function to handle overlap\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\n\t\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nACollisionActor::ACollisionActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set up the collision component\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\t// Set up overlap event\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle overlap events\nvoid ACollisionActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\n\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\t// Print message to log or any specific logic for overlapping objects\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Overlapping with %s\"), *OtherActor->GetName()));\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION to trigger a custom event and log to the console.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomEventActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomEventActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACustomEventActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"CustomEvent\")\n\tvoid TriggerCustomEvent();\n};\n```", "cpp_code": "```cpp\n#include \"CustomEventActor.h\"\n#include \"Engine/Engine.h\"\n\nACustomEventActor::ACustomEventActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ACustomEventActor::TriggerCustomEvent()\n{\n\tif (GEngine)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Custom event has been triggered!\"));\n\t}\n}\n```"}
{"requirement": "Create an Actor that moves in a wave-like pattern using a timeline.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"WaveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWaveActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWaveActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* FloatCurve;\n\n\tFTimeline WaveTimeline;\n\n\tUFUNCTION()\n\tvoid HandleProgress(float Value);\n\n\tFVector InitialLocation;\n};\n```", "cpp_code": "```cpp\n#include \"WaveActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\nAWaveActor::AWaveActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AWaveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tInitialLocation = GetActorLocation();\n\n\tif (FloatCurve)\n\t{\n\t\tFOnTimelineFloat ProgressFunction;\n\t\tProgressFunction.BindUFunction(this, FName(\"HandleProgress\"));\n\t\tWaveTimeline.AddInterpFloat(FloatCurve, ProgressFunction);\n\t\tWaveTimeline.SetLooping(true);\n\t\tWaveTimeline.PlayFromStart();\n\t}\n}\n\nvoid AWaveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tWaveTimeline.TickTimeline(DeltaTime);\n}\n\nvoid AWaveActor::HandleProgress(float Value)\n{\n\tFVector NewLocation = InitialLocation;\n\tNewLocation.Z += Value;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to pause and resume the Actor's animation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"Animation/AnimMontage.h\"\n#include \"MyAnimatedActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyAnimatedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyAnimatedActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Animation\")\n\tvoid PauseAnimation();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Animation\")\n\tvoid ResumeAnimation();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Animation\")\n\tUAnimMontage* AnimationMontage;\n\n\tUAnimInstance* AnimInstance;\n};\n```", "cpp_code": "```cpp\n#include \"MyAnimatedActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nAMyAnimatedActor::AMyAnimatedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AMyAnimatedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAnimInstance = MeshComponent->GetAnimInstance();\n}\n\nvoid AMyAnimatedActor::PauseAnimation()\n{\n\tif (AnimInstance && AnimationMontage)\n\t{\n\t\tAnimInstance->Montage_Pause(AnimationMontage);\n\t}\n}\n\nvoid AMyAnimatedActor::ResumeAnimation()\n{\n\tif (AnimInstance && AnimationMontage)\n\t{\n\t\tAnimInstance->Montage_Resume(AnimationMontage);\n\t}\n}\n```"}
{"requirement": "Create a UMG widget that shows the player's current level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"ULevelWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ULevelWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Level\")\n\tvoid UpdateLevel(int32 NewLevel);\n\nprotected:\n\tUPROPERTY(BlueprintReadOnly, meta = (BindWidget))\n\tclass UTextBlock* LevelText;\n};\n```", "cpp_code": "```cpp\n#include \"ULevelWidget.h\"\n#include \"Components/TextBlock.h\"\n\nvoid ULevelWidget::UpdateLevel(int32 NewLevel)\n{\n\tif (LevelText)\n\t{\n\t\tLevelText->SetText(FText::FromString(FString::Printf(TEXT(\"Level: %d\"), NewLevel)));\n\t}\n}\n```"}
{"requirement": "Develop a class that changes the Actor's color based on a random choice.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARandomColorActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Function to change the color randomly\n\tvoid ChangeColorRandomly();\n\n\t// Mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"RandomColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nARandomColorActor::ARandomColorActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set the static mesh (assuming the mesh is called 'YourMeshName' in the game's content folder)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/YourMeshPath/YourMeshName.YourMeshName'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ARandomColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tChangeColorRandomly();\n}\n\n// Called every frame\nvoid ARandomColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARandomColorActor::ChangeColorRandomly()\n{\n\tFLinearColor RandomColor = FLinearColor::MakeRandomColor();\n\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"BaseColor\"), RandomColor);\n}\n```"}
{"requirement": "Implement an Actor that spawns a light source when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpawnLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpawnLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpawnLightActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid SpawnLight();\n\n\tUPROPERTY(EditAnywhere)\n\tTSubclassOf<class APointLight> LightClass;\n};\n```", "cpp_code": "```cpp\n#include \"SpawnLightActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/PointLight.h\"\n\nASpawnLightActor::ASpawnLightActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASpawnLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpawnLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpawnLightActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"SpawnLight\", IE_Pressed, this, &ASpawnLightActor::SpawnLight);\n}\n\nvoid ASpawnLightActor::SpawnLight()\n{\n\tif (LightClass)\n\t{\n\t\tFVector Location = GetActorLocation();\n\t\tFRotator Rotation = GetActorRotation();\n\t\tGetWorld()->SpawnActor<APointLight>(LightClass, Location, Rotation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh that toggles visibility on interaction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleVisibilityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Mesh component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\t// Function to toggle visibility\n\tvoid ToggleVisibility();\n\n\t// Input setup\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach static mesh component\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Set a default static mesh (Assumes there's a mesh at the specified path)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMeshName\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Ensure the actor is interactable\n\tEnableInput(GetWorld()->GetFirstPlayerController());\n}\n\n// Called every frame\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to toggle visibility\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tbool bIsVisible = StaticMeshComponent->IsVisible();\n\tStaticMeshComponent->SetVisibility(!bIsVisible);\n}\n\n// Setup player input\nvoid AToggleVisibilityActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleVisibilityActor::ToggleVisibility);\n}\n```"}
{"requirement": "Develop a class that logs the Actor's local rotation every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotationLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotationLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotationLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFTimerHandle LoggerTimerHandle;\n\n\tUFUNCTION()\n\tvoid LogRotation();\n};\n```", "cpp_code": "```cpp\n#include \"RotationLoggerActor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n#include \"GameFramework/Actor.h\"\n\nARotationLoggerActor::ARotationLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARotationLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorld()->GetTimerManager().SetTimer(LoggerTimerHandle, this, &ARotationLoggerActor::LogRotation, 1.0f, true);\n}\n\nvoid ARotationLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARotationLoggerActor::LogRotation()\n{\n\tFRotator LocalRotation = GetActorRotation();\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor Local Rotation: Pitch=%f, Yaw=%f, Roll=%f\"), LocalRotation.Pitch, LocalRotation.Yaw, LocalRotation.Roll);\n}\n```"}
{"requirement": "Implement a UFUNCTION to set the Actor's material to an emissive one.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EmissiveMaterialActor.generated.h\"\n\nUCLASS()\nclass AEmissiveMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAEmissiveMaterialActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Material\")\n\tvoid SetEmissiveMaterial(UMaterialInterface* EmissiveMaterial);\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"EmissiveMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAEmissiveMaterialActor::AEmissiveMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AEmissiveMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AEmissiveMaterialActor::SetEmissiveMaterial(UMaterialInterface* EmissiveMaterial)\n{\n\tif (MeshComponent && EmissiveMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, EmissiveMaterial);\n\t}\n}\n```"}
{"requirement": "Create a simple AI Controller to have an AI character idle and then chase the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"AChaseAIController.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AChaseAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAChaseAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ChasePlayer();\n\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tfloat AcceptanceRadius = 100.0f;\n};\n```", "cpp_code": "```cpp\n#include \"AChaseAIController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Character.h\"\n\nAChaseAIController::AChaseAIController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AChaseAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChaseAIController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tChasePlayer();\n}\n\nvoid AChaseAIController::ChasePlayer()\n{\n\tAPawn* PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n\tif (PlayerPawn)\n\t{\n\t\tMoveToActor(PlayerPawn, AcceptanceRadius);\n\t}\n}\n```"}
{"requirement": "Develop an Actor that enlarges when overlapping with another Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EnlargeOnOverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AEnlargeOnOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAEnlargeOnOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"EnlargeOnOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nAEnlargeOnOverlapActor::AEnlargeOnOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AEnlargeOnOverlapActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AEnlargeOnOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AEnlargeOnOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AEnlargeOnOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tFVector NewScale = GetActorScale3D();\n\t\tNewScale *= 1.2f; // Increase scale by 20%\n\t\tSetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to change the player's camera view.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PlayerCameraController.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APlayerCameraController : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPlayerCameraController();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Camera\")\n\tvoid ChangeCameraView(AActor* NewViewTarget);\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerCameraController.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAPlayerCameraController::APlayerCameraController()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid APlayerCameraController::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APlayerCameraController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APlayerCameraController::ChangeCameraView(AActor* NewViewTarget)\n{\n\tif (APlayerController* PlayerController = UGameplayStatics::GetPlayerController(this, 0))\n\t{\n\t\tif (NewViewTarget)\n\t\t{\n\t\t\tPlayerController->SetViewTargetWithBlend(NewViewTarget);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a timeline that animates its color from blue to red.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"ColorTimelineActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorTimelineActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorTimelineActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUTimelineComponent* ColorTimeline;\n\n\tFOnTimelineFloat UpdateTimelineFloat;\n\n\tUFUNCTION()\n\tvoid HandleTimelineProgress(float Value);\n\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* ColorCurve;\n};\n```", "cpp_code": "```cpp\n#include \"ColorTimelineActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAColorTimelineActor::AColorTimelineActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tColorTimeline = CreateDefaultSubobject<UTimelineComponent>(TEXT(\"ColorTimeline\"));\n}\n\n// Called when the game starts or when spawned\nvoid AColorTimelineActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (ColorCurve)\n\t{\n\t\tUpdateTimelineFloat.BindUFunction(this, FName(\"HandleTimelineProgress\"));\n\t\tColorTimeline->AddInterpFloat(ColorCurve, UpdateTimelineFloat);\n\t\tColorTimeline->SetLooping(false);\n\t\tColorTimeline->PlayFromStart();\n\t}\n}\n\n// Called every frame\nvoid AColorTimelineActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AColorTimelineActor::HandleTimelineProgress(float Value)\n{\n\tFLinearColor NewColor = FLinearColor::LerpUsingHSV(FLinearColor::Blue, FLinearColor::Red, Value);\n\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"BaseColor\"), NewColor);\n}\n```"}
{"requirement": "Develop a class that triggers an alarm sound when the player enters a restricted area.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/BoxComponent.h\"\n#include \"RestrictedAreaAlarm.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ARestrictedAreaAlarm : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARestrictedAreaAlarm();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUBoxComponent* RestrictedArea;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* AlarmSoundCue;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"RestrictedAreaAlarm.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nARestrictedAreaAlarm::ARestrictedAreaAlarm()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRestrictedArea = CreateDefaultSubobject<UBoxComponent>(TEXT(\"RestrictedArea\"));\n\tRootComponent = RestrictedArea;\n\n\tRestrictedArea->OnComponentBeginOverlap.AddDynamic(this, &ARestrictedAreaAlarm::OnOverlapBegin);\n}\n\nvoid ARestrictedAreaAlarm::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARestrictedAreaAlarm::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARestrictedAreaAlarm::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tif (AlarmSoundCue)\n\t\t{\n\t\t\tUGameplayStatics::PlaySoundAtLocation(this, AlarmSoundCue, GetActorLocation());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a UMG widget that displays the current game time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"GameTimeWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UGameTimeWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUGameTimeWidget(const FObjectInitializer& ObjectInitializer);\n\n\tvirtual void NativeTick(const FGeometry& MyGeometry, float InDeltaTime) override;\n\nprotected:\n\tUPROPERTY(BlueprintReadOnly, meta = (BindWidget))\n\tclass UTextBlock* GameTimeText;\n};\n```", "cpp_code": "```cpp\n#include \"GameTimeWidget.h\"\n#include \"Components/TextBlock.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUGameTimeWidget::UGameTimeWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UGameTimeWidget::NativeTick(const FGeometry& MyGeometry, float InDeltaTime)\n{\n\tSuper::NativeTick(MyGeometry, InDeltaTime);\n\n\tif (GameTimeText)\n\t{\n\t\tfloat CurrentTime = UGameplayStatics::GetTimeSeconds(GetWorld());\n\t\tFText TimeText = FText::AsNumber(CurrentTime);\n\t\tGameTimeText->SetText(TimeText);\n\t}\n}\n```"}
{"requirement": "Create an Actor that moves to a random location when interacted with.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomMover : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  ARandomMover();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  // Interaction function\n  UFUNCTION()\n  void MoveToRandomLocation();\n\nprivate:\n  UPROPERTY(EditAnywhere)\n  UStaticMeshComponent* MeshComponent;\n\n  UFUNCTION()\n  void OnInteract();\n};\n```", "cpp_code": "```cpp\n#include \"RandomMover.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\n// Sets default values\nARandomMover::ARandomMover()\n{\n  // Set this actor to call Tick() every frame.\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Create mesh component\n  MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n  RootComponent = MeshComponent;\n\n  // Bind interaction function\n  OnActorClicked.AddDynamic(this, &ARandomMover::OnInteract);\n}\n\n// Called when the game starts or when spawned\nvoid ARandomMover::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid ARandomMover::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid ARandomMover::OnInteract()\n{\n  MoveToRandomLocation();\n}\n\nvoid ARandomMover::MoveToRandomLocation()\n{\n  if (GetWorld())\n  {\n\tFVector NewLocation = UKismetMathLibrary::RandomPointInBoundingBox(FVector(0.0f, 0.0f, 0.0f), FVector(1000.0f, 1000.0f, 1000.0f));\n\tSetActorLocation(NewLocation);\n  }\n}\n```"}
{"requirement": "Implement a simple networking function to replicate an Actor's material change.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"MyNetworkedActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyNetworkedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyNetworkedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Material\")\n\tvoid ChangeMaterial(UMaterialInterface* NewMaterial);\n\n\tUFUNCTION(Server, Reliable, WithValidation)\n\tvoid ServerChangeMaterial(UMaterialInterface* NewMaterial);\n\nprivate:\n\tUPROPERTY(ReplicatedUsing = OnRep_Material)\n\tUMaterialInterface* CurrentMaterial;\n\n\tUFUNCTION()\n\tvoid OnRep_Material();\n\n\tvoid GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n};\n```", "cpp_code": "```cpp\n#include \"MyNetworkedActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Net/UnrealNetwork.h\"\n\nAMyNetworkedActor::AMyNetworkedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tbReplicates = true;\n}\n\nvoid AMyNetworkedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyNetworkedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyNetworkedActor::ChangeMaterial(UMaterialInterface* NewMaterial)\n{\n\tif (HasAuthority())\n\t{\n\t\tCurrentMaterial = NewMaterial;\n\t\tOnRep_Material();\n\t}\n\telse\n\t{\n\t\tServerChangeMaterial(NewMaterial);\n\t}\n}\n\nvoid AMyNetworkedActor::ServerChangeMaterial_Implementation(UMaterialInterface* NewMaterial)\n{\n\tChangeMaterial(NewMaterial);\n}\n\nbool AMyNetworkedActor::ServerChangeMaterial_Validate(UMaterialInterface* NewMaterial)\n{\n\treturn true;\n}\n\nvoid AMyNetworkedActor::OnRep_Material()\n{\n\tif (MeshComponent)\n\t{\n\t\tMeshComponent->SetMaterial(0, CurrentMaterial);\n\t}\n}\n\nvoid AMyNetworkedActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AMyNetworkedActor, CurrentMaterial);\n}\n```"}
{"requirement": "Create a class that plays a sound when the player's score reaches a multiple of ten.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"ScoreSoundActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AScoreSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAScoreSoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnScoreChanged(int32 NewScore);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* ScoreSoundCue;\n\n\tUFUNCTION()\n\tvoid PlayScoreSound();\n};\n```", "cpp_code": "```cpp\n#include \"ScoreSoundActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAScoreSoundActor::AScoreSoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AScoreSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScoreSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScoreSoundActor::OnScoreChanged(int32 NewScore)\n{\n\tif (NewScore % 10 == 0 && NewScore != 0)\n\t{\n\t\tPlayScoreSound();\n\t}\n}\n\nvoid AScoreSoundActor::PlayScoreSound()\n{\n\tif (ScoreSoundCue)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, ScoreSoundCue, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Develop an Actor that changes its color based on its altitude.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AltitudeColorChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAltitudeColorChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAAltitudeColorChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tfloat AltitudeThreshold;\n\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tFLinearColor LowAltitudeColor;\n\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tFLinearColor HighAltitudeColor;\n\n\tvoid UpdateColor();\n};\n```", "cpp_code": "```cpp\n#include \"AltitudeColorChanger.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAAltitudeColorChanger::AAltitudeColorChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tAltitudeThreshold = 300.0f;\n\tLowAltitudeColor = FLinearColor::Red;\n\tHighAltitudeColor = FLinearColor::Blue;\n}\n\nvoid AAltitudeColorChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAltitudeColorChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateColor();\n}\n\nvoid AAltitudeColorChanger::UpdateColor()\n{\n\tfloat Altitude = GetActorLocation().Z;\n\tFLinearColor NewColor = Altitude > AltitudeThreshold ? HighAltitudeColor : LowAltitudeColor;\n\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"Color\"), NewColor);\n}\n```"}
{"requirement": "Implement a UFUNCTION to toggle the Actor's collision settings.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleCollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleCollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAToggleCollisionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Collision\")\n\tvoid ToggleCollision();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleCollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAToggleCollisionActor::AToggleCollisionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AToggleCollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleCollisionActor::ToggleCollision()\n{\n\tif (MeshComponent->GetCollisionEnabled() == ECollisionEnabled::NoCollision)\n\t{\n\t\tMeshComponent->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t}\n}\n```"}
{"requirement": "Create an Actor that follows a path defined by a spline component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SplineComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"PathFollowingActor.generated.h\"\n\nUCLASS()\nclass APathFollowingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPathFollowingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUSplineComponent* SplineComponent;\n\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Path\")\n\tfloat MovementSpeed;\n\n\tfloat CurrentSplineDistance;\n};\n```", "cpp_code": "```cpp\n#include \"PathFollowingActor.h\"\n#include \"Components/SplineComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAPathFollowingActor::APathFollowingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSplineComponent = CreateDefaultSubobject<USplineComponent>(TEXT(\"SplineComponent\"));\n\tRootComponent = SplineComponent;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComponent->SetupAttachment(SplineComponent);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMovementSpeed = 100.0f;\n\tCurrentSplineDistance = 0.0f;\n}\n\nvoid APathFollowingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APathFollowingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (SplineComponent)\n\t{\n\t\tCurrentSplineDistance += MovementSpeed * DeltaTime;\n\t\tfloat SplineLength = SplineComponent->GetSplineLength();\n\t\tif (CurrentSplineDistance > SplineLength)\n\t\t{\n\t\t\tCurrentSplineDistance = 0.0f;\n\t\t}\n\n\t\tFVector NewLocation = SplineComponent->GetLocationAtDistanceAlongSpline(CurrentSplineDistance, ESplineCoordinateSpace::World);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to spawn multiple Actors in a grid formation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GridSpawner.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AGridSpawner : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAGridSpawner();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Spawning\")\n\tvoid SpawnActorsInGrid(TSubclassOf<AActor> ActorToSpawn, int32 Rows, int32 Columns, float Spacing);\n\nprotected:\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"GridSpawner.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nAGridSpawner::AGridSpawner()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AGridSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AGridSpawner::SpawnActorsInGrid(TSubclassOf<AActor> ActorToSpawn, int32 Rows, int32 Columns, float Spacing)\n{\n\tif (!ActorToSpawn)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"ActorToSpawn is null.\"));\n\t\treturn;\n\t}\n\n\tUWorld* World = GetWorld();\n\tif (!World)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"World is null.\"));\n\t\treturn;\n\t}\n\n\tfor (int32 Row = 0; Row < Rows; ++Row)\n\t{\n\t\tfor (int32 Column = 0; Column < Columns; ++Column)\n\t\t{\n\t\t\tFVector SpawnLocation = GetActorLocation() + FVector(Row * Spacing, Column * Spacing, 0.0f);\n\t\t\tFRotator SpawnRotation = FRotator::ZeroRotator;\n\t\t\tWorld->SpawnActor<AActor>(ActorToSpawn, SpawnLocation, SpawnRotation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a UMG widget that shows a message when the player collects a power-up.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UPlayerPowerUpWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UPlayerPowerUpWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"PowerUp\")\n\tvoid ShowPowerUpMessage();\n};\n```", "cpp_code": "```cpp\n#include \"UPlayerPowerUpWidget.h\"\n\nvoid UPlayerPowerUpWidget::ShowPowerUpMessage()\n{\n\t// This function would be implemented in Blueprint to show the message on screen\n}\n```"}
{"requirement": "Develop a class that triggers an event when the Actor is clicked on.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ClickableActor.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnActorClickedEvent);\n\nUCLASS()\nclass YOURPROJECT_API AClickableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAClickableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(BlueprintAssignable, Category = \"Interaction\")\n\tFOnActorClickedEvent OnActorClicked;\n\n\tUFUNCTION()\n\tvoid ActorClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed);\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ClickableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nAClickableActor::AClickableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->OnClicked.AddDynamic(this, &AClickableActor::ActorClicked);\n\n\t// Example mesh setup (replace with an actual asset path in your project)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AClickableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AClickableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AClickableActor::ActorClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed)\n{\n\tOnActorClicked.Broadcast();\n}\n```"}
{"requirement": "Implement an Actor that uses a timeline to animate its rotation smoothly.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY()\n\tUTimelineComponent* RotationTimeline;\n\n\tUFUNCTION()\n\tvoid HandleRotationProgress(float Value);\n\n\tUPROPERTY(EditAnywhere, Category=\"Timeline\")\n\tUCurveFloat* RotationCurve;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRotationTimeline = CreateDefaultSubobject<UTimelineComponent>(TEXT(\"RotationTimeline\"));\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (RotationCurve)\n\t{\n\t\tFOnTimelineFloat ProgressFunction;\n\t\tProgressFunction.BindUFunction(this, FName(\"HandleRotationProgress\"));\n\t\tRotationTimeline->AddInterpFloat(RotationCurve, ProgressFunction);\n\t\tRotationTimeline->SetLooping(false);\n\t\tRotationTimeline->PlayFromStart();\n\t}\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRotationTimeline->TickComponent(DeltaTime, ELevelTick::LEVELTICK_TimeOnly, nullptr);\n}\n\nvoid ARotatingActor::HandleRotationProgress(float Value)\n{\n\tFRotator NewRotation = FRotator(0.0f, Value, 0.0f);\n\tMeshComponent->SetRelativeRotation(NewRotation);\n}\n```"}
{"requirement": "Create a simple AI Controller to make an AI character patrol a set route.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"APatrolAIController.generated.h\"\n\nUCLASS()\nclass MYGAME_API APatrolAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPatrolAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n\tvirtual void OnPossess(APawn* InPawn) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tTArray<AActor*> PatrolPoints;\n\n\tUFUNCTION()\n\tvoid MoveToNextPatrolPoint();\n\n\tint32 CurrentPatrolPointIndex;\n};\n```", "cpp_code": "```cpp\n#include \"APatrolAIController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"BehaviorTree/BlackboardComponent.h\"\n#include \"GameFramework/Character.h\"\n\nAPatrolAIController::APatrolAIController()\n{\n\tCurrentPatrolPointIndex = 0;\n}\n\nvoid APatrolAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAPawn* ControlledPawn = GetPawn();\n\tif (ControlledPawn)\n\t{\n\t\tMoveToNextPatrolPoint();\n\t}\n}\n\nvoid APatrolAIController::OnPossess(APawn* InPawn)\n{\n\tSuper::OnPossess(InPawn);\n\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), AActor::StaticClass(), PatrolPoints);\n\tMoveToNextPatrolPoint();\n}\n\nvoid APatrolAIController::MoveToNextPatrolPoint()\n{\n\tif (PatrolPoints.Num() == 0) return;\n\n\tMoveToActor(PatrolPoints[CurrentPatrolPointIndex]);\n\n\tCurrentPatrolPointIndex = (CurrentPatrolPointIndex + 1) % PatrolPoints.Num();\n}\n```"}
{"requirement": "Develop a class that logs when the Actor's health is modified.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthLoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AHealthLoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHealthLoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat Health;\n\n\tUFUNCTION()\n\tvoid SetHealth(float NewHealth);\n};\n```", "cpp_code": "```cpp\n#include \"HealthLoggingActor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAHealthLoggingActor::AHealthLoggingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tHealth = 100.0f; // Default health value\n}\n\n// Called when the game starts or when spawned\nvoid AHealthLoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AHealthLoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHealthLoggingActor::SetHealth(float NewHealth)\n{\n\tif (Health != NewHealth)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Health changed from %f to %f\"), Health, NewHealth);\n\t\tHealth = NewHealth;\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION to play a random animation montage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimMontage.h\"\n#include \"RandomAnimMontageActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomAnimMontageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARandomAnimMontageActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Animation\")\n\tvoid PlayRandomAnimMontage();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tTArray<UAnimMontage*> AnimMontages;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"RandomAnimMontageActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Animation/AnimInstance.h\"\n\nARandomAnimMontageActor::ARandomAnimMontageActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ARandomAnimMontageActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARandomAnimMontageActor::PlayRandomAnimMontage()\n{\n\tif (AnimMontages.Num() > 0)\n\t{\n\t\tint32 RandomIndex = FMath::RandRange(0, AnimMontages.Num() - 1);\n\t\tUAnimInstance* AnimInstance = MeshComponent->GetAnimInstance();\n\t\tif (AnimInstance && AnimMontages[RandomIndex])\n\t\t{\n\t\t\tAnimInstance->Montage_Play(AnimMontages[RandomIndex]);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a collision component to apply damage to the player on impact.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DamageActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADamageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADamageActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUSphereComponent* CollisionComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(EditAnywhere)\n\tfloat DamageAmount;\n};\n```", "cpp_code": "```cpp\n#include \"DamageActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/SphereComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/DamageType.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nADamageActor::ADamageActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tCollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"CollisionComponent\"));\n\tCollisionComponent->SetupAttachment(RootComponent);\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ADamageActor::OnOverlapBegin);\n\n\tDamageAmount = 10.0f;  // Default damage amount\n}\n\n// Called when the game starts or when spawned\nvoid ADamageActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADamageActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADamageActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this))\n\t{\n\t\tUGameplayStatics::ApplyDamage(OtherActor, DamageAmount, nullptr, this, UDamageType::StaticClass());\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to lock and unlock the player's movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"PlayerMovementController.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API APlayerMovementController : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPlayerMovementController();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid LockMovement();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid UnlockMovement();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tbool bIsMovementLocked;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerMovementController.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n\nAPlayerMovementController::APlayerMovementController()\n{\n\t// Set default values\n\tbIsMovementLocked = false;\n}\n\nvoid APlayerMovementController::LockMovement()\n{\n\tbIsMovementLocked = true;\n\tif (GetCharacterMovement())\n\t{\n\t\tGetCharacterMovement()->DisableMovement();\n\t}\n}\n\nvoid APlayerMovementController::UnlockMovement()\n{\n\tbIsMovementLocked = false;\n\tif (GetCharacterMovement())\n\t{\n\t\tGetCharacterMovement()->SetMovementMode(MOVE_Walking);\n\t}\n}\n\nvoid APlayerMovementController::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind input actions here\n\t// Example: PlayerInputComponent->BindAction(\"LockMovement\", IE_Pressed, this, &APlayerMovementController::LockMovement);\n\t// Example: PlayerInputComponent->BindAction(\"UnlockMovement\", IE_Pressed, this, &APlayerMovementController::UnlockMovement);\n}\n```"}
{"requirement": "Create an Actor that emits a sparkle effect every few seconds.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SparkleEmitter.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASparkleEmitter : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASparkleEmitter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Timer handle for sparkle emission\n\tFTimerHandle SparkleTimerHandle;\n\n\t// Function to emit sparkle\n\tvoid EmitSparkle();\n\n\t// Delay between sparkle emissions\n\tUPROPERTY(EditAnywhere, Category = \"Sparkle\")\n\tfloat SparkleInterval;\n};\n```", "cpp_code": "```cpp\n#include \"SparkleEmitter.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nASparkleEmitter::ASparkleEmitter()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSparkleInterval = 2.0f; // Default interval of 2 seconds\n}\n\n// Called when the game starts or when spawned\nvoid ASparkleEmitter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Set timer to emit sparkle\n\tGetWorld()->GetTimerManager().SetTimer(SparkleTimerHandle, this, &ASparkleEmitter::EmitSparkle, SparkleInterval, true);\n}\n\n// Called every frame\nvoid ASparkleEmitter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASparkleEmitter::EmitSparkle()\n{\n\tif (GEngine)\n\t{\n\t\t// Log or trigger particle system for sparkle effect\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Sparkle emitted!\"));\n\n\t\t// Example of playing a particle system at the actor's location\n\t\t// Replace \"YourParticleSystem\" with your actual particle system asset\n\t\tUParticleSystem* SparkleEffect = LoadObject<UParticleSystem>(nullptr, TEXT(\"/Game/YourParticleSystem.YourParticleSystem\"));\n\t\tif (SparkleEffect)\n\t\t{\n\t\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), SparkleEffect, GetActorLocation(), GetActorRotation());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Develop a class that changes the Actor's color to match the player's team.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TeamActor.generated.h\"\n\nUCLASS()\nclass ATeamActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATeamActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to change color based on team\n\tUFUNCTION(BlueprintCallable, Category = \"Team\")\n\tvoid ChangeColorToMatchTeam(int32 TeamID);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Team\")\n\tTMap<int32, FLinearColor> TeamColors;\n};\n```", "cpp_code": "```cpp\n#include \"TeamActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nATeamActor::ATeamActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Example Team Colors\n\tTeamColors.Add(1, FLinearColor::Red);\n\tTeamColors.Add(2, FLinearColor::Blue);\n\tTeamColors.Add(3, FLinearColor::Green);\n}\n\n// Called when the game starts or when spawned\nvoid ATeamActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATeamActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATeamActor::ChangeColorToMatchTeam(int32 TeamID)\n{\n\tif(TeamColors.Contains(TeamID))\n\t{\n\t\tFLinearColor* Color = TeamColors.Find(TeamID);\n\t\tif (Color)\n\t\t{\n\t\t\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"BaseColor\"), Color->ToFVector());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a UMG button widget that toggles the game's music on and off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UMusicToggleWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UUMusicToggleWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Music\")\n\tvoid ToggleMusic();\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tbool bIsMusicPlaying;\n};\n```", "cpp_code": "```cpp\n#include \"UMusicToggleWidget.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nvoid UUMusicToggleWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\tbIsMusicPlaying = true;\n}\n\nvoid UUMusicToggleWidget::ToggleMusic()\n{\n\tif (bIsMusicPlaying)\n\t{\n\t\tUGameplayStatics::SetGlobalTimeDilation(GetWorld(), 0.0f);\n\t}\n\telse\n\t{\n\t\tUGameplayStatics::SetGlobalTimeDilation(GetWorld(), 1.0f);\n\t}\n\tbIsMusicPlaying = !bIsMusicPlaying;\n}\n```"}
{"requirement": "Create an Actor that moves to a target location when spawned.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector TargetLocation;\n\tfloat MoveSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tTargetLocation = FVector(1000.f, 0.f, 0.f); // Example target location\n\tMoveSpeed = 100.f; // Movement speed in units per second\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentLocation = GetActorLocation();\n\tFVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n\tFVector NewLocation = CurrentLocation + Direction * MoveSpeed * DeltaTime;\n\n\tSetActorLocation(NewLocation);\n\n\t// Optionally check if the actor is close enough to the target to stop moving\n\tif (FVector::Dist(CurrentLocation, TargetLocation) < KINDA_SMALL_NUMBER)\n\t{\n\t\t// Stop moving or perform any action you need\n\t}\n}\n```"}
{"requirement": "Implement a simple networking function to replicate an Actor's visibility toggle.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"VisibilityToggleActor.generated.h\"\n\nUCLASS()\nclass AVisibilityToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAVisibilityToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visibility\")\n\tvoid ToggleVisibility();\n\n\tUFUNCTION(Server, Reliable, WithValidation)\n\tvoid ServerToggleVisibility();\n\n\tUFUNCTION()\n\tvoid OnRep_VisibilityChanged();\n\n\tUPROPERTY(ReplicatedUsing=OnRep_VisibilityChanged)\n\tbool bIsVisible;\n\n\tvoid GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n};\n```", "cpp_code": "```cpp\n#include \"VisibilityToggleActor.h\"\n#include \"Net/UnrealNetwork.h\"\n\nAVisibilityToggleActor::AVisibilityToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsVisible = true;\n\tSetReplicates(true);\n}\n\nvoid AVisibilityToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AVisibilityToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AVisibilityToggleActor::ToggleVisibility()\n{\n\tif (HasAuthority())\n\t{\n\t\tbIsVisible = !bIsVisible;\n\t\tOnRep_VisibilityChanged();\n\t}\n\telse\n\t{\n\t\tServerToggleVisibility();\n\t}\n}\n\nvoid AVisibilityToggleActor::ServerToggleVisibility_Implementation()\n{\n\tToggleVisibility();\n}\n\nbool AVisibilityToggleActor::ServerToggleVisibility_Validate()\n{\n\treturn true;\n}\n\nvoid AVisibilityToggleActor::OnRep_VisibilityChanged()\n{\n\tSetActorHiddenInGame(!bIsVisible);\n}\n\nvoid AVisibilityToggleActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AVisibilityToggleActor, bIsVisible);\n}\n```"}
{"requirement": "Create a class that spawns a shield Actor around the player on command.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ShieldSpawner.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AShieldSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAShieldSpawner();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Shield\")\n\tvoid SpawnShield();\n\nprivate:\n\tUPROPERTY(EditDefaultsOnly, Category=\"Shield\")\n\tTSubclassOf<AActor> ShieldClass;\n};\n```", "cpp_code": "```cpp\n#include \"ShieldSpawner.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Character.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAShieldSpawner::AShieldSpawner()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tstatic ConstructorHelpers::FClassFinder<AActor> ShieldBPClass(TEXT(\"/Game/Blueprints/ShieldBP\"));\n\tif (ShieldBPClass.Class != nullptr)\n\t{\n\t\tShieldClass = ShieldBPClass.Class;\n\t}\n}\n\nvoid AShieldSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AShieldSpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AShieldSpawner::SpawnShield()\n{\n\tif (ShieldClass != nullptr)\n\t{\n\t\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\t\tif (PlayerController != nullptr)\n\t\t{\n\t\t\tACharacter* PlayerCharacter = Cast<ACharacter>(PlayerController->GetPawn());\n\t\t\tif (PlayerCharacter != nullptr)\n\t\t\t{\n\t\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\t\tSpawnParams.Owner = this;\n\t\t\t\tFVector SpawnLocation = PlayerCharacter->GetActorLocation();\n\t\t\t\tFRotator SpawnRotation = PlayerCharacter->GetActorRotation();\n\t\t\t\tGetWorld()->SpawnActor<AActor>(ShieldClass, SpawnLocation, SpawnRotation, SpawnParams);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Develop an Actor with a timeline to animate the Actor's scale from small to large.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY()\n\tUTimelineComponent* ScaleTimeline;\n\n\tUFUNCTION()\n\tvoid HandleScaling(float Value);\n\n\tFOnTimelineFloat InterpFunction{};\n\n\tUPROPERTY(EditAnywhere, Category = \"Timeline\")\n\tUCurveFloat* ScaleCurve;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n#include \"Curves/CurveFloat.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tScaleTimeline = CreateDefaultSubobject<UTimelineComponent>(TEXT(\"ScaleTimeline\"));\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (ScaleCurve)\n\t{\n\t\tInterpFunction.BindUFunction(this, FName(\"HandleScaling\"));\n\t\tScaleTimeline->AddInterpFloat(ScaleCurve, InterpFunction);\n\t\tScaleTimeline->SetLooping(false);\n\t\tScaleTimeline->PlayFromStart();\n\t}\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (ScaleTimeline)\n\t{\n\t\tScaleTimeline->TickComponent(DeltaTime, ELevelTick::LEVELTICK_TimeOnly, nullptr);\n\t}\n}\n\nvoid AScalingActor::HandleScaling(float Value)\n{\n\tFVector NewScale = FMath::Lerp(FVector(0.1f, 0.1f, 0.1f), FVector(1.0f, 1.0f, 1.0f), Value);\n\tMeshComponent->SetWorldScale3D(NewScale);\n}\n```"}
{"requirement": "Implement a UFUNCTION to teleport the player to a safe zone.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TeleportPlayer.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ATeleportPlayer : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATeleportPlayer();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Teleportation\")\n\tvoid TeleportToSafeZone();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Teleportation\")\n\tFVector SafeZoneLocation;\n};\n```", "cpp_code": "```cpp\n#include \"TeleportPlayer.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nATeleportPlayer::ATeleportPlayer()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSafeZoneLocation = FVector(0.0f, 0.0f, 0.0f); // Default SafeZone location\n}\n\nvoid ATeleportPlayer::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATeleportPlayer::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATeleportPlayer::TeleportToSafeZone()\n{\n\tAActor* PlayerActor = UGameplayStatics::GetPlayerPawn(this, 0);\n\tif (PlayerActor)\n\t{\n\t\tPlayerActor->SetActorLocation(SafeZoneLocation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh that plays a sound when touched.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnMeshBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* TouchSound;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/EngineTypes.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyActor::OnMeshBeginOverlap);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyActor::OnMeshBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (TouchSound && OtherActor != this)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, TouchSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Develop a class that logs when the Actor enters a danger zone.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DangerZoneLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADangerZoneLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tADangerZoneLogger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor,\n\t\t\t\t\t\tclass UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,\n\t\t\t\t\t\tbool bFromSweep, const FHitResult & SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* DangerZoneTrigger;\n};\n```", "cpp_code": "```cpp\n#include \"DangerZoneLogger.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nADangerZoneLogger::ADangerZoneLogger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set up the danger zone trigger box\n\tDangerZoneTrigger = CreateDefaultSubobject<UBoxComponent>(TEXT(\"DangerZoneTrigger\"));\n\tRootComponent = DangerZoneTrigger;\n\n\tDangerZoneTrigger->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tDangerZoneTrigger->SetCollisionObjectType(ECollisionChannel::ECC_WorldStatic);\n\tDangerZoneTrigger->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap);\n\n\tDangerZoneTrigger->OnComponentBeginOverlap.AddDynamic(this, &ADangerZoneLogger::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ADangerZoneLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADangerZoneLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADangerZoneLogger::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor,\n\t\t\t\t\t\t\t\t\t   UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,\n\t\t\t\t\t\t\t\t\t   bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s has entered the danger zone!\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to increase the player's jump height temporarily.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"PlayerCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APlayerCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPlayerCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Character|Movement\")\n\tvoid IncreaseJumpHeight(float Multiplier, float Duration);\n\nprivate:\n\tFTimerHandle JumpHeightTimerHandle;\n\tfloat OriginalJumpZVelocity;\n\n\tvoid ResetJumpHeight();\n};\n```", "cpp_code": "```cpp\n#include \"PlayerCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"TimerManager.h\"\n\nAPlayerCharacter::APlayerCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APlayerCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tOriginalJumpZVelocity = GetCharacterMovement()->JumpZVelocity;\n}\n\nvoid APlayerCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APlayerCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\nvoid APlayerCharacter::IncreaseJumpHeight(float Multiplier, float Duration)\n{\n\tif (Multiplier > 0.0f && Duration > 0.0f)\n\t{\n\t\tGetCharacterMovement()->JumpZVelocity = OriginalJumpZVelocity * Multiplier;\n\t\tGetWorldTimerManager().SetTimer(JumpHeightTimerHandle, this, &APlayerCharacter::ResetJumpHeight, Duration, false);\n\t}\n}\n\nvoid APlayerCharacter::ResetJumpHeight()\n{\n\tGetCharacterMovement()->JumpZVelocity = OriginalJumpZVelocity;\n}\n```"}
{"requirement": "Create a UMG widget that shows the player's remaining lives.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"ULivesWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ULivesWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tULivesWidget(const FObjectInitializer& ObjectInitializer);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Lives\")\n\tvoid UpdateLives(int32 NewLives);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\n\tUPROPERTY(BlueprintReadOnly, meta=(BindWidget))\n\tclass UTextBlock* LivesText;\n};\n```", "cpp_code": "```cpp\n#include \"ULivesWidget.h\"\n#include \"Components/TextBlock.h\"\n\nULivesWidget::ULivesWidget(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)\n{\n}\n\nvoid ULivesWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\t// Example initialization if needed\n\tUpdateLives(3); // Assume player starts with 3 lives\n}\n\nvoid ULivesWidget::UpdateLives(int32 NewLives)\n{\n\tif (LivesText)\n\t{\n\t\tLivesText->SetText(FText::FromString(FString::Printf(TEXT(\"Lives: %d\"), NewLives)));\n\t}\n}\n```"}
{"requirement": "Implement a class to change the Actor's material to a glowing texture.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AGlowingMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AGlowingMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAGlowingMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Material\")\n\tvoid SetGlowingMaterial();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Material\")\n\tUMaterialInterface* GlowingMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"AGlowingMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAGlowingMaterialActor::AGlowingMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialAsset(TEXT(\"/Game/Path/To/Your/GlowingMaterial.GlowingMaterial\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tGlowingMaterial = MaterialAsset.Object;\n\t}\n}\n\nvoid AGlowingMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetGlowingMaterial();\n}\n\nvoid AGlowingMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AGlowingMaterialActor::SetGlowingMaterial()\n{\n\tif (GlowingMaterial && MeshComponent)\n\t{\n\t\tMeshComponent->SetMaterial(0, GlowingMaterial);\n\t}\n}\n```"}
{"requirement": "Create an Actor that plays an animation on receiving damage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"DamageableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ADamageableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADamageableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle damage\n\tUFUNCTION()\n\tvoid ReceiveDamage(float DamageAmount);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta=(AllowPrivateAccess=\"true\"))\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tUAnimSequence* DamageAnimation;\n\n\tUFUNCTION()\n\tvoid PlayDamageAnimation();\n};\n```", "cpp_code": "```cpp\n#include \"DamageableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Animation/AnimSequence.h\"\n\n// Sets default values\nADamageableActor::ADamageableActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize MeshComponent\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Optionally set a default mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Optionally set a default animation\n\tstatic ConstructorHelpers::FObjectFinder<UAnimSequence> AnimAsset(TEXT(\"/Game/Path/To/Your/Animation.Animation\"));\n\tif (AnimAsset.Succeeded())\n\t{\n\t\tDamageAnimation = AnimAsset.Object;\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ADamageableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADamageableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADamageableActor::ReceiveDamage(float DamageAmount)\n{\n\t// Logic to handle damage can be added here\n\n\t// Play damage animation\n\tPlayDamageAnimation();\n}\n\nvoid ADamageableActor::PlayDamageAnimation()\n{\n\tif (DamageAnimation && MeshComponent)\n\t{\n\t\tMeshComponent->PlayAnimation(DamageAnimation, false);\n\t}\n}\n```"}
{"requirement": "Develop a simple AI Controller to make an AI character circle the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"AICirclePlayerController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAICirclePlayerController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAICirclePlayerController();\n\t\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAPawn* PlayerPawn;\n\tfloat CircleRadius;\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"AICirclePlayerController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAAICirclePlayerController::AAICirclePlayerController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCircleRadius = 300.0f;\n\tRotationSpeed = 50.0f;\n}\n\nvoid AAICirclePlayerController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid AAICirclePlayerController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerPawn)\n\t{\n\t\tAPawn* ControlledPawn = GetPawn();\n\t\tif (ControlledPawn)\n\t\t{\n\t\t\tFVector DirectionToPlayer = ControlledPawn->GetActorLocation() - PlayerPawn->GetActorLocation();\n\t\t\tDirectionToPlayer.Z = 0.0f; // Keep it in the horizontal plane\n\t\t\tDirectionToPlayer.Normalize();\n\n\t\t\tFVector PerpendicularDirection = FVector::CrossProduct(DirectionToPlayer, FVector::UpVector);\n\t\t\tFVector NewLocation = PlayerPawn->GetActorLocation() + DirectionToPlayer * CircleRadius;\n\t\t\tNewLocation += PerpendicularDirection * FMath::Sin(GetWorld()->TimeSeconds * RotationSpeed);\n\n\t\t\tControlledPawn->SetActorLocation(NewLocation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement an Actor that changes its size based on the player's distance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceBasedSizeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceBasedSizeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADistanceBasedSizeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Size\")\n\tfloat MinScale;\n\n\tUPROPERTY(EditAnywhere, Category = \"Size\")\n\tfloat MaxScale;\n\n\tUPROPERTY(EditAnywhere, Category = \"Size\")\n\tfloat DistanceThreshold;\n\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"DistanceBasedSizeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nADistanceBasedSizeActor::ADistanceBasedSizeActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMinScale = 0.5f;\n\tMaxScale = 2.0f;\n\tDistanceThreshold = 1000.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ADistanceBasedSizeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\n// Called every frame\nvoid ADistanceBasedSizeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerActor)\n\t{\n\t\tfloat Distance = FVector::Dist(PlayerActor->GetActorLocation(), GetActorLocation());\n\t\tfloat ScaleFactor = FMath::Clamp(Distance / DistanceThreshold, MinScale, MaxScale);\n\n\t\tSetActorScale3D(FVector(ScaleFactor));\n\t}\n}\n```"}
