{"requirement": "Create an Actor class with a static mesh component using ConstructorHelpers to load a cube mesh asset.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CubeMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACubeMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACubeMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* CubeMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CubeMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACubeMeshActor::ACubeMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the static mesh component\n\tCubeMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"CubeMeshComponent\"));\n\tRootComponent = CubeMeshComponent;\n\n\t// Find and set the cube mesh asset\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> CubeMeshAsset(TEXT(\"/Game/Path/To/Your/CubeMesh.CubeMesh\"));\n\tif (CubeMeshAsset.Succeeded())\n\t{\n\t\tCubeMeshComponent->SetStaticMesh(CubeMeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ACubeMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n}\n\n// Called every frame\nvoid ACubeMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that moves the Actor upward by 10 units per second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMovingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyMovingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"MyMovingActor.h\"\n\n// Sets default values\nAMyMovingActor::AMyMovingActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation();\n\tNewLocation.Z += 10.0f * DeltaTime; // Move up by 10 units per second\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float variable to store health, with metadata to allow editing in the editor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHealthActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat Health;\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n\n// Sets default values\nAHealthActor::AHealthActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize health\n\tHealth = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent method in an Actor to bind the 'Jump' action to a function that logs a message.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AJumpLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AJumpLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAJumpLogger();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid LogJumpMessage();\n};\n```", "cpp_code": "```cpp\n#include \"AJumpLogger.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nAJumpLogger::AJumpLogger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AJumpLogger::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, &AJumpLogger::LogJumpMessage);\n\t}\n}\n\nvoid AJumpLogger::LogJumpMessage()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Jump action triggered!\"));\n\t}\n}\n```"}
{"requirement": "Create a simple custom Component class with a UPROPERTY integer that counts the number of ticks since the game started.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TickCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UTickCounterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUTickCounterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintReadOnly, VisibleAnywhere, Category=\"TickCounter\")\n\tint32 TickCount;\n};\n```", "cpp_code": "```cpp\n#include \"TickCounterComponent.h\"\n\nUTickCounterComponent::UTickCounterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTickCount = 0;\n}\n\nvoid UTickCounterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UTickCounterComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\t\n\tTickCount++;\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that returns the current location of the Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALocationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALocationActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Location\")\n\tFVector GetCurrentLocation() const;\n};\n```", "cpp_code": "```cpp\n#include \"LocationActor.h\"\n\n// Sets default values\nALocationActor::ALocationActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nFVector ALocationActor::GetCurrentLocation() const\n{\n\treturn GetActorLocation();\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in an Actor that broadcasts a message when the Actor is destroyed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyDestroyableActor.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnActorDestroyed);\n\nUCLASS()\nclass MYPROJECT_API AMyDestroyableActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMyDestroyableActor();\n\n\t// BlueprintAssignable delegate to broadcast when actor is destroyed\n\tUPROPERTY(BlueprintAssignable, Category=\"Events\")\n\tFOnActorDestroyed OnActorDestroyed;\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\t\n\t// Called when the actor is being destroyed\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n};\n```", "cpp_code": "```cpp\n#include \"MyDestroyableActor.h\"\n\n// Sets default values\nAMyDestroyableActor::AMyDestroyableActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyDestroyableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyDestroyableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called when the actor is being destroyed\nvoid AMyDestroyableActor::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\t\n\tif(EndPlayReason == EEndPlayReason::Destroyed)\n\t{\n\t\tOnActorDestroyed.Broadcast();\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that scales the Actor's mesh over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat ScalingFactor;\n\n\tFVector InitialScale;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tScalingFactor = 1.0f;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialScale = MeshComponent->GetComponentScale();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat ScaleIncrement = DeltaTime * ScalingFactor;\n\tFVector NewScale = InitialScale * (1.0f + ScaleIncrement);\n\tMeshComponent->SetWorldScale3D(NewScale);\n}\n```"}
{"requirement": "Create an Actor that logs a message to the console every time it overlaps with another Actor using OnBeginOverlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAOverlapLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLoggerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAOverlapLoggerActor::AOverlapLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapLoggerActor::OnOverlapBegin);\n}\n\nvoid AOverlapLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapLoggerActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlapped with: %s\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Use ConstructorHelpers to load a texture asset in an Actor and apply it to a material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TextureMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tATextureMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInstanceDynamic* DynamicMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"TextureMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nATextureMaterialActor::ATextureMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UTexture> TextureAsset(TEXT(\"/Game/Path/To/Your/Texture.Texture\"));\n\tif (TextureAsset.Succeeded())\n\t{\n\t\tUMaterialInterface* Material = StaticMeshComponent->GetMaterial(0);\n\t\tDynamicMaterial = UMaterialInstanceDynamic::Create(Material, this);\n\t\tDynamicMaterial->SetTextureParameterValue(\"TextureParameterName\", TextureAsset.Object);\n\t\tStaticMeshComponent->SetMaterial(0, DynamicMaterial);\n\t}\n}\n\nvoid ATextureMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATextureMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a custom Component that changes the color of its owning Actor every second using the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UColorChangeComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UColorChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUColorChangeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFLinearColor CurrentColor;\n\tfloat TimeAccumulator;\n};\n```", "cpp_code": "```cpp\n#include \"UColorChangeComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nUColorChangeComponent::UColorChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTimeAccumulator = 0.0f;\n}\n\nvoid UColorChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Initialize the color\n\tCurrentColor = FLinearColor::MakeRandomColor();\n\n\t// Change the actor's color initially\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tUStaticMeshComponent* MeshComp = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComp)\n\t\t{\n\t\t\tUMaterialInstanceDynamic* DynMaterial = MeshComp->CreateAndSetMaterialInstanceDynamic(0);\n\t\t\tif (DynMaterial)\n\t\t\t{\n\t\t\t\tDynMaterial->SetVectorParameterValue(\"Color\", CurrentColor);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid UColorChangeComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTimeAccumulator += DeltaTime;\n\n\tif (TimeAccumulator >= 1.0f)\n\t{\n\t\tTimeAccumulator = 0.0f;\n\t\tCurrentColor = FLinearColor::MakeRandomColor();\n\n\t\tif (AActor* Owner = GetOwner())\n\t\t{\n\t\t\tUStaticMeshComponent* MeshComp = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t\t\tif (MeshComp)\n\t\t\t{\n\t\t\t\tUMaterialInstanceDynamic* DynMaterial = MeshComp->CreateAndSetMaterialInstanceDynamic(0);\n\t\t\t\tif (DynMaterial)\n\t\t\t\t{\n\t\t\t\t\tDynMaterial->SetVectorParameterValue(\"Color\", CurrentColor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement SetupPlayerInputComponent to bind an input to increase a UPROPERTY float speed variable in an Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"IncreaseSpeedActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AIncreaseSpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAIncreaseSpeedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat Speed;\n\n\tvoid IncreaseSpeed();\n};\n```", "cpp_code": "```cpp\n#include \"IncreaseSpeedActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nAIncreaseSpeedActor::AIncreaseSpeedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSpeed = 0.0f;\n}\n\nvoid AIncreaseSpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AIncreaseSpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AIncreaseSpeedActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"IncreaseSpeed\", IE_Pressed, this, &AIncreaseSpeedActor::IncreaseSpeed);\n}\n\nvoid AIncreaseSpeedActor::IncreaseSpeed()\n{\n\tSpeed += 10.0f;\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY for a material and a BlueprintCallable function to change its material at runtime.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMaterialChangerActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyMaterialChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyMaterialChangerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Material\")\n\tUMaterialInterface* Material;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Material\")\n\tvoid ChangeMaterial(UMaterialInterface* NewMaterial);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyMaterialChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyMaterialChangerActor::AMyMaterialChangerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Optionally set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyMaterialChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyMaterialChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyMaterialChangerActor::ChangeMaterial(UMaterialInterface* NewMaterial)\n{\n\tif (NewMaterial && MeshComponent)\n\t{\n\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t\tMaterial = NewMaterial;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in a Component to rotate its parent Actor around the Y-axis continually.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"URotatingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API URotatingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tURotatingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"URotatingComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nURotatingComponent::URotatingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tRotationSpeed = 45.0f; // Degrees per second\n}\n\nvoid URotatingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotatingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFRotator NewRotation = Owner->GetActorRotation();\n\t\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\t\tOwner->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh and set its collision to trigger a log message on overlap using OnBeginOverlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACollisionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"Engine/World.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nACollisionActor::ACollisionActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tMeshComponent->SetCollisionObjectType(ECollisionChannel::ECC_WorldDynamic);\n\tMeshComponent->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap);\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ACollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlap Begin with %s\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Implement a simple UPROPERTY boolean in an Actor to toggle visibility, with metadata to show in editor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyVisibilityToggleActor.generated.h\"\n\nUCLASS()\nclass AMyVisibilityToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyVisibilityToggleActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Visibility\")\n\tbool bIsVisible;\n\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"MyVisibilityToggleActor.h\"\n\nAMyVisibilityToggleActor::AMyVisibilityToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsVisible = true;\n}\n\nvoid AMyVisibilityToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tSetActorHiddenInGame(!bIsVisible);\n}\n```"}
{"requirement": "Create an Actor with a tick-based behavior that oscillates its scale between two values.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OscillatingScaleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOscillatingScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOscillatingScaleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Oscillation\")\n\tFVector MinScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Oscillation\")\n\tFVector MaxScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Oscillation\")\n\tfloat OscillationSpeed;\n\n\tfloat TimeAccumulator;\n};\n```", "cpp_code": "```cpp\n#include \"OscillatingScaleActor.h\"\n\nAOscillatingScaleActor::AOscillatingScaleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMinScale = FVector(1.0f, 1.0f, 1.0f);\n\tMaxScale = FVector(2.0f, 2.0f, 2.0f);\n\tOscillationSpeed = 1.0f;\n\tTimeAccumulator = 0.0f;\n}\n\nvoid AOscillatingScaleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOscillatingScaleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeAccumulator += DeltaTime * OscillationSpeed;\n\tfloat ScaleFactor = (FMath::Sin(TimeAccumulator) + 1.0f) / 2.0f; // Scales between 0 and 1\n\tFVector NewScale = FMath::Lerp(MinScale, MaxScale, ScaleFactor);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Set up an input binding in an Actor to toggle a debug message on and off whenever the 'C' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ADebugToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADebugToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADebugToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid ToggleDebugMessage();\n\n\tbool bIsDebugMessageVisible;\n};\n```", "cpp_code": "```cpp\n#include \"ADebugToggleActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nADebugToggleActor::ADebugToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsDebugMessageVisible = false;\n}\n\nvoid ADebugToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADebugToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADebugToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ToggleDebugMessage\", IE_Pressed, this, &ADebugToggleActor::ToggleDebugMessage);\n}\n\nvoid ADebugToggleActor::ToggleDebugMessage()\n{\n\tbIsDebugMessageVisible = !bIsDebugMessageVisible;\n\tif (bIsDebugMessageVisible)\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Debug Message ON\"));\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Debug Message OFF\"));\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that triggers when a specific function is called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UCustomComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnCustomFunctionCalled);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UUCustomComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUUCustomComponent();\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Custom\")\n\tFOnCustomFunctionCalled OnCustomFunctionCalled;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Custom\")\n\tvoid CustomFunction();\n};\n```", "cpp_code": "```cpp\n#include \"UCustomComponent.h\"\n\nUUCustomComponent::UUCustomComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UUCustomComponent::CustomFunction()\n{\n\t// Logic for the function\n\n\t// Trigger the delegate\n\tOnCustomFunctionCalled.Broadcast();\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor class to load a sound and play it when the Actor begins play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Sound/SoundWave.h\"\n#include \"Sound/SoundAttenuation.h\"\n#include \"ASoundPlayingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASoundPlayingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"ASoundPlayingActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"ConstructorHelpers.h\"\n\nASoundPlayingActor::ASoundPlayingActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tstatic ConstructorHelpers::FObjectFinder<USoundCue> SoundCueObj(TEXT(\"/Game/Audio/YourSoundCue.YourSoundCue\"));\n\tif (SoundCueObj.Succeeded())\n\t{\n\t\tSoundToPlay = SoundCueObj.Object;\n\t}\n}\n\nvoid ASoundPlayingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UFUNCTION that logs the Actor's transform when called from a Blueprint.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tALoggingActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Logging\")\n\tvoid LogActorTransform();\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\nALoggingActor::ALoggingActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALoggingActor::LogActorTransform()\n{\n\tFTransform ActorTransform = GetActorTransform();\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Location: %s, Rotation: %s, Scale: %s\"),\n\t\t\t*ActorTransform.GetLocation().ToString(),\n\t\t\t*ActorTransform.GetRotation().Rotator().ToString(),\n\t\t\t*ActorTransform.GetScale3D().ToString()));\n\t}\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor Transform - Location: %s, Rotation: %s, Scale: %s\"),\n\t\t*ActorTransform.GetLocation().ToString(),\n\t\t*ActorTransform.GetRotation().Rotator().ToString(),\n\t\t*ActorTransform.GetScale3D().ToString());\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that moves the Actor in a circular pattern over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CircularMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACircularMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACircularMovementActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat Radius;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat Speed;\n\n\tfloat CurrentAngle;\n};\n```", "cpp_code": "```cpp\n#include \"CircularMovementActor.h\"\n\nACircularMovementActor::ACircularMovementActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRadius = 100.0f;\n\tSpeed = 50.0f;\n\tCurrentAngle = 0.0f;\n}\n\nvoid ACircularMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACircularMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tCurrentAngle += Speed * DeltaTime;\n\tif (CurrentAngle >= 360.0f)\n\t{\n\t\tCurrentAngle -= 360.0f;\n\t}\n\t\n\tfloat RadAngle = FMath::DegreesToRadians(CurrentAngle);\n\tFVector NewLocation = FVector(FMath::Cos(RadAngle) * Radius, FMath::Sin(RadAngle) * Radius, GetActorLocation().Z);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector that represents a velocity, and move the owning Actor by this velocity every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UVelocityComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UVelocityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUVelocityComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector Velocity;\n};\n```", "cpp_code": "```cpp\n#include \"UVelocityComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUVelocityComponent::UVelocityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tVelocity = FVector::ZeroVector;\n}\n\nvoid UVelocityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UVelocityComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->AddActorWorldOffset(Velocity * DeltaTime);\n\t}\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor that reduces an integer UPROPERTY health when it collides with another Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Health\")\n\tint32 Health;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapActor::AOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tUBoxComponent* BoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tBoxComponent->SetupAttachment(MeshComponent);\n\tBoxComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n\n\tHealth = 100; // Default health value\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tHealth -= 10; // Reduce health by 10 or any other value when overlap begins\n\t}\n}\n```"}
{"requirement": "Create an Actor with a mesh and set up collision to print a message when an overlap begins.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"MyMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\nAMyMeshActor::AMyMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyMeshActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AMyMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyMeshActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Overlap Begin\"));\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a function in an Actor to toggle a UPROPERTY boolean, and bind this function to a key press in SetupPlayerInputComponent.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid ToggleBoolean();\n\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Toggle\")\n\tbool bIsToggled;\n\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAToggleActor::AToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsToggled = false;\n}\n\nvoid AToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleActor::ToggleBoolean()\n{\n\tbIsToggled = !bIsToggled;\n}\n\nvoid AToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"ToggleKey\", IE_Pressed, this, &AToggleActor::ToggleBoolean);\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector that updates to match its owner Actor's location each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULocationSyncComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULocationSyncComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tULocationSyncComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Location\", meta=(AllowPrivateAccess = \"true\"))\n\tFVector OwnerLocation;\n};\n```", "cpp_code": "```cpp\n#include \"ULocationSyncComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nULocationSyncComponent::ULocationSyncComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid ULocationSyncComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tOwnerLocation = GetOwner()->GetActorLocation();\n}\n\nvoid ULocationSyncComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tOwnerLocation = GetOwner()->GetActorLocation();\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that gradually changes the Actor's color over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAColorChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tFLinearColor CurrentColor;\n\tfloat ColorChangeSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAColorChangingActor::AColorChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tCurrentColor = FLinearColor::Red;\n\tColorChangeSpeed = 0.1f;\n}\n\nvoid AColorChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AColorChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tCurrentColor = CurrentColor.LinearRGBToHSV();\n\tCurrentColor.R += DeltaTime * ColorChangeSpeed; // Adjust the hue over time\n\tif (CurrentColor.R > 1.0f)\n\t{\n\t\tCurrentColor.R = 0.0f;\n\t}\n\n\tCurrentColor = CurrentColor.HSVToLinearRGB();\n\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"BaseColor\"), FVector(CurrentColor));\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that resets the Actor's location to the origin.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetLocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetLocationActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAResetLocationActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Actor\")\n\tvoid ResetLocationToOrigin();\n};\n```", "cpp_code": "```cpp\n#include \"ResetLocationActor.h\"\n\n// Sets default values\nAResetLocationActor::AResetLocationActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetLocationActor::ResetLocationToOrigin()\n{\n\tSetActorLocation(FVector::ZeroVector);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in an Actor to trigger when a specific input is detected.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InputDelegateActor.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInputDetected);\n\nUCLASS()\nclass YOURPROJECT_API AInputDelegateActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAInputDelegateActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUPROPERTY(BlueprintAssignable, Category = \"Input\")\n\tFOnInputDetected OnInputDetected;\n\nprivate:\n\tvoid DetectInput();\n};\n```", "cpp_code": "```cpp\n#include \"InputDelegateActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAInputDelegateActor::AInputDelegateActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AInputDelegateActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AInputDelegateActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"DetectInputAction\", IE_Pressed, this, &AInputDelegateActor::DetectInput);\n}\n\nvoid AInputDelegateActor::DetectInput()\n{\n\tOnInputDetected.Broadcast();\n}\n```"}
{"requirement": "Use ConstructorHelpers to load a skeletal mesh in an Actor's constructor and attach it to the root component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ASkeletalMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AASkeletalMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAASkeletalMeshActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ASkeletalMeshActor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAASkeletalMeshActor::AASkeletalMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<USkeletalMesh> SkeletalMeshAsset(TEXT(\"/Game/Path/To/Your/SkeletalMesh.SkeletalMesh\"));\n\tif (SkeletalMeshAsset.Succeeded())\n\t{\n\t\tSkeletalMeshComponent->SetSkeletalMesh(SkeletalMeshAsset.Object);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY for an integer score, and reset it to zero in a BlueprintCallable function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScoreActor();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Score\")\n\tint32 Score;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid ResetScore();\n};\n```", "cpp_code": "```cpp\n#include \"ScoreActor.h\"\n\nAScoreActor::AScoreActor()\n{\n\t// Set default score\n\tScore = 0;\n}\n\nvoid AScoreActor::ResetScore()\n{\n\tScore = 0;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that bounces the Actor up and down along the Z-axis.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BouncingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ABouncingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tABouncingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Bouncing\")\n\tfloat BounceHeight;\n\n\tUPROPERTY(EditAnywhere, Category=\"Bouncing\")\n\tfloat BounceSpeed;\n\n\tfloat RunningTime;\n};\n```", "cpp_code": "```cpp\n#include \"BouncingActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nABouncingActor::ABouncingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tBounceHeight = 100.0f;\n\tBounceSpeed = 1.0f;\n\tRunningTime = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ABouncingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ABouncingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation();\n\tfloat DeltaHeight = FMath::Sin(RunningTime + DeltaTime * BounceSpeed) - FMath::Sin(RunningTime);\n\tNewLocation.Z += DeltaHeight * BounceHeight;\n\tRunningTime += DeltaTime * BounceSpeed;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a Component that executes a custom event every 5 seconds using the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UTimerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTimerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUTimerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tvoid CustomEvent();\n\tfloat TimeAccumulator;\n\tconst float EventInterval = 5.0f;\n};\n```", "cpp_code": "```cpp\n#include \"UTimerComponent.h\"\n\nUTimerComponent::UTimerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTimeAccumulator = 0.0f;\n}\n\nvoid UTimerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UTimerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTimeAccumulator += DeltaTime;\n\tif (TimeAccumulator >= EventInterval)\n\t{\n\t\tCustomEvent();\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n\nvoid UTimerComponent::CustomEvent()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Custom Event Executed\"));\n}\n```"}
{"requirement": "Set up input binding in an Actor to rotate it left and right using the 'A' and 'D' keys.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotateActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotateActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotateActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Input bindings\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed;\n\n\tvoid RotateLeft();\n\tvoid RotateRight();\n};\n```", "cpp_code": "```cpp\n#include \"RotateActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nARotateActor::ARotateActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ARotateActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotateActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid ARotateActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"RotateLeft\", IE_Pressed, this, &ARotateActor::RotateLeft);\n\tPlayerInputComponent->BindAction(\"RotateRight\", IE_Pressed, this, &ARotateActor::RotateRight);\n}\n\nvoid ARotateActor::RotateLeft()\n{\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw -= RotationSpeed * GetWorld()->GetDeltaSeconds();\n\tSetActorRotation(NewRotation);\n}\n\nvoid ARotateActor::RotateRight()\n{\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * GetWorld()->GetDeltaSeconds();\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY FString and a BlueprintCallable function to change its value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MyCategory\")\n\tFString MyString;\n\n\tUFUNCTION(BlueprintCallable, Category=\"MyCategory\")\n\tvoid SetMyString(const FString& NewString);\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::SetMyString(const FString& NewString)\n{\n\tMyString = NewString;\n}\n```"}
{"requirement": "Implement an OnBeginOverlap in an Actor that logs the name of the other Actor it collides with.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACollisionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION()\n\tvoid OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"ConstructorHelpers.h\"\n\nACollisionActor::ACollisionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionActor::OnBeginOverlap);\n}\n\nvoid ACollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionActor::OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor)\n\t{\n\t\tFString OtherActorName = OtherActor->GetName();\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlapped with actor: %s\"), *OtherActorName);\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY boolean that toggles every second using the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UToggleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UUToggleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUUToggleComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Toggle\", meta=(AllowPrivateAccess = \"true\"))\n\tbool bIsToggled;\n\n\tfloat TimeAccumulator;\n};\n```", "cpp_code": "```cpp\n#include \"UToggleComponent.h\"\n\nUUToggleComponent::UUToggleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tbIsToggled = false;\n\tTimeAccumulator = 0.0f;\n}\n\nvoid UUToggleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UUToggleComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTimeAccumulator += DeltaTime;\n\tif (TimeAccumulator >= 1.0f)\n\t{\n\t\tbIsToggled = !bIsToggled;\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to gradually increase a float UPROPERTY speed variable.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedIncreasingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedIncreasingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpeedIncreasingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat Speed;\n\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat SpeedIncrement;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedIncreasingActor.h\"\n\n// Sets default values\nASpeedIncreasingActor::ASpeedIncreasingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSpeed = 0.0f;\n\tSpeedIncrement = 10.0f; // Increment value per second\n}\n\n// Called when the game starts or when spawned\nvoid ASpeedIncreasingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpeedIncreasingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tSpeed += SpeedIncrement * DeltaTime;\n}\n```"}
{"requirement": "Create an Actor that uses ConstructorHelpers to load and apply a specific material to its mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Materials/Material.h\"\n\nAMaterialActor::AMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/Path/To/Your/Material.Material\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetMaterial(0, MaterialAsset.Object);\n\t}\n}\n\nvoid AMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to broadcast when the owning Actor's location changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULocationChangeNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnLocationChanged, const FVector&, NewLocation);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULocationChangeNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tULocationChangeNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFVector LastLocation;\n\npublic:\n\tUPROPERTY(BlueprintAssignable, Category=\"Location\")\n\tFOnLocationChanged OnLocationChanged;\n};\n```", "cpp_code": "```cpp\n#include \"ULocationChangeNotifierComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nULocationChangeNotifierComponent::ULocationChangeNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid ULocationChangeNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tLastLocation = Owner->GetActorLocation();\n\t}\n}\n\nvoid ULocationChangeNotifierComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector CurrentLocation = Owner->GetActorLocation();\n\t\tif (!CurrentLocation.Equals(LastLocation))\n\t\t{\n\t\t\tOnLocationChanged.Broadcast(CurrentLocation);\n\t\t\tLastLocation = CurrentLocation;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float variable representing health and log it at every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyHealthActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMyHealthActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat Health;\n};\n```", "cpp_code": "```cpp\n#include \"MyHealthActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nAMyHealthActor::AMyHealthActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHealth = 100.0f; // Default health value\n}\n\nvoid AMyHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Health: %f\"), Health);\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent method to toggle a static mesh's visibility with the 'V' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AToggleMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAToggleMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid ToggleMeshVisibility();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"ConstructorHelpers.h\"\n\nAToggleMeshActor::AToggleMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AToggleMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleMeshActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleMeshActor::ToggleMeshVisibility);\n}\n\nvoid AToggleMeshActor::ToggleMeshVisibility()\n{\n\tif (MeshComponent)\n\t{\n\t\tMeshComponent->SetVisibility(!MeshComponent->IsVisible());\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY FVector and a BlueprintCallable function to set its value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyVectorActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyVectorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMyVectorActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Vector\")\n\tvoid SetVectorValue(const FVector& NewValue);\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Vector\")\n\tFVector VectorValue;\n};\n```", "cpp_code": "```cpp\n#include \"MyVectorActor.h\"\n\nAMyVectorActor::AMyVectorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tVectorValue = FVector::ZeroVector;\n}\n\nvoid AMyVectorActor::SetVectorValue(const FVector& NewValue)\n{\n\tVectorValue = NewValue;\n}\n```"}
{"requirement": "Implement a Tick function in a Component that changes its owning Actor's rotation over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"URotatingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API URotatingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tURotatingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"URotatingComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nURotatingComponent::URotatingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tRotationRate = FRotator(0.0f, 10.0f, 0.0f); // Default rotation rate\n}\n\nvoid URotatingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotatingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFRotator NewRotation = Owner->GetActorRotation() + (RotationRate * DeltaTime);\n\t\tOwner->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with collision set to print a message when it begins overlapping with another Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapActor::AOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set a static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Set collision\n\tMeshComponent->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\tMeshComponent->SetCollisionObjectType(ECollisionChannel::ECC_WorldDynamic);\n\tMeshComponent->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap);\n\t\n\t// Bind overlap event\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this))\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Overlap Begin\"));\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to log a custom message when the 'Enter' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to log a custom message\n\tvoid LogCustomMessage();\n\n\t// Override SetupPlayerInputComponent\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingActor::ALoggingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Log a custom message\nvoid ALoggingActor::LogCustomMessage()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Enter key pressed - Custom message logged!\"));\n}\n\n// Setup player input bindings\nvoid ALoggingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the Enter key to LogCustomMessage\n\tPlayerInputComponent->BindAction(\"LogMessage\", IE_Pressed, this, &ALoggingActor::LogCustomMessage);\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY integer counter that increases every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCounterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUCounterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Counter\")\n\tint32 Counter;\n};\n```", "cpp_code": "```cpp\n#include \"UCounterComponent.h\"\n\nUCounterComponent::UCounterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCounter = 0;\n}\n\nvoid UCounterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCounterComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tCounter++;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to simulate simple gravity by moving down the Z-axis.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GravityActor.generated.h\"\n\nUCLASS()\nclass AGravityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAGravityActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Gravity\")\n\tfloat GravityStrength;\n};\n```", "cpp_code": "```cpp\n#include \"GravityActor.h\"\n\nAGravityActor::AGravityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tGravityStrength = 980.0f; // Default gravity strength assuming cm/s^2\n}\n\nvoid AGravityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AGravityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation();\n\tNewLocation.Z -= GravityStrength * DeltaTime;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a particle system and attach it to the Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"AParticleActor.generated.h\"\n\nUCLASS()\nclass AParticleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAParticleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUParticleSystemComponent* ParticleSystemComponent;\n};\n```", "cpp_code": "```cpp\n#include \"AParticleActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Particles/ParticleSystem.h\"\n\n// Sets default values\nAParticleActor::AParticleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the particle system component\n\tParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystemComponent\"));\n\tRootComponent = ParticleSystemComponent;\n\n\t// Find the particle system asset\n\tstatic ConstructorHelpers::FObjectFinder<UParticleSystem> ParticleAsset(TEXT(\"/Game/Particles/P_MyParticleSystem.P_MyParticleSystem\"));\n\tif (ParticleAsset.Succeeded())\n\t{\n\t\tParticleSystemComponent->SetTemplate(ParticleAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AParticleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n}\n\n// Called every frame\nvoid AParticleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function to double a UPROPERTY integer value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DoubleValueActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADoubleValueActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADoubleValueActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Value\")\n\tvoid DoubleValue();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Value\")\n\tint32 Value;\n};\n```", "cpp_code": "```cpp\n#include \"DoubleValueActor.h\"\n\n// Sets default values\nADoubleValueActor::ADoubleValueActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tValue = 0;\n}\n\n// Called when the game starts or when spawned\nvoid ADoubleValueActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADoubleValueActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADoubleValueActor::DoubleValue()\n{\n\tValue *= 2;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to check and log its distance from the origin every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceLoggerActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADistanceLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADistanceLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tfloat TimeSinceLastLog;\n\n\tvoid LogDistanceFromOrigin();\n};\n```", "cpp_code": "```cpp\n#include \"DistanceLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\nADistanceLoggerActor::ADistanceLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTimeSinceLastLog = 0.0f;\n}\n\nvoid ADistanceLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADistanceLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeSinceLastLog += DeltaTime;\n\tif (TimeSinceLastLog >= 1.0f)\n\t{\n\t\tLogDistanceFromOrigin();\n\t\tTimeSinceLastLog = 0.0f;\n\t}\n}\n\nvoid ADistanceLoggerActor::LogDistanceFromOrigin()\n{\n\tFVector ActorLocation = GetActorLocation();\n\tfloat Distance = ActorLocation.Size();\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Distance from Origin: %f\"), Distance));\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that broadcasts every time the owning Actor ticks.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UDelegateTickComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnActorTick);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UDelegateTickComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUDelegateTickComponent();\n\n\tvirtual void BeginPlay() override;\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Tick\")\n\tFOnActorTick OnActorTick;\n};\n```", "cpp_code": "```cpp\n#include \"UDelegateTickComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUDelegateTickComponent::UDelegateTickComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UDelegateTickComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UDelegateTickComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (OnActorTick.IsBound())\n\t{\n\t\tOnActorTick.Broadcast();\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to trigger a function that prints the current game time on 'T' key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintGameTimeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APrintGameTimeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPrintGameTimeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to print the current game time\n\tvoid PrintGameTime();\n};\n```", "cpp_code": "```cpp\n#include \"PrintGameTimeActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/InputSettings.h\"\n\n// Sets default values\nAPrintGameTimeActor::APrintGameTimeActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid APrintGameTimeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APrintGameTimeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid APrintGameTimeActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"PrintGameTime\", IE_Pressed, this, &APrintGameTimeActor::PrintGameTime);\n\t}\n}\n\n// Function to print the current game time\nvoid APrintGameTimeActor::PrintGameTime()\n{\n\tif (GetWorld())\n\t{\n\t\tfloat CurrentTime = GetWorld()->GetTimeSeconds();\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Current Game Time: %f\"), CurrentTime);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY array of integers and a BlueprintCallable function to add an element.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyIntegerArrayActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyIntegerArrayActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyIntegerArrayActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"IntegerArray\")\n\tTArray<int32> IntegerArray;\n\n\tUFUNCTION(BlueprintCallable, Category = \"IntegerArray\")\n\tvoid AddInteger(int32 NewInteger);\n};\n```", "cpp_code": "```cpp\n#include \"MyIntegerArrayActor.h\"\n\n// Sets default values\nAMyIntegerArrayActor::AMyIntegerArrayActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyIntegerArrayActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyIntegerArrayActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyIntegerArrayActor::AddInteger(int32 NewInteger)\n{\n\tIntegerArray.Add(NewInteger);\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor that changes a UPROPERTY color when it overlaps.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapColorChangeActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AOverlapColorChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOverlapColorChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Color\")\n\tFLinearColor OverlapColor;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nAOverlapColorChangeActor::AOverlapColorChangeActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapColorChangeActor::OnBeginOverlap);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapColorChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapColorChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapColorChangeActor::OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), OverlapColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY representing an angle, incremented by 5 degrees each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UAngleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UAngleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUAngleComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Angle\")\n\tfloat Angle;\n};\n```", "cpp_code": "```cpp\n#include \"UAngleComponent.h\"\n\nUAngleComponent::UAngleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tAngle = 0.0f;\n}\n\nvoid UAngleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UAngleComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Increment the angle by 5 degrees each tick\n\tAngle += 5.0f;\n\n\t// Keep the angle in the range [0, 360)\n\tif (Angle >= 360.0f)\n\t{\n\t\tAngle -= 360.0f;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that oscillates the Actor's rotation between two angles.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OscillatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOscillatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAOscillatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Oscillation\")\n\tFRotator StartRotation;\n\n\tUPROPERTY(EditAnywhere, Category=\"Oscillation\")\n\tFRotator EndRotation;\n\n\tUPROPERTY(EditAnywhere, Category=\"Oscillation\")\n\tfloat OscillationSpeed;\n\n\tfloat CurrentTime;\n};\n```", "cpp_code": "```cpp\n#include \"OscillatingActor.h\"\n\nAOscillatingActor::AOscillatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tStartRotation = FRotator(0.0f, 0.0f, 0.0f);\n\tEndRotation = FRotator(0.0f, 180.0f, 0.0f);\n\tOscillationSpeed = 1.0f;\n\tCurrentTime = 0.0f;\n}\n\nvoid AOscillatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOscillatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tCurrentTime += DeltaTime * OscillationSpeed;\n\tfloat Alpha = (FMath::Sin(CurrentTime) + 1.0f) / 2.0f;\n\tFRotator NewRotation = FMath::Lerp(StartRotation, EndRotation, Alpha);\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an Actor with a mesh loaded using ConstructorHelpers and a BlueprintCallable function to toggle collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMyActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Collision\")\n\tvoid ToggleCollision();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.MeshName\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AMyActor::ToggleCollision()\n{\n\tif (MeshComponent->IsCollisionEnabled())\n\t{\n\t\tMeshComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\t}\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component that triggers when a string UPROPERTY changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UStringChangeComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnStringChanged, const FString&, NewString);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UStringChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUStringChangeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(BlueprintAssignable, Category=\"StringChange\")\n\tFOnStringChanged OnStringChanged;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"StringChange\")\n\tFString MonitoredString;\n\n\tUFUNCTION()\n\tvoid SetMonitoredString(const FString& NewString);\n\nprivate:\n\tFString PreviousString;\n};\n```", "cpp_code": "```cpp\n#include \"UStringChangeComponent.h\"\n\nUStringChangeComponent::UStringChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tPreviousString = \"\";\n}\n\nvoid UStringChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UStringChangeComponent::SetMonitoredString(const FString& NewString)\n{\n\tif (MonitoredString != NewString)\n\t{\n\t\tMonitoredString = NewString;\n\t\tOnStringChanged.Broadcast(MonitoredString);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY FVector velocity, and move the Actor by this velocity each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector Velocity;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!Velocity.IsZero())\n\t{\n\t\tFVector NewLocation = GetActorLocation() + (Velocity * DeltaTime);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent method to bind a key to reset an Actor's position to a start point.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"ResetPositionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetPositionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResetPositionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tFVector StartPosition;\n\n\tvoid ResetPosition();\n};\n```", "cpp_code": "```cpp\n#include \"ResetPositionActor.h\"\n#include \"GameFramework/InputSettings.h\"\n#include \"Components/InputComponent.h\"\n\nAResetPositionActor::AResetPositionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetPositionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tStartPosition = GetActorLocation();\n}\n\nvoid AResetPositionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetPositionActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"ResetPosition\", IE_Pressed, this, &AResetPositionActor::ResetPosition);\n\t}\n}\n\nvoid AResetPositionActor::ResetPosition()\n{\n\tSetActorLocation(StartPosition);\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function to log its current velocity UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VelocityLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVelocityLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAVelocityLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Velocity\")\n\tvoid LogCurrentVelocity();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Movement\", meta=(AllowPrivateAccess=\"true\"))\n\tFVector CurrentVelocity;\n};\n```", "cpp_code": "```cpp\n#include \"VelocityLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nAVelocityLoggerActor::AVelocityLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentVelocity = FVector::ZeroVector;\n}\n\nvoid AVelocityLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AVelocityLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t// Update the CurrentVelocity with actor's velocity (example logic)\n\tCurrentVelocity = GetVelocity();\n}\n\nvoid AVelocityLoggerActor::LogCurrentVelocity()\n{\n\tif(GEngine)\n\t{\n\t\tFString VelocityString = CurrentVelocity.ToString();\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Current Velocity: %s\"), *VelocityString));\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in a Component to gradually change its owning Actor's scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UScaleChangingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UScaleChangingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUScaleChangingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector TargetScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tfloat ScaleSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"UScaleChangingComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUScaleChangingComponent::UScaleChangingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tTargetScale = FVector(2.0f, 2.0f, 2.0f);\n\tScaleSpeed = 0.1f;\n}\n\nvoid UScaleChangingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UScaleChangingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector CurrentScale = Owner->GetActorScale3D();\n\t\tFVector NewScale = FMath::VInterpTo(CurrentScale, TargetScale, DeltaTime, ScaleSpeed);\n\t\tOwner->SetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh and print its world position when it begins play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAMyStaticMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Static Mesh Component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// Create and set Static Mesh Component\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Optionally set a mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Print the Actor's world position\n\tFVector WorldPosition = GetActorLocation();\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor World Position: %s\"), *WorldPosition.ToString());\n}\n```"}
{"requirement": "Set up an input binding in an Actor to log a message when the 'Space' key is released.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpaceKeyActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpaceKeyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpaceKeyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to handle space key release\n\tvoid OnSpaceKeyReleased();\n};\n```", "cpp_code": "```cpp\n#include \"SpaceKeyActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nASpaceKeyActor::ASpaceKeyActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASpaceKeyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpaceKeyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpaceKeyActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"Jump\", IE_Released, this, &ASpaceKeyActor::OnSpaceKeyReleased);\n\t}\n}\n\nvoid ASpaceKeyActor::OnSpaceKeyReleased()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Space key released\"));\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY boolean that toggles when a custom method is called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UToggleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UToggleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUToggleComponent();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Toggle\")\n\tvoid ToggleBoolean();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Toggle\")\n\tbool bIsToggled;\n};\n```", "cpp_code": "```cpp\n#include \"UToggleComponent.h\"\n\nUToggleComponent::UToggleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbIsToggled = false;\n}\n\nvoid UToggleComponent::ToggleBoolean()\n{\n\tbIsToggled = !bIsToggled;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to smoothly transition its location towards a target point.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SmoothTransitionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASmoothTransitionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASmoothTransitionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector TargetLocation;\n\tUPROPERTY(EditAnywhere)\n\tfloat TransitionSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"SmoothTransitionActor.h\"\n#include \"GameFramework/Actor.h\"\n\nASmoothTransitionActor::ASmoothTransitionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTransitionSpeed = 10.0f; // Default speed\n}\n\nvoid ASmoothTransitionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Initialize TargetLocation to some value\n\tTargetLocation = FVector(1000.0f, 1000.0f, 1000.0f);\n}\n\nvoid ASmoothTransitionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentLocation = GetActorLocation();\n\tFVector NewLocation = FMath::VInterpTo(CurrentLocation, TargetLocation, DeltaTime, TransitionSpeed);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a sound cue and play it when the Actor collides.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"MySoundActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMySoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMySoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUAudioComponent* AudioComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUSoundCue* SoundCue;\n};\n```", "cpp_code": "```cpp\n#include \"MySoundActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMySoundActor::AMySoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n\n\tstatic ConstructorHelpers::FObjectFinder<USoundCue> SoundCueObject(TEXT(\"/Game/Audio/MySoundCue.MySoundCue\"));\n\tif (SoundCueObject.Succeeded())\n\t{\n\t\tSoundCue = SoundCueObject.Object;\n\t\tAudioComponent->SetSound(SoundCue);\n\t}\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMySoundActor::OnOverlapBegin);\n}\n\nvoid AMySoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMySoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMySoundActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (SoundCue && !AudioComponent->IsPlaying())\n\t{\n\t\tAudioComponent->Play();\n\t}\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function to return a UPROPERTY integer score value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScoreActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Score\")\n\tint32 GetScore() const;\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Score\")\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreActor.h\"\n\nAScoreActor::AScoreActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// Initialize score\n\tScore = 0;\n}\n\nint32 AScoreActor::GetScore() const\n{\n\treturn Score;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to gradually decrease a float UPROPERTY health variable over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAHealthActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat Health;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat HealthDecreaseRate;\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n\n// Sets default values\nAHealthActor::AHealthActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default values\n\tHealth = 100.0f;\n\tHealthDecreaseRate = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Decrease health over time\n\tHealth -= HealthDecreaseRate * DeltaTime;\n\t// Ensure health doesn't drop below zero\n\tif (Health < 0.0f)\n\t{\n\t\tHealth = 0.0f;\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that triggers on every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UComponentWithDelegate.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnTickDelegate);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UComponentWithDelegate : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUComponentWithDelegate();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Event\")\n\tFOnTickDelegate OnTick;\n};\n```", "cpp_code": "```cpp\n#include \"UComponentWithDelegate.h\"\n\nUComponentWithDelegate::UComponentWithDelegate()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UComponentWithDelegate::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UComponentWithDelegate::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tOnTick.Broadcast();\n}\n```"}
{"requirement": "Set up input binding in an Actor to increase an integer UPROPERTY counter by 1 on 'I' key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyCounterActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyCounterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyCounterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to increase the counter\n\tvoid IncreaseCounter();\n\n\t// Input Component Setup\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Counter\")\n\tint32 Counter;\n};\n```", "cpp_code": "```cpp\n#include \"MyCounterActor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAMyCounterActor::AMyCounterActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tCounter = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AMyCounterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyCounterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyCounterActor::IncreaseCounter()\n{\n\tCounter++;\n}\n\n// Setup player input\nvoid AMyCounterActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"IncreaseCounter\", IE_Pressed, this, &AMyCounterActor::IncreaseCounter);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY for a material and a function to log its name when called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid LogMaterialName();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Material\")\n\tUMaterialInterface* Material;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Materials/MaterialInterface.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyActor::LogMaterialName()\n{\n\tif (Material)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Material Name: %s\"), *Material->GetName());\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Material is not set.\"));\n\t}\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor that calls a BlueprintCallable function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Overlap\")\n\tvoid BlueprintCallableFunction();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/CollisionProfile.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapActor::AOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComponent->SetCollisionProfileName(UCollisionProfile::Pawn_ProfileName);\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tBlueprintCallableFunction();\n}\n\nvoid AOverlapActor::BlueprintCallableFunction()\n{\n\t// Implement your logic here\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector representing direction, and update the owning Actor's forward vector each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UDirectionComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UDirectionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUDirectionComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Direction\")\n\tFVector Direction;\n};\n```", "cpp_code": "```cpp\n#include \"UDirectionComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values for this component's properties\nUDirectionComponent::UDirectionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\t// Initialize the direction vector\n\tDirection = FVector(1.0f, 0.0f, 0.0f);\n}\n\n// Called when the game starts\nvoid UDirectionComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid UDirectionComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Update the owning Actor's forward vector\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->SetActorRotation(Direction.Rotation());\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that makes it look at a fixed point in space.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LookAtPointActor.generated.h\"\n\nUCLASS()\nclass ALookAtPointActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tALookAtPointActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Look At\")\n\tFVector LookAtPoint;\n};\n```", "cpp_code": "```cpp\n#include \"LookAtPointActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nALookAtPointActor::ALookAtPointActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t // Initialize LookAtPoint to a default value\n\t LookAtPoint = FVector(0.0f, 0.0f, 0.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ALookAtPointActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALookAtPointActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate the direction to look at\n\tFVector Direction = LookAtPoint - GetActorLocation();\n\tDirection.Normalize();\n\n\t// Construct a rotation to look at the point\n\tFRotator NewRotation = Direction.Rotation();\n\n\t// Set the actor's rotation to the new rotation\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an Actor with a static mesh component, and attach a particle system loaded via ConstructorHelpers.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUParticleSystemComponent* ParticleSystemComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\tParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystemComponent\"));\n\tParticleSystemComponent->SetupAttachment(StaticMeshComponent);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UParticleSystem> ParticleAsset(TEXT(\"/Game/Path/To/Your/ParticleSystem.ParticleSystem\"));\n\tif (ParticleAsset.Succeeded())\n\t{\n\t\tParticleSystemComponent->SetTemplate(ParticleAsset.Object);\n\t}\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to notify when an integer UPROPERTY changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UChangeNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnIntegerChanged, int32, NewValue);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UChangeNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUChangeNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(BlueprintAssignable, Category=\"Events\")\n\tFOnIntegerChanged OnIntegerChanged;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Notifier\")\n\tvoid SetNotifiableInteger(int32 NewValue);\n\nprivate:\n\tUPROPERTY()\n\tint32 NotifiableInteger;\n};\n```", "cpp_code": "```cpp\n#include \"UChangeNotifierComponent.h\"\n\nUChangeNotifierComponent::UChangeNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tNotifiableInteger = 0;\n}\n\nvoid UChangeNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UChangeNotifierComponent::SetNotifiableInteger(int32 NewValue)\n{\n\tif (NotifiableInteger != NewValue)\n\t{\n\t\tNotifiableInteger = NewValue;\n\t\tOnIntegerChanged.Broadcast(NewValue);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float representing scale, and a function to reset it to 1.0.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyScaleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMyScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyScaleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Scale\")\n\tvoid ResetScale();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Scale\")\n\tfloat Scale;\n};\n```", "cpp_code": "```cpp\n#include \"MyScaleActor.h\"\n\n// Sets default values\nAMyScaleActor::AMyScaleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the scale\n\tScale = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMyScaleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyScaleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid AMyScaleActor::ResetScale()\n{\n\tScale = 1.0f;\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind an action that logs the actor's current scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"ScaleLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScaleLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid LogActorScale();\n};\n```", "cpp_code": "```cpp\n#include \"ScaleLoggerActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nAScaleLoggerActor::AScaleLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AScaleLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScaleLoggerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"LogScale\", IE_Pressed, this, &AScaleLoggerActor::LogActorScale);\n\t}\n}\n\nvoid AScaleLoggerActor::LogActorScale()\n{\n\tFVector ActorScale = GetActorScale3D();\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor Scale: %s\"), *ActorScale.ToString());\n}\n```"}
{"requirement": "Create an Actor with a FVector UPROPERTY velocity and apply it to the Actor's movement each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMovingActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector Velocity;\n};\n```", "cpp_code": "```cpp\n#include \"MyMovingActor.h\"\n\nAMyMovingActor::AMyMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tVelocity = FVector::ZeroVector;\n}\n\nvoid AMyMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!Velocity.IsZero())\n\t{\n\t\tFVector NewLocation = GetActorLocation() + (Velocity * DeltaTime);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in a Component to increase the owning Actor's size over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"USizeIncreaseComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API USizeIncreaseComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUSizeIncreaseComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Size\")\n\tfloat SizeIncreaseRate;\n};\n```", "cpp_code": "```cpp\n#include \"USizeIncreaseComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUSizeIncreaseComponent::USizeIncreaseComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tSizeIncreaseRate = 1.0f;\n}\n\nvoid USizeIncreaseComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid USizeIncreaseComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector NewScale = Owner->GetActorScale3D() + FVector(SizeIncreaseRate * DeltaTime);\n\t\tOwner->SetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh, and implement collision to log the other Actor's velocity on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n#include \"Logging/LogMacros.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"MyOverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMyOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMesh;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"MyOverlapActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"GameFramework/MovementComponent.h\"\n\n// Sets default values\nAMyOverlapActor::AMyOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tStaticMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMesh\"));\n\tRootComponent = StaticMesh;\n\n\tStaticMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\tStaticMesh->SetCollisionObjectType(ECollisionChannel::ECC_WorldDynamic);\n\tStaticMesh->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap);\n\n\tStaticMesh->OnComponentBeginOverlap.AddDynamic(this, &AMyOverlapActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid AMyOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUMovementComponent* MovementComponent = OtherActor->FindComponentByClass<UMovementComponent>();\n\t\tif (MovementComponent)\n\t\t{\n\t\t\tFVector Velocity = MovementComponent->Velocity;\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Overlapping Actor's Velocity: %s\"), *Velocity.ToString());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to call a function that toggles a UPROPERTY boolean.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to toggle the boolean\n\tUFUNCTION()\n\tvoid ToggleBoolean();\n\n\t// Input Component binding\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Boolean to toggle\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Toggle\")\n\tbool bIsToggled;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleActor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAToggleActor::AToggleActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t bIsToggled = false;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\n// Called to bind functionality to input\nvoid AToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleAction\", IE_Pressed, this, &AToggleActor::ToggleBoolean);\n}\n\n// Function to toggle the boolean\nvoid AToggleActor::ToggleBoolean()\n{\n\tbIsToggled = !bIsToggled;\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY float that increases by 0.5 every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFloatIncrementComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatIncrementComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFloatIncrementComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Increment\")\n\tfloat IncrementingFloat;\n};\n```", "cpp_code": "```cpp\n#include \"UFloatIncrementComponent.h\"\n\nUFloatIncrementComponent::UFloatIncrementComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tIncrementingFloat = 0.0f;\n}\n\nvoid UFloatIncrementComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFloatIncrementComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tIncrementingFloat += 0.5f;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to rotate it around its origin continually.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Rotation\")\n\tFRotator RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Set default rotation speed\n\tRotationSpeed = FRotator(0.f, 45.f, 0.f); // 45 degrees per second around Y-axis\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate the new rotation\n\tFRotator NewRotation = GetActorRotation() + (RotationSpeed * DeltaTime);\n\n\t// Set the new rotation\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load and display a specific texture on its mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"MyTextureActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyTextureActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyTextureActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY()\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"MyTextureActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"Materials/Material.h\"\n#include \"Engine/Texture2D.h\"\n\nAMyTextureActor::AMyTextureActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/StarterContent/Materials/M_Brick_Clay.M_Brick_Clay\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MaterialAsset.Object, MeshComponent);\n\t\tstatic ConstructorHelpers::FObjectFinder<UTexture2D> TextureAsset(TEXT(\"/Game/StarterContent/Textures/T_Brick_Clay_BC.T_Brick_Clay_BC\"));\n\t\tif (TextureAsset.Succeeded())\n\t\t{\n\t\t\tDynamicMaterialInstance->SetTextureParameterValue(TEXT(\"Texture\"), TextureAsset.Object);\n\t\t}\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\nvoid AMyTextureActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyTextureActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that returns its current location as a string.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALocationActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tALocationActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Location\")\n\tFString GetLocationAsString() const;\n};\n```", "cpp_code": "```cpp\n#include \"LocationActor.h\"\n\nALocationActor::ALocationActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nFString ALocationActor::GetLocationAsString() const\n{\n\tFVector Location = GetActorLocation();\n\treturn FString::Printf(TEXT(\"X: %f, Y: %f, Z: %f\"), Location.X, Location.Y, Location.Z);\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to modify its material color based on its Z-coordinate.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADynamicColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADynamicColorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Material\")\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tvoid UpdateMaterialColor();\n};\n```", "cpp_code": "```cpp\n#include \"DynamicColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nADynamicColorActor::ADynamicColorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ADynamicColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MeshComponent)\n\t{\n\t\tDynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t}\n}\n\nvoid ADynamicColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tUpdateMaterialColor();\n}\n\nvoid ADynamicColorActor::UpdateMaterialColor()\n{\n\tif (DynamicMaterial)\n\t{\n\t\tfloat ZHeight = GetActorLocation().Z;\n\t\tFLinearColor NewColor = FLinearColor::LerpUsingHSV(FLinearColor::Red, FLinearColor::Blue, FMath::Clamp(ZHeight / 1000.0f, 0.0f, 1.0f));\n\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that broadcasts when a UPROPERTY float exceeds a threshold.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFloatThresholdComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnThresholdExceeded);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatThresholdComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFloatThresholdComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"FloatThreshold\")\n\tfloat MonitoredFloat;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"FloatThreshold\")\n\tfloat Threshold;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"FloatThreshold\")\n\tFOnThresholdExceeded OnThresholdExceeded;\n\nprivate:\n\tvoid CheckThreshold();\n};\n```", "cpp_code": "```cpp\n#include \"UFloatThresholdComponent.h\"\n\nUFloatThresholdComponent::UFloatThresholdComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tMonitoredFloat = 0.0f;\n\tThreshold = 100.0f; // Default threshold value\n}\n\nvoid UFloatThresholdComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFloatThresholdComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tCheckThreshold();\n}\n\nvoid UFloatThresholdComponent::CheckThreshold()\n{\n\tif (MonitoredFloat > Threshold)\n\t{\n\t\tOnThresholdExceeded.Broadcast();\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to print a message when the mouse left button is clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseClickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMouseClickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMouseClickActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid OnLeftMouseClick();\n};\n```", "cpp_code": "```cpp\n#include \"MouseClickActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nAMouseClickActor::AMouseClickActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AMouseClickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMouseClickActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"LeftMouseClick\", IE_Pressed, this, &AMouseClickActor::OnLeftMouseClick);\n\t}\n}\n\nvoid AMouseClickActor::OnLeftMouseClick()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Left Mouse Button Clicked!\"));\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY integer for health and a function to decrease it by a specified amount.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAHealthActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tint32 Health;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Health\")\n\tvoid DecreaseHealth(int32 Amount);\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n\nAHealthActor::AHealthActor()\n{\n\t// Set default health value\n\tHealth = 100;\n}\n\nvoid AHealthActor::DecreaseHealth(int32 Amount)\n{\n\tHealth -= Amount;\n\tif (Health < 0)\n\t{\n\t\tHealth = 0;\n\t}\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor that prints both Actors' names.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapPrinterActor.generated.h\"\n\nUCLASS()\nclass AOverlapPrinterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOverlapPrinterActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapPrinterActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"ConstructorHelpers.h\"\n\nAOverlapPrinterActor::AOverlapPrinterActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapPrinterActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AOverlapPrinterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapPrinterActor::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && (OtherActor != this))\n\t{\n\t\tFString OverlappedActorName = OverlappedActor->GetName();\n\t\tFString OtherActorName = OtherActor->GetName();\n\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Overlapped Actor: %s, Other Actor: %s\"), *OverlappedActorName, *OtherActorName));\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector that interpolates towards a target location each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UInterpLocationComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UInterpLocationComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUInterpLocationComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n\tFVector CurrentLocation;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n\tFVector TargetLocation;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n\tfloat InterpSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"UInterpLocationComponent.h\"\n\nUInterpLocationComponent::UInterpLocationComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tInterpSpeed = 1.0f;\n}\n\nvoid UInterpLocationComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCurrentLocation = GetOwner()->GetActorLocation();\n}\n\nvoid UInterpLocationComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (FVector::Dist(CurrentLocation, TargetLocation) > KINDA_SMALL_NUMBER)\n\t{\n\t\tCurrentLocation = FMath::VInterpTo(CurrentLocation, TargetLocation, DeltaTime, InterpSpeed);\n\t\tGetOwner()->SetActorLocation(CurrentLocation);\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor that changes its pitch by a small amount each frame.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PitchChangingActor.generated.h\"\n\nUCLASS()\nclass APitchChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPitchChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Pitch\")\n\tfloat PitchChangeRate;\n};\n```", "cpp_code": "```cpp\n#include \"PitchChangingActor.h\"\n\n// Sets default values\nAPitchChangingActor::APitchChangingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Set default pitch change rate\n\tPitchChangeRate = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid APitchChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APitchChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Get current rotation\n\tFRotator CurrentRotation = GetActorRotation();\n\n\t// Modify the pitch\n\tCurrentRotation.Pitch += PitchChangeRate * DeltaTime;\n\n\t// Set new rotation\n\tSetActorRotation(CurrentRotation);\n}\n```"}
{"requirement": "Create an Actor with a static mesh and load a material using ConstructorHelpers to apply to its mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMyStaticMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Mesh\")\n\tUStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.MeshName\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/Path/To/Your/Material.MaterialName\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetMaterial(0, MaterialAsset.Object);\n\t}\n}\n\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyStaticMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to fire when a bool UPROPERTY changes state.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UExampleComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBoolChanged, bool, NewValue);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UExampleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUExampleComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION()\n\tvoid SetBoolProperty(bool NewValue);\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Event\")\n\tFOnBoolChanged OnBoolChanged;\n\nprivate:\n\tUPROPERTY()\n\tbool bExampleBool;\n};\n```", "cpp_code": "```cpp\n#include \"UExampleComponent.h\"\n\nUExampleComponent::UExampleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbExampleBool = false;\n}\n\nvoid UExampleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UExampleComponent::SetBoolProperty(bool NewValue)\n{\n\tif (bExampleBool != NewValue)\n\t{\n\t\tbExampleBool = NewValue;\n\t\tOnBoolChanged.Broadcast(bExampleBool);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float representing rotation speed and apply it in the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 45.0f; // Default rotation speed\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind an axis that controls the Actor's forward movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"MyPawn.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyPawn : public APawn\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this pawn's properties\n\tAMyPawn();\n\nprotected:\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Called for forwards/backward input\n\tvoid MoveForward(float Value);\n\nprivate:\n\t// The mesh component for the pawn\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyPawn.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAMyPawn::AMyPawn()\n{\n\t// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set a default mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called to bind functionality to input\nvoid AMyPawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &AMyPawn::MoveForward);\n}\n\n// Called for forwards/backward input\nvoid AMyPawn::MoveForward(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\t// Add movement in that direction\n\t\tAddMovementInput(GetActorForwardVector(), Value);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a function to reset a UPROPERTY integer score and bind it to a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetScoreActor.generated.h\"\n\nUCLASS()\nclass AResetScoreActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResetScoreActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid ResetScore();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Score\")\n\tint32 Score;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ResetScoreActor.h\"\n#include \"Components/InputComponent.h\"\n\nAResetScoreActor::AResetScoreActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScore = 0;\n}\n\nvoid AResetScoreActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AResetScoreActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetScoreActor::ResetScore()\n{\n\tScore = 0;\n}\n\nvoid AResetScoreActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetScore\", IE_Pressed, this, &AResetScoreActor::ResetScore);\n}\n```"}
{"requirement": "Implement a Tick function in a Component to change its owning Actor's color over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UColorChangingComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UColorChangingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUColorChangingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFLinearColor CurrentColor;\n\tfloat TimeAccumulator;\n};\n```", "cpp_code": "```cpp\n#include \"UColorChangingComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nUColorChangingComponent::UColorChangingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCurrentColor = FLinearColor::White;\n\tTimeAccumulator = 0.0f;\n}\n\nvoid UColorChangingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UColorChangingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTimeAccumulator += DeltaTime;\n\tfloat SineValue = FMath::Sin(TimeAccumulator);\n\tCurrentColor = FLinearColor(0.5f * (SineValue + 1.0f), 0.0f, 1.0f - 0.5f * (SineValue + 1.0f));\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUMeshComponent* MeshComp = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComp)\n\t\t{\n\t\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComp->CreateAndSetMaterialInstanceDynamic(0);\n\t\t\tif (DynamicMaterial)\n\t\t\t{\n\t\t\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", CurrentColor);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh component, and log a message every time it moves.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AMovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMovingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tFVector LastLocation;\n};\n```", "cpp_code": "```cpp\n#include \"AMovingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMovingActor::AMovingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach static mesh component\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Example of setting a default static mesh (ensure you have a valid asset in your project)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/YourPath/YourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tLastLocation = GetActorLocation();\n}\n\n// Called when the game starts or when spawned\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentLocation = GetActorLocation();\n\tif (!CurrentLocation.Equals(LastLocation))\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Actor moved to: %s\"), *CurrentLocation.ToString());\n\t\tLastLocation = CurrentLocation;\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to increase a float UPROPERTY speed variable on 'Up' arrow key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Speed\")\n\tfloat Speed;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid IncreaseSpeed();\n};\n```", "cpp_code": "```cpp\n#include \"SpeedActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\nASpeedActor::ASpeedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSpeed = 0.0f;\n}\n\nvoid ASpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpeedActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"IncreaseSpeed\", IE_Pressed, this, &ASpeedActor::IncreaseSpeed);\n}\n\nvoid ASpeedActor::IncreaseSpeed()\n{\n\tSpeed += 10.0f; // Increase speed by 10 units\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FString and a method to append text to it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UTextAppenderComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTextAppenderComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUTextAppenderComponent();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Text\")\n\tvoid AppendText(const FString& NewText);\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Text\")\n\tFString Text;\n};\n```", "cpp_code": "```cpp\n#include \"UTextAppenderComponent.h\"\n\nUTextAppenderComponent::UTextAppenderComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UTextAppenderComponent::AppendText(const FString& NewText)\n{\n\tText.Append(NewText);\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to animate its mesh scaling in response to a sine wave.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SineWaveScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ASineWaveScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASineWaveScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tfloat RunningTime;\n};\n```", "cpp_code": "```cpp\n#include \"SineWaveScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nASineWaveScalingActor::ASineWaveScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRunningTime = 0.0f;\n}\n\nvoid ASineWaveScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASineWaveScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRunningTime += DeltaTime;\n\tfloat ScaleFactor = FMath::Sin(RunningTime);\n\tMeshComponent->SetWorldScale3D(FVector(ScaleFactor));\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a blueprint and spawn it when the Actor is initialized.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditDefaultsOnly, Category = \"Spawning\")\n\tTSubclassOf<AActor> BlueprintToSpawn;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Find the blueprint class\n\tstatic ConstructorHelpers::FObjectFinder<UClass> BlueprintClass(TEXT(\"/Game/Blueprints/MyBlueprint.MyBlueprint_C\"));\n\tif (BlueprintClass.Succeeded())\n\t{\n\t\tBlueprintToSpawn = BlueprintClass.Object;\n\t}\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (BlueprintToSpawn)\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tGetWorld()->SpawnActor<AActor>(BlueprintToSpawn, GetActorLocation(), GetActorRotation(), SpawnParams);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that prints the number of ticks since the game started.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TickCounterActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATickCounterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATickCounterActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Tick\")\n\tvoid PrintTickCount();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tint32 TickCount;\n};\n```", "cpp_code": "```cpp\n#include \"TickCounterActor.h\"\n#include \"Engine/Engine.h\"\n\nATickCounterActor::ATickCounterActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTickCount = 0;\n}\n\nvoid ATickCounterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATickCounterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tTickCount++;\n}\n\nvoid ATickCounterActor::PrintTickCount()\n{\n\tif (GEngine)\n\t{\n\t\tFString TickCountMessage = FString::Printf(TEXT(\"Ticks since game started: %d\"), TickCount);\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TickCountMessage);\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to simulate a pendulum-like movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PendulumActor.generated.h\"\n\nUCLASS()\nclass APendulumActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPendulumActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat SwingAmplitude;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat SwingFrequency;\n\n\tfloat InitialYaw;\n};\n```", "cpp_code": "```cpp\n#include \"PendulumActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAPendulumActor::APendulumActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tSwingAmplitude = 30.0f; // 30 degrees\n\tSwingFrequency = 1.0f; // 1 oscillation per second\n}\n\nvoid APendulumActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tInitialYaw = GetActorRotation().Yaw;\n}\n\nvoid APendulumActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat Time = GetWorld()->GetTimeSeconds();\n\tfloat DeltaYaw = SwingAmplitude * FMath::Sin(SwingFrequency * Time);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw = InitialYaw + DeltaYaw;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that fires every time a specific input is detected.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UInputDetectComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnInputDetected);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UUInputDetectComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this component's properties\n\tUUInputDetectComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Input\")\n\tFOnInputDetected OnInputDetected;\n\nprivate:\n\tvoid HandleInput();\n};\n```", "cpp_code": "```cpp\n#include \"UInputDetectComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values for this component's properties\nUUInputDetectComponent::UUInputDetectComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\n// Called when the game starts\nvoid UUInputDetectComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind input\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tif (UInputComponent* InputComponent = Owner->FindComponentByClass<UInputComponent>())\n\t\t{\n\t\t\tSetupPlayerInputComponent(InputComponent);\n\t\t}\n\t}\n}\n\nvoid UUInputDetectComponent::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"YourInputAction\", IE_Pressed, this, &UUInputDetectComponent::HandleInput);\n\t}\n}\n\nvoid UUInputDetectComponent::HandleInput()\n{\n\tOnInputDetected.Broadcast();\n}\n```"}
{"requirement": "Set up input binding in an Actor to log a message whenever the 'Left' arrow key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InputBindingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AInputBindingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAInputBindingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to handle input\n\tvoid HandleLeftArrow();\n};\n```", "cpp_code": "```cpp\n#include \"InputBindingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAInputBindingActor::AInputBindingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AInputBindingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AInputBindingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid AInputBindingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"LeftArrow\", IE_Pressed, this, &AInputBindingActor::HandleLeftArrow);\n\t}\n}\n\n// Function to handle input\nvoid AInputBindingActor::HandleLeftArrow()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Left Arrow Key Pressed\"));\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY array of FVectors and a function to clear the array.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyVectorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyVectorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMyVectorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Vectors\")\n\tTArray<FVector> VectorArray;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Vectors\")\n\tvoid ClearVectorArray();\n};\n```", "cpp_code": "```cpp\n#include \"MyVectorActor.h\"\n\nAMyVectorActor::AMyVectorActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyVectorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyVectorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyVectorActor::ClearVectorArray()\n{\n\tVectorArray.Empty();\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor to stop its movement when colliding with a specific tag.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor);\n\n\tUPROPERTY(EditAnywhere)\n\tFName StopTag;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nAOverlapActor::AOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnBeginOverlap);\n}\n\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && OtherActor != this && OtherActor->ActorHasTag(StopTag))\n\t{\n\t\tMeshComponent->SetPhysicsLinearVelocity(FVector::ZeroVector);\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY representing the last known location of its owning Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULastKnownLocationComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass MYPROJECT_API ULastKnownLocationComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tULastKnownLocationComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Location\")\n\tFVector LastKnownLocation;\n\n\tvoid UpdateLastKnownLocation();\n};\n```", "cpp_code": "```cpp\n#include \"ULastKnownLocationComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nULastKnownLocationComponent::ULastKnownLocationComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid ULastKnownLocationComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateLastKnownLocation();\n}\n\nvoid ULastKnownLocationComponent::UpdateLastKnownLocation()\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tLastKnownLocation = Owner->GetActorLocation();\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to apply a constant upward force to itself.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UpwardForceActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AUpwardForceActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAUpwardForceActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat ForceMagnitude;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"UpwardForceActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAUpwardForceActor::AUpwardForceActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tForceMagnitude = 1000.0f; // Example force magnitude\n}\n\n// Called when the game starts or when spawned\nvoid AUpwardForceActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AUpwardForceActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (MeshComponent)\n\t{\n\t\tFVector UpwardForce = FVector(0.0f, 0.0f, ForceMagnitude);\n\t\tMeshComponent->AddForce(UpwardForce);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh component and an OnBeginOverlap event to change its material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyOverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Materials\")\n\tUMaterialInterface* OverlapMaterial;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"MyOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyOverlapActor::AMyOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Static Mesh Component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set up overlap event\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyOverlapActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid AMyOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OverlapMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, OverlapMaterial);\n\t}\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to notify when a float UPROPERTY reaches zero.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UZeroNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnZeroReached);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UZeroNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUZeroNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"ZeroNotifier\")\n\tfloat MonitoredValue;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"ZeroNotifier\")\n\tFOnZeroReached OnZeroReached;\n\n\tUFUNCTION()\n\tvoid CheckValue();\n};\n```", "cpp_code": "```cpp\n#include \"UZeroNotifierComponent.h\"\n\nUZeroNotifierComponent::UZeroNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tMonitoredValue = 0.0f;\n}\n\nvoid UZeroNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UZeroNotifierComponent::CheckValue()\n{\n\tif (MonitoredValue == 0.0f)\n\t{\n\t\tOnZeroReached.Broadcast();\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY for a light intensity and a function to toggle the light.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyLightActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMyLightActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid ToggleLight();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light\")\n\tfloat LightIntensity;\n\nprivate:\n\tUPROPERTY()\n\tclass UPointLightComponent* PointLight;\n};\n```", "cpp_code": "```cpp\n#include \"MyLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\nAMyLightActor::AMyLightActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tPointLight->SetupAttachment(RootComponent);\n\tLightIntensity = 3000.0f;\n\tPointLight->SetIntensity(LightIntensity);\n}\n\nvoid AMyLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyLightActor::ToggleLight()\n{\n\tif (PointLight)\n\t{\n\t\tPointLight->ToggleVisibility();\n\t}\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind a key to change an Actor's color dynamically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ChangeColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAChangeColorActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid ChangeColor();\n};\n```", "cpp_code": "```cpp\n#include \"ChangeColorActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAChangeColorActor::AChangeColorActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetMaterial(0, UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this));\n}\n\n// Called when the game starts or when spawned\nvoid AChangeColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AChangeColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid AChangeColorActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"ChangeColor\", IE_Pressed, this, &AChangeColorActor::ChangeColor);\n\t}\n}\n\nvoid AChangeColorActor::ChangeColor()\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = Cast<UMaterialInstanceDynamic>(MeshComponent->GetMaterial(0));\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", NewColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY FVector and a BlueprintCallable function to set its value from a Blueprint.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyVectorActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyVectorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyVectorActor();\n\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Vector\")\n\tFVector MyVector;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Vector\")\n\tvoid SetMyVector(const FVector& NewVector);\n};\n```", "cpp_code": "```cpp\n#include \"MyVectorActor.h\"\n\nAMyVectorActor::AMyVectorActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AMyVectorActor::SetMyVector(const FVector& NewVector)\n{\n\tMyVector = NewVector;\n}\n```"}
{"requirement": "Implement a Tick function in a Component to cycle the owning Actor's color through a gradient over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ColorCyclerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UColorCyclerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUColorCyclerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tvoid CycleColor(float DeltaTime);\n\n\tFLinearColor CurrentColor;\n\tfloat ColorChangeSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"ColorCyclerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nUColorCyclerComponent::UColorCyclerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tColorChangeSpeed = 1.0f;\n\tCurrentColor = FLinearColor::Red;\n}\n\nvoid UColorCyclerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UColorCyclerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tCycleColor(DeltaTime);\n}\n\nvoid UColorCyclerComponent::CycleColor(float DeltaTime)\n{\n\tif(AActor* Owner = GetOwner())\n\t{\n\t\tUMeshComponent* MeshComponent = Owner->FindComponentByClass<UMeshComponent>();\n\t\tif(MeshComponent)\n\t\t{\n\t\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\t\tif(DynamicMaterial)\n\t\t\t{\n\t\t\t\tCurrentColor.R += ColorChangeSpeed * DeltaTime;\n\t\t\t\tCurrentColor.G += ColorChangeSpeed * DeltaTime;\n\t\t\t\tCurrentColor.B += ColorChangeSpeed * DeltaTime;\n\n\t\t\t\tif(CurrentColor.R > 1.0f) CurrentColor.R -= 1.0f;\n\t\t\t\tif(CurrentColor.G > 1.0f) CurrentColor.G -= 1.0f;\n\t\t\t\tif(CurrentColor.B > 1.0f) CurrentColor.B -= 1.0f;\n\n\t\t\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", CurrentColor);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a mesh and print its rotation when it receives an input from the user.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"PrintRotationActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APrintRotationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPrintRotationActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid PrintRotation();\n};\n```", "cpp_code": "```cpp\n#include \"PrintRotationActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/InputSettings.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAPrintRotationActor::APrintRotationActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid APrintRotationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APrintRotationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APrintRotationActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"PrintRotation\", IE_Pressed, this, &APrintRotationActor::PrintRotation);\n}\n\nvoid APrintRotationActor::PrintRotation()\n{\n\tFRotator ActorRotation = GetActorRotation();\n\tUE_LOG(LogTemp, Warning, TEXT(\"Actor Rotation: Pitch=%f, Yaw=%f, Roll=%f\"), ActorRotation.Pitch, ActorRotation.Yaw, ActorRotation.Roll);\n}\n```"}
{"requirement": "Set up an input binding in an Actor to decrease a UPROPERTY float health value when 'H' is pressed.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHealthActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input bindings\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat Health;\n\n\tUFUNCTION()\n\tvoid DecreaseHealth();\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAHealthActor::AHealthActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t Health = 100.0f; // Initialize health\n}\n\n// Called when the game starts or when spawned\nvoid AHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input bindings\nvoid AHealthActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the DecreaseHealth function to the 'H' key\n\tPlayerInputComponent->BindAction(\"DecreaseHealth\", IE_Pressed, this, &AHealthActor::DecreaseHealth);\n}\n\nvoid AHealthActor::DecreaseHealth()\n{\n\tHealth -= 10.0f; // Decrease health by 10\n\tif (Health < 0.0f)\n\t{\n\t\tHealth = 0.0f; // Clamp health to zero\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY integer counter that resets every time it reaches a specified value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCounterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUCounterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Counter\")\n\tvoid IncrementCounter();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Counter\")\n\tint32 Counter;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Counter\")\n\tint32 ResetValue;\n};\n```", "cpp_code": "```cpp\n#include \"UCounterComponent.h\"\n\nUCounterComponent::UCounterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCounter = 0;\n\tResetValue = 10; // Default reset value, can be set in editor\n}\n\nvoid UCounterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCounterComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\t// This component does not need to tick for this functionality\n}\n\nvoid UCounterComponent::IncrementCounter()\n{\n\tCounter++;\n\tif (Counter >= ResetValue)\n\t{\n\t\tCounter = 0;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to make it look at the player's camera location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LookAtPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALookAtPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALookAtPlayerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAPlayerCameraManager* PlayerCameraManager;\n};\n```", "cpp_code": "```cpp\n#include \"LookAtPlayerActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Camera/PlayerCameraManager.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nALookAtPlayerActor::ALookAtPlayerActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALookAtPlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tPlayerCameraManager = PlayerController->PlayerCameraManager;\n\t}\n}\n\n// Called every frame\nvoid ALookAtPlayerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerCameraManager)\n\t{\n\t\tFVector CameraLocation = PlayerCameraManager->GetCameraLocation();\n\t\tFRotator LookAtRotation = (CameraLocation - GetActorLocation()).Rotation();\n\t\tSetActorRotation(LookAtRotation);\n\t}\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load and apply a specific sound to play on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"CollisionSoundActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACollisionSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACollisionSoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUAudioComponent* AudioComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUSoundCue* CollisionSound;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionSoundActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nACollisionSoundActor::ACollisionSoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n\n\tstatic ConstructorHelpers::FObjectFinder<USoundCue> SoundCueFinder(TEXT(\"/Game/Audio/MyCollisionSoundCue.MyCollisionSoundCue\"));\n\tif (SoundCueFinder.Succeeded())\n\t{\n\t\tCollisionSound = SoundCueFinder.Object;\n\t\tAudioComponent->SetSound(CollisionSound);\n\t}\n\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ACollisionSoundActor::OnHit);\n}\n\nvoid ACollisionSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionSoundActor::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (CollisionSound && AudioComponent)\n\t{\n\t\tAudioComponent->Play();\n\t}\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that returns the distance to the player's controller.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADistanceActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Distance\")\n\tfloat GetDistanceToPlayer() const;\n};\n```", "cpp_code": "```cpp\n#include \"DistanceActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nADistanceActor::ADistanceActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nfloat ADistanceActor::GetDistanceToPlayer() const\n{\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController && PlayerController->GetPawn())\n\t{\n\t\tFVector PlayerLocation = PlayerController->GetPawn()->GetActorLocation();\n\t\tFVector ActorLocation = GetActorLocation();\n\t\treturn FVector::Dist(PlayerLocation, ActorLocation);\n\t}\n\treturn -1.0f; // Return -1 if the player controller or pawn is not found\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to create a pulsing effect by scaling the mesh over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PulsingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APulsingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPulsingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Pulse\")\n\tfloat PulseSpeed;\n\n\tUPROPERTY(EditAnywhere, Category = \"Pulse\")\n\tfloat PulseScaleAmplitude;\n};\n```", "cpp_code": "```cpp\n#include \"PulsingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAPulsingActor::APulsingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tPulseSpeed = 2.0f;\n\tPulseScaleAmplitude = 0.5f;\n}\n\nvoid APulsingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APulsingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat RunningTime = GetGameTimeSinceCreation();\n\tfloat ScaleFactor = 1.0f + PulseScaleAmplitude * FMath::Sin(PulseSpeed * RunningTime);\n\tMeshComponent->SetWorldScale3D(FVector(ScaleFactor));\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that broadcasts when the owning Actor's visibility changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UVisibilityChangeComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnVisibilityChanged, bool, bIsVisible);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UVisibilityChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUVisibilityChangeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOwnerVisibilityChanged();\n\npublic:\n\tUPROPERTY(BlueprintAssignable, Category=\"Visibility\")\n\tFOnVisibilityChanged OnVisibilityChanged;\n};\n```", "cpp_code": "```cpp\n#include \"UVisibilityChangeComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUVisibilityChangeComponent::UVisibilityChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UVisibilityChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->OnActorHiddenInGame.AddDynamic(this, &UVisibilityChangeComponent::OnOwnerVisibilityChanged);\n\t\tOwner->OnActorEndPlay.AddDynamic(this, &UVisibilityChangeComponent::OnOwnerVisibilityChanged);\n\t}\n}\n\nvoid UVisibilityChangeComponent::OnOwnerVisibilityChanged()\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tbool bIsVisible = !Owner->bHidden;\n\t\tOnVisibilityChanged.Broadcast(bIsVisible);\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to trigger a function that logs the current frame number.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogFrameActor.generated.h\"\n\nUCLASS()\nclass ALogFrameActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALogFrameActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid LogCurrentFrameNumber();\n};\n```", "cpp_code": "```cpp\n#include \"LogFrameActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nALogFrameActor::ALogFrameActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ALogFrameActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALogFrameActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ALogFrameActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"LogFrame\", IE_Pressed, this, &ALogFrameActor::LogCurrentFrameNumber);\n}\n\nvoid ALogFrameActor::LogCurrentFrameNumber()\n{\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Frame Number: %d\"), GFrameNumber);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY array of strings and a BlueprintCallable function to add to it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStringArrayActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStringArrayActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyStringArrayActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"StringArray\")\n\tvoid AddStringToArray(const FString& NewString);\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"StringArray\")\n\tTArray<FString> StringArray;\n};\n```", "cpp_code": "```cpp\n#include \"MyStringArrayActor.h\"\n\nAMyStringArrayActor::AMyStringArrayActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AMyStringArrayActor::AddStringToArray(const FString& NewString)\n{\n\tStringArray.Add(NewString);\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor that reverses its velocity upon collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionReverser.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionReverser : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACollisionReverser();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tFVector Velocity;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionReverser.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nACollisionReverser::ACollisionReverser()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionReverser::OnBeginOverlap);\n\n\tVelocity = FVector(100.f, 0.f, 0.f);\n}\n\nvoid ACollisionReverser::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionReverser::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation() + (Velocity * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n\nvoid ACollisionReverser::OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tVelocity = -Velocity;\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector velocity that accelerates every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UVelocityComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UVelocityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUVelocityComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Velocity\")\n\tFVector Velocity;\n\n\tUPROPERTY(EditAnywhere, Category=\"Velocity\")\n\tFVector Acceleration;\n};\n```", "cpp_code": "```cpp\n#include \"UVelocityComponent.h\"\n\n// Sets default values for this component's properties\nUVelocityComponent::UVelocityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\t// Initialize default velocity and acceleration\n\tVelocity = FVector::ZeroVector;\n\tAcceleration = FVector(10.0f, 0.0f, 0.0f); // Example acceleration\n}\n\n// Called when the game starts\nvoid UVelocityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid UVelocityComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Accelerate velocity\n\tVelocity += Acceleration * DeltaTime;\n\n\t// Log the current velocity (optional)\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Velocity: %s\"), *Velocity.ToString());\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to adjust its yaw based on the current game time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YawAdjustActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AYawAdjustActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic: \n\t// Sets default values for this actor's properties\n\tAYawAdjustActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"YawAdjustActor.h\"\n\n// Sets default values\nAYawAdjustActor::AYawAdjustActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize rotation speed\n\tRotationSpeed = 90.0f; // Degrees per second\n}\n\n// Called when the game starts or when spawned\nvoid AYawAdjustActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AYawAdjustActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Get the current time in seconds\n\tfloat CurrentTime = GetWorld()->GetTimeSeconds();\n\n\t// Calculate new yaw based on the time and rotation speed\n\tfloat NewYaw = CurrentTime * RotationSpeed;\n\n\t// Get current rotation\n\tFRotator CurrentRotation = GetActorRotation();\n\n\t// Adjust yaw\n\tCurrentRotation.Yaw = NewYaw;\n\n\t// Set new rotation\n\tSetActorRotation(CurrentRotation);\n}\n```"}
{"requirement": "Create an Actor with a static mesh and a BlueprintCallable function to toggle its physics simulation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TogglePhysicsActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ATogglePhysicsActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tATogglePhysicsActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Physics\")\n\tvoid TogglePhysicsSimulation();\n};\n```", "cpp_code": "```cpp\n#include \"TogglePhysicsActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nATogglePhysicsActor::ATogglePhysicsActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetSimulatePhysics(false);\n}\n\nvoid ATogglePhysicsActor::TogglePhysicsSimulation()\n{\n\tif (MeshComponent)\n\t{\n\t\tbool bIsSimulating = MeshComponent->IsSimulatingPhysics();\n\t\tMeshComponent->SetSimulatePhysics(!bIsSimulating);\n\t}\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to notify when a string UPROPERTY is appended.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UStringAppendNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnStringAppended, const FString&, NewString);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UStringAppendNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUStringAppendNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(BlueprintAssignable, Category=\"String\")\n\tFOnStringAppended OnStringAppended;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"String\")\n\tFString MyString;\n\n\tUFUNCTION(BlueprintCallable, Category=\"String\")\n\tvoid AppendToString(const FString& StringToAppend);\n};\n```", "cpp_code": "```cpp\n#include \"UStringAppendNotifierComponent.h\"\n\nUStringAppendNotifierComponent::UStringAppendNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UStringAppendNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UStringAppendNotifierComponent::AppendToString(const FString& StringToAppend)\n{\n\tMyString.Append(StringToAppend);\n\tOnStringAppended.Broadcast(MyString);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float for movement speed, modifiable via a public method.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMovementActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Public method to set movement speed\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid SetMovementSpeed(float NewSpeed);\n\nprivate:\n\t// Movement speed of the actor\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovementActor.h\"\n\n// Sets default values\nAMovementActor::AMovementActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementSpeed = 600.0f; // Default movement speed\n}\n\n// Called when the game starts or when spawned\nvoid AMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\n// Public method to set movement speed\nvoid AMovementActor::SetMovementSpeed(float NewSpeed)\n{\n\tMovementSpeed = NewSpeed;\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind an input that changes an Actor's scale uniformly.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UniformScaleActor.generated.h\"\n\nUCLASS()\nclass AUniformScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAUniformScaleActor();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid ChangeScale(float ScaleDelta);\n\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tfloat ScaleFactor;\n};\n```", "cpp_code": "```cpp\n#include \"UniformScaleActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAUniformScaleActor::AUniformScaleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScaleFactor = 1.0f;\n}\n\nvoid AUniformScaleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"ChangeScale\", this, &AUniformScaleActor::ChangeScale);\n}\n\nvoid AUniformScaleActor::ChangeScale(float ScaleDelta)\n{\n\tFVector NewScale = GetActorScale3D();\n\tNewScale *= (1.0f + ScaleDelta * ScaleFactor);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY integer and a BlueprintCallable function to double its value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DoubleValueActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADoubleValueActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tADoubleValueActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Value\")\n\tvoid DoubleValue();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Value\")\n\tint32 IntegerValue;\n};\n```", "cpp_code": "```cpp\n#include \"DoubleValueActor.h\"\n\nADoubleValueActor::ADoubleValueActor()\n{\n\t// Set default value for the integer\n\tIntegerValue = 0;\n}\n\nvoid ADoubleValueActor::DoubleValue()\n{\n\tIntegerValue *= 2;\n}\n```"}
{"requirement": "Implement a Tick function in a Component to animate its owning Actor's rotation over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"URotateComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API URotateComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tURotateComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"URotateComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nURotateComponent::URotateComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tRotationRate = FRotator(0.f, 10.f, 0.f);\n}\n\nvoid URotateComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotateComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFRotator NewRotation = Owner->GetActorRotation() + (RotationRate * DeltaTime);\n\t\tOwner->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh component, and use OnBeginOverlap to print the overlapping Actor's location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapActor::AOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach static mesh component\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Set up overlap event\n\tStaticMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n\n\t// Example of setting a static mesh (assuming you have a valid asset)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tFVector ActorLocation = OtherActor->GetActorLocation();\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlapping Actor Location: %s\"), *ActorLocation.ToString());\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to reset a FVector UPROPERTY to zero on 'R' key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetVectorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetVectorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAResetVectorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ResetVector();\n\n\tUPROPERTY(EditAnywhere)\n\tFVector ResettableVector;\n};\n```", "cpp_code": "```cpp\n#include \"ResetVectorActor.h\"\n#include \"Components/InputComponent.h\"\n\nAResetVectorActor::AResetVectorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetVectorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AResetVectorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetVectorActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetVector\", IE_Pressed, this, &AResetVectorActor::ResetVector);\n}\n\nvoid AResetVectorActor::ResetVector()\n{\n\tResettableVector = FVector::ZeroVector;\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FString that logs a message whenever its value changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UStringLoggerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UStringLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUStringLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void LogStringChange();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Logging\")\n\tFString LoggedString;\n\n\tUFUNCTION()\n\tvoid OnRep_LoggedString();\n\n\tFString PreviousString;\n};\n```", "cpp_code": "```cpp\n#include \"UStringLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUStringLoggerComponent::UStringLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UStringLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPreviousString = LoggedString;\n}\n\nvoid UStringLoggerComponent::LogStringChange()\n{\n\tif (LoggedString != PreviousString)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"String changed from %s to %s\"), *PreviousString, *LoggedString);\n\t\tPreviousString = LoggedString;\n\t}\n}\n\nvoid UStringLoggerComponent::OnRep_LoggedString()\n{\n\tLogStringChange();\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to apply a damping effect to its velocity over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DampingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADampingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADampingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Damping\")\n\tFVector Velocity;\n\n\tUPROPERTY(EditAnywhere, Category=\"Damping\")\n\tfloat DampingFactor;\n};\n```", "cpp_code": "```cpp\n#include \"DampingActor.h\"\n\nADampingActor::ADampingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tVelocity = FVector(100.f, 0.f, 0.f);\n\tDampingFactor = 0.98f;\n}\n\nvoid ADampingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADampingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Apply damping to the velocity\n\tVelocity *= DampingFactor;\n\n\t// Update the actor's location based on the velocity\n\tFVector NewLocation = GetActorLocation() + Velocity * DeltaTime;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a mesh and attach it to the Actor's root component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyMeshActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAMyMeshActor::AMyMeshActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the mesh component and attach it to the root\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Use ConstructorHelpers to find and load the mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that logs its current forward vector.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoggingActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Logging\")\n\tvoid LogForwardVector() const;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingActor::ALoggingActor()\n{\n\t // Set this actor to call Tick() every frame.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ALoggingActor::LogForwardVector() const\n{\n\tif(GEngine)\n\t{\n\t\tFVector ForwardVector = GetActorForwardVector();\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Forward Vector: %s\"), *ForwardVector.ToString()));\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to continuously update its velocity based on player input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\tvoid MoveForward(float Value);\n\tvoid MoveRight(float Value);\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector Velocity;\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MaxSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMaxSpeed = 600.0f;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!Velocity.IsZero())\n\t{\n\t\tVelocity = Velocity.GetClampedToMaxSize(MaxSpeed);\n\t\tAddActorWorldOffset(Velocity * DeltaTime, true);\n\t}\n}\n\nvoid AMyActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &AMyActor::MoveForward);\n\tPlayerInputComponent->BindAxis(\"MoveRight\", this, &AMyActor::MoveRight);\n}\n\nvoid AMyActor::MoveForward(float Value)\n{\n\tFVector Forward = GetActorForwardVector();\n\tVelocity.X = Value * MaxSpeed;\n}\n\nvoid AMyActor::MoveRight(float Value)\n{\n\tFVector Right = GetActorRightVector();\n\tVelocity.Y = Value * MaxSpeed;\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate to fire when the owning Actor's Y position changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"AYPositionChangeNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnYPositionChanged, float, NewYPosition);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UAYPositionChangeNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUAYPositionChangeNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"EventDispatchers\")\n\tFOnYPositionChanged OnYPositionChanged;\n\nprivate:\n\tfloat LastYPosition;\n};\n```", "cpp_code": "```cpp\n#include \"AYPositionChangeNotifierComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUAYPositionChangeNotifierComponent::UAYPositionChangeNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tLastYPosition = 0.0f;\n}\n\nvoid UAYPositionChangeNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tLastYPosition = Owner->GetActorLocation().Y;\n\t}\n}\n\nvoid UAYPositionChangeNotifierComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tfloat CurrentYPosition = Owner->GetActorLocation().Y;\n\t\tif (!FMath::IsNearlyEqual(CurrentYPosition, LastYPosition))\n\t\t{\n\t\t\tOnYPositionChanged.Broadcast(CurrentYPosition);\n\t\t\tLastYPosition = CurrentYPosition;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to print a message when a specific gamepad button is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GamepadInputActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AGamepadInputActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAGamepadInputActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid OnGamepadButtonPressed();\n};\n```", "cpp_code": "```cpp\n#include \"GamepadInputActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nAGamepadInputActor::AGamepadInputActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AGamepadInputActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AGamepadInputActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"GamepadButton\", IE_Pressed, this, &AGamepadInputActor::OnGamepadButtonPressed);\n}\n\nvoid AGamepadInputActor::OnGamepadButtonPressed()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Gamepad button pressed!\"));\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY array of floats and a BlueprintCallable function to compute the average.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AverageCalculatorActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AAverageCalculatorActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAAverageCalculatorActor();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Values\")\n\tTArray<float> FloatValues;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Calculation\")\n\tfloat CalculateAverage() const;\n};\n```", "cpp_code": "```cpp\n#include \"AverageCalculatorActor.h\"\n\nAAverageCalculatorActor::AAverageCalculatorActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nfloat AAverageCalculatorActor::CalculateAverage() const\n{\n\tif (FloatValues.Num() == 0)\n\t{\n\t\treturn 0.0f;\n\t}\n\n\tfloat Sum = 0.0f;\n\tfor (float Value : FloatValues)\n\t{\n\t\tSum += Value;\n\t}\n\treturn Sum / FloatValues.Num();\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor to log the tags of the overlapping Actors.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOverlapLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLoggerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"GameFramework/Actor.h\"\n\nAOverlapLoggerActor::AOverlapLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapLoggerActor::OnOverlapBegin);\n}\n\nvoid AOverlapLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapLoggerActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tfor (const FName& Tag : OtherActor->Tags)\n\t\t{\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Overlapping Actor Tag: %s\"), *Tag.ToString());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector representing a target location and interpolate towards it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UInterpolatingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UInterpolatingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUInterpolatingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n\tFVector TargetLocation;\n\nprivate:\n\tFVector CurrentLocation;\n\tUPROPERTY(EditAnywhere, Category=\"Interpolation\")\n\tfloat InterpolationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"UInterpolatingComponent.h\"\n\nUInterpolatingComponent::UInterpolatingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tInterpolationSpeed = 1.0f;\n}\n\nvoid UInterpolatingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCurrentLocation = GetOwner()->GetActorLocation();\n}\n\nvoid UInterpolatingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\t\n\tif (!FMath::IsNearlyEqual(CurrentLocation.Size(), TargetLocation.Size(), 1.0f))\n\t{\n\t\tCurrentLocation = FMath::VInterpTo(CurrentLocation, TargetLocation, DeltaTime, InterpolationSpeed);\n\t\tGetOwner()->SetActorLocation(CurrentLocation);\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to adjust its material's emissive strength based on game time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EmissiveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AEmissiveActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAEmissiveActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Emissive\")\n\tfloat EmissiveStrength;\n\n\tUPROPERTY(EditAnywhere, Category = \"Emissive\")\n\tfloat EmissiveMultiplier;\n\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"EmissiveActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAEmissiveActor::AEmissiveActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tEmissiveStrength = 1.0f;\n\tEmissiveMultiplier = 1.0f;\n}\n\nvoid AEmissiveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MeshComponent->GetMaterial(0))\n\t{\n\t\tDynamicMaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t}\n}\n\nvoid AEmissiveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterialInstance)\n\t{\n\t\tfloat GameTime = GetWorld()->GetTimeSeconds();\n\t\tfloat NewEmissiveStrength = EmissiveStrength + FMath::Sin(GameTime) * EmissiveMultiplier;\n\t\tDynamicMaterialInstance->SetScalarParameterValue(\"EmissiveStrength\", NewEmissiveStrength);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh loaded using ConstructorHelpers and simulate physics on it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyPhysicsActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyPhysicsActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyPhysicsActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Mesh\", meta = (AllowPrivateAccess = \"true\"))\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyPhysicsActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyPhysicsActor::AMyPhysicsActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetSimulatePhysics(true);\n}\n\n// Called when the game starts or when spawned\nvoid AMyPhysicsActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyPhysicsActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to fire when a UPROPERTY health variable is modified.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UHealthComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnHealthChangedSignature, float, NewHealth);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UUHealthComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUUHealthComponent();\n\n\tUPROPERTY(BlueprintAssignable, Category = \"Health\")\n\tFOnHealthChangedSignature OnHealthChanged;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Health\")\n\tfloat Health;\n\npublic:\n\tvoid SetHealth(float NewHealth);\n\tfloat GetHealth() const;\n};\n```", "cpp_code": "```cpp\n#include \"UHealthComponent.h\"\n\nUUHealthComponent::UUHealthComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tHealth = 100.0f; // Default health value\n}\n\nvoid UUHealthComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UUHealthComponent::SetHealth(float NewHealth)\n{\n\tif (Health != NewHealth)\n\t{\n\t\tHealth = NewHealth;\n\t\tOnHealthChanged.Broadcast(Health);\n\t}\n}\n\nfloat UUHealthComponent::GetHealth() const\n{\n\treturn Health;\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float representing bounce factor and a method to apply it on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BounceActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ABounceActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tABounceActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Bounce\")\n\tfloat BounceFactor;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"BounceActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nABounceActor::ABounceActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tUStaticMeshComponent* MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->SetNotifyRigidBodyCollision(true);\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ABounceActor::OnHit);\n\n\tBounceFactor = 1.2f;\n}\n\n// Called when the game starts or when spawned\nvoid ABounceActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ABounceActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle collision\nvoid ABounceActor::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tFVector Velocity = GetVelocity();\n\t\tFVector ReflectedVelocity = FMath::GetReflectionVector(Velocity, Hit.Normal);\n\t\tSetActorLocation(GetActorLocation() + ReflectedVelocity * BounceFactor);\n\t}\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind an axis input to control an Actor's vertical movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"VerticalMovementActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AVerticalMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAVerticalMovementActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Movement\", meta = (AllowPrivateAccess = \"true\"))\n\tfloat MovementSpeed;\n\n\t// Function to handle vertical movement\n\tvoid MoveVertical(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"VerticalMovementActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAVerticalMovementActor::AVerticalMovementActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set default movement speed\n\tMovementSpeed = 100.f;\n}\n\n// Called when the game starts or when spawned\nvoid AVerticalMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AVerticalMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid AVerticalMovementActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tcheck(PlayerInputComponent);\n\tPlayerInputComponent->BindAxis(\"MoveVertical\", this, &AVerticalMovementActor::MoveVertical);\n}\n\n// Function to handle vertical movement\nvoid AVerticalMovementActor::MoveVertical(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tFVector NewLocation = GetActorLocation();\n\t\tNewLocation.Z += Value * MovementSpeed * GetWorld()->GetDeltaSeconds();\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY integer for score and a function to increment it by a given value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAScoreActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Score\")\n\tint32 Score;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid IncrementScore(int32 Value);\n};\n```", "cpp_code": "```cpp\n#include \"ScoreActor.h\"\n\n// Sets default values\nAScoreActor::AScoreActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize Score\n\tScore = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AScoreActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AScoreActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid AScoreActor::IncrementScore(int32 Value)\n{\n\tScore += Value;\n}\n```"}
{"requirement": "Implement a Tick function in a Component to simulate a flickering light effect on its owning Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFlickeringLightComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFlickeringLightComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUFlickeringLightComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Flickering\")\n\tfloat MinIntensity;\n\n\tUPROPERTY(EditAnywhere, Category = \"Flickering\")\n\tfloat MaxIntensity;\n\n\tUPROPERTY(EditAnywhere, Category = \"Flickering\")\n\tfloat FlickerSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"UFlickeringLightComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"Math/UnrealMathUtility.h\"\n\nUFlickeringLightComponent::UFlickeringLightComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tMinIntensity = 1000.0f;\n\tMaxIntensity = 5000.0f;\n\tFlickerSpeed = 5.0f;\n}\n\nvoid UFlickeringLightComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFlickeringLightComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tUPointLightComponent* PointLight = Owner->FindComponentByClass<UPointLightComponent>();\n\t\tif (PointLight)\n\t\t{\n\t\t\tfloat NewIntensity = FMath::Lerp(MinIntensity, MaxIntensity, FMath::RandRange(0.0f, 1.0f));\n\t\t\tPointLight->SetIntensity(NewIntensity);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh and use OnBeginOverlap to log a message about the collision details.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionOverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACollisionOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor,\n\t\t\t\t\t\tclass UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,\n\t\t\t\t\t\tbool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACollisionOverlapActor::ACollisionOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionOverlapActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionOverlapActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor,\n\t\t\t\t\t\t\t\t\t\t\tclass UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,\n\t\t\t\t\t\t\t\t\t\t\tbool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (GEngine)\n\t{\n\t\tFString ActorName = OtherActor ? OtherActor->GetName() : TEXT(\"None\");\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Overlap Begin with: %s\"), *ActorName));\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to increase a UPROPERTY integer count whenever the 'E' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyIncrementActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyIncrementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyIncrementActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Counter\")\n\tint32 Count;\n\n\tvoid IncrementCount();\n};\n```", "cpp_code": "```cpp\n#include \"MyIncrementActor.h\"\n#include \"Components/InputComponent.h\"\n\nAMyIncrementActor::AMyIncrementActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCount = 0;\n}\n\nvoid AMyIncrementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyIncrementActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"IncreaseCount\", IE_Pressed, this, &AMyIncrementActor::IncrementCount);\n}\n\nvoid AMyIncrementActor::IncrementCount()\n{\n\tCount++;\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FString to store a log message, and a method to print it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULogMessageComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULogMessageComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tULogMessageComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Log\")\n\tFString LogMessage;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Log\")\n\tvoid PrintLogMessage() const;\n};\n```", "cpp_code": "```cpp\n#include \"ULogMessageComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nULogMessageComponent::ULogMessageComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid ULogMessageComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ULogMessageComponent::PrintLogMessage() const\n{\n\tif (!LogMessage.IsEmpty())\n\t{\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Log Message: %s\"), *LogMessage);\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Log Message is empty.\"));\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to rotate its mesh around its local Z-axis.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nARotatingMeshActor::ARotatingMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRotationSpeed = 45.0f; // Degrees per second\n}\n\nvoid ARotatingMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = MeshComponent->GetRelativeRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tMeshComponent->SetRelativeRotation(NewRotation);\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a texture and apply it to its material upon initialization.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TextureLoadingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ATextureLoadingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tATextureLoadingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"TextureLoadingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nATextureLoadingActor::ATextureLoadingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Load a static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Load a material\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/StarterContent/Materials/M_Basic_Wall.M_Basic_Wall\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MaterialAsset.Object, MeshComponent);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n\n\t// Load a texture\n\tstatic ConstructorHelpers::FObjectFinder<UTexture> TextureAsset(TEXT(\"/Game/StarterContent/Textures/T_Brick_Clay_Beige_D.T_Brick_Clay_Beige_D\"));\n\tif (TextureAsset.Succeeded() && DynamicMaterialInstance)\n\t{\n\t\tDynamicMaterialInstance->SetTextureParameterValue(\"BaseTexture\", TextureAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ATextureLoadingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATextureLoadingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that returns its current scale as a string.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAScaleActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Scale\")\n\tFString GetCurrentScaleAsString() const;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleActor.h\"\n\nAScaleActor::AScaleActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nFString AScaleActor::GetCurrentScaleAsString() const\n{\n\tFVector Scale = GetActorScale3D();\n\treturn FString::Printf(TEXT(\"X: %f, Y: %f, Z: %f\"), Scale.X, Scale.Y, Scale.Z);\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to modify its material color based on its distance from a point.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADistanceColorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector TargetPoint;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MaxDistance;\n\n\tUMaterialInstanceDynamic* DynamicMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"DistanceColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nADistanceColorActor::ADistanceColorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"Material'/Game/StarterContent/Materials/M_Basic_Wall.M_Basic_Wall'\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterial = UMaterialInstanceDynamic::Create(MaterialAsset.Object, this);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterial);\n\t}\n\n\tTargetPoint = FVector(0.0f, 0.0f, 0.0f);\n\tMaxDistance = 1000.0f;\n}\n\nvoid ADistanceColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADistanceColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterial)\n\t{\n\t\tfloat Distance = FVector::Dist(TargetPoint, GetActorLocation());\n\t\tfloat LerpValue = FMath::Clamp(Distance / MaxDistance, 0.0f, 1.0f);\n\t\tFLinearColor NewColor = FLinearColor::LerpUsingHSV(FLinearColor::Green, FLinearColor::Red, LerpValue);\n\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate to notify when the owning Actor's velocity changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"AVelocityChangeNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnVelocityChanged, FVector, NewVelocity);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UVelocityChangeNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUVelocityChangeNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Velocity\")\n\tFOnVelocityChanged OnVelocityChanged;\n\nprivate:\n\tFVector PreviousVelocity;\n};\n```", "cpp_code": "```cpp\n#include \"AVelocityChangeNotifierComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUVelocityChangeNotifierComponent::UVelocityChangeNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UVelocityChangeNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tPreviousVelocity = Owner->GetVelocity();\n\t}\n}\n\nvoid UVelocityChangeNotifierComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector CurrentVelocity = Owner->GetVelocity();\n\t\tif (!CurrentVelocity.Equals(PreviousVelocity))\n\t\t{\n\t\t\tOnVelocityChanged.Broadcast(CurrentVelocity);\n\t\t\tPreviousVelocity = CurrentVelocity;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to trigger a function that toggles a UPROPERTY boolean state.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ToggleBoolean();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Toggle\", meta=(AllowPrivateAccess=\"true\"))\n\tbool bToggleState;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAToggleActor::AToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbToggleState = false;\n}\n\nvoid AToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ToggleAction\", IE_Pressed, this, &AToggleActor::ToggleBoolean);\n}\n\nvoid AToggleActor::ToggleBoolean()\n{\n\tbToggleState = !bToggleState;\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY for a string name and a BlueprintCallable function to change it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"MyActor\")\n\tvoid SetName(const FString& NewName);\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MyActor\")\n\tFString Name;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tName = TEXT(\"DefaultName\");\n}\n\nvoid AMyActor::SetName(const FString& NewName)\n{\n\tName = NewName;\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor to apply a force to the overlapping Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyOverlapActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMesh;\n\n\tUFUNCTION()\n\tvoid OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUPROPERTY(EditAnywhere)\n\tfloat ForceMagnitude;\n};\n```", "cpp_code": "```cpp\n#include \"MyOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Character.h\"\n\n// Sets default values\nAMyOverlapActor::AMyOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMesh\"));\n\tRootComponent = StaticMesh;\n\n\tStaticMesh->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tStaticMesh->OnComponentBeginOverlap.AddDynamic(this, &AMyOverlapActor::OnBeginOverlap);\n\n\tForceMagnitude = 1000.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMyOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyOverlapActor::OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && OtherActor != this && OtherComp)\n\t{\n\t\tUPrimitiveComponent* OtherPrimitive = Cast<UPrimitiveComponent>(OtherComp);\n\t\tif (OtherPrimitive && OtherPrimitive->IsSimulatingPhysics())\n\t\t{\n\t\t\tFVector ForceDirection = OtherActor->GetActorLocation() - GetActorLocation();\n\t\t\tForceDirection.Normalize();\n\t\t\tOtherPrimitive->AddForce(ForceDirection * ForceMagnitude, NAME_None, true);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector representing a direction, and normalize it each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UNormalizingDirectionComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UNormalizingDirectionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUNormalizingDirectionComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Direction\")\n\tFVector Direction;\n};\n```", "cpp_code": "```cpp\n#include \"UNormalizingDirectionComponent.h\"\n\nUNormalizingDirectionComponent::UNormalizingDirectionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tDirection = FVector(1.0f, 0.0f, 0.0f); // Default direction\n}\n\nvoid UNormalizingDirectionComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UNormalizingDirectionComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (!Direction.IsZero())\n\t{\n\t\tDirection.Normalize();\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to change its pitch gradually as time progresses.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PitchChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APitchChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAPitchChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Pitch\")\n\tfloat PitchChangeRate;\n};\n```", "cpp_code": "```cpp\n#include \"PitchChangeActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAPitchChangeActor::APitchChangeActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPitchChangeRate = 10.0f; // Default pitch change rate per second\n}\n\n// Called when the game starts or when spawned\nvoid APitchChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid APitchChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Pitch += PitchChangeRate * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an Actor with a mesh and a BlueprintCallable function to toggle its visibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleVisibilityActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visibility\")\n\tvoid ToggleVisibility();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\t// Initialize the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set a default static mesh (assuming a mesh exists at this path)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tif (MeshComponent)\n\t{\n\t\tbool bIsVisible = MeshComponent->IsVisible();\n\t\tMeshComponent->SetVisibility(!bIsVisible);\n\t}\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to fire when a UPROPERTY float is halved.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFloatHalvedComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnFloatHalved);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatHalvedComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUFloatHalvedComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Float\")\n\tfloat TargetFloat;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Event\")\n\tFOnFloatHalved OnFloatHalved;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Float\")\n\tvoid HalveFloat();\n};\n```", "cpp_code": "```cpp\n#include \"UFloatHalvedComponent.h\"\n\nUFloatHalvedComponent::UFloatHalvedComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UFloatHalvedComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFloatHalvedComponent::HalveFloat()\n{\n\tTargetFloat /= 2.0f;\n\tOnFloatHalved.Broadcast();\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float representing a rotation rate, applied each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationRate = 45.0f; // Example default value\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationRate * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind a key to reset an Actor's velocity to zero.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"ResetVelocityActor.generated.h\"\n\nUCLASS()\nclass AResetVelocityActor : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResetVelocityActor();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid ResetVelocity();\n};\n```", "cpp_code": "```cpp\n#include \"ResetVelocityActor.h\"\n#include \"GameFramework/InputSettings.h\"\n#include \"Components/InputComponent.h\"\n\nAResetVelocityActor::AResetVelocityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetVelocityActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetVelocity\", IE_Pressed, this, &AResetVelocityActor::ResetVelocity);\n}\n\nvoid AResetVelocityActor::ResetVelocity()\n{\n\tif (UCharacterMovementComponent* MovementComponent = GetCharacterMovement())\n\t{\n\t\tMovementComponent->Velocity = FVector::ZeroVector;\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY FVector and a function to log its current position.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyPositionLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyPositionLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyPositionLoggerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to log the current position\n\tUFUNCTION()\n\tvoid LogCurrentPosition();\n\n\t// FVector to hold the position\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Position\")\n\tFVector CurrentPosition;\n};\n```", "cpp_code": "```cpp\n#include \"MyPositionLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAMyPositionLoggerActor::AMyPositionLoggerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyPositionLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Initialize CurrentPosition with the Actor's initial position\n\tCurrentPosition = GetActorLocation();\n}\n\n// Called every frame\nvoid AMyPositionLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update CurrentPosition each frame\n\tCurrentPosition = GetActorLocation();\n}\n\n// Function to log the current position\nvoid AMyPositionLoggerActor::LogCurrentPosition()\n{\n\t// Log the current position to the output log\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Current Position: %s\"), *CurrentPosition.ToString()));\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in a Component to transition its owning Actor's material over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UTransitionMaterialComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTransitionMaterialComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUTransitionMaterialComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\tfloat TransitionProgress;\n\n\tUPROPERTY(EditAnywhere, Category=\"Transition\")\n\tfloat TransitionDuration;\n};\n```", "cpp_code": "```cpp\n#include \"UTransitionMaterialComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nUTransitionMaterialComponent::UTransitionMaterialComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTransitionProgress = 0.0f;\n\tTransitionDuration = 5.0f; // default transition duration\n}\n\nvoid UTransitionMaterialComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUStaticMeshComponent* MeshComponent = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tUMaterialInterface* Material = MeshComponent->GetMaterial(0);\n\t\t\tDynamicMaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamicFromMaterial(0, Material);\n\t\t}\n\t}\n}\n\nvoid UTransitionMaterialComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (DynamicMaterialInstance && TransitionProgress < 1.0f)\n\t{\n\t\tTransitionProgress += DeltaTime / TransitionDuration;\n\t\tDynamicMaterialInstance->SetScalarParameterValue(TEXT(\"BlendFactor\"), FMath::Clamp(TransitionProgress, 0.0f, 1.0f));\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh component and a function to print a message when it begins play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAMyStaticMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Optionally set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUE_LOG(LogTemp, Warning, TEXT(\"AMyStaticMeshActor has begun play.\"));\n}\n```"}
{"requirement": "Set up an input binding in an Actor to call a function that toggles between two UPROPERTY states.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Toggle\")\n\tbool bIsToggled;\n\n\tvoid ToggleState();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAToggleActor::AToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tbIsToggled = false;\n}\n\nvoid AToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"ToggleInput\", IE_Pressed, this, &AToggleActor::ToggleState);\n\t}\n}\n\nvoid AToggleActor::ToggleState()\n{\n\tbIsToggled = !bIsToggled;\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY integer representing a tick counter that resets every 100 ticks.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TickCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTickCounterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUTickCounterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Tick\")\n\tint32 TickCounter;\n};\n```", "cpp_code": "```cpp\n#include \"TickCounterComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUTickCounterComponent::UTickCounterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTickCounter = 0;\n}\n\nvoid UTickCounterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UTickCounterComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTickCounter++;\n\tif (TickCounter >= 100)\n\t{\n\t\tTickCounter = 0;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to always face towards the player character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FacePlayerActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AFacePlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAFacePlayerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAActor* PlayerCharacter;\n};\n```", "cpp_code": "```cpp\n#include \"FacePlayerActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Actor.h\"\n\nAFacePlayerActor::AFacePlayerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AFacePlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);\n}\n\nvoid AFacePlayerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerCharacter)\n\t{\n\t\tFVector Direction = PlayerCharacter->GetActorLocation() - GetActorLocation();\n\t\tDirection.Z = 0; // Ignore Z-axis to only rotate on the X-Y plane\n\t\tFRotator NewRotation = Direction.Rotation();\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a mesh and set it as the root component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyMeshActor.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAMyMeshActor::AMyMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\n\t// Set the mesh component as the root component\n\tRootComponent = MeshComponent;\n\n\t// Find and load the mesh asset\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/MeshAsset.MeshAsset\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that calculates and logs its speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Speed\")\n\tvoid CalculateAndLogSpeed();\n\nprivate:\n\tFVector PreviousLocation;\n\tfloat Speed;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nASpeedActor::ASpeedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSpeed = 0.0f;\n}\n\nvoid ASpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPreviousLocation = GetActorLocation();\n}\n\nvoid ASpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tCalculateAndLogSpeed();\n}\n\nvoid ASpeedActor::CalculateAndLogSpeed()\n{\n\tFVector CurrentLocation = GetActorLocation();\n\tfloat Distance = FVector::Dist(CurrentLocation, PreviousLocation);\n\tSpeed = Distance / GetWorld()->GetDeltaSeconds();\n\tUE_LOG(LogTemp, Log, TEXT(\"Speed: %f units/s\"), Speed);\n\tPreviousLocation = CurrentLocation;\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to create a breathing effect by adjusting its scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BreathingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ABreathingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tABreathingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Breathing\")\n\tfloat BreathingSpeed;\n\n\tUPROPERTY(EditAnywhere, Category=\"Breathing\")\n\tfloat BreathingScaleAmplitude;\n\n\tFVector OriginalScale;\n};\n```", "cpp_code": "```cpp\n#include \"BreathingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nABreathingActor::ABreathingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tBreathingSpeed = 1.0f;\n\tBreathingScaleAmplitude = 0.1f;\n}\n\n// Called when the game starts or when spawned\nvoid ABreathingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tOriginalScale = GetActorScale3D();\n}\n\n// Called every frame\nvoid ABreathingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat ScaleOffset = FMath::Sin(GetWorld()->GetTimeSeconds() * BreathingSpeed) * BreathingScaleAmplitude;\n\tSetActorScale3D(OriginalScale + FVector(ScaleOffset, ScaleOffset, ScaleOffset));\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that fires when the owning Actor's Z position changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UPositionChangeComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnZPositionChanged);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UPositionChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUPositionChangeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Position\")\n\tFOnZPositionChanged OnZPositionChanged;\n\nprivate:\n\tfloat LastZPosition;\n};\n```", "cpp_code": "```cpp\n#include \"UPositionChangeComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUPositionChangeComponent::UPositionChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UPositionChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tLastZPosition = Owner->GetActorLocation().Z;\n\t}\n}\n\nvoid UPositionChangeComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tfloat CurrentZPosition = Owner->GetActorLocation().Z;\n\t\tif (!FMath::IsNearlyEqual(CurrentZPosition, LastZPosition))\n\t\t{\n\t\t\tOnZPositionChanged.Broadcast();\n\t\t\tLastZPosition = CurrentZPosition;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to print a message whenever the 'X' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintMessageActor.generated.h\"\n\nUCLASS()\nclass APrintMessageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPrintMessageActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid PrintMessage();\n};\n```", "cpp_code": "```cpp\n#include \"PrintMessageActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAPrintMessageActor::APrintMessageActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APrintMessageActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APrintMessageActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"PrintMessage\", IE_Pressed, this, &APrintMessageActor::PrintMessage);\n\t}\n}\n\nvoid APrintMessageActor::PrintMessage()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"The 'X' key was pressed!\"));\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY array of integers and a function to reverse its order.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReversingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AReversingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAReversingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Array\")\n\tvoid ReverseArray();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Array\")\n\tTArray<int32> IntArray;\n};\n```", "cpp_code": "```cpp\n#include \"ReversingActor.h\"\n\nAReversingActor::AReversingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AReversingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AReversingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AReversingActor::ReverseArray()\n{\n\tIntArray.Reverse();\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor to log both Actors' world positions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tAOverlapLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION()\n\tvoid OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLoggerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"ConstructorHelpers.h\"\n\nAOverlapLoggerActor::AOverlapLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetGenerateOverlapEvents(true);\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapLoggerActor::OnOverlapBegin);\n}\n\nvoid AOverlapLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapLoggerActor::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OverlappedActor && OtherActor && OverlappedActor != OtherActor)\n\t{\n\t\tFVector OverlappedActorLocation = OverlappedActor->GetActorLocation();\n\t\tFVector OtherActorLocation = OtherActor->GetActorLocation();\n\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Overlapped Actor Location: %s\"), *OverlappedActorLocation.ToString());\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Other Actor Location: %s\"), *OtherActorLocation.ToString());\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector that applies as a force to the owning Actor each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UForceApplierComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UForceApplierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUForceApplierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Force\")\n\tFVector AppliedForce;\n};\n```", "cpp_code": "```cpp\n#include \"UForceApplierComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUForceApplierComponent::UForceApplierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tAppliedForce = FVector::ZeroVector;\n}\n\nvoid UForceApplierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UForceApplierComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->AddForce(AppliedForce);\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to adjust its yaw based on the distance to the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YawAdjusterActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AYawAdjusterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAYawAdjusterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"YawAdjustment\")\n\tfloat YawSpeed;\n\n\tUPROPERTY(EditAnywhere, Category = \"YawAdjustment\")\n\tfloat MaxDistance;\n\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"YawAdjusterActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAYawAdjusterActor::AYawAdjusterActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tYawSpeed = 10.0f;\n\tMaxDistance = 1000.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AYawAdjusterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Find the player actor\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\n// Called every frame\nvoid AYawAdjusterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerActor)\n\t{\n\t\t// Calculate the distance to the player\n\t\tfloat DistanceToPlayer = FVector::Dist(PlayerActor->GetActorLocation(), GetActorLocation());\n\n\t\tif (DistanceToPlayer <= MaxDistance)\n\t\t{\n\t\t\t// Calculate the yaw adjustment based on the distance\n\t\t\tfloat YawAdjustment = YawSpeed * (1.0f - (DistanceToPlayer / MaxDistance)) * DeltaTime;\n\n\t\t\t// Apply the yaw adjustment to the actor\n\t\t\tFRotator NewRotation = GetActorRotation();\n\t\t\tNewRotation.Yaw += YawAdjustment;\n\t\t\tSetActorRotation(NewRotation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh using ConstructorHelpers and apply a dynamic material instance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADynamicMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADynamicMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nADynamicMeshActor::ADynamicMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/StarterContent/Materials/M_Basic_Wall.M_Basic_Wall\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MaterialAsset.Object, MeshComponent);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\nvoid ADynamicMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADynamicMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to fire when a float UPROPERTY is reset.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFloatResetComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FFloatResetDelegate, float, NewValue);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatResetComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFloatResetComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"FloatReset\")\n\tvoid ResetFloat();\n\n\tUPROPERTY(BlueprintAssignable, Category=\"FloatReset\")\n\tFFloatResetDelegate OnFloatReset;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"FloatReset\")\n\tfloat FloatValue;\n};\n```", "cpp_code": "```cpp\n#include \"UFloatResetComponent.h\"\n\nUFloatResetComponent::UFloatResetComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tFloatValue = 0.0f;\n}\n\nvoid UFloatResetComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFloatResetComponent::ResetFloat()\n{\n\tFloatValue = 0.0f;\n\tOnFloatReset.Broadcast(FloatValue);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float speed and a method to cap its value within a range.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedCapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedCapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedCapActor();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat Speed;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid CapSpeed(float MinSpeed, float MaxSpeed);\n};\n```", "cpp_code": "```cpp\n#include \"SpeedCapActor.h\"\n\nASpeedCapActor::ASpeedCapActor()\n{\n\t// Set default speed value\n\tSpeed = 0.0f;\n}\n\nvoid ASpeedCapActor::CapSpeed(float MinSpeed, float MaxSpeed)\n{\n\tif (Speed < MinSpeed)\n\t{\n\t\tSpeed = MinSpeed;\n\t}\n\telse if (Speed > MaxSpeed)\n\t{\n\t\tSpeed = MaxSpeed;\n\t}\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind a key to change an Actor's material at runtime.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAChangeMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n\n\tvoid ChangeMaterial();\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAChangeMaterialActor::AChangeMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AChangeMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMaterialActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AChangeMaterialActor::ChangeMaterial);\n}\n\nvoid AChangeMaterialActor::ChangeMaterial()\n{\n\tif (MeshComponent && NewMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY integer score and a function to increase it by a specific value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAScoreActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid IncreaseScore(int32 Value);\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Score\")\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreActor.h\"\n\n// Sets default values\nAScoreActor::AScoreActor()\n{\n\t// Initialize score to 0\n\tScore = 0;\n}\n\nvoid AScoreActor::IncreaseScore(int32 Value)\n{\n\tScore += Value;\n}\n```"}
{"requirement": "Implement a Tick function in a Component to animate the owning Actor's position along the X-axis.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UAnimatePositionComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UAnimatePositionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUAnimatePositionComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tfloat Speed = 100.0f; // Speed of movement along the X-axis\n};\n```", "cpp_code": "```cpp\n#include \"UAnimatePositionComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUAnimatePositionComponent::UAnimatePositionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UAnimatePositionComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UAnimatePositionComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector NewLocation = Owner->GetActorLocation();\n\t\tNewLocation.X += Speed * DeltaTime;\n\t\tOwner->SetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh and an OnBeginOverlap event to apply a new material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialOverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMesh;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"ConstructorHelpers.h\"\n\nAMaterialOverlapActor::AMaterialOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMesh\"));\n\tRootComponent = StaticMesh;\n\n\tStaticMesh->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tStaticMesh->OnComponentBeginOverlap.AddDynamic(this, &AMaterialOverlapActor::OnOverlapBegin);\n\n\t// Set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMesh->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AMaterialOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMaterialOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMaterialOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (NewMaterial && OtherActor != this)\n\t{\n\t\tStaticMesh->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to reset a float UPROPERTY value to its default on 'K' press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetFloatActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetFloatActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAResetFloatActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (AllowPrivateAccess = \"true\"))\n\tfloat ResettableFloat;\n\n\tUPROPERTY(EditDefaultsOnly, Category = \"Defaults\")\n\tfloat DefaultFloatValue;\n\n\tvoid ResetFloatToDefault();\n};\n```", "cpp_code": "```cpp\n#include \"ResetFloatActor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAResetFloatActor::AResetFloatActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default values\n\tDefaultFloatValue = 100.0f; // Example default value\n\tResettableFloat = DefaultFloatValue;\n}\n\n// Called when the game starts or when spawned\nvoid AResetFloatActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AResetFloatActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetFloatActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetFloat\", IE_Pressed, this, &AResetFloatActor::ResetFloatToDefault);\n}\n\nvoid AResetFloatActor::ResetFloatToDefault()\n{\n\tResettableFloat = DefaultFloatValue;\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FString to store a custom message, updated each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UCustomMessageComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomMessageComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUCustomMessageComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Custom\", meta = (AllowPrivateAccess = \"true\"))\n\tFString CustomMessage;\n};\n```", "cpp_code": "```cpp\n#include \"UCustomMessageComponent.h\"\n\nUCustomMessageComponent::UCustomMessageComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCustomMessage = TEXT(\"Initial Message\");\n}\n\nvoid UCustomMessageComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Initialization or other BeginPlay logic\n}\n\nvoid UCustomMessageComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\t\n\t// Update CustomMessage each tick\n\tCustomMessage = FString::Printf(TEXT(\"Updated Message at Time: %f\"), GetWorld()->GetTimeSeconds());\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to apply a gradual rotation based on game time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Set default rotation rate\n\tRotationRate = FRotator(0.f, 20.f, 0.f);\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Gradually rotate the actor\n\tFRotator NewRotation = GetActorRotation() + (RotationRate * DeltaTime);\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a sound asset and play it upon receiving input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundActor.generated.h\"\n\nUCLASS()\nclass ASoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY()\n\tUSoundBase* SoundToPlay;\n\n\tvoid PlaySound();\n};\n```", "cpp_code": "```cpp\n#include \"SoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nASoundActor::ASoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tstatic ConstructorHelpers::FObjectFinder<USoundBase> SoundAsset(TEXT(\"/Game/Audio/MySound.MySound\"));\n\tif (SoundAsset.Succeeded())\n\t{\n\t\tSoundToPlay = SoundAsset.Object;\n\t}\n}\n\nvoid ASoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"PlaySound\", IE_Pressed, this, &ASoundActor::PlaySound);\n\t}\n}\n\nvoid ASoundActor::PlaySound()\n{\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that returns the distance to another Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADistanceActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Utilities\")\n\tfloat GetDistanceToActor(AActor* OtherActor) const;\n};\n```", "cpp_code": "```cpp\n#include \"DistanceActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nADistanceActor::ADistanceActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nfloat ADistanceActor::GetDistanceToActor(AActor* OtherActor) const\n{\n\tif (!OtherActor)\n\t{\n\t\treturn 0.0f;\n\t}\n\n\treturn FVector::Dist(this->GetActorLocation(), OtherActor->GetActorLocation());\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to pulse its material's emissive color over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EmissivePulseActor.generated.h\"\n\nUCLASS()\nclass AEmissivePulseActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAEmissivePulseActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tUPROPERTY(EditAnywhere, Category = \"Pulse\")\n\tfloat PulseSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"EmissivePulseActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAEmissivePulseActor::AEmissivePulseActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tPulseSpeed = 2.0f;\n}\n\nvoid AEmissivePulseActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MeshComponent)\n\t{\n\t\tDynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t}\n}\n\nvoid AEmissivePulseActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterial)\n\t{\n\t\tfloat EmissiveStrength = (FMath::Sin(GetWorld()->TimeSeconds * PulseSpeed) + 1.0f) * 0.5f;\n\t\tDynamicMaterial->SetScalarParameterValue(\"EmissiveStrength\", EmissiveStrength);\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate that broadcasts when the owning Actor's visibility toggles.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"AToggleVisibilityComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnVisibilityToggled, bool, bIsVisible);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UAToggleVisibilityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUAToggleVisibilityComponent();\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Toggle\")\n\tFOnVisibilityToggled OnVisibilityToggled;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tvoid HandleVisibilityChange();\n\tbool bLastVisibilityState;\n};\n```", "cpp_code": "```cpp\n#include \"AToggleVisibilityComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUAToggleVisibilityComponent::UAToggleVisibilityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UAToggleVisibilityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tbLastVisibilityState = Owner->IsVisible();\n\t\tOwner->OnActorBeginCursorOver.AddDynamic(this, &UAToggleVisibilityComponent::HandleVisibilityChange);\n\t\tOwner->OnActorEndCursorOver.AddDynamic(this, &UAToggleVisibilityComponent::HandleVisibilityChange);\n\t}\n}\n\nvoid UAToggleVisibilityComponent::HandleVisibilityChange()\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tbool bCurrentVisibilityState = Owner->IsVisible();\n\t\tif (bCurrentVisibilityState != bLastVisibilityState)\n\t\t{\n\t\t\tbLastVisibilityState = bCurrentVisibilityState;\n\t\t\tOnVisibilityToggled.Broadcast(bCurrentVisibilityState);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to print a message when a specific mouse button is clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseClickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMouseClickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMouseClickActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid OnMouseClick();\n};\n```", "cpp_code": "```cpp\n#include \"MouseClickActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAMouseClickActor::AMouseClickActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMouseClickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMouseClickActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMouseClickActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"LeftMouseClick\", IE_Pressed, this, &AMouseClickActor::OnMouseClick);\n\t}\n}\n\nvoid AMouseClickActor::OnMouseClick()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Mouse button clicked!\"));\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY array of floats and a function to calculate their sum.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyFloatArrayActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyFloatArrayActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMyFloatArrayActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Array of floats\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Float Array\")\n\tTArray<float> FloatArray;\n\n\t// Function to calculate sum of floats\n\tUFUNCTION(BlueprintCallable, Category = \"Float Array\")\n\tfloat CalculateSum() const;\n};\n```", "cpp_code": "```cpp\n#include \"MyFloatArrayActor.h\"\n\n// Sets default values\nAMyFloatArrayActor::AMyFloatArrayActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyFloatArrayActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Function to calculate sum of floats\nfloat AMyFloatArrayActor::CalculateSum() const\n{\n\tfloat Sum = 0.0f;\n\tfor (float Value : FloatArray)\n\t{\n\t\tSum += Value;\n\t}\n\treturn Sum;\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor to reverse its movement direction upon collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReverseMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AReverseMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAReverseMovementActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tFVector MovementDirection;\n\n\tUFUNCTION()\n\tvoid OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor);\n};\n```", "cpp_code": "```cpp\n#include \"ReverseMovementActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAReverseMovementActor::AReverseMovementActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMovementDirection = FVector(1.0f, 0.0f, 0.0f);\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AReverseMovementActor::OnBeginOverlap);\n}\n\n// Called when the game starts or when spawned\nvoid AReverseMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AReverseMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation() + (MovementDirection * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n\nvoid AReverseMovementActor::OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tMovementDirection *= -1.0f;\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector representing a velocity, updated based on user input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UVelocityComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UVelocityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUVelocityComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector Velocity;\n\n\tvoid UpdateVelocity(float DeltaTime);\n\nprivate:\n\tvoid MoveForward(float Value);\n\tvoid MoveRight(float Value);\n\n\tFVector InputDirection;\n};\n```", "cpp_code": "```cpp\n#include \"UVelocityComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\nUVelocityComponent::UVelocityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UVelocityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->InputComponent = NewObject<UInputComponent>(Owner);\n\t\tOwner->InputComponent->RegisterComponent();\n\t\tSetupPlayerInputComponent(Owner->InputComponent);\n\t}\n}\n\nvoid UVelocityComponent::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &UVelocityComponent::MoveForward);\n\t\tPlayerInputComponent->BindAxis(\"MoveRight\", this, &UVelocityComponent::MoveRight);\n\t}\n}\n\nvoid UVelocityComponent::MoveForward(float Value)\n{\n\tInputDirection.X = Value;\n}\n\nvoid UVelocityComponent::MoveRight(float Value)\n{\n\tInputDirection.Y = Value;\n}\n\nvoid UVelocityComponent::UpdateVelocity(float DeltaTime)\n{\n\tVelocity = InputDirection * 100.0f;  // Scale the input for velocity\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to adjust its pitch based on its distance from an object.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceBasedPitchActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceBasedPitchActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADistanceBasedPitchActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tAActor* TargetActor;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid AdjustPitchBasedOnDistance();\n};\n```", "cpp_code": "```cpp\n#include \"DistanceBasedPitchActor.h\"\n#include \"Engine/World.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nADistanceBasedPitchActor::ADistanceBasedPitchActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\nvoid ADistanceBasedPitchActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADistanceBasedPitchActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tAdjustPitchBasedOnDistance();\n}\n\nvoid ADistanceBasedPitchActor::AdjustPitchBasedOnDistance()\n{\n\tif (TargetActor)\n\t{\n\t\tfloat Distance = FVector::Dist(GetActorLocation(), TargetActor->GetActorLocation());\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Pitch = FMath::Clamp(Distance, 0.0f, 90.0f); // Example: Clamping pitch based on distance\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh and a BlueprintCallable function to switch between two materials.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialSwitchActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialSwitchActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialSwitchActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Material\")\n\tvoid SwitchMaterial();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Material\")\n\tUMaterialInterface* Material1;\n\n\tUPROPERTY(EditAnywhere, Category = \"Material\")\n\tUMaterialInterface* Material2;\n\n\tbool bUseFirstMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialSwitchActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nAMaterialSwitchActor::AMaterialSwitchActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tbUseFirstMaterial = true;\n}\n\nvoid AMaterialSwitchActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Material1 != nullptr)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n}\n\nvoid AMaterialSwitchActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMaterialSwitchActor::SwitchMaterial()\n{\n\tif (bUseFirstMaterial && Material2 != nullptr)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material2);\n\t}\n\telse if (!bUseFirstMaterial && Material1 != nullptr)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n\n\tbUseFirstMaterial = !bUseFirstMaterial;\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to fire when a UPROPERTY health value decreases.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UHealthComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnHealthChanged);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UHealthComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUHealthComponent();\n\n\tUPROPERTY(BlueprintAssignable, Category=\"Health\")\n\tFOnHealthChanged OnHealthChanged;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat Health;\n\n\tUFUNCTION()\n\tvoid DecreaseHealth(float Amount);\n};\n```", "cpp_code": "```cpp\n#include \"UHealthComponent.h\"\n\nUHealthComponent::UHealthComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tHealth = 100.0f;\n}\n\nvoid UHealthComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UHealthComponent::DecreaseHealth(float Amount)\n{\n\tfloat OldHealth = Health;\n\tHealth = FMath::Clamp(Health - Amount, 0.0f, 100.0f);\n\tif (Health < OldHealth)\n\t{\n\t\tOnHealthChanged.Broadcast();\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float for jump strength and a method to apply it on input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"JumpActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AJumpActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAJumpActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUFUNCTION()\n\tvoid ApplyJump();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Jump\")\n\tfloat JumpStrength;\n};\n```", "cpp_code": "```cpp\n#include \"JumpActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAJumpActor::AJumpActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tJumpStrength = 600.0f; // Default jump strength value\n}\n\nvoid AJumpActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AJumpActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AJumpActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, &AJumpActor::ApplyJump);\n}\n\nvoid AJumpActor::ApplyJump()\n{\n\tif (ACharacter* Character = Cast<ACharacter>(GetOwner()))\n\t{\n\t\tCharacter->LaunchCharacter(FVector(0, 0, JumpStrength), false, false);\n\t}\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind an axis input to control an Actor's yaw rotation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"AYawControlPawn.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AYawControlPawn : public APawn\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this pawn's properties\n\tAYawControlPawn();\n\nprotected:\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to handle the yaw input\n\tvoid Turn(float Value);\n\n\t// Mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"AYawControlPawn.h\"\n#include \"Components/InputComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAYawControlPawn::AYawControlPawn()\n{\n\t// Set this pawn to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Optionally set a default mesh (Replace with your path)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called to bind functionality to input\nvoid AYawControlPawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tsuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the Turn function to the \"Turn\" axis\n\tPlayerInputComponent->BindAxis(\"Turn\", this, &AYawControlPawn::Turn);\n}\n\n// Function to handle the yaw input\nvoid AYawControlPawn::Turn(float Value)\n{\n\tif (FMath::Abs(Value) > KINDA_SMALL_NUMBER)\n\t{\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Yaw += Value;\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY integer for health and a function to reduce it over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAHealthActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tint32 Health;\n\n\tvoid ReduceHealth(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n\nAHealthActor::AHealthActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHealth = 100;\n}\n\nvoid AHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tReduceHealth(DeltaTime);\n}\n\nvoid AHealthActor::ReduceHealth(float DeltaTime)\n{\n\tHealth -= FMath::FloorToInt(DeltaTime * 10); // Reduces health over time\n\tif (Health < 0)\n\t{\n\t\tHealth = 0;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in a Component to simulate a lighting effect on the owning Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULightingEffectComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULightingEffectComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this component's properties\n\tULightingEffectComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tfloat LightIntensity;\n\tfloat LightChangeRate;\n};\n```", "cpp_code": "```cpp\n#include \"ULightingEffectComponent.h\"\n\n// Sets default values for this component's properties\nULightingEffectComponent::ULightingEffectComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tLightIntensity = 0.0f;\n\tLightChangeRate = 100.0f;\n}\n\n// Called when the game starts\nvoid ULightingEffectComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ULightingEffectComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Simulate a pulsing light effect\n\tLightIntensity += LightChangeRate * DeltaTime;\n\tif (LightIntensity > 300.0f || LightIntensity < 0.0f)\n\t{\n\t\tLightChangeRate = -LightChangeRate;\n\t}\n\n\t// Assuming the Owner has a PointLightComponent\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tTArray<UActorComponent*> Components = Owner->GetComponentsByClass(UPointLightComponent::StaticClass());\n\t\tfor (UActorComponent* Component : Components)\n\t\t{\n\t\t\tUPointLightComponent* LightComponent = Cast<UPointLightComponent>(Component);\n\t\t\tif (LightComponent)\n\t\t\t{\n\t\t\t\tLightComponent->SetIntensity(LightIntensity);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh and use OnBeginOverlap to log a message about the collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyOverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyOverlapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"MyOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyOverlapActor::AMyOverlapActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Find and set a static mesh for the component\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyOverlapActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid AMyOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Overlap Begin Event Triggered\"));\n\t}\n}\n```"}
{"requirement": "Set up an input binding in an Actor to increase a UPROPERTY integer score whenever the 'Z' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreIncrementer.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreIncrementer : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScoreIncrementer();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Score\")\n\tint32 Score;\n\n\tvoid IncreaseScore();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreIncrementer.h\"\n#include \"Components/InputComponent.h\"\n\nAScoreIncrementer::AScoreIncrementer()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScore = 0;\n}\n\nvoid AScoreIncrementer::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScoreIncrementer::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScoreIncrementer::IncreaseScore()\n{\n\tScore++;\n}\n\nvoid AScoreIncrementer::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"IncreaseScore\", IE_Pressed, this, &AScoreIncrementer::IncreaseScore);\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FString to store a debug message, printed each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UPrintDebugMessageComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UPrintDebugMessageComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPrintDebugMessageComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Debug\")\n\tFString DebugMessage;\n};\n```", "cpp_code": "```cpp\n#include \"UPrintDebugMessageComponent.h\"\n\nUPrintDebugMessageComponent::UPrintDebugMessageComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tDebugMessage = TEXT(\"Default Debug Message\");\n}\n\nvoid UPrintDebugMessageComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UPrintDebugMessageComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tUE_LOG(LogTemp, Warning, TEXT(\"%s\"), *DebugMessage);\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to rotate its mesh around a fixed point in space.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARotatingMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFVector RotationPoint;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nARotatingMeshActor::ARotatingMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/YourMeshPath.YourMeshName\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRotationPoint = FVector::ZeroVector;\n\tRotationSpeed = 30.0f; // degrees per second\n}\n\nvoid ARotatingMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (MeshComponent)\n\t{\n\t\tFRotator CurrentRotation = GetActorRotation();\n\t\tCurrentRotation.Yaw += RotationSpeed * DeltaTime;\n\t\tFQuat QuatRotation = FQuat(CurrentRotation);\n\n\t\tFVector Direction = GetActorLocation() - RotationPoint;\n\t\tDirection = QuatRotation.RotateVector(Direction);\n\n\t\tSetActorLocation(RotationPoint + Direction);\n\t\tSetActorRotation(QuatRotation);\n\t}\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load a material and apply it to a dynamic material instance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialDynamicActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialDynamicActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialDynamicActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* BaseMaterial;\n\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialDynamicActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nAMaterialDynamicActor::AMaterialDynamicActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialFinder(TEXT(\"/Game/Path/To/Your/Material.YourMaterial\"));\n\tif (MaterialFinder.Succeeded())\n\t{\n\t\tBaseMaterial = MaterialFinder.Object;\n\t}\n}\n\nvoid AMaterialDynamicActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (BaseMaterial)\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(BaseMaterial, this);\n\t\tif (DynamicMaterialInstance)\n\t\t{\n\t\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that returns its current forward direction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DirectionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADirectionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADirectionActor();\n\n\t// BlueprintCallable function to get the forward direction\n\tUFUNCTION(BlueprintCallable, Category=\"Direction\")\n\tFVector GetForwardDirection() const;\n};\n```", "cpp_code": "```cpp\n#include \"DirectionActor.h\"\n\n// Sets default values\nADirectionActor::ADirectionActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nFVector ADirectionActor::GetForwardDirection() const\n{\n\treturn GetActorForwardVector();\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to adjust its material color based on the game world time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADynamicMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADynamicMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY()\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tvoid UpdateMaterialColor(float GameTime);\n};\n```", "cpp_code": "```cpp\n#include \"DynamicMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nADynamicMaterialActor::ADynamicMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ADynamicMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MeshComponent->GetMaterial(0))\n\t{\n\t\tDynamicMaterial = UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterial);\n\t}\n}\n\nvoid ADynamicMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat GameTime = GetWorld()->GetTimeSeconds();\n\tUpdateMaterialColor(GameTime);\n}\n\nvoid ADynamicMaterialActor::UpdateMaterialColor(float GameTime)\n{\n\tif (DynamicMaterial)\n\t{\n\t\tfloat RedValue = FMath::Abs(FMath::Sin(GameTime));\n\t\tFLinearColor NewColor(RedValue, 0.0f, 0.0f, 1.0f);\n\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", NewColor);\n\t}\n}\n```"}
{"requirement": "Create a Component with a BlueprintAssignable delegate to notify when the owning Actor's scale changes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleChangeNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnScaleChanged);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UScaleChangeNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUScaleChangeNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(BlueprintAssignable)\n\tFOnScaleChanged OnScaleChanged;\n\nprivate:\n\tFVector LastScale;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangeNotifierComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUScaleChangeNotifierComponent::UScaleChangeNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UScaleChangeNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tLastScale = Owner->GetActorScale3D();\n\t}\n}\n\nvoid UScaleChangeNotifierComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector CurrentScale = Owner->GetActorScale3D();\n\t\tif (!CurrentScale.Equals(LastScale))\n\t\t{\n\t\t\tOnScaleChanged.Broadcast();\n\t\t\tLastScale = CurrentScale;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up input binding in an Actor to trigger a function that toggles the visibility of its mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AToggleMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid ToggleMeshVisibility();\n};\n```", "cpp_code": "```cpp\n#include \"AToggleMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"Components/InputComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAToggleMeshActor::AToggleMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AToggleMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleMeshActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleMeshActor::ToggleMeshVisibility);\n}\n\nvoid AToggleMeshActor::ToggleMeshVisibility()\n{\n\tif (MeshComponent)\n\t{\n\t\tMeshComponent->SetVisibility(!MeshComponent->IsVisible());\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY for a string message and a function to print it when called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MessageActor.generated.h\"\n\nUCLASS()\nclass AMessageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMessageActor();\n\n\tUFUNCTION()\n\tvoid PrintMessage() const;\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Message\")\n\tFString Message;\n};\n```", "cpp_code": "```cpp\n#include \"MessageActor.h\"\n#include \"Engine/Engine.h\"\n\nAMessageActor::AMessageActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tMessage = \"Default Message\";\n}\n\nvoid AMessageActor::PrintMessage() const\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, Message);\n\t}\n}\n```"}
{"requirement": "Implement an OnBeginOverlap event in an Actor to change its velocity upon collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector NewVelocity;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACollisionActor::ACollisionActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionActor::OnBeginOverlap);\n\n\t// Assuming a default mesh is set in the editor or here using ConstructorHelpers\n\t// static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Mesh.MeshName\"));\n\t// if (MeshAsset.Succeeded())\n\t// {\n\t//\t MeshComponent->SetStaticMesh(MeshAsset.Object);\n\t// }\n\n\tNewVelocity = FVector(100.f, 0.f, 0.f); // Example velocity change\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionActor::OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tMeshComponent->SetPhysicsLinearVelocity(NewVelocity);\n\t}\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY FVector representing a target direction, interpolated each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UInterpolatingDirectionComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UInterpolatingDirectionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:  \n\tUInterpolatingDirectionComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:   \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Interpolation\")\n\tFVector TargetDirection;\n\nprivate:\n\tFVector CurrentDirection;\n\tfloat InterpolationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"UInterpolatingDirectionComponent.h\"\n\nUInterpolatingDirectionComponent::UInterpolatingDirectionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCurrentDirection = FVector::ZeroVector;\n\tInterpolationSpeed = 5.0f; // Default interpolation speed\n}\n\nvoid UInterpolatingDirectionComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UInterpolatingDirectionComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Interpolate the current direction towards the target direction\n\tCurrentDirection = FMath::VInterpTo(CurrentDirection, TargetDirection, DeltaTime, InterpolationSpeed);\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to adjust its roll based on its speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RollingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARollingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARollingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The speed of the actor\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat Speed;\n\n\t// Adjust roll based on speed\n\tvoid AdjustRoll(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"RollingActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nARollingActor::ARollingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize speed\n\tSpeed = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ARollingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARollingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tAdjustRoll(DeltaTime);\n}\n\nvoid ARollingActor::AdjustRoll(float DeltaTime)\n{\n\t// Calculate the new roll based on speed\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Roll += Speed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an Actor with a mesh and a BlueprintCallable function to toggle its physics on and off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TogglePhysicsActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATogglePhysicsActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATogglePhysicsActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Physics\")\n\tvoid TogglePhysics();\n};\n```", "cpp_code": "```cpp\n#include \"TogglePhysicsActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nATogglePhysicsActor::ATogglePhysicsActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetSimulatePhysics(false);\n}\n\nvoid ATogglePhysicsActor::TogglePhysics()\n{\n\tbool bIsSimulatingPhysics = MeshComponent->IsSimulatingPhysics();\n\tMeshComponent->SetSimulatePhysics(!bIsSimulatingPhysics);\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate in a Component to fire when a UPROPERTY float changes its value.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFloatChangeNotifierComponent.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FFloatValueChangedSignature, float, NewValue);\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatChangeNotifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUFloatChangeNotifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(BlueprintAssignable, Category=\"Events\")\n\tFFloatValueChangedSignature OnFloatValueChanged;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Float\")\n\tvoid SetFloatValue(float NewValue);\n\nprivate:\n\tUPROPERTY()\n\tfloat FloatValue;\n};\n```", "cpp_code": "```cpp\n#include \"UFloatChangeNotifierComponent.h\"\n\nUFloatChangeNotifierComponent::UFloatChangeNotifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tFloatValue = 0.0f;\n}\n\nvoid UFloatChangeNotifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFloatChangeNotifierComponent::SetFloatValue(float NewValue)\n{\n\tif (FloatValue != NewValue)\n\t{\n\t\tFloatValue = NewValue;\n\t\tOnFloatValueChanged.Broadcast(NewValue);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY float for rotation speed, applied to its yaw rotation each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationSpeed = 45.0f; // Default rotation speed\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a SetupPlayerInputComponent to bind a key to reset an Actor's position to the origin.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AResettableActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AResettableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResettableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid ResetPosition();\n};\n```", "cpp_code": "```cpp\n#include \"AResettableActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\nAResettableActor::AResettableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResettableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AResettableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResettableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetPosition\", IE_Pressed, this, &AResettableActor::ResetPosition);\n}\n\nvoid AResettableActor::ResetPosition()\n{\n\tSetActorLocation(FVector::ZeroVector);\n}\n```"}
{"requirement": "Create an Actor with a UPROPERTY FVector and a function to log its current location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyCustomActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyCustomActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMyCustomActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Location\")\n\tFVector CurrentLocation;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Location\")\n\tvoid LogCurrentLocation();\n};\n```", "cpp_code": "```cpp\n#include \"MyCustomActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\nAMyCustomActor::AMyCustomActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentLocation = FVector::ZeroVector;\n}\n\nvoid AMyCustomActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyCustomActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyCustomActor::LogCurrentLocation()\n{\n\tCurrentLocation = GetActorLocation();\n\tif (GEngine)\n\t{\n\t\tFString LocationString = CurrentLocation.ToString();\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Current Location: %s\"), *LocationString));\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in a Component to animate its owning Actor's material over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UMaterialAnimatorComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURGAME_API UMaterialAnimatorComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUMaterialAnimatorComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\tfloat AnimationTime;\n};\n```", "cpp_code": "```cpp\n#include \"UMaterialAnimatorComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nUMaterialAnimatorComponent::UMaterialAnimatorComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tAnimationTime = 0.0f;\n}\n\nvoid UMaterialAnimatorComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUStaticMeshComponent* MeshComponent = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tUMaterialInterface* Material = MeshComponent->GetMaterial(0);\n\t\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(Material, this);\n\t\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t\t}\n\t}\n}\n\nvoid UMaterialAnimatorComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (DynamicMaterialInstance)\n\t{\n\t\tAnimationTime += DeltaTime;\n\t\tfloat ParameterValue = FMath::Sin(AnimationTime);\n\t\tDynamicMaterialInstance->SetScalarParameterValue(TEXT(\"MyParameter\"), ParameterValue);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh component and a function to print a message when play starts.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMyStaticMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Static mesh component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Optionally set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh>MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tUE_LOG(LogTemp, Warning, TEXT(\"Play has started!\"));\n}\n```"}
{"requirement": "Set up an input binding in an Actor to call a function that toggles a UPROPERTY boolean status.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid ToggleStatus();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Toggle\")\n\tbool bIsToggled;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\nAToggleActor::AToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsToggled = false;\n}\n\nvoid AToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleActor::ToggleStatus()\n{\n\tbIsToggled = !bIsToggled;\n}\n\nvoid AToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleAction\", IE_Pressed, this, &AToggleActor::ToggleStatus);\n}\n```"}
{"requirement": "Create a Component with a UPROPERTY integer representing a tick counter that resets every 50 ticks.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TickCounterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTickCounterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUTickCounterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Tick\")\n\tint32 TickCounter;\n};\n```", "cpp_code": "```cpp\n#include \"TickCounterComponent.h\"\n\nUTickCounterComponent::UTickCounterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTickCounter = 0;\n}\n\nvoid UTickCounterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UTickCounterComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTickCounter++;\n\tif (TickCounter >= 50)\n\t{\n\t\tTickCounter = 0;\n\t}\n}\n```"}
{"requirement": "Implement a Tick function in an Actor to always face towards a moving target.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FaceTargetActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFaceTargetActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAFaceTargetActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Target\")\n\tAActor* TargetActor;\n};\n```", "cpp_code": "```cpp\n#include \"FaceTargetActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAFaceTargetActor::AFaceTargetActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AFaceTargetActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AFaceTargetActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tFVector Direction = (TargetActor->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n\t\tFRotator NewRotation = Direction.Rotation();\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Use ConstructorHelpers in an Actor to load and set a mesh as the root component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AMyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"AMyActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a BlueprintCallable function that logs its speed in the console.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASpeedLoggerActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Speed\")\n\tvoid LogSpeed() const;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat Speed;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nASpeedLoggerActor::ASpeedLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSpeed = 0.0f;\n}\n\nvoid ASpeedLoggerActor::LogSpeed() const\n{\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Speed: %f\"), Speed);\n}\n```"}
