{"requirement": "Create an actor with a visible mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyVisibleMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyVisibleMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMyVisibleMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyVisibleMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAMyVisibleMeshActor::AMyVisibleMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component and set as root\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AMyVisibleMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyVisibleMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Add a jump function to a character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyCharacter();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\npublic:\n\tvoid Jump();\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n\nAMyCharacter::AMyCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, &AMyCharacter::Jump);\n}\n\nvoid AMyCharacter::Jump()\n{\n\tif (CanJump())\n\t{\n\t\tACharacter::Jump();\n\t}\n}\n```"}
{"requirement": "Create a rotating actor using a tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tFRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the rotation rate\n\tRotationRate = FRotator(0.f, 180.f, 0.f);\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Rotate the actor\n\tAddActorLocalRotation(RotationRate * DeltaTime);\n}\n```"}
{"requirement": "Implement a trigger volume that prints a message when an actor enters.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TriggerVolumeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATriggerVolumeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tATriggerVolumeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* TriggerVolume;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"TriggerVolumeActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nATriggerVolumeActor::ATriggerVolumeActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n\tRootComponent = TriggerVolume;\n\n\tTriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &ATriggerVolumeActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ATriggerVolumeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATriggerVolumeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATriggerVolumeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Actor has entered the trigger volume\"));\n\t}\n}\n```"}
{"requirement": "Add a health variable to a character using UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"YourCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AYourCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tAYourCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat Health;\n};\n```", "cpp_code": "```cpp\n#include \"YourCharacter.h\"\n\n// Sets default values\nAYourCharacter::AYourCharacter()\n{\n\t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tHealth = 100.0f; // Default health value\n}\n\n// Called when the game starts or when spawned\nvoid AYourCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AYourCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\n// Called to bind functionality to input\nvoid AYourCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n}\n```"}
{"requirement": "Create a simple pickup item that destroys itself when collected.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PickupItem.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API APickupItem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPickupItem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass USphereComponent* CollisionComponent;\n};\n```", "cpp_code": "```cpp\n#include \"PickupItem.h\"\n#include \"Components/SphereComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nAPickupItem::APickupItem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\tCollisionComponent->SetSphereRadius(50.0f);\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &APickupItem::OnOverlapBegin);\n}\n\nvoid APickupItem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APickupItem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APickupItem::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && OtherActor != this && OtherComp)\n\t{\n\t\tDestroy();\n\t}\n}\n```"}
{"requirement": "Implement a floating movement component for an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FloatingMovementComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatingMovementComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUFloatingMovementComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Floating\")\n\tfloat FloatSpeed = 20.0f;\n\n\tUPROPERTY(EditAnywhere, Category=\"Floating\")\n\tfloat Amplitude = 50.0f;\n\n\tFVector InitialLocation;\n};\n```", "cpp_code": "```cpp\n#include \"FloatingMovementComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUFloatingMovementComponent::UFloatingMovementComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UFloatingMovementComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Save the initial location of the actor\n\tInitialLocation = GetOwner()->GetActorLocation();\n}\n\nvoid UFloatingMovementComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (!GetOwner()) return;\n\n\t// Calculate new location\n\tFVector NewLocation = InitialLocation;\n\tNewLocation.Z += Amplitude * FMath::Sin(FloatSpeed * GetWorld()->GetTimeSeconds());\n\n\t// Update Actor's location\n\tGetOwner()->SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Add a function to change the material of a mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AYourActor();\n\n  UFUNCTION(BlueprintCallable, Category = \"Mesh\")\n  void ChangeMeshMaterial(UMeshComponent* MeshComponent, UMaterialInterface* NewMaterial);\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::ChangeMeshMaterial(UMeshComponent* MeshComponent, UMaterialInterface* NewMaterial)\n{\n  if (MeshComponent && NewMaterial)\n  {\n\tMeshComponent->SetMaterial(0, NewMaterial);\n  }\n}\n```"}
{"requirement": "Bind a key to print a message in the log.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"KeyBindingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AKeyBindingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AKeyBindingActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n  void PrintMessage();\n};\n```", "cpp_code": "```cpp\n#include \"KeyBindingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n\nAKeyBindingActor::AKeyBindingActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AKeyBindingActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AKeyBindingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n  Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n  PlayerInputComponent->BindAction(\"PrintMessage\", IE_Pressed, this, &AKeyBindingActor::PrintMessage);\n}\n\nvoid AKeyBindingActor::PrintMessage()\n{\n  if (GEngine)\n  {\n\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Key Pressed: Print Message\"));\n\tUE_LOG(LogTemp, Warning, TEXT(\"Key Pressed: Print Message\"));\n  }\n}\n```"}
{"requirement": "Create a door actor that opens and closes with a toggle function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DoorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADoorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADoorActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Door\")\n\tvoid ToggleDoor();\n\nprivate:\n\tbool bIsOpen;\n\n\tUPROPERTY(EditAnywhere)\n\tFRotator OpenRotation;\n\n\tUPROPERTY(EditAnywhere)\n\tFRotator ClosedRotation;\n\n\tvoid OpenDoor();\n\tvoid CloseDoor();\n};\n```", "cpp_code": "```cpp\n#include \"DoorActor.h\"\n\n// Sets default values\nADoorActor::ADoorActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tbIsOpen = false;\n\n\t// Define default rotations\n\tOpenRotation = FRotator(0.f, 90.f, 0.f);\n\tClosedRotation = FRotator(0.f, 0.f, 0.f);\n}\n\n// Called when the game starts or when spawned\nvoid ADoorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADoorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADoorActor::ToggleDoor()\n{\n\tif (bIsOpen)\n\t{\n\t\tCloseDoor();\n\t}\n\telse\n\t{\n\t\tOpenDoor();\n\t}\n}\n\nvoid ADoorActor::OpenDoor()\n{\n\tSetActorRotation(OpenRotation);\n\tbIsOpen = true;\n}\n\nvoid ADoorActor::CloseDoor()\n{\n\tSetActorRotation(ClosedRotation);\n\tbIsOpen = false;\n}\n```"}
{"requirement": "Implement a timer that prints a message every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerExample.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ATimerExample : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tATimerExample();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFTimerHandle TimerHandle;\n\tvoid PrintMessage();\n};\n```", "cpp_code": "```cpp\n#include \"TimerExample.h\"\n#include \"Engine/Engine.h\"\n\nATimerExample::ATimerExample()\n{\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ATimerExample::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tGetWorldTimerManager().SetTimer(TimerHandle, this, &ATimerExample::PrintMessage, 1.0f, true);\n}\n\nvoid ATimerExample::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATimerExample::PrintMessage()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Green, TEXT(\"Message printed every second\"));\n\t}\n}\n```"}
{"requirement": "Create a light actor that changes color over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingLight.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangingLight : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAColorChangingLight();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPointLightComponent* PointLight;\n\n\tFLinearColor CurrentColor;\n\tfloat TimeAccumulator;\n\tfloat ColorChangeRate;\n\n\tvoid UpdateLightColor(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingLight.h\"\n#include \"Components/PointLightComponent.h\"\n\nAColorChangingLight::AColorChangingLight()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\tCurrentColor = FLinearColor::Red;\n\tTimeAccumulator = 0.0f;\n\tColorChangeRate = 1.0f; // Change color every second\n}\n\nvoid AColorChangingLight::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AColorChangingLight::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateLightColor(DeltaTime);\n}\n\nvoid AColorChangingLight::UpdateLightColor(float DeltaTime)\n{\n\tTimeAccumulator += DeltaTime;\n\n\tif (TimeAccumulator >= ColorChangeRate)\n\t{\n\t\tTimeAccumulator = 0.0f;\n\n\t\t// Cycle through colors: Red -> Green -> Blue -> Red\n\t\tif (CurrentColor == FLinearColor::Red)\n\t\t{\n\t\t\tCurrentColor = FLinearColor::Green;\n\t\t}\n\t\telse if (CurrentColor == FLinearColor::Green)\n\t\t{\n\t\t\tCurrentColor = FLinearColor::Blue;\n\t\t}\n\t\telse if (CurrentColor == FLinearColor::Blue)\n\t\t{\n\t\t\tCurrentColor = FLinearColor::Red;\n\t\t}\n\t}\n\n\tPointLight->SetLightColor(CurrentColor);\n}\n```"}
{"requirement": "Add a function to increase a character's speed temporarily.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SpeedBoostCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API ASpeedBoostCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedBoostCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid IncreaseSpeedTemporarily(float SpeedMultiplier, float Duration);\n\nprivate:\n\tvoid ResetSpeed();\n\n\tFTimerHandle SpeedBoostTimerHandle;\n\tfloat OriginalSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedBoostCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"TimerManager.h\"\n\nASpeedBoostCharacter::ASpeedBoostCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASpeedBoostCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tOriginalSpeed = GetCharacterMovement()->MaxWalkSpeed;\n}\n\nvoid ASpeedBoostCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpeedBoostCharacter::IncreaseSpeedTemporarily(float SpeedMultiplier, float Duration)\n{\n\tGetCharacterMovement()->MaxWalkSpeed *= SpeedMultiplier;\n\tGetWorldTimerManager().SetTimer(SpeedBoostTimerHandle, this, &ASpeedBoostCharacter::ResetSpeed, Duration, false);\n}\n\nvoid ASpeedBoostCharacter::ResetSpeed()\n{\n\tGetCharacterMovement()->MaxWalkSpeed = OriginalSpeed;\n\tGetWorldTimerManager().ClearTimer(SpeedBoostTimerHandle);\n}\n```"}
{"requirement": "Create a simple camera shake effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Camera/CameraShakeBase.h\"\n#include \"SimpleCameraShake.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API USimpleCameraShake : public UCameraShakeBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tUSimpleCameraShake();\n};\n```", "cpp_code": "```cpp\n#include \"SimpleCameraShake.h\"\n\nUSimpleCameraShake::USimpleCameraShake()\n{\n\tOscillationDuration = 0.25f;\n\tOscillationBlendInTime = 0.05f;\n\tOscillationBlendOutTime = 0.05f;\n\n\tRotOscillation.Pitch.Amplitude = 10.0f;\n\tRotOscillation.Pitch.Frequency = 5.0f;\n\n\tRotOscillation.Yaw.Amplitude = 10.0f;\n\tRotOscillation.Yaw.Frequency = 5.0f;\n\n\tRotOscillation.Roll.Amplitude = 0.0f;\n\tRotOscillation.Roll.Frequency = 0.0f;\n}\n```"}
{"requirement": "Implement a HUD element that displays player health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/HUD.h\"\n#include \"PlayerHealthHUD.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APlayerHealthHUD : public AHUD\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPlayerHealthHUD();\n\nprotected:\n\tvirtual void DrawHUD() override;\n\nprivate:\n\tvoid DrawHealthBar();\n\n\t// Example health value, replace with actual player health retrieval\n\tfloat PlayerHealth;\n\tfloat MaxPlayerHealth;\n\n\t// Health bar properties\n\tFVector2D HealthBarPosition;\n\tFVector2D HealthBarSize;\n\tFLinearColor HealthBarColor;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerHealthHUD.h\"\n#include \"Engine/Canvas.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAPlayerHealthHUD::APlayerHealthHUD()\n{\n\t// Initialize default values\n\tPlayerHealth = 100.0f;\n\tMaxPlayerHealth = 100.0f;\n\tHealthBarPosition = FVector2D(50, 50);\n\tHealthBarSize = FVector2D(200, 25);\n\tHealthBarColor = FLinearColor::Green;\n}\n\nvoid APlayerHealthHUD::DrawHUD()\n{\n\tSuper::DrawHUD();\n\n\t// Update PlayerHealth here with actual data\n\n\tDrawHealthBar();\n}\n\nvoid APlayerHealthHUD::DrawHealthBar()\n{\n\t// Calculate the width of the health bar based on current health\n\tfloat HealthPercentage = PlayerHealth / MaxPlayerHealth;\n\tfloat HealthBarWidth = HealthBarSize.X * HealthPercentage;\n\n\t// Draw the health bar background\n\tFCanvasTileItem BackgroundTile(HealthBarPosition, HealthBarSize, FLinearColor::Black);\n\tBackgroundTile.BlendMode = SE_BLEND_Translucent;\n\tCanvas->DrawItem(BackgroundTile);\n\n\t// Draw the health bar\n\tFCanvasTileItem HealthTile(HealthBarPosition, FVector2D(HealthBarWidth, HealthBarSize.Y), HealthBarColor);\n\tHealthTile.BlendMode = SE_BLEND_Translucent;\n\tCanvas->DrawItem(HealthTile);\n}\n```"}
{"requirement": "Create a basic inventory system with an array of items.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InventorySystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FInventoryItem\n{\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Inventory\")\n\tFString ItemName;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Inventory\")\n\tint32 Quantity;\n\n\tFInventoryItem() : ItemName(\"\"), Quantity(0) {}\n};\n\nUCLASS()\nclass AInventorySystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAInventorySystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Inventory\")\n\tTArray<FInventoryItem> Items;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tvoid AddItem(const FString& ItemName, int32 Quantity);\n};\n```", "cpp_code": "```cpp\n#include \"InventorySystem.h\"\n\nAInventorySystem::AInventorySystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AInventorySystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AInventorySystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AInventorySystem::AddItem(const FString& ItemName, int32 Quantity)\n{\n\tfor (FInventoryItem& Item : Items)\n\t{\n\t\tif (Item.ItemName == ItemName)\n\t\t{\n\t\t\tItem.Quantity += Quantity;\n\t\t\treturn;\n\t\t}\n\t}\n\tFInventoryItem NewItem;\n\tNewItem.ItemName = ItemName;\n\tNewItem.Quantity = Quantity;\n\tItems.Add(NewItem);\n}\n```"}
{"requirement": "Add a sound effect that plays when an actor is clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"ClickableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AClickableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAClickableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tUSoundBase* ClickSound;\n\n\tUFUNCTION()\n\tvoid OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n};\n```", "cpp_code": "```cpp\n#include \"ClickableActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\nAClickableActor::AClickableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tOnClicked.AddDynamic(this, &AClickableActor::OnClicked);\n}\n\nvoid AClickableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AClickableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AClickableActor::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tif (ClickSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, ClickSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Implement a simple save and load system for player score.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/SaveGame.h\"\n#include \"PlayerScoreSaveGame.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UPlayerScoreSaveGame : public USaveGame\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPlayerScoreSaveGame();\n\n\tUPROPERTY(VisibleAnywhere, Category = Basic)\n\tint32 PlayerScore;\n};\n\nUCLASS()\nclass YOURGAME_API AYourGameGameModeBase : public AGameModeBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tvoid SavePlayerScore(int32 Score);\n\tint32 LoadPlayerScore();\n};\n```", "cpp_code": "```cpp\n#include \"PlayerScoreSaveGame.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUPlayerScoreSaveGame::UPlayerScoreSaveGame()\n{\n\tPlayerScore = 0;\n}\n\nvoid AYourGameGameModeBase::SavePlayerScore(int32 Score)\n{\n\tUPlayerScoreSaveGame* SaveGameInstance = Cast<UPlayerScoreSaveGame>(UGameplayStatics::CreateSaveGameObject(UPlayerScoreSaveGame::StaticClass()));\n\tif (SaveGameInstance)\n\t{\n\t\tSaveGameInstance->PlayerScore = Score;\n\t\tUGameplayStatics::SaveGameToSlot(SaveGameInstance, TEXT(\"PlayerScoreSlot\"), 0);\n\t}\n}\n\nint32 AYourGameGameModeBase::LoadPlayerScore()\n{\n\tUPlayerScoreSaveGame* LoadGameInstance = Cast<UPlayerScoreSaveGame>(UGameplayStatics::LoadGameFromSlot(TEXT(\"PlayerScoreSlot\"), 0));\n\tif (LoadGameInstance)\n\t{\n\t\treturn LoadGameInstance->PlayerScore;\n\t}\n\treturn 0;\n}\n```"}
{"requirement": "Create a projectile that moves forward when spawned.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Projectile.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AProjectile : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AProjectile();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n  UStaticMeshComponent* ProjectileMesh;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Movement\")\n  float MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"Projectile.h\"\n#include \"GameFramework/ProjectileMovementComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nAProjectile::AProjectile()\n{\n  PrimaryActorTick.bCanEverTick = true;\n\n  ProjectileMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"ProjectileMesh\"));\n  RootComponent = ProjectileMesh;\n\n  MovementSpeed = 1000.0f;\n}\n\nvoid AProjectile::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AProjectile::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  FVector NewLocation = GetActorLocation() + GetActorForwardVector() * MovementSpeed * DeltaTime;\n  SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Add a function to check if a character is in the air.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Function to check if the character is in the air\n\tUFUNCTION(BlueprintCallable, Category=\"Character\")\n\tbool IsInAir() const;\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n\nbool AMyCharacter::IsInAir() const\n{\n\treturn GetCharacterMovement()->IsFalling();\n}\n```"}
{"requirement": "Implement a basic countdown timer on the HUD.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/HUD.h\"\n#include \"CountdownTimerHUD.generated.h\"\n\nUCLASS()\nclass MYGAME_API ACountdownTimerHUD : public AHUD\n{\n\tGENERATED_BODY()\n\npublic:\n\tACountdownTimerHUD();\n\n\tvirtual void DrawHUD() override;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tfloat CountdownTime;\n\tFText CountdownText;\n\tFTimerHandle CountdownTimerHandle;\n\n\tvoid UpdateCountdownDisplay();\n\tvoid CountdownHasFinished();\n};\n```", "cpp_code": "```cpp\n#include \"CountdownTimerHUD.h\"\n#include \"Engine/Canvas.h\"\n#include \"Engine/Font.h\"\n#include \"TimerManager.h\"\n\nACountdownTimerHUD::ACountdownTimerHUD()\n{\n\tCountdownTime = 60.0f; // Set initial countdown time in seconds\n}\n\nvoid ACountdownTimerHUD::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Start the countdown timer\n\tGetWorldTimerManager().SetTimer(CountdownTimerHandle, this, &ACountdownTimerHUD::UpdateCountdownDisplay, 1.0f, true);\n}\n\nvoid ACountdownTimerHUD::DrawHUD()\n{\n\tSuper::DrawHUD();\n\n\t// Draw the countdown timer text on the screen\n\tif (GEngine && GEngine->GetMediumFont())\n\t{\n\t\tFVector2D ScreenDimensions = FVector2D(Canvas->SizeX, Canvas->SizeY);\n\t\tFVector2D TextSize;\n\t\tGetTextSize(CountdownText.ToString(), TextSize.X, TextSize.Y, GEngine->GetMediumFont());\n\t\tFVector2D TextPosition = FVector2D(ScreenDimensions.X / 2.0f - TextSize.X / 2.0f, 50.0f);\n\t\tFCanvasTextItem TextItem(TextPosition, CountdownText, GEngine->GetMediumFont(), FLinearColor::White);\n\t\tCanvas->DrawItem(TextItem);\n\t}\n}\n\nvoid ACountdownTimerHUD::UpdateCountdownDisplay()\n{\n\tif (CountdownTime > 0)\n\t{\n\t\tCountdownTime--;\n\t\tCountdownText = FText::FromString(FString::Printf(TEXT(\"Time Remaining: %d\"), FMath::CeilToInt(CountdownTime)));\n\t}\n\telse\n\t{\n\t\tCountdownHasFinished();\n\t}\n}\n\nvoid ACountdownTimerHUD::CountdownHasFinished()\n{\n\tGetWorldTimerManager().ClearTimer(CountdownTimerHandle);\n\tCountdownText = FText::FromString(TEXT(\"Time's Up!\"));\n}\n```"}
{"requirement": "Create a character that can crouch with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"CrouchingCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ACrouchingCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tACrouchingCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid StartCrouch();\n\tvoid StopCrouch();\n};\n```", "cpp_code": "```cpp\n#include \"CrouchingCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nACrouchingCharacter::ACrouchingCharacter()\n{\n\t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ACrouchingCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACrouchingCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid ACrouchingCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"Crouch\", IE_Pressed, this, &ACrouchingCharacter::StartCrouch);\n\tPlayerInputComponent->BindAction(\"Crouch\", IE_Released, this, &ACrouchingCharacter::StopCrouch);\n}\n\nvoid ACrouchingCharacter::StartCrouch()\n{\n\tCrouch();\n}\n\nvoid ACrouchingCharacter::StopCrouch()\n{\n\tUnCrouch();\n}\n```"}
{"requirement": "Add a function to respawn a character at a specific location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyCharacter : public ACharacter\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this character's properties\n  AMyCharacter();\n\n  // Function to respawn the character at a specific location\n  UFUNCTION(BlueprintCallable, Category = \"Respawn\")\n  void RespawnAtLocation(const FVector& NewLocation);\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n\n// Sets default values\nAMyCharacter::AMyCharacter()\n{\n  // Set this character to call Tick() every frame.\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyCharacter::RespawnAtLocation(const FVector& NewLocation)\n{\n  // Set the new location for the character\n  SetActorLocation(NewLocation);\n\n  // Additional logic for respawning can be added here\n}\n```"}
{"requirement": "Implement a simple fade-in effect on level start.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FadeInEffect.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AFadeInEffect : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAFadeInEffect();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Fade\")\n\tfloat FadeDuration;\n\n\tUFUNCTION()\n\tvoid StartFadeIn();\n};\n```", "cpp_code": "```cpp\n#include \"FadeInEffect.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nAFadeInEffect::AFadeInEffect()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tFadeDuration = 2.0f; // Default fade duration\n}\n\nvoid AFadeInEffect::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartFadeIn();\n}\n\nvoid AFadeInEffect::StartFadeIn()\n{\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tPlayerController->PlayerCameraManager->StartCameraFade(1.0f, 0.0f, FadeDuration, FLinearColor::Black);\n\t}\n}\n```"}
{"requirement": "Create a basic day-night cycle with a directional light.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DayNightCycle.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADayNightCycle : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADayNightCycle();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"DayNight\")\n\tfloat DayLengthInSeconds;\n\n\tUPROPERTY(EditAnywhere, Category = \"DayNight\")\n\tADirectionalLight* DirectionalLight;\n\n\tfloat CurrentTimeOfDay;\n};\n```", "cpp_code": "```cpp\n#include \"DayNightCycle.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/DirectionalLight.h\"\n\nADayNightCycle::ADayNightCycle()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tDayLengthInSeconds = 120.0f; // 2 minutes for a full cycle\n\tCurrentTimeOfDay = 0.0f;\n}\n\nvoid ADayNightCycle::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (DirectionalLight == nullptr)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"DirectionalLight not set on DayNightCycle.\"));\n\t}\n}\n\nvoid ADayNightCycle::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DirectionalLight)\n\t{\n\t\tCurrentTimeOfDay += DeltaTime;\n\t\tif (CurrentTimeOfDay >= DayLengthInSeconds)\n\t\t{\n\t\t\tCurrentTimeOfDay = 0.0f;\n\t\t}\n\n\t\tfloat SunAngle = (CurrentTimeOfDay / DayLengthInSeconds) * 360.0f;\n\t\tFRotator NewRotation = FRotator(SunAngle, 0.0f, 0.0f);\n\t\tDirectionalLight->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Add a function to pause and resume the game.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"PauseGameMode.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APauseGameMode : public AGameModeBase\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPauseGameMode();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Game\")\n\tvoid PauseGame();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Game\")\n\tvoid ResumeGame();\n\nprivate:\n\tbool bIsGamePaused;\n};\n```", "cpp_code": "```cpp\n#include \"PauseGameMode.h\"\n\nAPauseGameMode::APauseGameMode()\n{\n\tbIsGamePaused = false;\n}\n\nvoid APauseGameMode::PauseGame()\n{\n\tif (!bIsGamePaused)\n\t{\n\t\tUGameplayStatics::SetGamePaused(GetWorld(), true);\n\t\tbIsGamePaused = true;\n\t}\n}\n\nvoid APauseGameMode::ResumeGame()\n{\n\tif (bIsGamePaused)\n\t{\n\t\tUGameplayStatics::SetGamePaused(GetWorld(), false);\n\t\tbIsGamePaused = false;\n\t}\n}\n```"}
{"requirement": "Implement a basic score system using integers.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScoreSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Score\")\n\tvoid AddScore(int32 Points);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Score\")\n\tint32 GetScore() const;\n\nprivate:\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreSystem.h\"\n\nAScoreSystem::AScoreSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScore = 0;\n}\n\nvoid AScoreSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScoreSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScoreSystem::AddScore(int32 Points)\n{\n\tScore += Points;\n}\n\nint32 AScoreSystem::GetScore() const\n{\n\treturn Score;\n}\n```"}
{"requirement": "Create a flashlight effect that toggles on and off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Flashlight.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFlashlight : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAFlashlight();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to toggle the flashlight\n\tUFUNCTION(BlueprintCallable, Category=\"Flashlight\")\n\tvoid ToggleFlashlight();\n\nprivate:\n\t// Point light component for the flashlight\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tclass UPointLightComponent* FlashlightLight;\n\n\t// Whether the flashlight is currently on\n\tbool bIsFlashlightOn;\n};\n```", "cpp_code": "```cpp\n#include \"Flashlight.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nAFlashlight::AFlashlight()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Point Light Component\n\tFlashlightLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"FlashlightLight\"));\n\tRootComponent = FlashlightLight;\n\n\t// Initialize the flashlight to be off\n\tbIsFlashlightOn = false;\n\tFlashlightLight->SetVisibility(bIsFlashlightOn);\n}\n\n// Called when the game starts or when spawned\nvoid AFlashlight::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AFlashlight::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Toggle the flashlight on and off\nvoid AFlashlight::ToggleFlashlight()\n{\n\tbIsFlashlightOn = !bIsFlashlightOn;\n\tFlashlightLight->SetVisibility(bIsFlashlightOn);\n}\n```"}
{"requirement": "Add a collision event that changes an actor's color.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionColorChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionColorChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionColorChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nACollisionColorChangeActor::ACollisionColorChangeActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetNotifyRigidBodyCollision(true);\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ACollisionColorChangeActor::OnHit);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionColorChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionColorChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionColorChangeActor::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", NewColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a basic sprint mechanic for a character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SprintCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASprintCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tASprintCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Sprint speed multiplier\n\tUPROPERTY(EditAnywhere, Category=\"Sprint\")\n\tfloat SprintMultiplier;\n\n\t// Default movement speed\n\tfloat DefaultWalkSpeed;\n\n\t// Function to start sprinting\n\tvoid StartSprinting();\n\n\t// Function to stop sprinting\n\tvoid StopSprinting();\n};\n```", "cpp_code": "```cpp\n#include \"SprintCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nASprintCharacter::ASprintCharacter()\n{\n\t// Set this character to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize sprint multiplier\n\tSprintMultiplier = 2.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASprintCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Save the default walk speed\n\tDefaultWalkSpeed = GetCharacterMovement()->MaxWalkSpeed;\n}\n\n// Called every frame\nvoid ASprintCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid ASprintCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind sprint actions\n\tPlayerInputComponent->BindAction(\"Sprint\", IE_Pressed, this, &ASprintCharacter::StartSprinting);\n\tPlayerInputComponent->BindAction(\"Sprint\", IE_Released, this, &ASprintCharacter::StopSprinting);\n}\n\nvoid ASprintCharacter::StartSprinting()\n{\n\t// Increase the character's speed\n\tGetCharacterMovement()->MaxWalkSpeed = DefaultWalkSpeed * SprintMultiplier;\n}\n\nvoid ASprintCharacter::StopSprinting()\n{\n\t// Reset the character's speed to default\n\tGetCharacterMovement()->MaxWalkSpeed = DefaultWalkSpeed;\n}\n```"}
{"requirement": "Create a simple health pickup that restores health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthPickup.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHealthPickup : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAHealthPickup();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat HealthAmount;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* CollisionComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tclass UStaticMeshComponent* PickupMesh;\n};\n```", "cpp_code": "```cpp\n#include \"HealthPickup.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourGameCharacter.h\"  // Replace with your character class\n\nAHealthPickup::AHealthPickup()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\tCollisionComponent->SetCollisionProfileName(TEXT(\"OverlapAll\"));\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AHealthPickup::OnOverlapBegin);\n\n\tPickupMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"PickupMesh\"));\n\tPickupMesh->SetupAttachment(RootComponent);\n\n\tHealthAmount = 50.0f;  // Default health amount\n}\n\nvoid AHealthPickup::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthPickup::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHealthPickup::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tAYourGameCharacter* Character = Cast<AYourGameCharacter>(OtherActor);  // Replace with your character class\n\t\tif (Character)\n\t\t{\n\t\t\tCharacter->ChangeHealth(HealthAmount);  // Assumes your character has a ChangeHealth function\n\t\t\tDestroy();  // Destroy the pickup after use\n\t\t}\n\t}\n}\n```"}
{"requirement": "Add a function to play an animation on an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Animation\")\n\tvoid PlayAnimation(UAnimSequence* AnimationToPlay);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyActor::PlayAnimation(UAnimSequence* AnimationToPlay)\n{\n\tif (SkeletalMeshComponent && AnimationToPlay)\n\t{\n\t\tSkeletalMeshComponent->PlayAnimation(AnimationToPlay, false);\n\t}\n}\n```"}
{"requirement": "Implement a basic zoom feature for the player camera.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ZoomCameraComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API UZoomCameraComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUZoomCameraComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Zoom\")\n\tfloat ZoomedFOV;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Zoom\")\n\tfloat ZoomInterpSpeed;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Zoom\")\n\tfloat DefaultFOV;\n\n\tvoid ZoomIn();\n\tvoid ZoomOut();\n\nprivate:\n\tbool bIsZoomedIn;\n\tclass UCameraComponent* CameraComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ZoomCameraComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Camera/CameraComponent.h\"\n\nUZoomCameraComponent::UZoomCameraComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tZoomedFOV = 65.0f;\n\tZoomInterpSpeed = 20.0f;\n\tDefaultFOV = 90.0f;\n\tbIsZoomedIn = false;\n}\n\nvoid UZoomCameraComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tCameraComponent = GetOwner()->FindComponentByClass<UCameraComponent>();\n\tif (CameraComponent)\n\t{\n\t\tDefaultFOV = CameraComponent->FieldOfView;\n\t}\n}\n\nvoid UZoomCameraComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (CameraComponent)\n\t{\n\t\tfloat TargetFOV = bIsZoomedIn ? ZoomedFOV : DefaultFOV;\n\t\tfloat CurrentFOV = CameraComponent->FieldOfView;\n\t\tCameraComponent->SetFieldOfView(FMath::FInterpTo(CurrentFOV, TargetFOV, DeltaTime, ZoomInterpSpeed));\n\t}\n}\n\nvoid UZoomCameraComponent::ZoomIn()\n{\n\tbIsZoomedIn = true;\n}\n\nvoid UZoomCameraComponent::ZoomOut()\n{\n\tbIsZoomedIn = false;\n}\n```"}
{"requirement": "Create a bounce effect when an actor hits the ground.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BouncingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ABouncingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tABouncingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Bounce\")\n\tfloat BounceFactor;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"BouncingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nABouncingActor::ABouncingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->SetNotifyRigidBodyCollision(true);\n\n\tBounceFactor = 1.0f;\n\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ABouncingActor::OnHit);\n}\n\nvoid ABouncingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ABouncingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ABouncingActor::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tFVector BounceVelocity = -NormalImpulse * BounceFactor;\n\t\tMeshComponent->AddImpulse(BounceVelocity, NAME_None, true);\n\t}\n}\n```"}
{"requirement": "Add a function to randomly change an actor's location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomLocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomLocationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARandomLocationActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"RandomLocation\")\n\tvoid ChangeLocationRandomly();\n\nprivate:\n\tFVector GetRandomLocationWithinBounds(const FVector& MinBounds, const FVector& MaxBounds) const;\n\n\tUPROPERTY(EditAnywhere, Category=\"RandomLocation\")\n\tFVector MinBounds;\n\n\tUPROPERTY(EditAnywhere, Category=\"RandomLocation\")\n\tFVector MaxBounds;\n};\n```", "cpp_code": "```cpp\n#include \"RandomLocationActor.h\"\n#include \"Engine/World.h\"\n#include \"Math/UnrealMathUtility.h\"\n\n// Sets default values\nARandomLocationActor::ARandomLocationActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Set default bounds\n\tMinBounds = FVector(-1000.0f, -1000.0f, 0.0f);\n\tMaxBounds = FVector(1000.0f, 1000.0f, 500.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ARandomLocationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARandomLocationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARandomLocationActor::ChangeLocationRandomly()\n{\n\tFVector NewLocation = GetRandomLocationWithinBounds(MinBounds, MaxBounds);\n\tSetActorLocation(NewLocation);\n}\n\nFVector ARandomLocationActor::GetRandomLocationWithinBounds(const FVector& MinBounds, const FVector& MaxBounds) const\n{\n\tfloat RandomX = FMath::FRandRange(MinBounds.X, MaxBounds.X);\n\tfloat RandomY = FMath::FRandRange(MinBounds.Y, MaxBounds.Y);\n\tfloat RandomZ = FMath::FRandRange(MinBounds.Z, MaxBounds.Z);\n\treturn FVector(RandomX, RandomY, RandomZ);\n}\n```"}
{"requirement": "Implement a simple fire rate control for a weapon.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Weapon.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AWeapon : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAWeapon();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to fire the weapon\n\tvoid Fire();\n\nprivate:\n\t// Fire rate in rounds per second\n\tUPROPERTY(EditAnywhere, Category = \"Weapon\")\n\tfloat FireRate;\n\n\t// Time since last fire\n\tfloat TimeSinceLastFire;\n};\n```", "cpp_code": "```cpp\n#include \"Weapon.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nAWeapon::AWeapon()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize fire rate and timer\n\tFireRate = 1.0f; // 1 round per second\n\tTimeSinceLastFire = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AWeapon::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AWeapon::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update time since last fire\n\tTimeSinceLastFire += DeltaTime;\n}\n\nvoid AWeapon::Fire()\n{\n\tif (TimeSinceLastFire >= 1.0f / FireRate)\n\t{\n\t\t// Fire the weapon\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Weapon Fired!\"));\n\n\t\t// Reset the timer\n\t\tTimeSinceLastFire = 0.0f;\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Weapon can't fire yet!\"));\n\t}\n}\n```"}
{"requirement": "Create a character that can swim when in water.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SwimmableCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASwimmableCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tASwimmableCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid StartSwimming();\n\n\tUFUNCTION()\n\tvoid StopSwimming();\n\nprivate:\n\tbool bIsInWater;\n\tvoid CheckIfInWater();\n};\n```", "cpp_code": "```cpp\n#include \"SwimmableCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nASwimmableCharacter::ASwimmableCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsInWater = false;\n}\n\nvoid ASwimmableCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASwimmableCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tCheckIfInWater();\n}\n\nvoid ASwimmableCharacter::StartSwimming()\n{\n\t// Logic to start swimming\n\t// E.g., change movement mode\n\tGetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_Swimming);\n}\n\nvoid ASwimmableCharacter::StopSwimming()\n{\n\t// Logic to stop swimming\n\t// E.g., revert movement mode\n\tGetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_Walking);\n}\n\nvoid ASwimmableCharacter::CheckIfInWater()\n{\n\t// Simple example of checking if character is in water\n\tif (GetActorLocation().Z < WaterLevel && !bIsInWater)\n\t{\n\t\tbIsInWater = true;\n\t\tStartSwimming();\n\t}\n\telse if (GetActorLocation().Z >= WaterLevel && bIsInWater)\n\t{\n\t\tbIsInWater = false;\n\t\tStopSwimming();\n\t}\n}\n```"}
{"requirement": "Add a function to log the player's current position.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PlayerPositionLogger.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APlayerPositionLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPlayerPositionLogger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Logs the player's current position\n\tUFUNCTION(BlueprintCallable, Category=\"Player\")\n\tvoid LogPlayerPosition();\n};\n```", "cpp_code": "```cpp\n#include \"PlayerPositionLogger.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAPlayerPositionLogger::APlayerPositionLogger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid APlayerPositionLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APlayerPositionLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APlayerPositionLogger::LogPlayerPosition()\n{\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tAPawn* PlayerPawn = PlayerController->GetPawn();\n\t\tif (PlayerPawn)\n\t\t{\n\t\t\tFVector PlayerLocation = PlayerPawn->GetActorLocation();\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Player Location: X=%f, Y=%f, Z=%f\"), PlayerLocation.X, PlayerLocation.Y, PlayerLocation.Z);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a simple gravity switch for an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GravitySwitchActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AGravitySwitchActor : public AActor\n{\n  GENERATED_BODY()\n\npublic: \n  AGravitySwitchActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic: \n  virtual void Tick(float DeltaTime) override;\n\n  UFUNCTION(BlueprintCallable, Category=\"Gravity\")\n  void ToggleGravity();\n\nprivate:\n  UPROPERTY(EditAnywhere, Category=\"Gravity\")\n  bool bIsGravityEnabled;\n};\n```", "cpp_code": "```cpp\n#include \"GravitySwitchActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nAGravitySwitchActor::AGravitySwitchActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n  bIsGravityEnabled = true;\n}\n\nvoid AGravitySwitchActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AGravitySwitchActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AGravitySwitchActor::ToggleGravity()\n{\n  bIsGravityEnabled = !bIsGravityEnabled;\n  TArray<UActorComponent*> Components = GetComponentsByClass(UPrimitiveComponent::StaticClass());\n  for (UActorComponent* Component : Components)\n  {\n\tif (UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(Component))\n\t{\n\t  PrimitiveComponent->SetEnableGravity(bIsGravityEnabled);\n\t}\n  }\n}\n```"}
{"requirement": "Create a console command that prints a custom message.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintMessageConsoleCommand.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APrintMessageConsoleCommand : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPrintMessageConsoleCommand();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid PrintCustomMessage();\n};\n```", "cpp_code": "```cpp\n#include \"PrintMessageConsoleCommand.h\"\n#include \"Engine/Engine.h\"\n\nAPrintMessageConsoleCommand::APrintMessageConsoleCommand()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APrintMessageConsoleCommand::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (GEngine)\n\t{\n\t\tGEngine->Exec(GetWorld(), TEXT(\"ce PrintCustomMessage\"));\n\t}\n}\n\nvoid APrintMessageConsoleCommand::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APrintMessageConsoleCommand::PrintCustomMessage()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"This is a custom message from the console command!\"));\n\t}\n}\n\nstatic FAutoConsoleCommand PrintCustomMessageCommand = FAutoConsoleCommand(\n\tTEXT(\"PrintCustomMessage\"),\n\tTEXT(\"Executes the PrintCustomMessage function.\"),\n\tFConsoleCommandDelegate::CreateStatic(&APrintMessageConsoleCommand::PrintCustomMessage)\n);\n```"}
{"requirement": "Add a function to toggle an actor's visibility.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleVisibilityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visibility\")\n\tvoid ToggleVisibility();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tSetActorHiddenInGame(!bHidden);\n\tSetActorEnableCollision(!bHidden);\n\tSetActorTickEnabled(!bHidden);\n}\n```"}
{"requirement": "Implement a basic health regeneration system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthRegenSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHealthRegenSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAHealthRegenSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat MaxHealth;\n\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat CurrentHealth;\n\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat RegenRate;\n\n\tvoid RegenerateHealth(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"HealthRegenSystem.h\"\n\nAHealthRegenSystem::AHealthRegenSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMaxHealth = 100.0f;\n\tCurrentHealth = 50.0f;\n\tRegenRate = 5.0f; // Health per second\n}\n\nvoid AHealthRegenSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthRegenSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tRegenerateHealth(DeltaTime);\n}\n\nvoid AHealthRegenSystem::RegenerateHealth(float DeltaTime)\n{\n\tif (CurrentHealth < MaxHealth)\n\t{\n\t\tCurrentHealth += RegenRate * DeltaTime;\n\t\tif (CurrentHealth > MaxHealth)\n\t\t{\n\t\t\tCurrentHealth = MaxHealth;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a simple checkpoint system for a player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CheckpointSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ACheckpointSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACheckpointSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to set a checkpoint\n\tUFUNCTION(BlueprintCallable, Category = \"Checkpoint\")\n\tvoid SetCheckpoint(FVector NewCheckpointLocation);\n\n\t// Function to get the last checkpoint location\n\tUFUNCTION(BlueprintCallable, Category = \"Checkpoint\")\n\tFVector GetCheckpoint() const;\n\nprivate:\n\t// Variable to store the last checkpoint location\n\tFVector CheckpointLocation;\n};\n```", "cpp_code": "```cpp\n#include \"CheckpointSystem.h\"\n\n// Sets default values\nACheckpointSystem::ACheckpointSystem()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ACheckpointSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Initialize the checkpoint location to a default value, e.g., the actor's starting location\n\tCheckpointLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid ACheckpointSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACheckpointSystem::SetCheckpoint(FVector NewCheckpointLocation)\n{\n\tCheckpointLocation = NewCheckpointLocation;\n}\n\nFVector ACheckpointSystem::GetCheckpoint() const\n{\n\treturn CheckpointLocation;\n}\n```"}
{"requirement": "Add a function to rotate an actor towards a point.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotatableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Rotation\")\n\tvoid RotateTowardsPoint(const FVector& TargetPoint);\n};\n```", "cpp_code": "```cpp\n#include \"RotatableActor.h\"\n#include \"GameFramework/Actor.h\"\n\nARotatableActor::ARotatableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARotatableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARotatableActor::RotateTowardsPoint(const FVector& TargetPoint)\n{\n\tFVector Direction = TargetPoint - GetActorLocation();\n\tDirection.Z = 0.0f; // Assuming you want to rotate only on the Z axis\n\tFRotator NewRotation = Direction.Rotation();\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a basic wall jump mechanic for a character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"WallJumpCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AWallJumpCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWallJumpCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tbool bIsWallJumping;\n\tFVector WallNormal;\n\n\tUFUNCTION()\n\tvoid OnWallJump();\n\n\tvoid CheckForWall();\n};\n```", "cpp_code": "```cpp\n#include \"WallJumpCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/InputComponent.h\"\n\nAWallJumpCharacter::AWallJumpCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsWallJumping = false;\n}\n\nvoid AWallJumpCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AWallJumpCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tCheckForWall();\n}\n\nvoid AWallJumpCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"WallJump\", IE_Pressed, this, &AWallJumpCharacter::OnWallJump);\n}\n\nvoid AWallJumpCharacter::OnWallJump()\n{\n\tif (bIsWallJumping)\n\t{\n\t\tFVector JumpDirection = FVector::UpVector + WallNormal * 0.5f;\n\t\tLaunchCharacter(JumpDirection * 600.0f, true, true);\n\t\tbIsWallJumping = false;\n\t}\n}\n\nvoid AWallJumpCharacter::CheckForWall()\n{\n\tFVector Start = GetActorLocation();\n\tFVector ForwardVector = GetActorForwardVector();\n\tFVector End = ((ForwardVector * 100.0f) + Start);\n\tFHitResult HitResult;\n\tFCollisionQueryParams CollisionParams;\n\n\tif (GetWorld()->LineTraceSingleByChannel(HitResult, Start, End, ECC_Visibility, CollisionParams))\n\t{\n\t\tif (HitResult.bBlockingHit)\n\t\t{\n\t\t\tWallNormal = HitResult.Normal;\n\t\t\tbIsWallJumping = true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tbIsWallJumping = false;\n\t}\n}\n```"}
{"requirement": "Create an actor that changes size over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SizeChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASizeChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASizeChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialScale;\n\tUPROPERTY(EditAnywhere, Category = \"Size\")\n\tfloat ScaleFactor;\n\tUPROPERTY(EditAnywhere, Category = \"Size\")\n\tfloat Speed;\n};\n```", "cpp_code": "```cpp\n#include \"SizeChangingActor.h\"\n\n// Sets default values\nASizeChangingActor::ASizeChangingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tInitialScale = FVector(1.0f);\n\tScaleFactor = 1.0f;\n\tSpeed = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASizeChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tInitialScale = GetActorScale3D();\n}\n\n// Called every frame\nvoid ASizeChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat NewScaleFactor = ScaleFactor + FMath::Sin(GetWorld()->TimeSeconds * Speed) * 0.5f;\n\tSetActorScale3D(InitialScale * NewScaleFactor);\n}\n```"}
{"requirement": "Add a function to check if an actor is in a trigger box.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyTriggerBox.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyTriggerBox : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyTriggerBox();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Trigger\")\n\tbool IsActorInTriggerBox(AActor* ActorToCheck) const;\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* TriggerBoxComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyTriggerBox.h\"\n#include \"Components/BoxComponent.h\"\n\nAMyTriggerBox::AMyTriggerBox()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tTriggerBoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerBoxComponent\"));\n\tRootComponent = TriggerBoxComponent;\n}\n\nvoid AMyTriggerBox::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nbool AMyTriggerBox::IsActorInTriggerBox(AActor* ActorToCheck) const\n{\n\tif (!ActorToCheck || !TriggerBoxComponent)\n\t{\n\t\treturn false;\n\t}\n\n\treturn TriggerBoxComponent->IsOverlappingActor(ActorToCheck);\n}\n```"}
{"requirement": "Implement a basic energy system with a depletion rate.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EnergySystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AEnergySystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAEnergySystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Energy value\n\tUPROPERTY(EditAnywhere, Category = \"Energy\")\n\tfloat Energy;\n\n\t// Energy depletion rate per second\n\tUPROPERTY(EditAnywhere, Category = \"Energy\")\n\tfloat DepletionRate;\n\n\t// Function to deplete energy\n\tvoid DepleteEnergy(float DeltaTime);\n\n\t// Function to handle energy reaching zero\n\tvoid OnEnergyDepleted();\n};\n```", "cpp_code": "```cpp\n#include \"EnergySystem.h\"\n\n// Sets default values\nAEnergySystem::AEnergySystem()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize energy and depletion rate\n\tEnergy = 100.0f;\n\tDepletionRate = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AEnergySystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AEnergySystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Deplete energy based on the delta time\n\tDepleteEnergy(DeltaTime);\n}\n\nvoid AEnergySystem::DepleteEnergy(float DeltaTime)\n{\n\tEnergy -= DepletionRate * DeltaTime;\n\n\t// Clamp the energy to zero to prevent negative values\n\tif (Energy <= 0.0f)\n\t{\n\t\tEnergy = 0.0f;\n\t\tOnEnergyDepleted();\n\t}\n}\n\nvoid AEnergySystem::OnEnergyDepleted()\n{\n\t// Handle what happens when energy is depleted\n\tUE_LOG(LogTemp, Warning, TEXT(\"Energy Depleted!\"));\n\t// Additional logic for energy depletion can be added here\n}\n```"}
{"requirement": "Create a rain effect with a particle system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RainParticleSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARainParticleSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARainParticleSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The particle system component for rain\n\tUPROPERTY(VisibleAnywhere)\n\tclass UParticleSystemComponent* RainParticleSystemComponent;\n\n\t// Function to initialize the particle system\n\tvoid InitializeRainParticleSystem();\n};\n```", "cpp_code": "```cpp\n#include \"RainParticleSystem.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nARainParticleSystem::ARainParticleSystem()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the particle system component and attach it to the root\n\tRainParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"RainParticleSystem\"));\n\tRootComponent = RainParticleSystemComponent;\n\n\t// Load the rain particle system asset\n\tstatic ConstructorHelpers::FObjectFinder<UParticleSystem> ParticleSystemAsset(TEXT(\"/Game/PathToYourParticleSystem/PS_Rain\"));\n\tif (ParticleSystemAsset.Succeeded())\n\t{\n\t\tRainParticleSystemComponent->SetTemplate(ParticleSystemAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ARainParticleSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tInitializeRainParticleSystem();\n}\n\n// Called every frame\nvoid ARainParticleSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARainParticleSystem::InitializeRainParticleSystem()\n{\n\t// Additional setup for the particle system can be done here\n\tRainParticleSystemComponent->ActivateSystem();\n}\n```"}
{"requirement": "Add a function to explode an actor on key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ExplodingActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AExplodingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AExplodingActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:  \n  virtual void Tick(float DeltaTime) override;\n\n  UFUNCTION()\n  void Explode();\n\nprivate:\n  void SetupInputComponent();\n\n  UPROPERTY(EditAnywhere)\n  float ExplosionRadius;\n\n  UPROPERTY(EditAnywhere)\n  float ExplosionStrength;\n};\n```", "cpp_code": "```cpp\n#include \"ExplodingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAExplodingActor::AExplodingActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AExplodingActor::BeginPlay()\n{\n  Super::BeginPlay();\n  SetupInputComponent();\n}\n\nvoid AExplodingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AExplodingActor::Explode()\n{\n  UGameplayStatics::ApplyRadialDamage(\n\tthis,\n\tExplosionStrength,\n\tGetActorLocation(),\n\tExplosionRadius,\n\tnullptr,\n\tTArray<AActor*>(),\n\tthis,\n\tGetInstigatorController(),\n\ttrue\n  );\n  Destroy();\n}\n\nvoid AExplodingActor::SetupInputComponent()\n{\n  if (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n  {\n\tif (InputComponent == nullptr)\n\t{\n\t  InputComponent = NewObject<UInputComponent>(this);\n\t  InputComponent->RegisterComponent();\n\t}\n\tInputComponent->BindAction(\"Explode\", IE_Pressed, this, &AExplodingActor::Explode);\n\tPlayerController->PushInputComponent(InputComponent);\n  }\n}\n```"}
{"requirement": "Implement a simple flashlight with battery life.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Flashlight.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFlashlight : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFlashlight();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Flashlight\")\n\tbool bIsOn;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Flashlight\")\n\tfloat BatteryLife;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Flashlight\")\n\tfloat BatteryDrainRate;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Flashlight\")\n\tvoid ToggleFlashlight();\n\nprivate:\n\tvoid DrainBattery(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"Flashlight.h\"\n\nAFlashlight::AFlashlight()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsOn = false;\n\tBatteryLife = 100.0f;\n\tBatteryDrainRate = 1.0f;\n}\n\nvoid AFlashlight::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AFlashlight::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsOn)\n\t{\n\t\tDrainBattery(DeltaTime);\n\t}\n}\n\nvoid AFlashlight::ToggleFlashlight()\n{\n\tif (BatteryLife > 0.0f)\n\t{\n\t\tbIsOn = !bIsOn;\n\t}\n\telse\n\t{\n\t\tbIsOn = false;\n\t}\n}\n\nvoid AFlashlight::DrainBattery(float DeltaTime)\n{\n\tif (BatteryLife > 0.0f)\n\t{\n\t\tBatteryLife -= BatteryDrainRate * DeltaTime;\n\t\tif (BatteryLife <= 0.0f)\n\t\t{\n\t\t\tBatteryLife = 0.0f;\n\t\t\tbIsOn = false;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a character that can slide under obstacles.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SlidingCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASlidingCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tASlidingCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sliding\")\n\tfloat SlideSpeed;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sliding\")\n\tfloat SlideDuration;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Sliding\")\n\tvoid StartSlide();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Sliding\")\n\tvoid StopSlide();\n\nprivate:\n\tFTimerHandle SlideTimerHandle;\n\tbool bIsSliding;\n};\n```", "cpp_code": "```cpp\n#include \"SlidingCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"TimerManager.h\"\n\nASlidingCharacter::ASlidingCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSlideSpeed = 600.0f;\n\tSlideDuration = 1.0f;\n\tbIsSliding = false;\n}\n\nvoid ASlidingCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASlidingCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tif (bIsSliding)\n\t{\n\t\tFVector SlideDirection = GetActorForwardVector();\n\t\tAddMovementInput(SlideDirection, SlideSpeed * DeltaTime);\n\t}\n}\n\nvoid ASlidingCharacter::StartSlide()\n{\n\tif (!bIsSliding)\n\t{\n\t\tbIsSliding = true;\n\t\tGetCharacterMovement()->MaxWalkSpeed = SlideSpeed;\n\t\tGetWorldTimerManager().SetTimer(SlideTimerHandle, this, &ASlidingCharacter::StopSlide, SlideDuration, false);\n\t}\n}\n\nvoid ASlidingCharacter::StopSlide()\n{\n\tbIsSliding = false;\n\tGetCharacterMovement()->MaxWalkSpeed = 600.0f; // Reset to default walk speed\n\tGetWorldTimerManager().ClearTimer(SlideTimerHandle);\n}\n```"}
{"requirement": "Add a function to log the current level name.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LevelLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALevelLogger : public AActor\n{\n  GENERATED_BODY()\n\npublic:  \n  ALevelLogger();\n\n  UFUNCTION(BlueprintCallable, Category=\"Logging\")\n  void LogCurrentLevelName();\n};\n```", "cpp_code": "```cpp\n#include \"LevelLogger.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nALevelLogger::ALevelLogger()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ALevelLogger::LogCurrentLevelName()\n{\n  if (UWorld* World = GetWorld())\n  {\n\tFString LevelName = UGameplayStatics::GetCurrentLevelName(World);\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Level Name: %s\"), *LevelName);\n  }\n}\n```"}
{"requirement": "Implement a basic health bar with UMG.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"HealthBarWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API UHealthBarWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Health\")\n\tvoid SetHealthPercentage(float HealthPercentage);\n\nprotected:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UProgressBar* HealthProgressBar;\n};\n```", "cpp_code": "```cpp\n#include \"HealthBarWidget.h\"\n#include \"Components/ProgressBar.h\"\n\nvoid UHealthBarWidget::SetHealthPercentage(float HealthPercentage)\n{\n\tif (HealthProgressBar)\n\t{\n\t\tHealthProgressBar->SetPercent(HealthPercentage);\n\t}\n}\n```"}
{"requirement": "Create a simple wind effect that moves actors.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WindEffectActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWindEffectActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAWindEffectActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Wind\")\n\tFVector WindDirection;\n\n\tUPROPERTY(EditAnywhere, Category = \"Wind\")\n\tfloat WindStrength;\n};\n```", "cpp_code": "```cpp\n#include \"WindEffectActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAWindEffectActor::AWindEffectActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tWindDirection = FVector(1.0f, 0.0f, 0.0f);\n\tWindStrength = 100.0f;\n}\n\nvoid AWindEffectActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AWindEffectActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector Movement = WindDirection * WindStrength * DeltaTime;\n\tfor (TActorIterator<AActor> It(GetWorld()); It; ++It)\n\t{\n\t\tAActor* Actor = *It;\n\t\tif (Actor != this)\n\t\t{\n\t\t\tActor->AddActorWorldOffset(Movement);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Add a function to check the player's speed.", "header_code": "```cpp\nUCLASS()\nclass YOURGAME_API APlayerCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Function to get the player's current speed\n\tUFUNCTION(BlueprintCallable, Category=\"Player\")\n\tfloat GetPlayerSpeed() const;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerCharacter.h\"\n\nfloat APlayerCharacter::GetPlayerSpeed() const\n{\n\treturn GetVelocity().Size();\n}\n```"}
{"requirement": "Implement a basic wall running mechanic.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"WallRunningCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AWallRunningCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWallRunningCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid StartWallRun();\n\n\tUFUNCTION()\n\tvoid StopWallRun();\n\n\tUFUNCTION()\n\tbool CanWallRun() const;\n\n\tUFUNCTION()\n\tvoid PerformWallRun(float DeltaTime);\n\nprivate:\n\tbool bIsWallRunning;\n\tFVector WallRunDirection;\n\n\tUPROPERTY(EditAnywhere, Category=\"WallRun\")\n\tfloat WallRunSpeed;\n\n\tUPROPERTY(EditAnywhere, Category=\"WallRun\")\n\tfloat WallRunDuration;\n\n\tUPROPERTY(EditAnywhere, Category=\"WallRun\")\n\tfloat WallRunGravityScale;\n};\n```", "cpp_code": "```cpp\n#include \"WallRunningCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/InputComponent.h\"\n\nAWallRunningCharacter::AWallRunningCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsWallRunning = false;\n\tWallRunSpeed = 600.0f;\n\tWallRunDuration = 1.0f;\n\tWallRunGravityScale = 0.3f;\n}\n\nvoid AWallRunningCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AWallRunningCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsWallRunning)\n\t{\n\t\tPerformWallRun(DeltaTime);\n\t}\n}\n\nvoid AWallRunningCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"WallRun\", IE_Pressed, this, &AWallRunningCharacter::StartWallRun);\n\tPlayerInputComponent->BindAction(\"WallRun\", IE_Released, this, &AWallRunningCharacter::StopWallRun);\n}\n\nvoid AWallRunningCharacter::StartWallRun()\n{\n\tif (CanWallRun())\n\t{\n\t\tbIsWallRunning = true;\n\t\tGetCharacterMovement()->GravityScale = WallRunGravityScale;\n\t\tWallRunDirection = GetActorRightVector(); // Assume wall on the right for simplicity\n\t}\n}\n\nvoid AWallRunningCharacter::StopWallRun()\n{\n\tbIsWallRunning = false;\n\tGetCharacterMovement()->GravityScale = 1.0f;\n}\n\nbool AWallRunningCharacter::CanWallRun() const\n{\n\t// Add logic to check if wall run is possible (e.g., raycasting to check for nearby walls)\n\treturn true;\n}\n\nvoid AWallRunningCharacter::PerformWallRun(float DeltaTime)\n{\n\tif (!bIsWallRunning) return;\n\n\tFVector NewLocation = GetActorLocation() + WallRunDirection * WallRunSpeed * DeltaTime;\n\tSetActorLocation(NewLocation);\n\n\tWallRunDuration -= DeltaTime;\n\tif (WallRunDuration <= 0.0f)\n\t{\n\t\tStopWallRun();\n\t}\n}\n```"}
{"requirement": "Create a simple collectable coin system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Coin.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ACoin : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACoin();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle the collection of the coin\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprivate:\n\t// Sphere component to detect overlaps\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tclass USphereComponent* CollisionComponent;\n\n\t// Static mesh for the coin\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tclass UStaticMeshComponent* CoinMesh;\n\n\t// Coin value\n\tUPROPERTY(EditAnywhere, Category = \"Coin\")\n\tint32 CoinValue;\n};\n```", "cpp_code": "```cpp\n#include \"Coin.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nACoin::ACoin()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set up the sphere component\n\tCollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\tCollisionComponent->InitSphereRadius(50.0f);\n\tCollisionComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\n\t// Create and set up the static mesh component\n\tCoinMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"CoinMesh\"));\n\tCoinMesh->SetupAttachment(RootComponent);\n\n\t// Set default coin value\n\tCoinValue = 10;\n\n\t// Register the overlap event\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACoin::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ACoin::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACoin::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACoin::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor != nullptr && OtherActor != this && OtherComp != nullptr)\n\t{\n\t\t// Implement logic to add the coin value to the player's total\n\t\t// For example, cast to the player's character and increase the score\n\t\tDestroy(); // Destroy the coin after collection\n\t}\n}\n```"}
{"requirement": "Add a function to change the skybox during play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SkyboxChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASkyboxChanger : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tASkyboxChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Skybox\")\n\tvoid ChangeSkybox(UStaticMesh* NewSkybox);\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* SkyboxMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SkyboxChanger.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nASkyboxChanger::ASkyboxChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSkyboxMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"SkyboxMeshComponent\"));\n\tRootComponent = SkyboxMeshComponent;\n}\n\nvoid ASkyboxChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASkyboxChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASkyboxChanger::ChangeSkybox(UStaticMesh* NewSkybox)\n{\n\tif (SkyboxMeshComponent && NewSkybox)\n\t{\n\t\tSkyboxMeshComponent->SetStaticMesh(NewSkybox);\n\t}\n}\n```"}
{"requirement": "Implement a basic dual-wield weapon system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DualWieldWeaponSystem.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADualWieldWeaponSystem : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tADualWieldWeaponSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to equip weapons\n\tUFUNCTION(BlueprintCallable, Category=\"Weapon\")\n\tvoid EquipWeapons(AActor* LeftWeapon, AActor* RightWeapon);\n\n\t// Function to fire left weapon\n\tUFUNCTION(BlueprintCallable, Category=\"Weapon\")\n\tvoid FireLeftWeapon();\n\n\t// Function to fire right weapon\n\tUFUNCTION(BlueprintCallable, Category=\"Weapon\")\n\tvoid FireRightWeapon();\n\nprivate:\n\t// Pointers to the weapons\n\tUPROPERTY()\n\tAActor* LeftWeapon;\n\n\tUPROPERTY()\n\tAActor* RightWeapon;\n};\n```", "cpp_code": "```cpp\n#include \"DualWieldWeaponSystem.h\"\n\n// Sets default values\nADualWieldWeaponSystem::ADualWieldWeaponSystem()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tLeftWeapon = nullptr;\n\tRightWeapon = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid ADualWieldWeaponSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ADualWieldWeaponSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ADualWieldWeaponSystem::EquipWeapons(AActor* NewLeftWeapon, AActor* NewRightWeapon)\n{\n\tif (NewLeftWeapon)\n\t{\n\t\tLeftWeapon = NewLeftWeapon;\n\t\t// Additional logic for equipping left weapon can be added here\n\t}\n\tif (NewRightWeapon)\n\t{\n\t\tRightWeapon = NewRightWeapon;\n\t\t// Additional logic for equipping right weapon can be added here\n\t}\n}\n\nvoid ADualWieldWeaponSystem::FireLeftWeapon()\n{\n\tif (LeftWeapon)\n\t{\n\t\t// Logic to fire the left weapon\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Firing Left Weapon!\"));\n\t}\n}\n\nvoid ADualWieldWeaponSystem::FireRightWeapon()\n{\n\tif (RightWeapon)\n\t{\n\t\t// Logic to fire the right weapon\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Firing Right Weapon!\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that spins when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpinActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpinActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tASpinActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle click event\n\tUFUNCTION()\n\tvoid OnClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed);\n\nprivate:\n\t// Rotation speed\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed;\n\n\t// Flag to check if spinning\n\tbool bIsSpinning;\n\n\t// Root component\n\tUSceneComponent* RootComp;\n\n\t// Static Mesh\n\tUStaticMeshComponent* MeshComp;\n};\n```", "cpp_code": "```cpp\n#include \"SpinActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nASpinActor::ASpinActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create root component\n\tRootComp = CreateDefaultSubobject<USceneComponent>(TEXT(\"RootComponent\"));\n\tRootComponent = RootComp;\n\n\t// Create static mesh component\n\tMeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComp->SetupAttachment(RootComp);\n\n\t// Enable click events\n\tMeshComp->SetMobility(EComponentMobility::Movable);\n\tMeshComp->OnClicked.AddDynamic(this, &ASpinActor::OnClicked);\n\n\t// Initialize variables\n\tRotationSpeed = 180.0f;\n\tbIsSpinning = false;\n}\n\n// Called when the game starts or when spawned\nvoid ASpinActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpinActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsSpinning)\n\t{\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n\nvoid ASpinActor::OnClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed)\n{\n\tbIsSpinning = !bIsSpinning;\n}\n```"}
{"requirement": "Add a function to toggle slow motion.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SlowMotionToggle.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASlowMotionToggle : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASlowMotionToggle();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"TimeControl\")\n\tvoid ToggleSlowMotion();\n\nprivate:\n\tbool bIsSlowMotionActive;\n};\n```", "cpp_code": "```cpp\n#include \"SlowMotionToggle.h\"\n#include \"GameFramework/WorldSettings.h\"\n\nASlowMotionToggle::ASlowMotionToggle()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsSlowMotionActive = false;\n}\n\nvoid ASlowMotionToggle::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASlowMotionToggle::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASlowMotionToggle::ToggleSlowMotion()\n{\n\tif (GetWorld())\n\t{\n\t\tUWorld* World = GetWorld();\n\t\tAWorldSettings* WorldSettings = World->GetWorldSettings();\n\t\tif (bIsSlowMotionActive)\n\t\t{\n\t\t\tWorldSettings->SetTimeDilation(1.0f);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWorldSettings->SetTimeDilation(0.5f); // Adjust this value for desired slow motion effect\n\t\t}\n\t\tbIsSlowMotionActive = !bIsSlowMotionActive;\n\t}\n}\n```"}
{"requirement": "Implement a basic healing zone for the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealingZone.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHealingZone : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAHealingZone();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Healing\")\n\tfloat HealingRate;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass USphereComponent* CollisionComponent;\n\n\tUPROPERTY()\n\tTSet<AActor*> OverlappingPlayers;\n};\n```", "cpp_code": "```cpp\n#include \"HealingZone.h\"\n#include \"Components/SphereComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/Character.h\"\n#include \"TimerManager.h\"\n\nAHealingZone::AHealingZone()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"SphereComponent\"));\n\tCollisionComponent->InitSphereRadius(200.0f);\n\tCollisionComponent->SetCollisionProfileName(TEXT(\"Trigger\"));\n\tRootComponent = CollisionComponent;\n\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AHealingZone::OnOverlapBegin);\n\tCollisionComponent->OnComponentEndOverlap.AddDynamic(this, &AHealingZone::OnOverlapEnd);\n\n\tHealingRate = 5.0f;\n}\n\nvoid AHealingZone::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealingZone::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfor (AActor* Player : OverlappingPlayers)\n\t{\n\t\tif (ACharacter* Character = Cast<ACharacter>(Player))\n\t\t{\n\t\t\t// Assuming the character has a function to modify health\n\t\t\t// Character->ModifyHealth(HealingRate * DeltaTime);\n\t\t}\n\t}\n}\n\nvoid AHealingZone::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tOverlappingPlayers.Add(OtherActor);\n\t}\n}\n\nvoid AHealingZone::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tOverlappingPlayers.Remove(OtherActor);\n\t}\n}\n```"}
{"requirement": "Create a simple NPC that follows the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"NPCFollower.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ANPCFollower : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tANPCFollower();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAPawn* PlayerPawn;\n\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tfloat AcceptanceRadius = 200.0f;\n};\n```", "cpp_code": "```cpp\n#include \"NPCFollower.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"AIController.h\"\n\nANPCFollower::ANPCFollower()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ANPCFollower::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid ANPCFollower::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerPawn)\n\t{\n\t\tAAIController* AIController = Cast<AAIController>(GetController());\n\t\tif (AIController)\n\t\t{\n\t\t\tAIController->MoveToActor(PlayerPawn, AcceptanceRadius);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Add a function to spawn an actor at a random location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActorSpawner.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActorSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAYourActorSpawner();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Spawning\")\n\tvoid SpawnActorAtRandomLocation();\n\n\tUPROPERTY(EditAnywhere, Category = \"Spawning\")\n\tTSubclassOf<AActor> ActorToSpawn;\n\n\tUPROPERTY(EditAnywhere, Category = \"Spawning\")\n\tFVector SpawnAreaMin;\n\n\tUPROPERTY(EditAnywhere, Category = \"Spawning\")\n\tFVector SpawnAreaMax;\n};\n```", "cpp_code": "```cpp\n#include \"YourActorSpawner.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\n// Sets default values\nAYourActorSpawner::AYourActorSpawner()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AYourActorSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AYourActorSpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AYourActorSpawner::SpawnActorAtRandomLocation()\n{\n\tif (ActorToSpawn)\n\t{\n\t\tFVector RandomLocation = UKismetMathLibrary::RandomPointInBoundingBox(SpawnAreaMin, SpawnAreaMax - SpawnAreaMin);\n\t\tFActorSpawnParameters SpawnParams;\n\t\tGetWorld()->SpawnActor<AActor>(ActorToSpawn, RandomLocation, FRotator::ZeroRotator, SpawnParams);\n\t}\n}\n```"}
{"requirement": "Implement a simple music system with volume control.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimpleMusicSystem.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASimpleMusicSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASimpleMusicSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Music\")\n\tvoid PlayMusic();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Music\")\n\tvoid StopMusic();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Music\")\n\tvoid SetVolume(float Volume);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Music\")\n\tUSoundCue* MusicCue;\n\n\tUPROPERTY(EditAnywhere, Category=\"Music\")\n\tfloat Volume;\n\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SimpleMusicSystem.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n\nASimpleMusicSystem::ASimpleMusicSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->bAutoActivate = false;\n\tVolume = 1.0f;\n}\n\nvoid ASimpleMusicSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (MusicCue)\n\t{\n\t\tAudioComponent->SetSound(MusicCue);\n\t}\n}\n\nvoid ASimpleMusicSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASimpleMusicSystem::PlayMusic()\n{\n\tif (AudioComponent && MusicCue)\n\t{\n\t\tAudioComponent->Play();\n\t}\n}\n\nvoid ASimpleMusicSystem::StopMusic()\n{\n\tif (AudioComponent)\n\t{\n\t\tAudioComponent->Stop();\n\t}\n}\n\nvoid ASimpleMusicSystem::SetVolume(float NewVolume)\n{\n\tVolume = FMath::Clamp(NewVolume, 0.0f, 1.0f);\n\tif (AudioComponent)\n\t{\n\t\tAudioComponent->SetVolumeMultiplier(Volume);\n\t}\n}\n```"}
{"requirement": "Create a character that clings to surfaces.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"ClingingCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AClingingCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAClingingCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Cling\")\n\tbool bIsClinging;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Cling\")\n\tvoid StartClinging();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Cling\")\n\tvoid StopClinging();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Cling\")\n\tfloat ClingSpeed;\n\nprivate:\n\tvoid ClingToSurface(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"ClingingCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAClingingCharacter::AClingingCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsClinging = false;\n\tClingSpeed = 200.0f;\n}\n\nvoid AClingingCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AClingingCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsClinging)\n\t{\n\t\tClingToSurface(DeltaTime);\n\t}\n}\n\nvoid AClingingCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"Cling\", IE_Pressed, this, &AClingingCharacter::StartClinging);\n\tPlayerInputComponent->BindAction(\"Cling\", IE_Released, this, &AClingingCharacter::StopClinging);\n}\n\nvoid AClingingCharacter::StartClinging()\n{\n\tbIsClinging = true;\n\tGetCharacterMovement()->GravityScale = 0.0f;\n}\n\nvoid AClingingCharacter::StopClinging()\n{\n\tbIsClinging = false;\n\tGetCharacterMovement()->GravityScale = 1.0f;\n}\n\nvoid AClingingCharacter::ClingToSurface(float DeltaTime)\n{\n\tif (Controller)\n\t{\n\t\tFVector ForwardVector = Controller->GetControlRotation().Vector();\n\t\tAddMovementInput(ForwardVector, ClingSpeed * DeltaTime);\n\t}\n}\n```"}
{"requirement": "Add a function to print out available console commands.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ConsoleCommandPrinter.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AConsoleCommandPrinter : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic: \n\t// Sets default values for this actor's properties\n\tAConsoleCommandPrinter();\n\n\t// Function to print available console commands\n\tUFUNCTION(BlueprintCallable, Category=\"Console Commands\")\n\tvoid PrintAvailableConsoleCommands();\n};\n```", "cpp_code": "```cpp\n#include \"ConsoleCommandPrinter.h\"\n#include \"Engine/Engine.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Actor.h\"\n\nAConsoleCommandPrinter::AConsoleCommandPrinter()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AConsoleCommandPrinter::PrintAvailableConsoleCommands()\n{\n\tif (GEngine)\n\t{\n\t\tFString Output;\n\t\tfor (TObjectIterator<UConsole> It; It; ++It)\n\t\t{\n\t\t\tUConsole* Console = *It;\n\t\t\tif (Console)\n\t\t\t{\n\t\t\t\tOutput = Console->ConsoleCommandHistory;\n\t\t\t\tfor (const FString& Command : Console->AutoCompleteList)\n\t\t\t\t{\n\t\t\t\t\tOutput += Command + TEXT(\"\\n\");\n\t\t\t\t}\n\t\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, Output);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a basic color change on damage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangeOnDamage.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AColorChangeOnDamage : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorChangeOnDamage();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnTakeDamage();\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Damage\")\n\tFLinearColor DamageColor;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Damage\")\n\tFLinearColor DefaultColor;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeOnDamage.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAColorChangeOnDamage::AColorChangeOnDamage()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tDefaultColor = FLinearColor::White;\n\tDamageColor = FLinearColor::Red;\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangeOnDamage::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"Color\"), DefaultColor);\n}\n\n// Called every frame\nvoid AColorChangeOnDamage::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AColorChangeOnDamage::OnTakeDamage()\n{\n\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"Color\"), DamageColor);\n}\n```"}
{"requirement": "Create a simple teleportation system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TeleportationSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATeleportationSystem : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tATeleportationSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Teleportation\")\n\tvoid TeleportActor(AActor* ActorToTeleport, const FVector& TargetLocation);\n};\n```", "cpp_code": "```cpp\n#include \"TeleportationSystem.h\"\n\nATeleportationSystem::ATeleportationSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ATeleportationSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATeleportationSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATeleportationSystem::TeleportActor(AActor* ActorToTeleport, const FVector& TargetLocation)\n{\n\tif (ActorToTeleport)\n\t{\n\t\tActorToTeleport->SetActorLocation(TargetLocation);\n\t}\n}\n```"}
{"requirement": "Add a function to toggle character invisibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visibility\")\n\tvoid ToggleInvisibility();\n\nprivate:\n\tbool bIsInvisible;\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n\nAMyCharacter::AMyCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsInvisible = false;\n}\n\nvoid AMyCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\nvoid AMyCharacter::ToggleInvisibility()\n{\n\tbIsInvisible = !bIsInvisible;\n\tSetActorHiddenInGame(bIsInvisible);\n\tSetActorEnableCollision(!bIsInvisible);\n}\n```"}
{"requirement": "Implement a basic sliding door mechanic.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SlidingDoor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASlidingDoor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tASlidingDoor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector OpenPosition;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector ClosedPosition;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat DoorSpeed;\n\n\tUFUNCTION(BlueprintCallable)\n\tvoid OpenDoor();\n\n\tUFUNCTION(BlueprintCallable)\n\tvoid CloseDoor();\n\nprivate:\n\tbool bIsOpening;\n\tbool bIsClosing;\n};\n```", "cpp_code": "```cpp\n#include \"SlidingDoor.h\"\n\nASlidingDoor::ASlidingDoor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tClosedPosition = GetActorLocation();\n\tOpenPosition = ClosedPosition + FVector(0, 200, 0); // Example offset for open position\n\tDoorSpeed = 100.0f;\n\tbIsOpening = false;\n\tbIsClosing = false;\n}\n\nvoid ASlidingDoor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASlidingDoor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsOpening)\n\t{\n\t\tFVector CurrentPosition = GetActorLocation();\n\t\tFVector NewPosition = FMath::VInterpConstantTo(CurrentPosition, OpenPosition, DeltaTime, DoorSpeed);\n\t\tSetActorLocation(NewPosition);\n\n\t\tif (CurrentPosition.Equals(OpenPosition, 1.0f))\n\t\t{\n\t\t\tbIsOpening = false;\n\t\t}\n\t}\n\telse if (bIsClosing)\n\t{\n\t\tFVector CurrentPosition = GetActorLocation();\n\t\tFVector NewPosition = FMath::VInterpConstantTo(CurrentPosition, ClosedPosition, DeltaTime, DoorSpeed);\n\t\tSetActorLocation(NewPosition);\n\n\t\tif (CurrentPosition.Equals(ClosedPosition, 1.0f))\n\t\t{\n\t\t\tbIsClosing = false;\n\t\t}\n\t}\n}\n\nvoid ASlidingDoor::OpenDoor()\n{\n\tbIsOpening = true;\n\tbIsClosing = false;\n}\n\nvoid ASlidingDoor::CloseDoor()\n{\n\tbIsClosing = true;\n\tbIsOpening = false;\n}\n```"}
{"requirement": "Create an actor that changes its mesh based on time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ADynamicMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADynamicMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ChangeMesh();\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Meshes\")\n\tTArray<UStaticMesh*> Meshes;\n\n\tfloat TimeAccumulator;\n\n\tUPROPERTY(EditAnywhere, Category=\"Time\")\n\tfloat ChangeInterval;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n\nADynamicMeshActor::ADynamicMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tTimeAccumulator = 0.0f;\n\tChangeInterval = 5.0f; // Change mesh every 5 seconds by default\n}\n\nvoid ADynamicMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADynamicMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeAccumulator += DeltaTime;\n\tif (TimeAccumulator >= ChangeInterval)\n\t{\n\t\tChangeMesh();\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n\nvoid ADynamicMeshActor::ChangeMesh()\n{\n\tif (Meshes.Num() > 0)\n\t{\n\t\tint32 MeshIndex = FMath::RandRange(0, Meshes.Num() - 1);\n\t\tMeshComponent->SetStaticMesh(Meshes[MeshIndex]);\n\t}\n}\n```"}
{"requirement": "Add a function to detect when the player is falling.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"FallingCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AFallingCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFallingCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Movement\")\n\tbool IsFalling() const;\n};\n```", "cpp_code": "```cpp\n#include \"FallingCharacter.h\"\n\nAFallingCharacter::AFallingCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AFallingCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AFallingCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nbool AFallingCharacter::IsFalling() const\n{\n\treturn GetCharacterMovement()->IsFalling();\n}\n```"}
{"requirement": "Implement a basic dynamic weather system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WeatherSystem.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AWeatherSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAWeatherSystem();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Weather\")\n\tfloat WeatherChangeInterval;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Weather\")\n\tvoid ChangeWeather();\n\nprivate:\n\tvoid UpdateWeather();\n\n\tFTimerHandle WeatherChangeTimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"WeatherSystem.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAWeatherSystem::AWeatherSystem()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tWeatherChangeInterval = 60.0f; // Default to change weather every 60 seconds\n}\n\n// Called when the game starts or when spawned\nvoid AWeatherSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tGetWorldTimerManager().SetTimer(WeatherChangeTimerHandle, this, &AWeatherSystem::ChangeWeather, WeatherChangeInterval, true);\n}\n\n// Called every frame\nvoid AWeatherSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AWeatherSystem::ChangeWeather()\n{\n\tUpdateWeather();\n}\n\nvoid AWeatherSystem::UpdateWeather()\n{\n\t// Simple weather change logic\n\tint WeatherType = FMath::RandRange(0, 2);\n\tswitch (WeatherType)\n\t{\n\tcase 0:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Weather changed to Sunny\"));\n\t\tbreak;\n\tcase 1:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Weather changed to Rainy\"));\n\t\tbreak;\n\tcase 2:\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Weather changed to Cloudy\"));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n```"}
{"requirement": "Create a destructible object that breaks on impact.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DestructibleComponent.h\"\n#include \"DestructibleObject.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADestructibleObject : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADestructibleObject();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Destructible\")\n\tUDestructibleComponent* DestructibleComponent;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"DestructibleObject.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nADestructibleObject::ADestructibleObject()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tDestructibleComponent = CreateDefaultSubobject<UDestructibleComponent>(TEXT(\"DestructibleComponent\"));\n\tRootComponent = DestructibleComponent;\n\n\tDestructibleComponent->OnComponentHit.AddDynamic(this, &ADestructibleObject::OnHit);\n}\n\nvoid ADestructibleObject::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADestructibleObject::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADestructibleObject::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (DestructibleComponent)\n\t{\n\t\tDestructibleComponent->ApplyDamage(10.0f, Hit.ImpactPoint, NormalImpulse, 1000.0f);\n\t}\n}\n```"}
{"requirement": "Add a function to control actor brightness.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BrightnessControlActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ABrightnessControlActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tABrightnessControlActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Brightness\")\n\tvoid SetBrightness(float NewBrightness);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Brightness\")\n\tfloat Brightness;\n};\n```", "cpp_code": "```cpp\n#include \"BrightnessControlActor.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nABrightnessControlActor::ABrightnessControlActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tBrightness = 1.0f;\n}\n\nvoid ABrightnessControlActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ABrightnessControlActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ABrightnessControlActor::SetBrightness(float NewBrightness)\n{\n\tBrightness = FMath::Clamp(NewBrightness, 0.0f, 1.0f);\n\n\tTArray<UPrimitiveComponent*> Components;\n\tGetComponents(Components);\n\n\tfor (UPrimitiveComponent* Component : Components)\n\t{\n\t\tif (Component)\n\t\t{\n\t\t\tComponent->SetScalarParameterValueOnMaterials(TEXT(\"Brightness\"), Brightness);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a basic inventory limit system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"InventorySystem.generated.h\"\n\nUCLASS(Blueprintable)\nclass YOURGAME_API UInventorySystem : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUInventorySystem();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tbool AddItem(FString ItemName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tbool RemoveItem(FString ItemName);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Inventory\")\n\tTArray<FString> GetInventoryItems() const;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Inventory\")\n\tint32 InventoryLimit;\n\n\tUPROPERTY()\n\tTArray<FString> Items;\n};\n```", "cpp_code": "```cpp\n#include \"InventorySystem.h\"\n\nUInventorySystem::UInventorySystem()\n{\n\tInventoryLimit = 10; // Default inventory limit\n}\n\nbool UInventorySystem::AddItem(FString ItemName)\n{\n\tif (Items.Num() < InventoryLimit)\n\t{\n\t\tItems.Add(ItemName);\n\t\treturn true;\n\t}\n\treturn false; // Inventory is full\n}\n\nbool UInventorySystem::RemoveItem(FString ItemName)\n{\n\treturn Items.Remove(ItemName) > 0;\n}\n\nTArray<FString> UInventorySystem::GetInventoryItems() const\n{\n\treturn Items;\n}\n```"}
{"requirement": "Create a simple starfield background.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"StarfieldBackground.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AStarfieldBackground : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAStarfieldBackground();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid GenerateStarfield();\n\n\tUPROPERTY(EditAnywhere, Category = \"Starfield\")\n\tint32 NumberOfStars;\n\n\tUPROPERTY(EditAnywhere, Category = \"Starfield\")\n\tfloat StarfieldRadius;\n\n\tUPROPERTY(EditDefaultsOnly, Category = \"Starfield\")\n\tUMaterial* StarMaterial;\n\n\tUPROPERTY()\n\tTArray<UStaticMeshComponent*> Stars;\n};\n```", "cpp_code": "```cpp\n#include \"StarfieldBackground.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAStarfieldBackground::AStarfieldBackground()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tNumberOfStars = 100;\n\tStarfieldRadius = 1000.0f;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> StarMesh(TEXT(\"/Engine/BasicShapes/Sphere.Sphere\"));\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> StarMat(TEXT(\"/Game/StarMaterial.StarMaterial\"));\n\n\tif (StarMesh.Succeeded() && StarMat.Succeeded())\n\t{\n\t\tStarMaterial = StarMat.Object;\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AStarfieldBackground::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGenerateStarfield();\n}\n\n// Called every frame\nvoid AStarfieldBackground::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AStarfieldBackground::GenerateStarfield()\n{\n\tfor (int32 i = 0; i < NumberOfStars; ++i)\n\t{\n\t\tUStaticMeshComponent* Star = NewObject<UStaticMeshComponent>(this);\n\t\tStar->SetStaticMesh(ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"/Engine/BasicShapes/Sphere.Sphere\")).Object);\n\t\tStar->SetMaterial(0, StarMaterial);\n\n\t\tFVector RandomLocation = FMath::VRand() * FMath::RandRange(0.0f, StarfieldRadius);\n\t\tStar->SetWorldLocation(RandomLocation);\n\t\tStar->SetWorldScale3D(FVector(0.1f));\n\t\tStar->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepWorldTransform);\n\t\tStar->RegisterComponent();\n\t\tStars.Add(Star);\n\t}\n}\n```"}
{"requirement": "Add a function to pause sound effects.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/AudioComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SoundEffectManager.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundEffectManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundEffectManager();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Audio\")\n\tvoid PauseSoundEffects();\n\nprivate:\n\tUPROPERTY()\n\tTArray<UAudioComponent*> AudioComponents;\n};\n```", "cpp_code": "```cpp\n#include \"SoundEffectManager.h\"\n#include \"Components/AudioComponent.h\"\n\nASoundEffectManager::ASoundEffectManager()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ASoundEffectManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Find all audio components in the scene\n\tTArray<UActorComponent*> Components;\n\tGetComponents(UAudioComponent::StaticClass(), Components);\n\n\tfor (UActorComponent* Component : Components)\n\t{\n\t\tUAudioComponent* AudioComponent = Cast<UAudioComponent>(Component);\n\t\tif (AudioComponent && AudioComponent->IsPlaying())\n\t\t{\n\t\t\tAudioComponents.Add(AudioComponent);\n\t\t}\n\t}\n}\n\nvoid ASoundEffectManager::PauseSoundEffects()\n{\n\tfor (UAudioComponent* AudioComponent : AudioComponents)\n\t{\n\t\tif (AudioComponent && AudioComponent->IsPlaying())\n\t\t{\n\t\t\tAudioComponent->SetPaused(true);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a basic on-screen key prompt.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"KeyPromptActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AKeyPromptActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAKeyPromptActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Prompt\")\n\tFString PromptMessage;\n\n\tUPROPERTY(EditAnywhere, Category=\"Prompt\")\n\tFKey PromptKey;\n\n\tvoid ShowPrompt();\n\n\tvoid HidePrompt();\n\n\tbool bIsPromptVisible;\n};\n```", "cpp_code": "```cpp\n#include \"KeyPromptActor.h\"\n#include \"Engine/Engine.h\"\n\nAKeyPromptActor::AKeyPromptActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsPromptVisible = false;\n}\n\nvoid AKeyPromptActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AKeyPromptActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!bIsPromptVisible && FInputKeyEventArgs::IsPressed(PromptKey))\n\t{\n\t\tShowPrompt();\n\t\tbIsPromptVisible = true;\n\t}\n\telse if (bIsPromptVisible && !FInputKeyEventArgs::IsPressed(PromptKey))\n\t{\n\t\tHidePrompt();\n\t\tbIsPromptVisible = false;\n\t}\n}\n\nvoid AKeyPromptActor::ShowPrompt()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, PromptMessage);\n\t}\n}\n\nvoid AKeyPromptActor::HidePrompt()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->ClearOnScreenDebugMessages();\n\t}\n}\n```"}
{"requirement": "Create a simple score multiplier system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreMultiplierSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AScoreMultiplierSystem : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAScoreMultiplierSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid AddScore(int32 BasePoints);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid SetMultiplier(float NewMultiplier);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tint32 GetTotalScore() const;\n\nprivate:\n\tint32 TotalScore;\n\tfloat Multiplier;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreMultiplierSystem.h\"\n\nAScoreMultiplierSystem::AScoreMultiplierSystem()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTotalScore = 0;\n\tMultiplier = 1.0f;\n}\n\nvoid AScoreMultiplierSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScoreMultiplierSystem::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScoreMultiplierSystem::AddScore(int32 BasePoints)\n{\n\tTotalScore += FMath::RoundToInt(BasePoints * Multiplier);\n}\n\nvoid AScoreMultiplierSystem::SetMultiplier(float NewMultiplier)\n{\n\tMultiplier = NewMultiplier;\n}\n\nint32 AScoreMultiplierSystem::GetTotalScore() const\n{\n\treturn TotalScore;\n}\n```"}
{"requirement": "Add a function to print the number of actors in a level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CountActors.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACountActors : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACountActors();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Level\")\n\tvoid PrintNumberOfActorsInLevel();\n};\n```", "cpp_code": "```cpp\n#include \"CountActors.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nACountActors::ACountActors()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ACountActors::PrintNumberOfActorsInLevel()\n{\n\tif (GetWorld())\n\t{\n\t\tint32 ActorCount = GetWorld()->GetActorCount();\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Number of actors in the level: %d\"), ActorCount);\n\t}\n}\n```"}
{"requirement": "Implement a simple health display using text.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthDisplay.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHealthDisplay : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAHealthDisplay();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tint32 Health;\n\n\tUFUNCTION()\n\tvoid DisplayHealth();\n};\n```", "cpp_code": "```cpp\n#include \"HealthDisplay.h\"\n#include \"Engine/Engine.h\"\n\nAHealthDisplay::AHealthDisplay()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHealth = 100; // Initialize health\n}\n\nvoid AHealthDisplay::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tDisplayHealth();\n}\n\nvoid AHealthDisplay::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHealthDisplay::DisplayHealth()\n{\n\tif (GEngine)\n\t{\n\t\tFString HealthString = FString::Printf(TEXT(\"Current Health: %d\"), Health);\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, HealthString);\n\t}\n}\n```"}
{"requirement": "Create a character that can wall slide.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"WallSlideCharacter.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWallSlideCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWallSlideCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid WallSlide();\n\n\tbool bIsSliding;\n\n\tUFUNCTION()\n\tvoid OnWallHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"WallSlideCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/CapsuleComponent.h\"\n\nAWallSlideCharacter::AWallSlideCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tGetCapsuleComponent()->OnComponentHit.AddDynamic(this, &AWallSlideCharacter::OnWallHit);\n\n\tbIsSliding = false;\n}\n\nvoid AWallSlideCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AWallSlideCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsSliding)\n\t{\n\t\tWallSlide();\n\t}\n}\n\nvoid AWallSlideCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\nvoid AWallSlideCharacter::WallSlide()\n{\n\t// Simple gravity reduction for wall sliding effect\n\tFVector NewVelocity = GetCharacterMovement()->Velocity;\n\tNewVelocity.Z = FMath::Clamp(NewVelocity.Z, -200.f, 0.f);\n\tGetCharacterMovement()->Velocity = NewVelocity;\n}\n\nvoid AWallSlideCharacter::OnWallHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\t// Check if the hit surface is a wall\n\tFVector Normal = Hit.Normal;\n\n\tif (FMath::Abs(Normal.Z) < KINDA_SMALL_NUMBER)\n\t{\n\t\tbIsSliding = true;\n\t}\n\telse\n\t{\n\t\tbIsSliding = false;\n\t}\n}\n```"}
{"requirement": "Add a function to detect actor overlap events.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* CollisionComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/BoxComponent.h\"\n\nAOverlapActor::AOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tRootComponent = CollisionComponent;\n\n\tCollisionComponent->SetGenerateOverlapEvents(true);\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n}\n\nvoid AOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlap Begin with: %s\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Implement a basic shooting mechanic.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyShootingActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyShootingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyShootingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Shooting\")\n\tvoid Shoot();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Shooting\")\n\tTSubclassOf<AActor> ProjectileClass;\n\n\tUPROPERTY(EditAnywhere, Category=\"Shooting\")\n\tFVector MuzzleOffset;\n};\n```", "cpp_code": "```cpp\n#include \"MyShootingActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nAMyShootingActor::AMyShootingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyShootingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyShootingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyShootingActor::Shoot()\n{\n\tif (ProjectileClass)\n\t{\n\t\tFVector MuzzleLocation = GetActorLocation() + FTransform(GetActorRotation()).TransformVector(MuzzleOffset);\n\t\tFRotator MuzzleRotation = GetActorRotation();\n\t\tUWorld* World = GetWorld();\n\t\tif (World)\n\t\t{\n\t\t\tWorld->SpawnActor<AActor>(ProjectileClass, MuzzleLocation, MuzzleRotation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a simple level transition system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LevelTransitionSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALevelTransitionSystem : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALevelTransitionSystem();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"LevelTransition\")\n\tvoid TransitionToLevel(FName LevelName);\n};\n```", "cpp_code": "```cpp\n#include \"LevelTransitionSystem.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nALevelTransitionSystem::ALevelTransitionSystem()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALevelTransitionSystem::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALevelTransitionSystem::TransitionToLevel(FName LevelName)\n{\n\tif (!LevelName.IsNone())\n\t{\n\t\tUGameplayStatics::OpenLevel(this, LevelName);\n\t}\n}\n```"}
{"requirement": "Add a function to invert character controls.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"InvertControlsCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AInvertControlsCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tAInvertControlsCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Function to invert controls\n\tUFUNCTION(BlueprintCallable, Category=\"Character\")\n\tvoid InvertControls();\n\nprivate:\n\tbool bAreControlsInverted;\n\n\tvoid MoveForward(float Value);\n\tvoid MoveRight(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"InvertControlsCharacter.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/InputComponent.h\"\n\nAInvertControlsCharacter::AInvertControlsCharacter()\n{\n\t// Set default values\n\tbAreControlsInverted = false;\n}\n\nvoid AInvertControlsCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AInvertControlsCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AInvertControlsCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &AInvertControlsCharacter::MoveForward);\n\tPlayerInputComponent->BindAxis(\"MoveRight\", this, &AInvertControlsCharacter::MoveRight);\n}\n\nvoid AInvertControlsCharacter::MoveForward(float Value)\n{\n\tif (bAreControlsInverted)\n\t{\n\t\tValue = -Value;\n\t}\n\tAddMovementInput(GetActorForwardVector(), Value);\n}\n\nvoid AInvertControlsCharacter::MoveRight(float Value)\n{\n\tif (bAreControlsInverted)\n\t{\n\t\tValue = -Value;\n\t}\n\tAddMovementInput(GetActorRightVector(), Value);\n}\n\nvoid AInvertControlsCharacter::InvertControls()\n{\n\tbAreControlsInverted = !bAreControlsInverted;\n}\n```"}
{"requirement": "Implement a basic auto-save feature.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AutoSaveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAutoSaveActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAutoSaveActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid AutoSave();\n\n\tUPROPERTY(EditAnywhere, Category=\"AutoSave\")\n\tfloat SaveInterval;\n\n\tFTimerHandle AutoSaveTimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"AutoSaveActor.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n\nAAutoSaveActor::AAutoSaveActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSaveInterval = 300.0f; // default to 5 minutes\n}\n\nvoid AAutoSaveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorld()->GetTimerManager().SetTimer(AutoSaveTimerHandle, this, &AAutoSaveActor::AutoSave, SaveInterval, true);\n}\n\nvoid AAutoSaveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AAutoSaveActor::AutoSave()\n{\n\tUE_LOG(LogTemp, Log, TEXT(\"Auto-saving game state...\"));\n\t// Implement your save logic here\n}\n```"}
{"requirement": "Create an actor that emits light periodically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"PeriodicLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APeriodicLightActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAPeriodicLightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUPointLightComponent* PointLight;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat LightOnDuration;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat LightOffDuration;\n\n\tFTimerHandle LightTimerHandle;\n\n\tvoid ToggleLight();\n};\n```", "cpp_code": "```cpp\n#include \"PeriodicLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nAPeriodicLightActor::APeriodicLightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\tLightOnDuration = 1.0f;\n\tLightOffDuration = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid APeriodicLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tToggleLight();\n}\n\n// Called every frame\nvoid APeriodicLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APeriodicLightActor::ToggleLight()\n{\n\tPointLight->ToggleVisibility();\n\tfloat NextDuration = PointLight->IsVisible() ? LightOffDuration : LightOnDuration;\n\tGetWorldTimerManager().SetTimer(LightTimerHandle, this, &APeriodicLightActor::ToggleLight, NextDuration);\n}\n```"}
{"requirement": "Add a function to check the player's health status.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"PlayerCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API APlayerCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tAPlayerCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Function to check the player's health status\n\tUFUNCTION(BlueprintCallable, Category=\"Health\")\n\tFString CheckHealthStatus() const;\n\nprivate:\n\t// Player's health\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\", meta=(AllowPrivateAccess = \"true\"))\n\tfloat Health;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerCharacter.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAPlayerCharacter::APlayerCharacter()\n{\n\t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize health\n\tHealth = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid APlayerCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APlayerCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid APlayerCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\n// Function to check the player's health status\nFString APlayerCharacter::CheckHealthStatus() const\n{\n\tif (Health > 75.0f)\n\t{\n\t\treturn TEXT(\"Healthy\");\n\t}\n\telse if (Health > 50.0f)\n\t{\n\t\treturn TEXT(\"Injured\");\n\t}\n\telse if (Health > 25.0f)\n\t{\n\t\treturn TEXT(\"Critical\");\n\t}\n\telse\n\t{\n\t\treturn TEXT(\"Near Death\");\n\t}\n}\n```"}
{"requirement": "Implement a basic toggle for character abilities.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"AbilityToggleCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AAbilityToggleCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAbilityToggleCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Abilities\")\n\tvoid ToggleAbility();\n\nprivate:\n\tbool bIsAbilityActive;\n};\n```", "cpp_code": "```cpp\n#include \"AbilityToggleCharacter.h\"\n\nAAbilityToggleCharacter::AAbilityToggleCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsAbilityActive = false;\n}\n\nvoid AAbilityToggleCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAbilityToggleCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Example logic when ability is active\n\tif (bIsAbilityActive)\n\t{\n\t\t// Ability active logic here\n\t}\n}\n\nvoid AAbilityToggleCharacter::ToggleAbility()\n{\n\tbIsAbilityActive = !bIsAbilityActive;\n\tUE_LOG(LogTemp, Log, TEXT(\"Ability is now %s\"), bIsAbilityActive ? TEXT(\"Active\") : TEXT(\"Inactive\"));\n}\n```"}
{"requirement": "Create a simple interactive door system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InteractiveDoor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AInteractiveDoor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAInteractiveDoor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Door\")\n\tvoid OpenDoor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Door\")\n\tvoid CloseDoor();\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat OpenAngle;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat CloseAngle;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat DoorSpeed;\n\n\tUPROPERTY(VisibleAnywhere)\n\tbool bIsOpen;\n\n\tUPROPERTY(VisibleAnywhere)\n\tFRotator CurrentRotation;\n\n\tUPROPERTY(VisibleAnywhere)\n\tFRotator TargetRotation;\n\n\tvoid UpdateDoorRotation(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"InteractiveDoor.h\"\n#include \"GameFramework/Actor.h\"\n\nAInteractiveDoor::AInteractiveDoor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tOpenAngle = 90.0f;\n\tCloseAngle = 0.0f;\n\tDoorSpeed = 2.0f;\n\tbIsOpen = false;\n\tCurrentRotation = GetActorRotation();\n\tTargetRotation = CurrentRotation;\n}\n\nvoid AInteractiveDoor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AInteractiveDoor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateDoorRotation(DeltaTime);\n}\n\nvoid AInteractiveDoor::OpenDoor()\n{\n\tif (!bIsOpen)\n\t{\n\t\tTargetRotation = FRotator(CurrentRotation.Pitch, CurrentRotation.Yaw + OpenAngle, CurrentRotation.Roll);\n\t\tbIsOpen = true;\n\t}\n}\n\nvoid AInteractiveDoor::CloseDoor()\n{\n\tif (bIsOpen)\n\t{\n\t\tTargetRotation = FRotator(CurrentRotation.Pitch, CurrentRotation.Yaw + CloseAngle, CurrentRotation.Roll);\n\t\tbIsOpen = false;\n\t}\n}\n\nvoid AInteractiveDoor::UpdateDoorRotation(float DeltaTime)\n{\n\tif (CurrentRotation.Equals(TargetRotation, 1.0f))\n\t{\n\t\treturn;\n\t}\n\tCurrentRotation = FMath::RInterpConstantTo(CurrentRotation, TargetRotation, DeltaTime, DoorSpeed);\n\tSetActorRotation(CurrentRotation);\n}\n```"}
{"requirement": "Add a function to reset the player's position.", "header_code": "```cpp\nUCLASS()\nclass MYGAME_API AMyPlayerCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Function to reset the player's position\n\tUFUNCTION(BlueprintCallable, Category=\"Player\")\n\tvoid ResetPlayerPosition();\n\nprivate:\n\t// Default position to reset the player to\n\tFVector DefaultPosition;\n};\n```", "cpp_code": "```cpp\n#include \"MyPlayerCharacter.h\"\n#include \"GameFramework/Actor.h\"\n\nAMyPlayerCharacter::AMyPlayerCharacter()\n{\n\t// Initialize the default position (example position)\n\tDefaultPosition = FVector(0.0f, 0.0f, 0.0f);\n}\n\nvoid AMyPlayerCharacter::ResetPlayerPosition()\n{\n\tSetActorLocation(DefaultPosition);\n}\n```"}
{"requirement": "Implement a basic stealth mechanic.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"StealthCharacter.generated.h\"\n\nUCLASS()\nclass STEALTHGAME_API AStealthCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAStealthCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Stealth\")\n\tvoid EnterStealthMode();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Stealth\")\n\tvoid ExitStealthMode();\n\nprivate:\n\tbool bIsStealthed;\n\tUPROPERTY(EditAnywhere, Category = \"Stealth\")\n\tfloat StealthSpeedMultiplier;\n};\n```", "cpp_code": "```cpp\n#include \"StealthCharacter.h\"\n\nAStealthCharacter::AStealthCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsStealthed = false;\n\tStealthSpeedMultiplier = 0.5f; // Default to half speed\n}\n\nvoid AStealthCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AStealthCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsStealthed)\n\t{\n\t\t// Implement any logic that should occur while in stealth mode\n\t}\n}\n\nvoid AStealthCharacter::EnterStealthMode()\n{\n\tbIsStealthed = true;\n\tGetCharacterMovement()->MaxWalkSpeed *= StealthSpeedMultiplier;\n\t// Additional logic for entering stealth mode (e.g., change material)\n}\n\nvoid AStealthCharacter::ExitStealthMode()\n{\n\tbIsStealthed = false;\n\tGetCharacterMovement()->MaxWalkSpeed /= StealthSpeedMultiplier;\n\t// Additional logic for exiting stealth mode (e.g., revert material)\n}\n```"}
