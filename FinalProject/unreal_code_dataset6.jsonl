{"requirement": "Create a basic Actor class that rotates continuously using the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize rotation speed\n\tRotationSpeed = FRotator(0.0f, 45.0f, 0.0f); // Rotating 45 degrees per second on the Yaw (Z-axis)\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Rotate actor\n\tAddActorLocalRotation(RotationSpeed * DeltaTime);\n}\n```"}
{"requirement": "Implement a UMG widget that displays a player's health percentage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UHealthWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UHealthWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Health\")\n\tvoid UpdateHealth(float HealthPercentage);\n\nprotected:\n\tUPROPERTY(BlueprintReadOnly, meta=(BindWidget))\n\tclass UProgressBar* HealthProgressBar;\n};\n```", "cpp_code": "```cpp\n#include \"UHealthWidget.h\"\n#include \"Components/ProgressBar.h\"\n\nvoid UHealthWidget::UpdateHealth(float HealthPercentage)\n{\n\tif (HealthProgressBar)\n\t{\n\t\tHealthProgressBar->SetPercent(HealthPercentage);\n\t}\n}\n```"}
{"requirement": "Develop a simple AI Controller that moves an AI character to a random location within a given radius.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"AICharacterController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAICharacterController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAICharacterController();\n\n\tvirtual void BeginPlay() override;\n\nprotected:\n\tUPROPERTY(EditAnywhere, Category=\"AI\")\n\tfloat MoveRadius;\n\nprivate:\n\tvoid MoveToRandomLocation();\n};\n```", "cpp_code": "```cpp\n#include \"AICharacterController.h\"\n#include \"NavigationSystem.h\"\n#include \"GameFramework/Actor.h\"\n\nAAICharacterController::AAICharacterController()\n{\n\tMoveRadius = 1000.0f; // Default radius\n}\n\nvoid AAICharacterController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tMoveToRandomLocation();\n}\n\nvoid AAICharacterController::MoveToRandomLocation()\n{\n\tif (AActor* ControlledPawn = GetPawn())\n\t{\n\t\tFVector Origin = ControlledPawn->GetActorLocation();\n\t\tFVector RandomPoint;\n\t\tUNavigationSystemV1* NavSystem = FNavigationSystem::GetCurrent<UNavigationSystemV1>(this);\n\n\t\tif (NavSystem && NavSystem->GetRandomPointInNavigableRadius(Origin, MoveRadius, RandomPoint))\n\t\t{\n\t\t\tMoveToLocation(RandomPoint);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor class that changes color upon collision with another Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to change color\n\tUFUNCTION()\n\tvoid ChangeColor();\n\n\t// Called when there is a collision\n\tUFUNCTION()\n\tvoid OnCollision(AActor* SelfActor, AActor* OtherActor, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY()\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAColorChangingActor::AColorChangingActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set up collision handling\n\tMeshComponent->OnComponentHit.AddDynamic(this, &AColorChangingActor::OnCollision);\n\n\t// Find and set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Create a dynamic material instance\n\tDynamicMaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AColorChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AColorChangingActor::ChangeColor()\n{\n\tif (DynamicMaterialInstance)\n\t{\n\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\tDynamicMaterialInstance->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t}\n}\n\nvoid AColorChangingActor::OnCollision(AActor* SelfActor, AActor* OtherActor, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tChangeColor();\n}\n```"}
{"requirement": "Implement a BlueprintCallable function in an Actor class to reset its position.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PositionResetActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APositionResetActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPositionResetActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Position\")\n\tvoid ResetPosition();\n\nprotected:\n\tFVector InitialPosition;\n\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"PositionResetActor.h\"\n\n// Sets default values\nAPositionResetActor::APositionResetActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid APositionResetActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Store the initial position of the actor\n\tInitialPosition = GetActorLocation();\n}\n\nvoid APositionResetActor::ResetPosition()\n{\n\t// Set the actor's position back to the initial position\n\tSetActorLocation(InitialPosition);\n}\n```"}
{"requirement": "Create a static mesh component that scales up when the player presses a specific input key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleMeshOnInputActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AScaleMeshOnInputActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScaleMeshOnInputActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUFUNCTION()\n\tvoid ScaleUpMesh();\n\n\tFVector InitialScale;\n\tFVector TargetScale;\n\tfloat ScaleFactor;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleMeshOnInputActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"ConstructorHelpers.h\"\n\nAScaleMeshOnInputActor::AScaleMeshOnInputActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tInitialScale = FVector(1.0f, 1.0f, 1.0f);\n\tTargetScale = FVector(2.0f, 2.0f, 2.0f);\n\tScaleFactor = 1.1f;\n}\n\nvoid AScaleMeshOnInputActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tStaticMeshComponent->SetWorldScale3D(InitialScale);\n}\n\nvoid AScaleMeshOnInputActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScaleMeshOnInputActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ScaleUp\", IE_Pressed, this, &AScaleMeshOnInputActor::ScaleUpMesh);\n}\n\nvoid AScaleMeshOnInputActor::ScaleUpMesh()\n{\n\tFVector CurrentScale = StaticMeshComponent->GetComponentScale();\n\tFVector NewScale = CurrentScale * ScaleFactor;\n\tif (NewScale.X <= TargetScale.X && NewScale.Y <= TargetScale.Y && NewScale.Z <= TargetScale.Z)\n\t{\n\t\tStaticMeshComponent->SetWorldScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Develop a class that plays a sound when overlapping with a specific trigger volume.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/BoxComponent.h\"\n#include \"SoundTriggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundTriggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundTriggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUBoxComponent* TriggerVolume;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"SoundTriggerActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundTriggerActor::ASoundTriggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n\tRootComponent = TriggerVolume;\n\tTriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &ASoundTriggerActor::OnOverlapBegin);\n}\n\nvoid ASoundTriggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundTriggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundTriggerActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (SoundToPlay && OtherActor != this)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Implement an Actor that spawns another Actor at a specified location upon a player's input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpawnerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpawnerActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  ASpawnerActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\n  virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\nprivate:\n  UPROPERTY(EditAnywhere, Category = \"Spawning\")\n  TSubclassOf<AActor> ActorToSpawn;\n\n  UPROPERTY(EditAnywhere, Category = \"Spawning\")\n  FVector SpawnLocation;\n\n  void SpawnActor();\n};\n```", "cpp_code": "```cpp\n#include \"SpawnerActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\nASpawnerActor::ASpawnerActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASpawnerActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid ASpawnerActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid ASpawnerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n  Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n  if (PlayerInputComponent)\n  {\n\tPlayerInputComponent->BindAction(\"Spawn\", IE_Pressed, this, &ASpawnerActor::SpawnActor);\n  }\n}\n\nvoid ASpawnerActor::SpawnActor()\n{\n  if (ActorToSpawn)\n  {\n\tFActorSpawnParameters SpawnParams;\n\tGetWorld()->SpawnActor<AActor>(ActorToSpawn, SpawnLocation, FRotator::ZeroRotator, SpawnParams);\n  }\n}\n```"}
{"requirement": "Create a UMG button widget that changes text when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UButtonTextWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UButtonTextWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUButtonTextWidget(const FObjectInitializer& ObjectInitializer);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnButtonClicked();\n\n\tUPROPERTY(meta = (BindWidget))\n\tclass UButton* MyButton;\n\n\tUPROPERTY(meta = (BindWidget))\n\tclass UTextBlock* MyTextBlock;\n\n\tbool bIsFirstText;\n};\n```", "cpp_code": "```cpp\n#include \"UButtonTextWidget.h\"\n#include \"Components/Button.h\"\n#include \"Components/TextBlock.h\"\n\nUButtonTextWidget::UButtonTextWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer), bIsFirstText(true)\n{\n}\n\nvoid UButtonTextWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\n\tif (MyButton)\n\t{\n\t\tMyButton->OnClicked.AddDynamic(this, &UButtonTextWidget::OnButtonClicked);\n\t}\n}\n\nvoid UButtonTextWidget::OnButtonClicked()\n{\n\tif (MyTextBlock)\n\t{\n\t\tif (bIsFirstText)\n\t\t{\n\t\t\tMyTextBlock->SetText(FText::FromString(\"Second Text\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMyTextBlock->SetText(FText::FromString(\"First Text\"));\n\t\t}\n\t\tbIsFirstText = !bIsFirstText;\n\t}\n}\n```"}
{"requirement": "Develop a class with a UPROPERTY that allows setting the Actor's movement speed from the editor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AMovementSpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovementSpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMovementSpeedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"AMovementSpeedActor.h\"\n\nAMovementSpeedActor::AMovementSpeedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementSpeed = 600.f; // Default movement speed\n}\n\nvoid AMovementSpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMovementSpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t// Implementation for moving the actor using MovementSpeed can be added here\n}\n```"}
{"requirement": "Implement a simple networking function to replicate the Actor's location across clients.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReplicatedActor.generated.h\"\n\nUCLASS()\nclass AReplicatedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAReplicatedActor();\n\nprotected:\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n\nprivate:\n\tUPROPERTY(ReplicatedUsing=OnRep_ReplicatedLocation)\n\tFVector ReplicatedLocation;\n\n\tUFUNCTION()\n\tvoid OnRep_ReplicatedLocation();\n\n\tvoid SetActorLocationFromReplicated();\n};\n```", "cpp_code": "```cpp\n#include \"ReplicatedActor.h\"\n#include \"Net/UnrealNetwork.h\"\n\nAReplicatedActor::AReplicatedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbReplicates = true;\n}\n\nvoid AReplicatedActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AReplicatedActor, ReplicatedLocation);\n}\n\nvoid AReplicatedActor::OnRep_ReplicatedLocation()\n{\n\tSetActorLocationFromReplicated();\n}\n\nvoid AReplicatedActor::SetActorLocationFromReplicated()\n{\n\tSetActorLocation(ReplicatedLocation);\n}\n```"}
{"requirement": "Create an Actor that follows the player's location using a simple movement function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FollowPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AFollowPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAFollowPlayerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"FollowPlayerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAFollowPlayerActor::AFollowPlayerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementSpeed = 200.0f; // Default movement speed\n}\n\n// Called when the game starts or when spawned\nvoid AFollowPlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AFollowPlayerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tAActor* PlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n\tif (PlayerActor)\n\t{\n\t\tFVector Direction = PlayerActor->GetActorLocation() - GetActorLocation();\n\t\tDirection.Normalize();\n\n\t\tFVector NewLocation = GetActorLocation() + (Direction * MovementSpeed * DeltaTime);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Implement a skeletal mesh component that plays an animation montage on input action.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimMontage.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"UPlayMontageActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APlayMontageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPlayMontageActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tclass USkeletalMeshComponent* SkeletalMeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Animation\", meta = (AllowPrivateAccess = \"true\"))\n\tUAnimMontage* AnimationMontage;\n\n\tvoid PlayAnimationMontage();\n};\n```", "cpp_code": "```cpp\n#include \"UPlayMontageActor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/InputSettings.h\"\n\nAPlayMontageActor::APlayMontageActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n}\n\nvoid APlayMontageActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APlayMontageActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APlayMontageActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"PlayMontage\", IE_Pressed, this, &APlayMontageActor::PlayAnimationMontage);\n}\n\nvoid APlayMontageActor::PlayAnimationMontage()\n{\n\tif (AnimationMontage && SkeletalMeshComponent)\n\t{\n\t\tUAnimInstance* AnimInstance = SkeletalMeshComponent->GetAnimInstance();\n\t\tif (AnimInstance)\n\t\t{\n\t\t\tAnimInstance->Montage_Play(AnimationMontage);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor that toggles its visibility when a specific key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AToggleVisibilityActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  AToggleVisibilityActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  // Setup player input\n  virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n  // Function to toggle visibility\n  void ToggleVisibility();\n\n  UPROPERTY(VisibleAnywhere)\n  UStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Create and set static mesh component\n  MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n  RootComponent = MeshComponent;\n\n  // Set default mesh (assuming \"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\" exists in the project)\n  static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n  if (MeshAsset.Succeeded())\n  {\n\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n  }\n}\n\n// Called when the game starts or when spawned\nvoid AToggleVisibilityActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n  Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n  if (PlayerInputComponent)\n  {\n\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleVisibilityActor::ToggleVisibility);\n  }\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n  if (MeshComponent)\n  {\n\tbool bIsVisible = MeshComponent->IsVisible();\n\tMeshComponent->SetVisibility(!bIsVisible);\n  }\n}\n```"}
{"requirement": "Develop a class that logs a message to the console every second using the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tALoggingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tfloat TimeAccumulator;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n#include \"Engine/Engine.h\"\n\nALoggingActor::ALoggingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTimeAccumulator = 0.0f;\n}\n\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeAccumulator += DeltaTime;\n\tif (TimeAccumulator >= 1.0f)\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Green, TEXT(\"Logging message every second\"));\n\t\t}\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION that changes the material of an Actor when called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAChangeMaterialActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Material\")\n\tvoid ChangeMaterial(UMaterialInterface* NewMaterial);\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAChangeMaterialActor::AChangeMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Optionally set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AChangeMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialActor::ChangeMaterial(UMaterialInterface* NewMaterial)\n{\n\tif (NewMaterial && MeshComponent)\n\t{\n\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a collision component that triggers an event when overlapped.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACollisionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* CollisionComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\nACollisionActor::ACollisionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tRootComponent = CollisionComponent;\n\tCollisionComponent->SetCollisionProfileName(\"Trigger\");\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionActor::OnOverlapBegin);\n}\n\nvoid ACollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Overlap Begin\"));\n\t\t}\n\t}\n}\n```"}
{"requirement": "Develop a class with a BlueprintCallable function to increase the score by a specified amount.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreManager.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScoreManager();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid IncreaseScore(int32 Amount);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Score\", meta=(AllowPrivateAccess = \"true\"))\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreManager.h\"\n\n// Sets default values\nAScoreManager::AScoreManager()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tScore = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AScoreManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScoreManager::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScoreManager::IncreaseScore(int32 Amount)\n{\n\tScore += Amount;\n}\n```"}
{"requirement": "Implement a simple AI Controller that makes an AI character patrol between two points.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"PatrolAIController.generated.h\"\n\nUCLASS()\nclass APawnPatrol : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPawnPatrol();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid MoveToNextPatrolPoint();\n\n\tUPROPERTY(EditAnywhere, Category=\"Patrol\")\n\tAActor* PatrolPoint1;\n\n\tUPROPERTY(EditAnywhere, Category=\"Patrol\")\n\tAActor* PatrolPoint2;\n\n\tAActor* CurrentPatrolPoint;\n};\n```", "cpp_code": "```cpp\n#include \"PatrolAIController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Actor.h\"\n\nAPawnPatrol::APawnPatrol()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APawnPatrol::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCurrentPatrolPoint = PatrolPoint1;\n\tMoveToNextPatrolPoint();\n}\n\nvoid APawnPatrol::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!CurrentPatrolPoint) return;\n\n\tconst FVector DistanceToGoal = GetPawn()->GetActorLocation() - CurrentPatrolPoint->GetActorLocation();\n\tif (DistanceToGoal.Size() < 100.0f)\n\t{\n\t\tMoveToNextPatrolPoint();\n\t}\n}\n\nvoid APawnPatrol::MoveToNextPatrolPoint()\n{\n\tif (CurrentPatrolPoint == PatrolPoint1)\n\t{\n\t\tCurrentPatrolPoint = PatrolPoint2;\n\t}\n\telse\n\t{\n\t\tCurrentPatrolPoint = PatrolPoint1;\n\t}\n\tMoveToActor(CurrentPatrolPoint, -1.0f);\n}\n```"}
{"requirement": "Create a class that prints the player's current location to the screen every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"APlayerLocationPrinter.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APlayerLocationPrinter : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPlayerLocationPrinter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"APlayerLocationPrinter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"Engine/Engine.h\"\n\nAPlayerLocationPrinter::APlayerLocationPrinter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APlayerLocationPrinter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APlayerLocationPrinter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tif (APawn* PlayerPawn = PlayerController->GetPawn())\n\t\t{\n\t\t\tFVector PlayerLocation = PlayerPawn->GetActorLocation();\n\t\t\tif (GEngine)\n\t\t\t{\n\t\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, FString::Printf(TEXT(\"Player Location: %s\"), *PlayerLocation.ToString()));\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement an Actor that moves upwards continuously and resets position once reaching a certain height.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat MoveSpeed;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MaxHeight;\n\n\tFVector InitialPosition;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMoveSpeed = 100.0f; // Default speed\n\tMaxHeight = 1000.0f; // Default max height\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialPosition = GetActorLocation();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation();\n\tNewLocation.Z += MoveSpeed * DeltaTime;\n\n\tif (NewLocation.Z >= InitialPosition.Z + MaxHeight)\n\t{\n\t\tNewLocation.Z = InitialPosition.Z;\n\t}\n\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a UMG slider widget that adjusts the volume of background music.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"USliderVolumeWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API USliderVolumeWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tvirtual void NativeConstruct() override;\n\nprotected:\n\tUPROPERTY(meta = (BindWidget))\n\tclass USlider* VolumeSlider;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnVolumeSliderChanged(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"USliderVolumeWidget.h\"\n#include \"Components/Slider.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Sound/SoundMix.h\"\n#include \"Sound/SoundClass.h\"\n\nvoid USliderVolumeWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\n\tif (VolumeSlider)\n\t{\n\t\tVolumeSlider->OnValueChanged.AddDynamic(this, &USliderVolumeWidget::OnVolumeSliderChanged);\n\t\tfloat CurrentVolume = UGameplayStatics::GetSoundClassVolume(UGameplayStatics::GetSoundClassFromName(\"Master\"));\n\t\tVolumeSlider->SetValue(CurrentVolume);\n\t}\n}\n\nvoid USliderVolumeWidget::OnVolumeSliderChanged(float Value)\n{\n\tUGameplayStatics::SetSoundClassVolume(UGameplayStatics::GetSoundClassFromName(\"Master\"), Value);\n}\n```"}
{"requirement": "Develop a class that changes the Actor's scale based on the player's velocity.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/Character.h\"\n#include \"ScaleWithVelocityActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AScaleWithVelocityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScaleWithVelocityActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tACharacter* PlayerCharacter;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat ScaleFactor;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleWithVelocityActor.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAScaleWithVelocityActor::AScaleWithVelocityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScaleFactor = 0.01f;\n}\n\nvoid AScaleWithVelocityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);\n}\n\nvoid AScaleWithVelocityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerCharacter)\n\t{\n\t\tFVector Velocity = PlayerCharacter->GetVelocity();\n\t\tfloat Speed = Velocity.Size();\n\t\tFVector NewScale = FVector::OneVector + Speed * ScaleFactor * FVector::OneVector;\n\t\tSetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function that destroys the Actor after a delay.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DestroyAfterDelayActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADestroyAfterDelayActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tADestroyAfterDelayActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Custom\")\n\tvoid DestroyActorAfterDelay(float DelayInSeconds);\n\nprivate:\n\tvoid PerformDestroy();\n};\n```", "cpp_code": "```cpp\n#include \"DestroyAfterDelayActor.h\"\n#include \"TimerManager.h\"\n\nADestroyAfterDelayActor::ADestroyAfterDelayActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ADestroyAfterDelayActor::DestroyActorAfterDelay(float DelayInSeconds)\n{\n\tif (DelayInSeconds > 0.0f)\n\t{\n\t\tGetWorldTimerManager().SetTimerForNextTick([this, DelayInSeconds]() {\n\t\t\tGetWorldTimerManager().SetTimerForNextTick([this]() {\n\t\t\t\tPerformDestroy();\n\t\t\t});\n\t\t});\n\t}\n\telse\n\t{\n\t\tPerformDestroy();\n\t}\n}\n\nvoid ADestroyAfterDelayActor::PerformDestroy()\n{\n\tDestroy();\n}\n```"}
{"requirement": "Create an Actor with a timer that triggers an event every 3 seconds.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyTimedActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyTimedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyTimedActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\t// Timer handle for the recurring event\n\tFTimerHandle TimerHandle;\n\n\t// Function to be called every 3 seconds\n\tvoid OnTimerTick();\n};\n```", "cpp_code": "```cpp\n#include \"MyTimedActor.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nAMyTimedActor::AMyTimedActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid AMyTimedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Set a timer to call OnTimerTick every 3 seconds\n\tGetWorldTimerManager().SetTimer(TimerHandle, this, &AMyTimedActor::OnTimerTick, 3.0f, true);\n}\n\n// Function to be called every 3 seconds\nvoid AMyTimedActor::OnTimerTick()\n{\n\t// Log or perform any action here\n\tUE_LOG(LogTemp, Warning, TEXT(\"Timer ticked!\"));\n}\n```"}
{"requirement": "Develop a class that changes the camera's field of view when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FOVChanger.generated.h\"\n\nUCLASS()\nclass AFOVChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFOVChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Input function to change FOV\n\tvoid ChangeFOV();\n\n\t// Camera Component\n\tUPROPERTY(VisibleAnywhere)\n\tclass UCameraComponent* CameraComponent;\n\n\t// Field of View values\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"FOV\")\n\tfloat DefaultFOV;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"FOV\")\n\tfloat ZoomedFOV;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"FOV\")\n\tfloat FOVChangeSpeed;\n\nprivate:\n\t// Flag to check if zoomed in\n\tbool bIsZoomedIn;\n};\n```", "cpp_code": "```cpp\n#include \"FOVChanger.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAFOVChanger::AFOVChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Camera Component\n\tCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"CameraComponent\"));\n\tRootComponent = CameraComponent;\n\n\t// Initialize FOV values\n\tDefaultFOV = 90.0f;\n\tZoomedFOV = 60.0f;\n\tFOVChangeSpeed = 20.0f;\n\n\t// Start not zoomed in\n\tbIsZoomedIn = false;\n}\n\nvoid AFOVChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCameraComponent->FieldOfView = DefaultFOV;\n}\n\nvoid AFOVChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat TargetFOV = bIsZoomedIn ? ZoomedFOV : DefaultFOV;\n\tCameraComponent->FieldOfView = FMath::FInterpTo(CameraComponent->FieldOfView, TargetFOV, DeltaTime, FOVChangeSpeed);\n}\n\nvoid AFOVChanger::ChangeFOV()\n{\n\tbIsZoomedIn = !bIsZoomedIn;\n}\n\nvoid AFOVChanger::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ChangeFOV\", IE_Pressed, this, &AFOVChanger::ChangeFOV);\n}\n```"}
{"requirement": "Implement an Actor that spawns particles upon destruction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"Particles/ParticleEmitter.h\"\n#include \"MyParticleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyParticleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyParticleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\n\t// Particle system to spawn upon destruction\n\tUPROPERTY(EditAnywhere, Category = \"Effects\")\n\tUParticleSystem* DestructionParticles;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle destruction\n\tvirtual void Destroyed() override;\n};\n```", "cpp_code": "```cpp\n#include \"MyParticleActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAMyParticleActor::AMyParticleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyParticleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyParticleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle destruction\nvoid AMyParticleActor::Destroyed()\n{\n\tSuper::Destroyed();\n\n\tif(DestructionParticles)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), DestructionParticles, GetActorLocation(), GetActorRotation());\n\t}\n}\n```"}
{"requirement": "Create an Actor that plays a sound when clicked in the game world.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"SoundPlayingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundPlayingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void NotifyActorOnClicked(FKey ButtonPressed) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUSoundBase* ClickSound;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SoundPlayingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Sound/SoundBase.h\"\n\nASoundPlayingActor::ASoundPlayingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n}\n\nvoid ASoundPlayingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundPlayingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundPlayingActor::NotifyActorOnClicked(FKey ButtonPressed)\n{\n\tSuper::NotifyActorOnClicked(ButtonPressed);\n\n\tif (ClickSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, ClickSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Develop a class that gradually increases the player's speed over time using the Tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedIncreaseActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedIncreaseActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedIncreaseActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat InitialSpeed;\n\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat SpeedIncreaseRate;\n\n\tfloat CurrentSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedIncreaseActor.h\"\n\nASpeedIncreaseActor::ASpeedIncreaseActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tInitialSpeed = 600.0f; // Default initial speed\n\tSpeedIncreaseRate = 50.0f; // Default speed increase rate per second\n\tCurrentSpeed = InitialSpeed;\n}\n\nvoid ASpeedIncreaseActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCurrentSpeed = InitialSpeed;\n}\n\nvoid ASpeedIncreaseActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tCurrentSpeed += SpeedIncreaseRate * DeltaTime;\n\t// Use CurrentSpeed to affect player movement\n}\n```"}
{"requirement": "Implement a simple networking function to replicate the Actor's rotation across clients.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"NetworkingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ANetworkingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tANetworkingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to replicate rotation\n\tUFUNCTION()\n\tvoid OnRep_Rotation();\n\n\t// Replicated property for rotation\n\tUPROPERTY(ReplicatedUsing = OnRep_Rotation)\n\tFRotator ActorRotation;\n\n\t// Function to get replication properties\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n};\n```", "cpp_code": "```cpp\n#include \"NetworkingActor.h\"\n#include \"Net/UnrealNetwork.h\"\n\n// Sets default values\nANetworkingActor::ANetworkingActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Enable replication\n\tbReplicates = true;\n}\n\n// Called when the game starts or when spawned\nvoid ANetworkingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ANetworkingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update ActorRotation with the current rotation\n\tif (HasAuthority())\n\t{\n\t\tActorRotation = GetActorRotation();\n\t}\n}\n\nvoid ANetworkingActor::OnRep_Rotation()\n{\n\t// Set the actor's rotation to the replicated rotation\n\tSetActorRotation(ActorRotation);\n}\n\nvoid ANetworkingActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\t// Replicate ActorRotation\n\tDOREPLIFETIME(ANetworkingActor, ActorRotation);\n}\n```"}
{"requirement": "Create an Actor that changes its material color when an overlapping Actor is detected.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"ColorChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Box component for detecting overlaps\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* OverlapComponent;\n\n\t// Material to change to when overlapping\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\n\t// Function to handle overlap events\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAColorChangingActor::AColorChangingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Mesh Component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Create Overlap Component\n\tOverlapComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"OverlapComponent\"));\n\tOverlapComponent->SetupAttachment(RootComponent);\n\tOverlapComponent->OnComponentBeginOverlap.AddDynamic(this, &AColorChangingActor::OnOverlapBegin);\n\n\t// Set up a static mesh for the MeshComponent\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Create a dynamic material instance\n\tif (MeshComponent->GetMaterial(0) != nullptr)\n\t{\n\t\tDynamicMaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t}\n}\n\n// Called every frame\nvoid AColorChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle overlap events\nvoid AColorChangingActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (DynamicMaterialInstance)\n\t{\n\t\t// Change color to red when overlapping\n\t\tDynamicMaterialInstance->SetVectorParameterValue(FName(\"Color\"), FLinearColor::Red);\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION that toggles the Actor's physics simulation on and off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TogglePhysicsActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATogglePhysicsActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATogglePhysicsActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Physics\")\n\tvoid TogglePhysics();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"TogglePhysicsActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nATogglePhysicsActor::ATogglePhysicsActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ATogglePhysicsActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATogglePhysicsActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATogglePhysicsActor::TogglePhysics()\n{\n\tif (MeshComponent)\n\t{\n\t\tbool bIsSimulating = MeshComponent->IsSimulatingPhysics();\n\t\tMeshComponent->SetSimulatePhysics(!bIsSimulating);\n\t}\n}\n```"}
{"requirement": "Create a class that logs a custom message when a specific input key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALoggingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tvoid LogCustomMessage();\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nALoggingActor::ALoggingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ALoggingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"LogKey\", IE_Pressed, this, &ALoggingActor::LogCustomMessage);\n}\n\nvoid ALoggingActor::LogCustomMessage()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Custom message logged!\"));\n\t}\n}\n```"}
{"requirement": "Develop an Actor with a collision component that applies a force to overlapping Actors.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ForceApplyingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AForceApplyingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAForceApplyingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprotected:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* CollisionComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat ForceStrength;\n};\n```", "cpp_code": "```cpp\n#include \"ForceApplyingActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nAForceApplyingActor::AForceApplyingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComponent->SetupAttachment(RootComponent);\n\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AForceApplyingActor::OnOverlapBegin);\n\n\tForceStrength = 1000.0f;\n}\n\nvoid AForceApplyingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AForceApplyingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AForceApplyingActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUPrimitiveComponent* OtherPrimitiveComponent = Cast<UPrimitiveComponent>(OtherComp);\n\t\tif (OtherPrimitiveComponent && OtherPrimitiveComponent->IsSimulatingPhysics())\n\t\t{\n\t\t\tFVector Direction = OtherActor->GetActorLocation() - GetActorLocation();\n\t\t\tDirection.Normalize();\n\t\t\tOtherPrimitiveComponent->AddForce(Direction * ForceStrength);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to teleport the Actor to a random location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomTeleportActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ARandomTeleportActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARandomTeleportActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Teleport\")\n\tvoid TeleportToRandomLocation();\n};\n```", "cpp_code": "```cpp\n#include \"RandomTeleportActor.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n#include \"GameFramework/Actor.h\"\n\nARandomTeleportActor::ARandomTeleportActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARandomTeleportActor::TeleportToRandomLocation()\n{\n\tif (GetWorld())\n\t{\n\t\tFVector RandomLocation = UKismetMathLibrary::RandomPointInBoundingBox(FVector(0.0f, 0.0f, 0.0f), FVector(1000.0f, 1000.0f, 500.0f));\n\t\tSetActorLocation(RandomLocation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a skeletal mesh that plays a looping animation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"MyAnimatedActor.generated.h\"\n\nUCLASS()\nclass AMyAnimatedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMyAnimatedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Animation\", meta = (AllowPrivateAccess = \"true\"))\n\tUAnimSequence* LoopingAnimation;\n};\n```", "cpp_code": "```cpp\n#include \"MyAnimatedActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyAnimatedActor::AMyAnimatedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<USkeletalMesh> SkeletalMesh(TEXT(\"/Game/Path/To/Your/SkeletalMesh.SkeletalMesh\"));\n\tif (SkeletalMesh.Succeeded())\n\t{\n\t\tSkeletalMeshComponent->SetSkeletalMesh(SkeletalMesh.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UAnimSequence> AnimSequence(TEXT(\"/Game/Path/To/Your/Animation.Animation\"));\n\tif (AnimSequence.Succeeded())\n\t{\n\t\tLoopingAnimation = AnimSequence.Object;\n\t}\n}\n\nvoid AMyAnimatedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (LoopingAnimation)\n\t{\n\t\tSkeletalMeshComponent->PlayAnimation(LoopingAnimation, true);\n\t}\n}\n\nvoid AMyAnimatedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Develop a class that reverses the Actor's movement direction when reaching a boundary.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReversibleActor.generated.h\"\n\nUCLASS()\nclass AReversibleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAReversibleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat MovementSpeed;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector MovementDirection;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector BoundaryMin;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector BoundaryMax;\n\n\tvoid ReverseDirectionIfNecessary();\n};\n```", "cpp_code": "```cpp\n#include \"ReversibleActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAReversibleActor::AReversibleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementSpeed = 100.0f;\n\tMovementDirection = FVector(1.0f, 0.0f, 0.0f);\n\tBoundaryMin = FVector(-500.0f, -500.0f, 0.0f);\n\tBoundaryMax = FVector(500.0f, 500.0f, 0.0f);\n}\n\nvoid AReversibleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AReversibleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFVector NewLocation = GetActorLocation() + (MovementDirection * MovementSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n\tReverseDirectionIfNecessary();\n}\n\nvoid AReversibleActor::ReverseDirectionIfNecessary()\n{\n\tFVector CurrentLocation = GetActorLocation();\n\tif (CurrentLocation.X <= BoundaryMin.X || CurrentLocation.X >= BoundaryMax.X)\n\t{\n\t\tMovementDirection.X *= -1;\n\t}\n\tif (CurrentLocation.Y <= BoundaryMin.Y || CurrentLocation.Y >= BoundaryMax.Y)\n\t{\n\t\tMovementDirection.Y *= -1;\n\t}\n}\n```"}
{"requirement": "Implement a UMG widget that displays the player's current score.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"ScoreWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API UScoreWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUScoreWidget(const FObjectInitializer& ObjectInitializer);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Score\")\n\tvoid UpdateScore(int32 NewScore);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UTextBlock* ScoreText;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreWidget.h\"\n#include \"Components/TextBlock.h\"\n\nUScoreWidget::UScoreWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UScoreWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\n\t// Initialize the score display if necessary\n\tif (ScoreText)\n\t{\n\t\tScoreText->SetText(FText::FromString(\"Score: 0\"));\n\t}\n}\n\nvoid UScoreWidget::UpdateScore(int32 NewScore)\n{\n\tif (ScoreText)\n\t{\n\t\tScoreText->SetText(FText::Format(NSLOCTEXT(\"ScoreNamespace\", \"ScoreFormat\", \"Score: {0}\"), FText::AsNumber(NewScore)));\n\t}\n}\n```"}
{"requirement": "Create an Actor with a timeline component to animate its position over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"AnimatedPositionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAnimatedPositionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAnimatedPositionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUTimelineComponent* TimelineComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* PositionCurve;\n\n\tFOnTimelineFloat InterpFunction;\n\n\tUFUNCTION()\n\tvoid HandleProgress(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"AnimatedPositionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAAnimatedPositionActor::AAnimatedPositionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tTimelineComponent = CreateDefaultSubobject<UTimelineComponent>(TEXT(\"TimelineComponent\"));\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UCurveFloat> CurveAsset(TEXT(\"/Game/Path/To/Your/Curve.Curve\"));\n\tif (CurveAsset.Succeeded())\n\t{\n\t\tPositionCurve = CurveAsset.Object;\n\t}\n}\n\nvoid AAnimatedPositionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (PositionCurve)\n\t{\n\t\tInterpFunction.BindUFunction(this, FName(\"HandleProgress\"));\n\t\tTimelineComponent->AddInterpFloat(PositionCurve, InterpFunction);\n\t\tTimelineComponent->SetLooping(false);\n\t\tTimelineComponent->PlayFromStart();\n\t}\n}\n\nvoid AAnimatedPositionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tTimelineComponent->TickComponent(DeltaTime, ELevelTick::LEVELTICK_TimeOnly, nullptr);\n}\n\nvoid AAnimatedPositionActor::HandleProgress(float Value)\n{\n\tFVector NewLocation = FMath::Lerp(FVector(0.0f, 0.0f, 0.0f), FVector(100.0f, 0.0f, 0.0f), Value);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Develop a UFUNCTION that broadcasts a custom event when called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomEventBroadcaster.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnCustomEvent);\n\nUCLASS()\nclass YOURPROJECT_API ACustomEventBroadcaster : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomEventBroadcaster();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"CustomEvent\")\n\tvoid BroadcastCustomEvent();\n\n\tUPROPERTY(BlueprintAssignable, Category=\"CustomEvent\")\n\tFOnCustomEvent OnCustomEvent;\n};\n```", "cpp_code": "```cpp\n#include \"CustomEventBroadcaster.h\"\n\n// Sets default values\nACustomEventBroadcaster::ACustomEventBroadcaster()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomEventBroadcaster::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACustomEventBroadcaster::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACustomEventBroadcaster::BroadcastCustomEvent()\n{\n\tOnCustomEvent.Broadcast();\n}\n```"}
{"requirement": "Implement a class that increases the player's health when a specific input is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthIncreasingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthIncreasingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAHealthIncreasingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat Health;\n\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat HealthIncreaseAmount;\n\n\tvoid IncreaseHealth();\n};\n```", "cpp_code": "```cpp\n#include \"HealthIncreasingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAHealthIncreasingActor::AHealthIncreasingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tHealth = 100.0f;\n\tHealthIncreaseAmount = 10.0f;\n}\n\nvoid AHealthIncreasingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthIncreasingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHealthIncreasingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"IncreaseHealth\", IE_Pressed, this, &AHealthIncreasingActor::IncreaseHealth);\n}\n\nvoid AHealthIncreasingActor::IncreaseHealth()\n{\n\tHealth += HealthIncreaseAmount;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Health increased to: %f\"), Health);\n}\n```"}
{"requirement": "Create an Actor that rotates towards the player's location when in range.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationRange;\n\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Actor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 90.0f;\n\tRotationRange = 1000.0f;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tif (PlayerActor)\n\t{\n\t\tFVector ToPlayer = PlayerActor->GetActorLocation() - GetActorLocation();\n\t\tif (ToPlayer.Size() <= RotationRange)\n\t\t{\n\t\t\tFRotator TargetRotation = ToPlayer.Rotation();\n\t\t\tFRotator CurrentRotation = GetActorRotation();\n\t\t\tFRotator NewRotation = FMath::RInterpTo(CurrentRotation, TargetRotation, DeltaTime, RotationSpeed);\n\t\t\tSetActorRotation(NewRotation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to toggle the Actor's visibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleVisibilityActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visibility\")\n\tvoid ToggleVisibility();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tSetActorHiddenInGame(!bHidden);\n}\n```"}
{"requirement": "Create a static mesh component that changes size based on the player's input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UStaticMeshScaler.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AUStaticMeshScaler : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAUStaticMeshScaler();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Function to increase size\n\tvoid IncreaseSize();\n\n\t// Function to decrease size\n\tvoid DecreaseSize();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tfloat ScaleStep;\n};\n```", "cpp_code": "```cpp\n#include \"UStaticMeshScaler.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"GameFramework/InputSettings.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAUStaticMeshScaler::AUStaticMeshScaler()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Find and set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.MeshName\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tScaleStep = 0.1f;\n}\n\n// Called when the game starts or when spawned\nvoid AUStaticMeshScaler::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AUStaticMeshScaler::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AUStaticMeshScaler::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"IncreaseSize\", IE_Pressed, this, &AUStaticMeshScaler::IncreaseSize);\n\tPlayerInputComponent->BindAction(\"DecreaseSize\", IE_Pressed, this, &AUStaticMeshScaler::DecreaseSize);\n}\n\nvoid AUStaticMeshScaler::IncreaseSize()\n{\n\tFVector NewScale = StaticMeshComponent->GetComponentScale();\n\tNewScale += FVector(ScaleStep);\n\tStaticMeshComponent->SetWorldScale3D(NewScale);\n}\n\nvoid AUStaticMeshScaler::DecreaseSize()\n{\n\tFVector NewScale = StaticMeshComponent->GetComponentScale();\n\tNewScale -= FVector(ScaleStep);\n\tStaticMeshComponent->SetWorldScale3D(NewScale);\n}\n```"}
{"requirement": "Develop a class that changes the Actor's material to a random color every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomColorActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARandomColorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid ChangeMaterialColor();\n};\n```", "cpp_code": "```cpp\n#include \"RandomColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nARandomColorActor::ARandomColorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ARandomColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARandomColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tChangeMaterialColor();\n}\n\nvoid ARandomColorActor::ChangeMaterialColor()\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tFLinearColor RandomColor = FLinearColor::MakeRandomColor();\n\t\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), RandomColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement an Actor that plays a sound at a random interval.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundPlayingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASoundPlayingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* SoundToPlay;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tfloat MinInterval;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tfloat MaxInterval;\n\n\tFTimerHandle TimerHandle;\n\n\tvoid PlaySound();\n\tvoid SetRandomInterval();\n};\n```", "cpp_code": "```cpp\n#include \"SoundPlayingActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"TimerManager.h\"\n\nASoundPlayingActor::ASoundPlayingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tMinInterval = 1.0f;\n\tMaxInterval = 5.0f;\n}\n\nvoid ASoundPlayingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetRandomInterval();\n}\n\nvoid ASoundPlayingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundPlayingActor::PlaySound()\n{\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n\tSetRandomInterval();\n}\n\nvoid ASoundPlayingActor::SetRandomInterval()\n{\n\tfloat Interval = FMath::FRandRange(MinInterval, MaxInterval);\n\tGetWorldTimerManager().SetTimer(TimerHandle, this, &ASoundPlayingActor::PlaySound, Interval, false);\n}\n```"}
{"requirement": "Create a UMG widget that shows a message when the game starts.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UMessageWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API UMessageWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"UI\")\n\tvoid ShowMessage();\n};\n```", "cpp_code": "```cpp\n#include \"UMessageWidget.h\"\n#include \"Components/TextBlock.h\"\n#include \"Blueprint/WidgetTree.h\"\n\nvoid UMessageWidget::ShowMessage()\n{\n\tif (UTextBlock* TextBlock = WidgetTree->FindWidget<UTextBlock>(TEXT(\"MessageTextBlock\")))\n\t{\n\t\tTextBlock->SetText(FText::FromString(TEXT(\"Game Started!\")));\n\t}\n}\n```"}
{"requirement": "Develop a class that spawns a projectile when the player presses a button.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ProjectileSpawner.generated.h\"\n\nclass AProjectile;\n\nUCLASS()\nclass MYGAME_API AProjectileSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAProjectileSpawner();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid SpawnProjectile();\n\n\tUPROPERTY(EditAnywhere, Category=\"Spawning\")\n\tTSubclassOf<AProjectile> ProjectileClass;\n};\n```", "cpp_code": "```cpp\n#include \"ProjectileSpawner.h\"\n#include \"Projectile.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\nAProjectileSpawner::AProjectileSpawner()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AProjectileSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AProjectileSpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AProjectileSpawner::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tif(PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"SpawnProjectile\", IE_Pressed, this, &AProjectileSpawner::SpawnProjectile);\n\t}\n}\n\nvoid AProjectileSpawner::SpawnProjectile()\n{\n\tif(ProjectileClass)\n\t{\n\t\tUWorld* World = GetWorld();\n\t\tif(World)\n\t\t{\n\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\tSpawnParams.Owner = this;\n\t\t\tSpawnParams.Instigator = GetInstigator();\n\n\t\t\tFVector SpawnLocation = GetActorLocation();\n\t\t\tFRotator SpawnRotation = GetActorRotation();\n\n\t\t\tAProjectile* Projectile = World->SpawnActor<AProjectile>(ProjectileClass, SpawnLocation, SpawnRotation, SpawnParams);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a simple AI Controller that makes an AI character follow the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"APlayerFollowAIController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APlayerFollowAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPlayerFollowAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAPawn* PlayerPawn;\n};\n```", "cpp_code": "```cpp\n#include \"APlayerFollowAIController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Character.h\"\n\nAPlayerFollowAIController::APlayerFollowAIController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APlayerFollowAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid APlayerFollowAIController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerPawn)\n\t{\n\t\tMoveToActor(PlayerPawn, 5.0f);\n\t}\n}\n```"}
{"requirement": "Create an Actor that boosts the player's speed when near it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedBoostActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedBoostActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpeedBoostActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat SpeedBoostAmount;\n\n\tUPROPERTY(EditAnywhere, Category = \"Speed\")\n\tfloat BoostRadius;\n\n\tvoid BoostPlayerSpeed();\n};\n```", "cpp_code": "```cpp\n#include \"SpeedBoostActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Character.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASpeedBoostActor::ASpeedBoostActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tSpeedBoostAmount = 600.0f;\n\tBoostRadius = 500.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASpeedBoostActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpeedBoostActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tBoostPlayerSpeed();\n}\n\nvoid ASpeedBoostActor::BoostPlayerSpeed()\n{\n\tACharacter* PlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);\n\tif (PlayerCharacter)\n\t{\n\t\tfloat DistanceToPlayer = FVector::Dist(PlayerCharacter->GetActorLocation(), GetActorLocation());\n\t\tif (DistanceToPlayer <= BoostRadius)\n\t\t{\n\t\t\tPlayerCharacter->GetCharacterMovement()->MaxWalkSpeed += SpeedBoostAmount;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION that resets the player's score.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PlayerScoreManager.generated.h\"\n\nUCLASS()\nclass MYGAME_API APlayerScoreManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAPlayerScoreManager();\n\n\t// Function to reset player's score\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid ResetPlayerScore();\n\nprotected:\n\t// Player's score\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Score\")\n\tint32 PlayerScore;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerScoreManager.h\"\n\n// Sets default values\nAPlayerScoreManager::APlayerScoreManager()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize player's score\n\tPlayerScore = 0;\n}\n\nvoid APlayerScoreManager::ResetPlayerScore()\n{\n\tPlayerScore = 0;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Player's score has been reset.\"));\n}\n```"}
{"requirement": "Create an Actor with a collision component that destroys itself on impact.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionDestroyActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionDestroyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tACollisionDestroyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* CollisionComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionDestroyActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nACollisionDestroyActor::ACollisionDestroyActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set collision component\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\t// Register overlap event\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionDestroyActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionDestroyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACollisionDestroyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ACollisionDestroyActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\t// Destroy the actor when overlapping with another actor\n\t\tDestroy();\n\t}\n}\n```"}
{"requirement": "Develop a class that changes the Actor's texture when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TextureChangerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tATextureChangerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY()\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tUPROPERTY(EditAnywhere, Category=\"Textures\")\n\tUTexture* NewTexture;\n\n\tvoid ChangeTexture();\n};\n```", "cpp_code": "```cpp\n#include \"TextureChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"Engine/Texture.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nATextureChangerActor::ATextureChangerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/StarterContent/Materials/M_Brick_Clay_New.M_Brick_Clay_New\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterial = UMaterialInstanceDynamic::Create(MaterialAsset.Object, MeshComponent);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterial);\n\t}\n\n\tNewTexture = nullptr;\n}\n\nvoid ATextureChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATextureChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATextureChangerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ChangeTexture\", IE_Pressed, this, &ATextureChangerActor::ChangeTexture);\n}\n\nvoid ATextureChangerActor::ChangeTexture()\n{\n\tif (DynamicMaterial && NewTexture)\n\t{\n\t\tDynamicMaterial->SetTextureParameterValue(FName(\"Texture\"), NewTexture);\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to switch between two animations.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"AnimationSwitcher.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AAnimationSwitcher : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAnimationSwitcher();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Animation\")\n\tvoid SwitchAnimation();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tUAnimSequence* Animation1;\n\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tUAnimSequence* Animation2;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUAnimSequence* CurrentAnimation;\n};\n```", "cpp_code": "```cpp\n#include \"AnimationSwitcher.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Animation/AnimSequence.h\"\n\nAAnimationSwitcher::AAnimationSwitcher()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UAnimSequence> Anim1(TEXT(\"/Game/Path/To/Animation1.Animation1\"));\n\tstatic ConstructorHelpers::FObjectFinder<UAnimSequence> Anim2(TEXT(\"/Game/Path/To/Animation2.Animation2\"));\n\n\tif (Anim1.Succeeded())\n\t{\n\t\tAnimation1 = Anim1.Object;\n\t}\n\n\tif (Anim2.Succeeded())\n\t{\n\t\tAnimation2 = Anim2.Object;\n\t}\n\n\tCurrentAnimation = Animation1;\n}\n\nvoid AAnimationSwitcher::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAnimationSwitcher::SwitchAnimation()\n{\n\tif (CurrentAnimation == Animation1)\n\t{\n\t\tCurrentAnimation = Animation2;\n\t}\n\telse\n\t{\n\t\tCurrentAnimation = Animation1;\n\t}\n\n\t// Assuming there's an animation component or similar to apply the animation\n\t// MeshComponent->PlayAnimation(CurrentAnimation, false); // Example\n}\n```"}
{"requirement": "Create a class that logs the time passed since the game started every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"ATimeLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATimeLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATimeLoggerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\t// Timer handle for logging\n\tFTimerHandle LogTimeTimerHandle;\n\n\t// Function to log time since start\n\tvoid LogTimeSinceStart();\n};\n```", "cpp_code": "```cpp\n#include \"ATimeLoggerActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nATimeLoggerActor::ATimeLoggerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid ATimeLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Start a timer to log every second\n\tGetWorld()->GetTimerManager().SetTimer(LogTimeTimerHandle, this, &ATimeLoggerActor::LogTimeSinceStart, 1.0f, true);\n}\n\nvoid ATimeLoggerActor::LogTimeSinceStart()\n{\n\tfloat TimeSinceStart = GetWorld()->GetTimeSeconds();\n\tUE_LOG(LogTemp, Log, TEXT(\"Time since start: %f seconds\"), TimeSinceStart);\n}\n```"}
{"requirement": "Develop an Actor that turns red when health is below a threshold.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAHealthActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Health\")\n\tfloat Health;\n\n\tUPROPERTY(EditAnywhere, Category = \"Health\")\n\tfloat HealthThreshold;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid UpdateColorBasedOnHealth();\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAHealthActor::AHealthActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/Path/To/Your/StaticMesh.StaticMesh'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tHealth = 100.0f;\n\tHealthThreshold = 50.0f;\n}\n\nvoid AHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateColorBasedOnHealth();\n}\n\nvoid AHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateColorBasedOnHealth();\n}\n\nvoid AHealthActor::UpdateColorBasedOnHealth()\n{\n\tif (Health < HealthThreshold)\n\t{\n\t\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"Color\"), FLinearColor::Red);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"Color\"), FLinearColor::White);\n\t}\n}\n```"}
{"requirement": "Implement a simple networking function to replicate the Actor's scale across clients.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"AScaleReplicator.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleReplicator : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScaleReplicator();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, ReplicatedUsing=OnRep_Scale)\n\tFVector ActorScale;\n\n\tUFUNCTION()\n\tvoid OnRep_Scale();\n\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n};\n```", "cpp_code": "```cpp\n#include \"AScaleReplicator.h\"\n#include \"Net/UnrealNetwork.h\"\n\nAScaleReplicator::AScaleReplicator()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbReplicates = true;\n}\n\nvoid AScaleReplicator::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScaleReplicator::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScaleReplicator::OnRep_Scale()\n{\n\tSetActorScale3D(ActorScale);\n}\n\nvoid AScaleReplicator::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AScaleReplicator, ActorScale);\n}\n```"}
{"requirement": "Create an Actor that moves in a circular path using a timeline.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"CircularPathActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACircularPathActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACircularPathActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid HandleProgress(float Value);\n\n\tUPROPERTY(EditAnywhere, Category=\"Circular Movement\")\n\tfloat Radius;\n\n\tUPROPERTY(EditAnywhere, Category=\"Circular Movement\")\n\tfloat Speed;\n\n\tFTimeline CircleTimeline;\n\n\tFVector StartLocation;\n\n\tFOnTimelineFloat ProgressFunction;\n\n\tUPROPERTY()\n\tUTimelineComponent* TimelineComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CircularPathActor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nACircularPathActor::ACircularPathActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRadius = 300.0f;\n\tSpeed = 1.0f;\n\n\tTimelineComponent = CreateDefaultSubobject<UTimelineComponent>(TEXT(\"TimelineComponent\"));\n}\n\nvoid ACircularPathActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tStartLocation = GetActorLocation();\n\n\tif (TimelineComponent)\n\t{\n\t\tProgressFunction.BindUFunction(this, FName(\"HandleProgress\"));\n\t\tTimelineComponent->AddInterpFloat(CircleTimeline, ProgressFunction);\n\t\tTimelineComponent->SetLooping(true);\n\t\tTimelineComponent->SetPlayRate(Speed);\n\t\tTimelineComponent->PlayFromStart();\n\t}\n}\n\nvoid ACircularPathActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TimelineComponent)\n\t{\n\t\tTimelineComponent->TickComponent(DeltaTime, ELevelTick::LEVELTICK_TimeOnly, nullptr);\n\t}\n}\n\nvoid ACircularPathActor::HandleProgress(float Value)\n{\n\tfloat Angle = Value * 2.0f * PI;\n\tFVector NewLocation = StartLocation;\n\tNewLocation.X += Radius * FMath::Cos(Angle);\n\tNewLocation.Y += Radius * FMath::Sin(Angle);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Implement a UMG button widget that pauses the game when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UPauseGameWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UPauseGameWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Game\")\n\tvoid OnPauseButtonClicked();\n};\n```", "cpp_code": "```cpp\n#include \"UPauseGameWidget.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nvoid UPauseGameWidget::OnPauseButtonClicked()\n{\n\tUWorld* World = GetWorld();\n\tif (World)\n\t{\n\t\tAPlayerController* PlayerController = World->GetFirstPlayerController();\n\t\tif (PlayerController)\n\t\t{\n\t\t\tbool bIsPaused = UGameplayStatics::IsGamePaused(World);\n\t\t\tUGameplayStatics::SetGamePaused(World, !bIsPaused);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor that emits light based on its proximity to the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ProximityLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AProximityLightActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAProximityLightActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUPointLightComponent* PointLight;\n\n\tUPROPERTY(EditAnywhere, Category=\"Light\")\n\tfloat MaxLightIntensity;\n\n\tUPROPERTY(EditAnywhere, Category=\"Light\")\n\tfloat ActivationRadius;\n\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"ProximityLightActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAProximityLightActor::AProximityLightActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tPointLight->SetupAttachment(RootComponent);\n\n\tMaxLightIntensity = 3000.0f;\n\tActivationRadius = 500.0f;\n}\n\nvoid AProximityLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid AProximityLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerActor)\n\t{\n\t\tfloat DistanceToPlayer = FVector::Dist(PlayerActor->GetActorLocation(), GetActorLocation());\n\t\tif (DistanceToPlayer <= ActivationRadius)\n\t\t{\n\t\t\tfloat Intensity = FMath::Lerp(0.0f, MaxLightIntensity, 1.0f - (DistanceToPlayer / ActivationRadius));\n\t\t\tPointLight->SetIntensity(Intensity);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPointLight->SetIntensity(0.0f);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Develop a class that applies a random rotation to itself every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomRotatorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomRotatorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARandomRotatorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ApplyRandomRotation();\n\n\tFTimerHandle TimerHandle_RandomRotation;\n};\n```", "cpp_code": "```cpp\n#include \"RandomRotatorActor.h\"\n#include \"TimerManager.h\"\n\nARandomRotatorActor::ARandomRotatorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARandomRotatorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGetWorldTimerManager().SetTimer(TimerHandle_RandomRotation, this, &ARandomRotatorActor::ApplyRandomRotation, 1.0f, true);\n}\n\nvoid ARandomRotatorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARandomRotatorActor::ApplyRandomRotation()\n{\n\tFRotator NewRotation = FRotator(FMath::FRandRange(0.0f, 360.0f), FMath::FRandRange(0.0f, 360.0f), FMath::FRandRange(0.0f, 360.0f));\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a BlueprintCallable function that spawns a decoy Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DecoySpawner.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADecoySpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADecoySpawner();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Decoy\")\n\tvoid SpawnDecoy();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditDefaultsOnly, Category = \"Decoy\")\n\tTSubclassOf<AActor> DecoyClass;\n};\n```", "cpp_code": "```cpp\n#include \"DecoySpawner.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nADecoySpawner::ADecoySpawner()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Find the Decoy class in the content browser\n\tstatic ConstructorHelpers::FClassFinder<AActor> DecoyBPClass(TEXT(\"/Game/Blueprints/BP_Decoy\"));\n\tif (DecoyBPClass.Class != NULL)\n\t{\n\t\tDecoyClass = DecoyBPClass.Class;\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ADecoySpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADecoySpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADecoySpawner::SpawnDecoy()\n{\n\tif (DecoyClass != nullptr)\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tGetWorld()->SpawnActor<AActor>(DecoyClass, GetActorLocation(), GetActorRotation(), SpawnParams);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh that changes material on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialSwitcherActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialSwitcherActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMaterialSwitcherActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnMeshHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialSwitcherActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMaterialSwitcherActor::AMaterialSwitcherActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Find and set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMeshComponent->SetNotifyRigidBodyCollision(true);\n\tMeshComponent->OnComponentHit.AddDynamic(this, &AMaterialSwitcherActor::OnMeshHit);\n}\n\n// Called when the game starts or when spawned\nvoid AMaterialSwitcherActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n}\n\n// Called every frame\nvoid AMaterialSwitcherActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid AMaterialSwitcherActor::OnMeshHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (NewMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Develop a class that logs the Actor's velocity to the screen.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VelocityLoggerActor.generated.h\"\n\nUCLASS()\nclass AVelocityLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAVelocityLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"VelocityLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAVelocityLoggerActor::AVelocityLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AVelocityLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AVelocityLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector Velocity = GetVelocity();\n\tFString VelocityString = Velocity.ToString();\n\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Velocity: %s\"), *VelocityString));\n}\n```"}
{"requirement": "Implement a UFUNCTION to change the Actor's scale dynamically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicScaler.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADynamicScaler : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADynamicScaler();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Transformation\")\n\tvoid ChangeScale(FVector NewScale);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicScaler.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nADynamicScaler::ADynamicScaler()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ADynamicScaler::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADynamicScaler::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADynamicScaler::ChangeScale(FVector NewScale)\n{\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a simple AI Controller to make an AI character idle when the player is far.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"AICharacterController.generated.h\"\n\nUCLASS()\nclass AAICharacterController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAICharacterController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaSeconds) override;\n\nprivate:\n\tAPawn* PlayerPawn;\n\tfloat IdleDistanceThreshold;\n};\n```", "cpp_code": "```cpp\n#include \"AICharacterController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAAICharacterController::AAICharacterController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tIdleDistanceThreshold = 1000.0f; // Set an arbitrary distance threshold\n}\n\nvoid AAICharacterController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid AAICharacterController::Tick(float DeltaSeconds)\n{\n\tSuper::Tick(DeltaSeconds);\n\n\tif (!PlayerPawn)\n\t{\n\t\treturn;\n\t}\n\n\tAPawn* ControlledPawn = GetPawn();\n\tif (!ControlledPawn)\n\t{\n\t\treturn;\n\t}\n\n\tfloat DistanceToPlayer = FVector::Dist(PlayerPawn->GetActorLocation(), ControlledPawn->GetActorLocation());\n\n\tif (DistanceToPlayer > IdleDistanceThreshold)\n\t{\n\t\t// Idle behavior\n\t\tControlledPawn->GetMovementComponent()->StopMovementImmediately();\n\t}\n\telse\n\t{\n\t\t// Implement chasing or other behavior here\n\t}\n}\n```"}
{"requirement": "Develop a class that prints a random joke from an array each time a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomJokeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomJokeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARandomJokeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input bindings\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid PrintRandomJoke();\n\n\tUPROPERTY()\n\tTArray<FString> Jokes;\n};\n```", "cpp_code": "```cpp\n#include \"RandomJokeActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nARandomJokeActor::ARandomJokeActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize jokes\n\tJokes.Add(TEXT(\"Why don't scientists trust atoms? Because they make up everything!\"));\n\tJokes.Add(TEXT(\"What do you get when you cross a snowman and a vampire? Frostbite.\"));\n\tJokes.Add(TEXT(\"Why was the math book sad? Because it had too many problems.\"));\n}\n\n// Called when the game starts or when spawned\nvoid ARandomJokeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARandomJokeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input bindings\nvoid ARandomJokeActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"PrintJoke\", IE_Pressed, this, &ARandomJokeActor::PrintRandomJoke);\n}\n\nvoid ARandomJokeActor::PrintRandomJoke()\n{\n\tif (Jokes.Num() > 0)\n\t{\n\t\tint32 RandomIndex = FMath::RandRange(0, Jokes.Num() - 1);\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Yellow, Jokes[RandomIndex]);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement an Actor that scales down over time and destroys itself when too small.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat ScaleDownRate;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat MinimumScale;\n\n\tvoid CheckAndDestroy();\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tScaleDownRate = 0.1f;\n\tMinimumScale = 0.1f;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewScale = GetActorScale3D() - FVector(ScaleDownRate * DeltaTime);\n\tSetActorScale3D(NewScale);\n\n\tCheckAndDestroy();\n}\n\nvoid AScalingActor::CheckAndDestroy()\n{\n\tif (GetActorScale3D().X <= MinimumScale || GetActorScale3D().Y <= MinimumScale || GetActorScale3D().Z <= MinimumScale)\n\t{\n\t\tDestroy();\n\t}\n}\n```"}
{"requirement": "Create a UMG widget that displays a countdown timer.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UMGCountdownWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UUMGCountdownWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUUMGCountdownWidget(const FObjectInitializer& ObjectInitializer);\n\n\tvirtual void NativeConstruct() override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Countdown\")\n\tvoid StartCountdown(float CountdownTime);\n\nprivate:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UTextBlock* CountdownText;\n\n\tFTimerHandle CountdownTimerHandle;\n\tfloat RemainingTime;\n\n\tvoid UpdateTimerDisplay();\n\tvoid CountdownHasFinished();\n};\n```", "cpp_code": "```cpp\n#include \"UMGCountdownWidget.h\"\n#include \"Components/TextBlock.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n\nUUMGCountdownWidget::UUMGCountdownWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UUMGCountdownWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\t// Initialize widget components here\n}\n\nvoid UUMGCountdownWidget::StartCountdown(float CountdownTime)\n{\n\tRemainingTime = CountdownTime;\n\tUpdateTimerDisplay();\n\tGetWorld()->GetTimerManager().SetTimer(CountdownTimerHandle, this, &UUMGCountdownWidget::UpdateTimerDisplay, 1.0f, true);\n}\n\nvoid UUMGCountdownWidget::UpdateTimerDisplay()\n{\n\tif (RemainingTime < 1)\n\t{\n\t\tCountdownHasFinished();\n\t}\n\telse\n\t{\n\t\t--RemainingTime;\n\t\tif (CountdownText)\n\t\t{\n\t\t\tCountdownText->SetText(FText::AsNumber(FMath::CeilToInt(RemainingTime)));\n\t\t}\n\t}\n}\n\nvoid UUMGCountdownWidget::CountdownHasFinished()\n{\n\tGetWorld()->GetTimerManager().ClearTimer(CountdownTimerHandle);\n\tif (CountdownText)\n\t{\n\t\tCountdownText->SetText(FText::FromString(TEXT(\"Time's Up!\")));\n\t}\n}\n```"}
{"requirement": "Implement a class to toggle between different camera perspectives.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CameraToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACameraToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACameraToggleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid ToggleCameraPerspective();\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tTArray<UCameraComponent*> CameraComponents;\n\t\n\tint32 CurrentCameraIndex;\n};\n```", "cpp_code": "```cpp\n#include \"CameraToggleActor.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nACameraToggleActor::ACameraToggleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCurrentCameraIndex = 0;\n\n\t// Example setup for multiple cameras\n\tUCameraComponent* FirstCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FirstCamera\"));\n\tFirstCamera->SetupAttachment(RootComponent);\n\tCameraComponents.Add(FirstCamera);\n\n\tUCameraComponent* SecondCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"SecondCamera\"));\n\tSecondCamera->SetupAttachment(RootComponent);\n\tCameraComponents.Add(SecondCamera);\n}\n\n// Called when the game starts or when spawned\nvoid ACameraToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (CameraComponents.Num() > 0)\n\t{\n\t\tfor (int32 i = 0; i < CameraComponents.Num(); ++i)\n\t\t{\n\t\t\tCameraComponents[i]->SetActive(i == CurrentCameraIndex);\n\t\t}\n\t}\n}\n\n// Called every frame\nvoid ACameraToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACameraToggleActor::ToggleCameraPerspective()\n{\n\tif (CameraComponents.Num() > 0)\n\t{\n\t\tCameraComponents[CurrentCameraIndex]->SetActive(false);\n\t\tCurrentCameraIndex = (CurrentCameraIndex + 1) % CameraComponents.Num();\n\t\tCameraComponents[CurrentCameraIndex]->SetActive(true);\n\t}\n}\n```"}
{"requirement": "Create an Actor that automatically moves forward and bounces off walls.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AutoMoveActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AAutoMoveActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAAutoMoveActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat MoveSpeed;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector MoveDirection;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult& Hit);\n\n};\n```", "cpp_code": "```cpp\n#include \"AutoMoveActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAAutoMoveActor::AAutoMoveActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMoveSpeed = 200.0f;\n\tMoveDirection = FVector(1.0f, 0.0f, 0.0f);\n\n\tMeshComponent->OnComponentHit.AddDynamic(this, &AAutoMoveActor::OnHit);\n}\n\nvoid AAutoMoveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAutoMoveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation() + (MoveDirection * MoveSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n\nvoid AAutoMoveActor::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tMoveDirection = FVector::Reflect(MoveDirection, Hit.Normal);\n}\n```"}
{"requirement": "Develop a class that changes the background music when a specific location is reached.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"LocationMusicChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALocationMusicChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALocationMusicChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category = \"Music\")\n\tUSoundCue* NewBackgroundMusic;\n\n\tUPROPERTY(EditAnywhere, Category = \"Location\")\n\tFVector TargetLocation;\n\n\tUPROPERTY(EditAnywhere, Category = \"Location\")\n\tfloat TriggerRadius;\n\nprivate:\n\tvoid ChangeMusic();\n\tbool IsPlayerInTargetLocation() const;\n};\n```", "cpp_code": "```cpp\n#include \"LocationMusicChanger.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Sound/SoundCue.h\"\n\nALocationMusicChanger::ALocationMusicChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTriggerRadius = 500.0f;  // Default radius\n}\n\nvoid ALocationMusicChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALocationMusicChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (IsPlayerInTargetLocation())\n\t{\n\t\tChangeMusic();\n\t}\n}\n\nvoid ALocationMusicChanger::ChangeMusic()\n{\n\tif (NewBackgroundMusic)\n\t{\n\t\tUGameplayStatics::PlaySound2D(this, NewBackgroundMusic);\n\t}\n}\n\nbool ALocationMusicChanger::IsPlayerInTargetLocation() const\n{\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tAPawn* PlayerPawn = PlayerController->GetPawn();\n\t\tif (PlayerPawn)\n\t\t{\n\t\t\tFVector PlayerLocation = PlayerPawn->GetActorLocation();\n\t\t\tfloat Distance = FVector::Dist(PlayerLocation, TargetLocation);\n\t\t\treturn Distance <= TriggerRadius;\n\t\t}\n\t}\n\treturn false;\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to reset the level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LevelResetter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ALevelResetter : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALevelResetter();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Level\")\n\tvoid ResetLevel();\n};\n```", "cpp_code": "```cpp\n#include \"LevelResetter.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nALevelResetter::ALevelResetter()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALevelResetter::ResetLevel()\n{\n\tUWorld* World = GetWorld();\n\tif (World)\n\t{\n\t\tFName CurrentLevelName = *UGameplayStatics::GetCurrentLevelName(World);\n\t\tUGameplayStatics::OpenLevel(World, CurrentLevelName);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a rotating component that can be started and stopped.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Rotation\")\n\tvoid StartRotation();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Rotation\")\n\tvoid StopRotation();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationSpeed;\n\n\tbool bIsRotating;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"ConstructorHelpers.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRotationSpeed = FRotator(0.f, 180.f, 0.f);\n\tbIsRotating = false;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsRotating)\n\t{\n\t\tFRotator NewRotation = GetActorRotation() + (RotationSpeed * DeltaTime);\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n\nvoid ARotatingActor::StartRotation()\n{\n\tbIsRotating = true;\n}\n\nvoid ARotatingActor::StopRotation()\n{\n\tbIsRotating = false;\n}\n```"}
{"requirement": "Develop a class that spawns a random item from a list on pressing a key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomItemSpawner.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ARandomItemSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARandomItemSpawner();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Spawning\")\n\tTArray<TSubclassOf<AActor>> ItemClasses;\n\n\tUFUNCTION()\n\tvoid SpawnRandomItem();\n};\n```", "cpp_code": "```cpp\n#include \"RandomItemSpawner.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nARandomItemSpawner::ARandomItemSpawner()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARandomItemSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARandomItemSpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARandomItemSpawner::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"SpawnItem\", IE_Pressed, this, &ARandomItemSpawner::SpawnRandomItem);\n}\n\nvoid ARandomItemSpawner::SpawnRandomItem()\n{\n\tif (ItemClasses.Num() > 0)\n\t{\n\t\tint32 RandomIndex = FMath::RandRange(0, ItemClasses.Num() - 1);\n\t\tTSubclassOf<AActor> ItemToSpawn = ItemClasses[RandomIndex];\n\n\t\tif (ItemToSpawn)\n\t\t{\n\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\tGetWorld()->SpawnActor<AActor>(ItemToSpawn, GetActorLocation(), FRotator::ZeroRotator, SpawnParams);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a UMG widget that displays a loading bar.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"ULoadingBarWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ULoadingBarWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tULoadingBarWidget(const FObjectInitializer& ObjectInitializer);\n\n\tUFUNCTION(BlueprintCallable, Category = \"Loading\")\n\tvoid SetLoadingProgress(float Progress);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UProgressBar* LoadingProgressBar;\n};\n```", "cpp_code": "```cpp\n#include \"ULoadingBarWidget.h\"\n#include \"Components/ProgressBar.h\"\n\nULoadingBarWidget::ULoadingBarWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid ULoadingBarWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\t// You can initialize your widget here\n}\n\nvoid ULoadingBarWidget::SetLoadingProgress(float Progress)\n{\n\tif (LoadingProgressBar)\n\t{\n\t\tLoadingProgressBar->SetPercent(Progress);\n\t}\n}\n```"}
{"requirement": "Create a class that logs the player's score to the console.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScoreLogger();\n\n\t// Logs the player's score\n\tUFUNCTION(BlueprintCallable, Category=\"Score\")\n\tvoid LogScore(int32 PlayerScore);\n};\n```", "cpp_code": "```cpp\n#include \"ScoreLogger.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAScoreLogger::AScoreLogger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AScoreLogger::LogScore(int32 PlayerScore)\n{\n\tif (GEngine)\n\t{\n\t\tFString ScoreMessage = FString::Printf(TEXT(\"Player Score: %d\"), PlayerScore);\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, ScoreMessage);\n\t}\n}\n```"}
{"requirement": "Develop an Actor with a timeline that changes its opacity over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"OpacityChangingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AOpacityChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tAOpacityChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tFTimeline OpacityTimeline;\n\n\tUFUNCTION()\n\tvoid HandleOpacityChange(float Value);\n\n\tUFUNCTION()\n\tvoid OnTimelineFinished();\n\n\tUPROPERTY(EditAnywhere, Category = \"Timeline\")\n\tUCurveFloat* OpacityCurve;\n};\n```", "cpp_code": "```cpp\n#include \"OpacityChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n\nAOpacityChangingActor::AOpacityChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AOpacityChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (OpacityCurve)\n\t{\n\t\tFOnTimelineFloat TimelineCallback;\n\t\tTimelineCallback.BindUFunction(this, FName(\"HandleOpacityChange\"));\n\n\t\tFOnTimelineEventStatic TimelineFinishedCallback;\n\t\tTimelineFinishedCallback.BindUFunction(this, FName(\"OnTimelineFinished\"));\n\n\t\tOpacityTimeline.AddInterpFloat(OpacityCurve, TimelineCallback);\n\t\tOpacityTimeline.SetTimelineFinishedFunc(TimelineFinishedCallback);\n\t\tOpacityTimeline.SetLooping(false);\n\t\tOpacityTimeline.PlayFromStart();\n\t}\n}\n\nvoid AOpacityChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tOpacityTimeline.TickTimeline(DeltaTime);\n}\n\nvoid AOpacityChangingActor::HandleOpacityChange(float Value)\n{\n\tFLinearColor NewColor = MeshComponent->GetMaterial(0)->GetVectorParameterValue(FName(\"BaseColor\"));\n\tNewColor.A = Value;\n\tMeshComponent->SetVectorParameterValueOnMaterials(FName(\"BaseColor\"), NewColor);\n}\n\nvoid AOpacityChangingActor::OnTimelineFinished()\n{\n\t// Handle the end of the timeline\n}\n```"}
{"requirement": "Implement a UFUNCTION to reverse the Actor's direction instantaneously.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReverseDirectionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AReverseDirectionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAReverseDirectionActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid ReverseDirection();\n};\n```", "cpp_code": "```cpp\n#include \"ReverseDirectionActor.h\"\n\n// Sets default values\nAReverseDirectionActor::AReverseDirectionActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AReverseDirectionActor::ReverseDirection()\n{\n\tFVector CurrentVelocity = GetVelocity();\n\tFVector ReversedVelocity = -CurrentVelocity;\n\tGetRootComponent()->ComponentVelocity = ReversedVelocity;\n}\n```"}
{"requirement": "Create an Actor that plays a victory sound when the player wins.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VictorySoundActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AVictorySoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAVictorySoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to play victory sound\n\tUFUNCTION(BlueprintCallable, Category=\"Victory\")\n\tvoid PlayVictorySound();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Audio\")\n\tUSoundBase* VictorySound;\n};\n```", "cpp_code": "```cpp\n#include \"VictorySoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAVictorySoundActor::AVictorySoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the VictorySound\n\tVictorySound = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid AVictorySoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AVictorySoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AVictorySoundActor::PlayVictorySound()\n{\n\tif (VictorySound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, VictorySound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Implement a simple AI Controller to patrol between dynamic waypoints.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PatrolAIController.generated.h\"\n\nUCLASS()\nclass APatrolAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPatrolAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid MoveToNextWaypoint();\n\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tTArray<AActor*> PatrolWaypoints;\n\n\tint32 CurrentWaypointIndex;\n};\n```", "cpp_code": "```cpp\n#include \"PatrolAIController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Actor.h\"\n\nAPatrolAIController::APatrolAIController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentWaypointIndex = 0;\n}\n\nvoid APatrolAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Optionally find waypoints dynamically at runtime\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), AActor::StaticClass(), PatrolWaypoints);\n\n\tif (PatrolWaypoints.Num() > 0)\n\t{\n\t\tMoveToNextWaypoint();\n\t}\n}\n\nvoid APatrolAIController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (GetPawn() && PatrolWaypoints.Num() > 0)\n\t{\n\t\tfloat DistanceToWaypoint = FVector::Dist(GetPawn()->GetActorLocation(), PatrolWaypoints[CurrentWaypointIndex]->GetActorLocation());\n\n\t\tif (DistanceToWaypoint < 100.0f) // close enough to the waypoint\n\t\t{\n\t\t\tMoveToNextWaypoint();\n\t\t}\n\t}\n}\n\nvoid APatrolAIController::MoveToNextWaypoint()\n{\n\tif (PatrolWaypoints.Num() == 0)\n\t{\n\t\treturn;\n\t}\n\n\tMoveToActor(PatrolWaypoints[CurrentWaypointIndex]);\n\n\tCurrentWaypointIndex = (CurrentWaypointIndex + 1) % PatrolWaypoints.Num();\n}\n```"}
{"requirement": "Create a class that increases a counter every time a specific input is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CounterActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACounterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACounterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Counter variable\n\tUPROPERTY(VisibleAnywhere, Category = \"Counter\")\n\tint32 Counter;\n\n\t// Function to increase the counter\n\tvoid IncreaseCounter();\n};\n```", "cpp_code": "```cpp\n#include \"CounterActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nACounterActor::ACounterActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize counter\n\tCounter = 0;\n}\n\n// Called when the game starts or when spawned\nvoid ACounterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACounterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid ACounterActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind IncreaseCounter function to \"IncreaseCounter\" action\n\tPlayerInputComponent->BindAction(\"IncreaseCounter\", IE_Pressed, this, &ACounterActor::IncreaseCounter);\n}\n\n// Function to increase the counter\nvoid ACounterActor::IncreaseCounter()\n{\n\tCounter++;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Counter: %d\"), Counter);\n}\n```"}
{"requirement": "Develop an Actor that changes its texture based on the time of day.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimedTextureActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATimedTextureActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATimedTextureActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Textures\")\n\tUTexture* MorningTexture;\n\n\tUPROPERTY(EditAnywhere, Category = \"Textures\")\n\tUTexture* AfternoonTexture;\n\n\tUPROPERTY(EditAnywhere, Category = \"Textures\")\n\tUTexture* EveningTexture;\n\n\tvoid UpdateTextureBasedOnTimeOfDay();\n};\n```", "cpp_code": "```cpp\n#include \"TimedTextureActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Texture.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nATimedTextureActor::ATimedTextureActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ATimedTextureActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateTextureBasedOnTimeOfDay();\n}\n\n// Called every frame\nvoid ATimedTextureActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateTextureBasedOnTimeOfDay();\n}\n\nvoid ATimedTextureActor::UpdateTextureBasedOnTimeOfDay()\n{\n\tfloat CurrentHour = UGameplayStatics::GetTimeSeconds(GetWorld()) / 3600.0f;\n\tUTexture* NewTexture = nullptr;\n\n\tif (CurrentHour >= 6.0f && CurrentHour < 12.0f)\n\t{\n\t\tNewTexture = MorningTexture;\n\t}\n\telse if (CurrentHour >= 12.0f && CurrentHour < 18.0f)\n\t{\n\t\tNewTexture = AfternoonTexture;\n\t}\n\telse\n\t{\n\t\tNewTexture = EveningTexture;\n\t}\n\n\tif (NewTexture)\n\t{\n\t\tMeshComponent->SetMaterial(0, UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this));\n\t\tUMaterialInstanceDynamic* DynMaterial = Cast<UMaterialInstanceDynamic>(MeshComponent->GetMaterial(0));\n\t\tif (DynMaterial)\n\t\t{\n\t\t\tDynMaterial->SetTextureParameterValue(TEXT(\"Texture\"), NewTexture);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function that switches the Actor's material to a different texture.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SwitchMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASwitchMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASwitchMaterialActor();\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Material\")\n\tvoid SwitchMaterial(UTexture* NewTexture);\n};\n```", "cpp_code": "```cpp\n#include \"SwitchMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nASwitchMaterialActor::ASwitchMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ASwitchMaterialActor::SwitchMaterial(UTexture* NewTexture)\n{\n\tif (!NewTexture)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"SwitchMaterial called with a null texture.\"));\n\t\treturn;\n\t}\n\n\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\tif (DynamicMaterial)\n\t{\n\t\tDynamicMaterial->SetTextureParameterValue(FName(\"TextureParameter\"), NewTexture);\n\t}\n}\n```"}
{"requirement": "Create an Actor that plays a unique sound on spawn.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Components/AudioComponent.h\"\n#include \"UniqueSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AUniqueSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAUniqueSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Sound component to play the sound\n\tUPROPERTY(EditAnywhere, Category=\"Sound\")\n\tUSoundBase* SpawnSound;\n\n\t// Audio component\n\tUPROPERTY(VisibleAnywhere, Category=\"Sound\")\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"UniqueSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAUniqueSoundActor::AUniqueSoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// Create audio component and attach to root\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n}\n\n// Called when the game starts or when spawned\nvoid AUniqueSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Play the sound if it's set\n\tif (SpawnSound)\n\t{\n\t\tAudioComponent->SetSound(SpawnSound);\n\t\tAudioComponent->Play();\n\t}\n}\n```"}
{"requirement": "Develop a class that logs when an Actor enters and exits a trigger volume.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"LoggingTriggerVolume.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingTriggerVolume : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tALoggingTriggerVolume();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* TriggerVolume;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n};\n```", "cpp_code": "```cpp\n#include \"LoggingTriggerVolume.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n\n// Sets default values\nALoggingTriggerVolume::ALoggingTriggerVolume()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t // Create the trigger volume\n\t TriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n\t RootComponent = TriggerVolume;\n\n\t // Bind events\n\t TriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &ALoggingTriggerVolume::OnOverlapBegin);\n\t TriggerVolume->OnComponentEndOverlap.AddDynamic(this, &ALoggingTriggerVolume::OnOverlapEnd);\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingTriggerVolume::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ALoggingTriggerVolume::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ALoggingTriggerVolume::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s has entered the trigger volume\"), *OtherActor->GetName());\n\t}\n}\n\nvoid ALoggingTriggerVolume::OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s has exited the trigger volume\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Implement a UMG widget that acts as an on-screen joystick for character movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UJoystickWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UJoystickWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUJoystickWidget(const FObjectInitializer& ObjectInitializer);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UImage* JoystickBackground;\n\n\tUPROPERTY(meta = (BindWidget))\n\tclass UImage* JoystickThumb;\n\n\tFVector2D InitialPosition;\n\n\tUFUNCTION()\n\tvoid OnTouchStarted(ETouchIndex::Type FingerIndex, FVector Location);\n\n\tUFUNCTION()\n\tvoid OnTouchMoved(ETouchIndex::Type FingerIndex, FVector Location);\n\n\tUFUNCTION()\n\tvoid OnTouchEnded(ETouchIndex::Type FingerIndex, FVector Location);\n\n\tvoid UpdateJoystickPosition(FVector2D TouchPosition);\n};\n```", "cpp_code": "```cpp\n#include \"UJoystickWidget.h\"\n#include \"Components/Image.h\"\n#include \"Blueprint/WidgetTree.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n#include \"Components/CanvasPanelSlot.h\"\n\nUJoystickWidget::UJoystickWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UJoystickWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\t\n\t// Bind touch events\n\tif (JoystickBackground)\n\t{\n\t\tJoystickBackground->OnMouseButtonDownEvent.BindUFunction(this, FName(\"OnTouchStarted\"));\n\t\tJoystickBackground->OnMouseMoveEvent.BindUFunction(this, FName(\"OnTouchMoved\"));\n\t\tJoystickBackground->OnMouseButtonUpEvent.BindUFunction(this, FName(\"OnTouchEnded\"));\n\t}\n\n\tif (JoystickThumb)\n\t{\n\t\tInitialPosition = JoystickThumb->Slot->AsCanvasSlot()->GetPosition();\n\t}\n}\n\nvoid UJoystickWidget::OnTouchStarted(ETouchIndex::Type FingerIndex, FVector Location)\n{\n\tUpdateJoystickPosition(FVector2D(Location.X, Location.Y));\n}\n\nvoid UJoystickWidget::OnTouchMoved(ETouchIndex::Type FingerIndex, FVector Location)\n{\n\tUpdateJoystickPosition(FVector2D(Location.X, Location.Y));\n}\n\nvoid UJoystickWidget::OnTouchEnded(ETouchIndex::Type FingerIndex, FVector Location)\n{\n\t// Reset thumb position\n\tif (JoystickThumb)\n\t{\n\t\tJoystickThumb->Slot->AsCanvasSlot()->SetPosition(InitialPosition);\n\t}\n}\n\nvoid UJoystickWidget::UpdateJoystickPosition(FVector2D TouchPosition)\n{\n\tif (JoystickThumb)\n\t{\n\t\tFVector2D DeltaPosition = TouchPosition - InitialPosition;\n\t\t// Clamp the movement\n\t\tDeltaPosition = UKismetMathLibrary::ClampVector2DSize(DeltaPosition, 0, 100);\n\n\t\tJoystickThumb->Slot->AsCanvasSlot()->SetPosition(InitialPosition + DeltaPosition);\n\n\t\t// Here you would typically send the DeltaPosition to your character or player controller\n\t}\n}\n```"}
{"requirement": "Create an Actor that applies a temporary speed boost to the player on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedBoostActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API ASpeedBoostActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpeedBoostActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"SpeedBoost\")\n\tfloat SpeedBoostAmount;\n\n\tUPROPERTY(EditAnywhere, Category=\"SpeedBoost\")\n\tfloat BoostDuration;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor,\n\t\t\t\t\t\tclass UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,\n\t\t\t\t\t\tbool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"SpeedBoostActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"TimerManager.h\"\n\nASpeedBoostActor::ASpeedBoostActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\tMeshComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ASpeedBoostActor::OnOverlapBegin);\n\n\tSpeedBoostAmount = 600.0f; // Example boost amount\n\tBoostDuration = 5.0f; // Example duration in seconds\n}\n\nvoid ASpeedBoostActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpeedBoostActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpeedBoostActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor,\n\t\t\t\t\t\t\t\t\t  UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,\n\t\t\t\t\t\t\t\t\t  bool bFromSweep, const FHitResult & SweepResult)\n{\n\tACharacter* Character = Cast<ACharacter>(OtherActor);\n\tif (Character)\n\t{\n\t\tUCharacterMovementComponent* MovementComponent = Character->GetCharacterMovement();\n\t\tif (MovementComponent)\n\t\t{\n\t\t\tMovementComponent->MaxWalkSpeed += SpeedBoostAmount;\n\n\t\t\tFTimerHandle TimerHandle;\n\t\t\tGetWorld()->GetTimerManager().SetTimer(TimerHandle, [=]() {\n\t\t\t\tMovementComponent->MaxWalkSpeed -= SpeedBoostAmount;\n\t\t\t}, BoostDuration, false);\n\n\t\t\tDestroy(); // Destroy the boost actor after applying the effect\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION that changes the Actor's material to indicate damage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"DamageableActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADamageableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADamageableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Damage\")\n\tvoid ChangeMaterialToIndicateDamage(UMaterialInterface* DamageMaterial);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Damage\")\n\tUMaterialInterface* OriginalMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"DamageableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nADamageableActor::ADamageableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Geometry/Meshes/YourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialAsset(TEXT(\"/Game/Materials/YourMaterial.YourMaterial\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tOriginalMaterial = MaterialAsset.Object;\n\t\tMeshComponent->SetMaterial(0, OriginalMaterial);\n\t}\n}\n\nvoid ADamageableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADamageableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADamageableActor::ChangeMaterialToIndicateDamage(UMaterialInterface* DamageMaterial)\n{\n\tif (DamageMaterial && MeshComponent)\n\t{\n\t\tMeshComponent->SetMaterial(0, DamageMaterial);\n\t}\n}\n```"}
{"requirement": "Create a class that rotates the Actor towards the player's camera view.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotateTowardsCameraActor.generated.h\"\n\nUCLASS()\nclass ARotateTowardsCameraActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotateTowardsCameraActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid RotateTowardsCamera();\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"RotateTowardsCameraActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Camera/PlayerCameraManager.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\n// Sets default values\nARotateTowardsCameraActor::ARotateTowardsCameraActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ARotateTowardsCameraActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotateTowardsCameraActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRotateTowardsCamera();\n}\n\nvoid ARotateTowardsCameraActor::RotateTowardsCamera()\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tAPlayerCameraManager* CameraManager = PlayerController->PlayerCameraManager;\n\t\tif (CameraManager)\n\t\t{\n\t\t\tFVector ActorLocation = GetActorLocation();\n\t\t\tFVector CameraLocation = CameraManager->GetCameraLocation();\n\t\t\tFRotator LookAtRotation = UKismetMathLibrary::FindLookAtRotation(ActorLocation, CameraLocation);\n\t\t\tSetActorRotation(LookAtRotation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Develop an Actor with a timeline to animate its rotation smoothly.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* RotationCurve;\n\n\tFTimeline RotationTimeline;\n\n\tUFUNCTION()\n\tvoid HandleRotationProgress(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (RotationCurve)\n\t{\n\t\tFOnTimelineFloat RotationProgress;\n\t\tRotationProgress.BindUFunction(this, FName(\"HandleRotationProgress\"));\n\t\tRotationTimeline.AddInterpFloat(RotationCurve, RotationProgress);\n\t\tRotationTimeline.SetLooping(true);\n\t\tRotationTimeline.PlayFromStart();\n\t}\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRotationTimeline.TickTimeline(DeltaTime);\n}\n\nvoid ARotatingActor::HandleRotationProgress(float Value)\n{\n\tFRotator NewRotation = FRotator(0.f, Value * 360.f, 0.f);\n\tMeshComponent->SetRelativeRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a simple networking function to replicate the Actor's visibility state.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"AReplicatedVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AReplicatedVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAReplicatedVisibilityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid SetActorVisibility(bool bVisible);\n\n\tUFUNCTION(NetMulticast, Reliable)\n\tvoid Multicast_SetActorVisibility(bool bVisible);\n\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n\nprivate:\n\tUPROPERTY(ReplicatedUsing = OnRep_VisibilityChanged)\n\tbool bIsVisible;\n\n\tUFUNCTION()\n\tvoid OnRep_VisibilityChanged();\n};\n```", "cpp_code": "```cpp\n#include \"AReplicatedVisibilityActor.h\"\n\n// Sets default values\nAReplicatedVisibilityActor::AReplicatedVisibilityActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tbReplicates = true;\n\tbIsVisible = true;\n}\n\n// Called when the game starts or when spawned\nvoid AReplicatedVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AReplicatedVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AReplicatedVisibilityActor::SetActorVisibility(bool bVisible)\n{\n\tif (HasAuthority())\n\t{\n\t\tbIsVisible = bVisible;\n\t\tMulticast_SetActorVisibility(bIsVisible);\n\t}\n}\n\nvoid AReplicatedVisibilityActor::Multicast_SetActorVisibility_Implementation(bool bVisible)\n{\n\tSetActorHiddenInGame(!bVisible);\n}\n\nvoid AReplicatedVisibilityActor::OnRep_VisibilityChanged()\n{\n\tSetActorHiddenInGame(!bIsVisible);\n}\n\nvoid AReplicatedVisibilityActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AReplicatedVisibilityActor, bIsVisible);\n}\n```"}
{"requirement": "Create an Actor that changes its material when touched by the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMaterialOnTouchActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMaterialOnTouchActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAChangeMaterialOnTouchActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Materials\")\n\tUMaterialInterface* NewMaterial;\n\n\tUFUNCTION()\n\tvoid OnPlayerTouch(class UPrimitiveComponent* TouchedComponent, AActor* OtherActor, \n\t\t\t\t\t  UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, \n\t\t\t\t\t  const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialOnTouchActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"ConstructorHelpers.h\"\n\nAChangeMaterialOnTouchActor::AChangeMaterialOnTouchActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AChangeMaterialOnTouchActor::OnPlayerTouch);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AChangeMaterialOnTouchActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMaterialOnTouchActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialOnTouchActor::OnPlayerTouch(UPrimitiveComponent* TouchedComponent, AActor* OtherActor, \n\t\t\t\t\t\t\t\t\t\t\t\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, \n\t\t\t\t\t\t\t\t\t\t\t\tconst FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor != this && NewMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to reset the Actor's scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetScaleActor.generated.h\"\n\nUCLASS()\nclass AResetScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAResetScaleActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Scale\")\n\tvoid ResetScale();\n};\n```", "cpp_code": "```cpp\n#include \"ResetScaleActor.h\"\n\n// Sets default values\nAResetScaleActor::AResetScaleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetScaleActor::ResetScale()\n{\n\tSetActorScale3D(FVector(1.0f, 1.0f, 1.0f));\n}\n```"}
{"requirement": "Create a class that logs a warning message when the player is low on health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LowHealthLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALowHealthLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALowHealthLogger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid CheckHealth();\n\n\tUPROPERTY(EditAnywhere, Category = \"Health\")\n\tfloat Health;\n\n\tUPROPERTY(EditAnywhere, Category = \"Health\")\n\tfloat LowHealthThreshold;\n};\n```", "cpp_code": "```cpp\n#include \"LowHealthLogger.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nALowHealthLogger::ALowHealthLogger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHealth = 100.0f;\n\tLowHealthThreshold = 25.0f;\n}\n\nvoid ALowHealthLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALowHealthLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tCheckHealth();\n}\n\nvoid ALowHealthLogger::CheckHealth()\n{\n\tif (Health < LowHealthThreshold)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Player is low on health!\"));\n\t}\n}\n```"}
{"requirement": "Develop an Actor that moves towards a target point when spawned.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tFVector TargetLocation;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MoveSpeed;\n\n\tFVector StartLocation;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMoveSpeed = 100.0f;\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartLocation = GetActorLocation();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (FVector::Dist(StartLocation, TargetLocation) > KINDA_SMALL_NUMBER)\n\t{\n\t\tFVector Direction = (TargetLocation - StartLocation).GetSafeNormal();\n\t\tFVector NewLocation = GetActorLocation() + Direction * MoveSpeed * DeltaTime;\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Implement a UMG widget that acts as a virtual health bar.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UHealthBarWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UHealthBarWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Health\")\n\tvoid SetHealthPercentage(float HealthPercent);\n\nprotected:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UProgressBar* HealthBar;\n};\n```", "cpp_code": "```cpp\n#include \"UHealthBarWidget.h\"\n#include \"Components/ProgressBar.h\"\n\nvoid UHealthBarWidget::SetHealthPercentage(float HealthPercent)\n{\n\tif (HealthBar)\n\t{\n\t\tHealthBar->SetPercent(HealthPercent);\n\t}\n}\n```"}
{"requirement": "Create an Actor that changes its material color periodically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AColorChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAColorChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tFTimerHandle ColorChangeTimerHandle;\n\n\tvoid ChangeColor();\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nAColorChangingActor::AColorChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/StarterContent/Materials/M_Basic_Wall.M_Basic_Wall\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterial = UMaterialInstanceDynamic::Create(MaterialAsset.Object, MeshComponent);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterial);\n\t}\n}\n\nvoid AColorChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGetWorldTimerManager().SetTimer(ColorChangeTimerHandle, this, &AColorChangingActor::ChangeColor, 1.0f, true);\n}\n\nvoid AColorChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AColorChangingActor::ChangeColor()\n{\n\tif (DynamicMaterial)\n\t{\n\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t}\n}\n```"}
{"requirement": "Develop a class that uses a timer to call a function every 5 seconds.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"ATimerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATimerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATimerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\t// Function to be called by the timer\n\tvoid TimerFunction();\n\n\t// Timer handle\n\tFTimerHandle TimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"ATimerActor.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nATimerActor::ATimerActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid ATimerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Set the timer to call TimerFunction every 5 seconds\n\tGetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &ATimerActor::TimerFunction, 5.0f, true);\n}\n\n// Function to be called by the timer\nvoid ATimerActor::TimerFunction()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"TimerFunction called\"));\n}\n```"}
{"requirement": "Implement a UFUNCTION to set a new target location for the Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TargetActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATargetActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATargetActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid SetNewTargetLocation(FVector NewLocation);\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector TargetLocation;\n};\n```", "cpp_code": "```cpp\n#include \"TargetActor.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nATargetActor::ATargetActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ATargetActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATargetActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Logic to move towards the target location can be implemented here\n}\n\nvoid ATargetActor::SetNewTargetLocation(FVector NewLocation)\n{\n\tTargetLocation = NewLocation;\n\t// Additional logic to handle the new target location can be implemented here\n}\n```"}
{"requirement": "Create an Actor with a collision component that spawns particles upon overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Components/BoxComponent.h\"\n#include \"AParticleSpawner.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AParticleSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAParticleSpawner();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Box Collision Component\n\tUPROPERTY(VisibleAnywhere, Category = \"Collision\")\n\tUBoxComponent* CollisionBox;\n\n\t// Particle System to spawn\n\tUPROPERTY(EditAnywhere, Category = \"Effects\")\n\tUParticleSystem* ParticleEffect;\n\n\t// Handle overlap event\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"AParticleSpawner.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAParticleSpawner::AParticleSpawner()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the Box Component\n\tCollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionBox\"));\n\tRootComponent = CollisionBox;\n\n\t// Set up the collision box\n\tCollisionBox->SetCollisionProfileName(TEXT(\"Trigger\"));\n\tCollisionBox->OnComponentBeginOverlap.AddDynamic(this, &AParticleSpawner::OnOverlapBegin);\n\n\t// Initialize the Particle System\n\tParticleEffect = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid AParticleSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AParticleSpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Handle the overlap event\nvoid AParticleSpawner::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (ParticleEffect && OtherActor != this)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ParticleEffect, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Implement a UMG button widget that exits the game when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"MyExitButtonWidget.generated.h\"\n\nUCLASS()\nclass UMyExitButtonWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"UI\")\n\tvoid OnExitButtonClicked();\n};\n```", "cpp_code": "```cpp\n#include \"MyExitButtonWidget.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nvoid UMyExitButtonWidget::OnExitButtonClicked()\n{\n\tUGameplayStatics::GetPlayerController(GetWorld(), 0)->ConsoleCommand(TEXT(\"quit\"));\n}\n```"}
{"requirement": "Create an Actor that plays a sound on each collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundCollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundCollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundCollisionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* CollisionSound;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"SoundCollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASoundCollisionActor::ASoundCollisionActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set up collision\n\tMeshComponent->SetNotifyRigidBodyCollision(true);\n\tMeshComponent->BodyInstance.SetCollisionProfileName(\"BlockAll\");\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ASoundCollisionActor::OnHit);\n\n\t// Find and assign a default mesh, if desired\n\t// static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Mesh.MeshName\"));\n\t// if (MeshAsset.Succeeded()) {\n\t//\t MeshComponent->SetStaticMesh(MeshAsset.Object);\n\t// }\n}\n\n// Called when the game starts or when spawned\nvoid ASoundCollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASoundCollisionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundCollisionActor::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (CollisionSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, CollisionSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Develop a class that logs the Actor's world position every frame.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogPositionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALogPositionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALogPositionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"LogPositionActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\n// Sets default values\nALogPositionActor::ALogPositionActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALogPositionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALogPositionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector ActorLocation = GetActorLocation();\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor's World Position: %s\"), *ActorLocation.ToString());\n}\n```"}
{"requirement": "Implement a simple networking function to replicate a score variable.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReplicatedScoreActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AReplicatedScoreActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAReplicatedScoreActor();\n\nprotected:\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n\nprivate:\n\tUPROPERTY(Replicated, VisibleAnywhere, Category=\"Score\")\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"ReplicatedScoreActor.h\"\n#include \"Net/UnrealNetwork.h\"\n\nAReplicatedScoreActor::AReplicatedScoreActor()\n{\n\t// Enable replication for this actor\n\tbReplicates = true;\n\t\n\t// Initialize score\n\tScore = 0;\n}\n\nvoid AReplicatedScoreActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AReplicatedScoreActor, Score);\n}\n```"}
{"requirement": "Create a class that changes the Actor's appearance based on health levels.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AppearanceChangerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAppearanceChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAAppearanceChangerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Changes appearance based on health\n\tvoid UpdateAppearance();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Health\")\n\tfloat Health;\n\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Health thresholds for appearance change\n\tUPROPERTY(EditAnywhere, Category = \"Appearance\")\n\tTArray<UStaticMesh*> HealthMeshes;\n};\n```", "cpp_code": "```cpp\n#include \"AppearanceChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAAppearanceChangerActor::AAppearanceChangerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Initialize health\n\tHealth = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AAppearanceChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AAppearanceChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tUpdateAppearance();\n}\n\nvoid AAppearanceChangerActor::UpdateAppearance()\n{\n\tif (HealthMeshes.Num() == 0) return;\n\n\tint32 MeshIndex = FMath::Clamp(static_cast<int32>((100.0f - Health) / 100.0f * HealthMeshes.Num()), 0, HealthMeshes.Num() - 1);\n\n\tif (MeshComponent && HealthMeshes[MeshIndex])\n\t{\n\t\tMeshComponent->SetStaticMesh(HealthMeshes[MeshIndex]);\n\t}\n}\n```"}
{"requirement": "Develop an Actor with a timeline to animate its scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"ScaleTimelineActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleTimelineActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScaleTimelineActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid HandleScaleProgress(float Value);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* ScaleCurve;\n\n\tFTimeline ScaleTimeline;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleTimelineActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\nAScaleTimelineActor::AScaleTimelineActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AScaleTimelineActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (ScaleCurve)\n\t{\n\t\tFOnTimelineFloat ProgressFunction;\n\t\tProgressFunction.BindUFunction(this, FName(\"HandleScaleProgress\"));\n\n\t\tScaleTimeline.AddInterpFloat(ScaleCurve, ProgressFunction);\n\t\tScaleTimeline.SetLooping(false);\n\t\tScaleTimeline.PlayFromStart();\n\t}\n}\n\nvoid AScaleTimelineActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tScaleTimeline.TickTimeline(DeltaTime);\n}\n\nvoid AScaleTimelineActor::HandleScaleProgress(float Value)\n{\n\tFVector NewScale = FMath::Lerp(FVector(1.0f, 1.0f, 1.0f), FVector(2.0f, 2.0f, 2.0f), Value);\n\tMeshComponent->SetWorldScale3D(NewScale);\n}\n```"}
{"requirement": "Implement a UFUNCTION to teleport the Actor to a specific location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TeleportingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ATeleportingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATeleportingActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Teleport\")\n\tvoid TeleportToLocation(const FVector& NewLocation);\n};\n```", "cpp_code": "```cpp\n#include \"TeleportingActor.h\"\n\nATeleportingActor::ATeleportingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ATeleportingActor::TeleportToLocation(const FVector& NewLocation)\n{\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an Actor that follows the player within a specific radius.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FollowPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFollowPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFollowPlayerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Follow\")\n\tfloat FollowRadius;\n\n\tUPROPERTY(EditAnywhere, Category=\"Follow\")\n\tfloat MoveSpeed;\n\n\tAActor* PlayerActor;\n\n\tvoid FollowPlayer();\n};\n```", "cpp_code": "```cpp\n#include \"FollowPlayerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAFollowPlayerActor::AFollowPlayerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tFollowRadius = 500.0f;\n\tMoveSpeed = 200.0f;\n\tPlayerActor = nullptr;\n}\n\nvoid AFollowPlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid AFollowPlayerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFollowPlayer();\n}\n\nvoid AFollowPlayerActor::FollowPlayer()\n{\n\tif (!PlayerActor) return;\n\n\tFVector Direction = PlayerActor->GetActorLocation() - GetActorLocation();\n\tfloat DistanceToPlayer = Direction.Size();\n\n\tif (DistanceToPlayer > FollowRadius)\n\t{\n\t\tDirection.Normalize();\n\t\tFVector NewLocation = GetActorLocation() + Direction * MoveSpeed * GetWorld()->GetDeltaSeconds();\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to add a specified amount of health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAHealthActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Health\")\n\tvoid AddHealth(float HealthAmount);\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Health\", meta = (AllowPrivateAccess = \"true\"))\n\tfloat CurrentHealth;\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n\nAHealthActor::AHealthActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentHealth = 100.0f;\n}\n\nvoid AHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHealthActor::AddHealth(float HealthAmount)\n{\n\tCurrentHealth += HealthAmount;\n\t// Clamp current health to a maximum value if required\n\t// CurrentHealth = FMath::Clamp(CurrentHealth, 0.0f, MaxHealth);\n}\n```"}
{"requirement": "Create a UMG widget that shows the player's current ammo.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UAmmoWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UUAmmoWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintImplementableEvent, Category = \"Ammo\")\n\tvoid UpdateAmmoDisplay(int32 CurrentAmmo);\n};\n```", "cpp_code": "```cpp\n#include \"UAmmoWidget.h\"\n\n// The functionality of updating the widget will be handled in Blueprint using the UpdateAmmoDisplay function.\n```"}
{"requirement": "Develop a class that changes the Actor's texture when a signal is received.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TextureChangerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tATextureChangerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid ChangeTexture(UTexture* NewTexture);\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Materials\")\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"TextureChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Texture.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nATextureChangerActor::ATextureChangerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/YourStaticMeshPath.YourStaticMeshPath\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> MaterialAsset(TEXT(\"/Game/YourMaterialPath.YourMaterialPath\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MaterialAsset.Object, MeshComponent);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ATextureChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATextureChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATextureChangerActor::ChangeTexture(UTexture* NewTexture)\n{\n\tif (DynamicMaterialInstance && NewTexture)\n\t{\n\t\tDynamicMaterialInstance->SetTextureParameterValue(FName(\"TextureParameter\"), NewTexture);\n\t}\n}\n```"}
{"requirement": "Implement an Actor that emits a sound cue when health is below a certain level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"HealthSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthSoundActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AHealthSoundActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  UPROPERTY(EditAnywhere, Category=\"Health\")\n  float Health;\n\n  UPROPERTY(EditAnywhere, Category=\"Health\")\n  float HealthThreshold;\n\n  UPROPERTY(EditAnywhere, Category=\"Sound\")\n  USoundCue* SoundCue;\n\n  UPROPERTY(VisibleAnywhere, Category=\"Sound\")\n  UAudioComponent* AudioComponent;\n\n  void CheckHealth();\n};\n```", "cpp_code": "```cpp\n#include \"HealthSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n\nAHealthSoundActor::AHealthSoundActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n\n  Health = 100.0f;\n  HealthThreshold = 50.0f;\n\n  AudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n  AudioComponent->bAutoActivate = false;\n  RootComponent = AudioComponent;\n}\n\nvoid AHealthSoundActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AHealthSoundActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n  CheckHealth();\n}\n\nvoid AHealthSoundActor::CheckHealth()\n{\n  if (Health < HealthThreshold && SoundCue && !AudioComponent->IsPlaying())\n  {\n\tAudioComponent->SetSound(SoundCue);\n\tAudioComponent->Play();\n  }\n}\n```"}
{"requirement": "Create an Actor with a static mesh that changes color on interaction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InteractiveColorChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AInteractiveColorChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAInteractiveColorChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle interaction\n\tUFUNCTION()\n\tvoid OnInteract();\n\n\t// Static Mesh Component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\nprivate:\n\t// Helper function to change color\n\tvoid ChangeColor();\n};\n```", "cpp_code": "```cpp\n#include \"InteractiveColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAInteractiveColorChangeActor::AInteractiveColorChangeActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Static Mesh Component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AInteractiveColorChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AInteractiveColorChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle interaction\nvoid AInteractiveColorChangeActor::OnInteract()\n{\n\tChangeColor();\n}\n\n// Helper function to change color\nvoid AInteractiveColorChangeActor::ChangeColor()\n{\n\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\tif (DynamicMaterial)\n\t{\n\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", NewColor);\n\t}\n}\n```"}
{"requirement": "Develop a class that logs a message when overlapping with a specific object type.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOverlapLogger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLogger.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"Engine/Engine.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAOverlapLogger::AOverlapLogger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapLogger::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid AOverlapLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOverlapLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapLogger::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this))\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Overlapping with: %s\"), *OtherActor->GetName()));\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION to initiate a power-up effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PowerUpActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APowerUpActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPowerUpActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"PowerUp\")\n\tvoid ActivatePowerUp();\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat PowerUpDuration;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"PowerUpActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAPowerUpActor::APowerUpActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set the mesh (assuming you have a StaticMesh'/Game/Path/To/Your/Mesh.Mesh' asset)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/Path/To/Your/Mesh.Mesh'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Initialize power-up duration\n\tPowerUpDuration = 5.0f;\n}\n\n// Called when the game starts or when spawned\nvoid APowerUpActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APowerUpActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APowerUpActor::ActivatePowerUp()\n{\n\t// Logic to activate the power-up effect\n\tUE_LOG(LogTemp, Warning, TEXT(\"Power-up activated for %f seconds!\"), PowerUpDuration);\n\t// Additional effect logic here\n}\n```"}
{"requirement": "Create a simple AI Controller to make an AI character avoid the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"AAvoidPlayerAIController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAvoidPlayerAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAvoidPlayerAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaSeconds) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tfloat AvoidanceRadius = 300.0f;\n};\n```", "cpp_code": "```cpp\n#include \"AAvoidPlayerAIController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAAvoidPlayerAIController::AAvoidPlayerAIController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AAvoidPlayerAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAvoidPlayerAIController::Tick(float DeltaSeconds)\n{\n\tSuper::Tick(DeltaSeconds);\n\n\tAPawn* ControlledPawn = GetPawn();\n\tif (!ControlledPawn) return;\n\n\tAPawn* PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n\tif (!PlayerPawn) return;\n\n\tFVector DistanceToPlayer = ControlledPawn->GetActorLocation() - PlayerPawn->GetActorLocation();\n\tif (DistanceToPlayer.Size() < AvoidanceRadius)\n\t{\n\t\tFVector AwayFromPlayer = DistanceToPlayer.GetSafeNormal();\n\t\tFVector NewLocation = ControlledPawn->GetActorLocation() + AwayFromPlayer * 100.0f * DeltaSeconds;\n\t\tControlledPawn->SetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Develop an Actor that scales based on a given multiplier.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScalableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Scaling\")\n\tfloat ScaleMultiplier;\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid UpdateScale();\n};\n```", "cpp_code": "```cpp\n#include \"ScalableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAScalableActor::AScalableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t\tMeshComponent->SetRelativeScale3D(FVector(1.0f, 1.0f, 1.0f));\n\t}\n\n\tScaleMultiplier = 1.0f;\n}\n\nvoid AScalableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateScale();\n}\n\nvoid AScalableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t// Call UpdateScale if needed\n}\n\nvoid AScalableActor::UpdateScale()\n{\n\tFVector NewScale = FVector(ScaleMultiplier);\n\tMeshComponent->SetWorldScale3D(NewScale);\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to trigger an explosion effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ExplosionEffectActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AExplosionEffectActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAExplosionEffectActor();\n\n\t// BlueprintCallable function to trigger the explosion effect\n\tUFUNCTION(BlueprintCallable, Category=\"Explosion\")\n\tvoid TriggerExplosion();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ExplosionEffectActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAExplosionEffectActor::AExplosionEffectActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Optionally, set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AExplosionEffectActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AExplosionEffectActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// BlueprintCallable function to trigger the explosion effect\nvoid AExplosionEffectActor::TriggerExplosion()\n{\n\t// Implement your explosion logic here\n\tUE_LOG(LogTemp, Warning, TEXT(\"Explosion triggered!\"));\n\t// Example: Spawn particle system, play sound, etc.\n}\n```"}
{"requirement": "Create an Actor with a collision component that triggers a visual effect on contact.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/SphereComponent.h\"\n#include \"VisualEffectTriggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVisualEffectTriggerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAVisualEffectTriggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUSphereComponent* CollisionComponent;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"VisualEffectTriggerActor.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAVisualEffectTriggerActor::AVisualEffectTriggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\tCollisionComponent->InitSphereRadius(100.0f);\n\tCollisionComponent->SetCollisionProfileName(TEXT(\"Trigger\"));\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AVisualEffectTriggerActor::OnOverlapBegin);\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComponent->SetupAttachment(RootComponent);\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AVisualEffectTriggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AVisualEffectTriggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AVisualEffectTriggerActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor != this && OtherComp)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), YourVisualEffect, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Develop a class that resets the game score when the player presses a key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreResetActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AScoreResetActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScoreResetActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to reset the game score\n\tvoid ResetScore();\n\n\t// The score variable\n\tint32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreResetActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAScoreResetActor::AScoreResetActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the score to some default value\n\tScore = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AScoreResetActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScoreResetActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid AScoreResetActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"ResetScore\", IE_Pressed, this, &AScoreResetActor::ResetScore);\n\t}\n}\n\n// Function to reset the game score\nvoid AScoreResetActor::ResetScore()\n{\n\tScore = 0;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Score has been reset.\"));\n}\n```"}
{"requirement": "Implement a UMG widget that acts as a mini-map.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UMiniMapWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UUMiniMapWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUUMiniMapWidget(const FObjectInitializer& ObjectInitializer);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UImage* MiniMapImage;\n};\n```", "cpp_code": "```cpp\n#include \"UMiniMapWidget.h\"\n#include \"Components/Image.h\"\n\nUUMiniMapWidget::UUMiniMapWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UUMiniMapWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\n\t// Ensure MiniMapImage is valid and do any custom initialization here\n\tif (MiniMapImage)\n\t{\n\t\t// Set up the mini-map image here, e.g. setting a texture\n\t}\n}\n```"}
{"requirement": "Create an Actor that can be possessed by the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"PlayerPossessableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APlayerPossessableActor : public APawn\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this pawn's properties\n\tAPlayerPossessableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Static mesh component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Mesh\", meta=(AllowPrivateAccess=\"true\"))\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerPossessableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAPlayerPossessableActor::APlayerPossessableActor()\n{\n\t// Set this pawn to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid APlayerPossessableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APlayerPossessableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid APlayerPossessableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind input actions and axes here\n}\n```"}
{"requirement": "Develop a class that logs the elapsed time since the game started.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ElapsedTimeLogger.generated.h\"\n\nUCLASS()\nclass AElapsedTimeLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAElapsedTimeLogger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tfloat StartTime;\n};\n```", "cpp_code": "```cpp\n#include \"ElapsedTimeLogger.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAElapsedTimeLogger::AElapsedTimeLogger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AElapsedTimeLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tStartTime = GetWorld()->GetTimeSeconds();\n}\n\n// Called every frame\nvoid AElapsedTimeLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat ElapsedTime = GetWorld()->GetTimeSeconds() - StartTime;\n\tUE_LOG(LogTemp, Log, TEXT(\"Elapsed Time: %f seconds\"), ElapsedTime);\n}\n```"}
{"requirement": "Implement a UFUNCTION to toggle the Actor's light component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"ToggleLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleLightActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Light\")\n\tvoid ToggleLight();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUPointLightComponent* PointLightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nAToggleLightActor::AToggleLightActor()\n{\n\t// Create and attach the light component\n\tPointLightComponent = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLightComponent\"));\n\tRootComponent = PointLightComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleLightActor::ToggleLight()\n{\n\tif (PointLightComponent)\n\t{\n\t\tPointLightComponent->ToggleVisibility();\n\t}\n}\n```"}
{"requirement": "Create an Actor that moves along a path defined by waypoints.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WaypointPathActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWaypointPathActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAWaypointPathActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Path\")\n\tTArray<AActor*> Waypoints;\n\n\tint32 CurrentWaypointIndex;\n\n\tUPROPERTY(EditAnywhere, Category=\"Path\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"WaypointPathActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAWaypointPathActor::AWaypointPathActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCurrentWaypointIndex = 0;\n\tMovementSpeed = 100.0f; // Default speed\n}\n\n// Called when the game starts or when spawned\nvoid AWaypointPathActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Ensure there are waypoints defined\n\tif (Waypoints.Num() == 0)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"No waypoints defined for %s\"), *GetName());\n\t}\n}\n\n// Called every frame\nvoid AWaypointPathActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (Waypoints.Num() == 0)\n\t{\n\t\treturn;\n\t}\n\n\tif (CurrentWaypointIndex < Waypoints.Num())\n\t{\n\t\tAActor* CurrentWaypoint = Waypoints[CurrentWaypointIndex];\n\t\tFVector Direction = (CurrentWaypoint->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n\t\tFVector NewLocation = GetActorLocation() + Direction * MovementSpeed * DeltaTime;\n\n\t\tSetActorLocation(NewLocation);\n\n\t\tif (FVector::Dist(GetActorLocation(), CurrentWaypoint->GetActorLocation()) < 10.0f)\n\t\t{\n\t\t\tCurrentWaypointIndex++;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a simple AI Controller to have an AI character flee when damaged.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"AFleeAIController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFleeAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFleeAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnTakeDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy, AActor* DamageCauser);\n\nprivate:\n\tFVector CalculateFleeDirection();\n\tvoid MoveInFleeDirection();\n\n\tFVector FleeDirection;\n\tbool bShouldFlee;\n};\n```", "cpp_code": "```cpp\n#include \"AFleeAIController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"NavigationSystem.h\"\n#include \"AI/Navigation/NavigationPath.h\"\n\nAFleeAIController::AFleeAIController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbShouldFlee = false;\n}\n\nvoid AFleeAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (GetPawn())\n\t{\n\t\tGetPawn()->OnTakeAnyDamage.AddDynamic(this, &AFleeAIController::OnTakeDamage);\n\t}\n}\n\nvoid AFleeAIController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tif (bShouldFlee)\n\t{\n\t\tMoveInFleeDirection();\n\t}\n}\n\nvoid AFleeAIController::OnTakeDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy, AActor* DamageCauser)\n{\n\tFleeDirection = CalculateFleeDirection();\n\tbShouldFlee = true;\n}\n\nFVector AFleeAIController::CalculateFleeDirection()\n{\n\tif (AActor* Pawn = GetPawn())\n\t{\n\t\tFVector FleeDirection = Pawn->GetActorLocation() - UGameplayStatics::GetPlayerPawn(GetWorld(), 0)->GetActorLocation();\n\t\tFleeDirection.Normalize();\n\t\treturn FleeDirection;\n\t}\n\treturn FVector::ZeroVector;\n}\n\nvoid AFleeAIController::MoveInFleeDirection()\n{\n\tif (AActor* Pawn = GetPawn())\n\t{\n\t\tFVector NewLocation = Pawn->GetActorLocation() + FleeDirection * 100.0f; // Move 100 units away\n\t\tUNavigationSystemV1* NavSystem = UNavigationSystemV1::GetCurrent(GetWorld());\n\t\tif (NavSystem)\n\t\t{\n\t\t\tFNavLocation NavLocation;\n\t\t\tif (NavSystem->ProjectPointToNavigation(NewLocation, NavLocation))\n\t\t\t{\n\t\t\t\tMoveToLocation(NavLocation.Location);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a class that changes the Actor's material when health is restored.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"HealthRestoredActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthRestoredActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAHealthRestoredActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Health\")\n\tvoid RestoreHealth(float HealthAmount);\n\nprivate:\n\tvoid ChangeMaterial();\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Materials\")\n\tUMaterialInterface* RestoredMaterial;\n\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat CurrentHealth;\n\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat MaxHealth;\n};\n```", "cpp_code": "```cpp\n#include \"HealthRestoredActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAHealthRestoredActor::AHealthRestoredActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tCurrentHealth = 100.0f;\n\tMaxHealth = 100.0f;\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialAsset(TEXT(\"/Game/Path/To/Material.Material\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tRestoredMaterial = MaterialAsset.Object;\n\t}\n}\n\nvoid AHealthRestoredActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthRestoredActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHealthRestoredActor::RestoreHealth(float HealthAmount)\n{\n\tCurrentHealth = FMath::Clamp(CurrentHealth + HealthAmount, 0.0f, MaxHealth);\n\tif (HealthAmount > 0 && CurrentHealth == MaxHealth)\n\t{\n\t\tChangeMaterial();\n\t}\n}\n\nvoid AHealthRestoredActor::ChangeMaterial()\n{\n\tif (MeshComponent && RestoredMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, RestoredMaterial);\n\t}\n}\n```"}
{"requirement": "Develop an Actor that plays a sound on each tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundTickActor.generated.h\"\n\nUCLASS()\nclass ASoundTickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundTickActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"SoundTickActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundTickActor::ASoundTickActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundTickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASoundTickActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to change the Actor's movement speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeSpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeSpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAChangeSpeedActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MovementSpeed;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid SetMovementSpeed(float NewSpeed);\n};\n```", "cpp_code": "```cpp\n#include \"ChangeSpeedActor.h\"\n\n// Sets default values\nAChangeSpeedActor::AChangeSpeedActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t MovementSpeed = 600.0f; // Default speed value\n}\n\n// Called when the game starts or when spawned\nvoid AChangeSpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AChangeSpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid AChangeSpeedActor::SetMovementSpeed(float NewSpeed)\n{\n\tMovementSpeed = NewSpeed;\n}\n```"}
{"requirement": "Create an Actor with a timeline to animate its material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"MaterialTimelineActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialTimelineActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialTimelineActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* Mesh;\n\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tFTimeline MaterialTimeline;\n\n\tUFUNCTION()\n\tvoid HandleTimelineProgress(float Value);\n\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* CurveFloat;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialTimelineActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nAMaterialTimelineActor::AMaterialTimelineActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh\"));\n\tRootComponent = Mesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMesh->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AMaterialTimelineActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Mesh->GetMaterial(0))\n\t{\n\t\tDynamicMaterial = UMaterialInstanceDynamic::Create(Mesh->GetMaterial(0), this);\n\t\tMesh->SetMaterial(0, DynamicMaterial);\n\t}\n\n\tif (CurveFloat)\n\t{\n\t\tFOnTimelineFloat ProgressFunction;\n\t\tProgressFunction.BindUFunction(this, FName(\"HandleTimelineProgress\"));\n\t\tMaterialTimeline.AddInterpFloat(CurveFloat, ProgressFunction);\n\t\tMaterialTimeline.SetLooping(true);\n\t\tMaterialTimeline.PlayFromStart();\n\t}\n}\n\nvoid AMaterialTimelineActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tMaterialTimeline.TickTimeline(DeltaTime);\n}\n\nvoid AMaterialTimelineActor::HandleTimelineProgress(float Value)\n{\n\tif (DynamicMaterial)\n\t{\n\t\tDynamicMaterial->SetScalarParameterValue(FName(\"YourParameter\"), Value);\n\t}\n}\n```"}
{"requirement": "Develop a class that destroys the Actor when its health reaches zero.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthDestroyActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthDestroyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHealthDestroyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnHealthChanged();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat Health;\n\n\tvoid CheckHealth();\n};\n```", "cpp_code": "```cpp\n#include \"HealthDestroyActor.h\"\n\n// Sets default values\nAHealthDestroyActor::AHealthDestroyActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tHealth = 100.f; // Initial health value\n}\n\n// Called when the game starts or when spawned\nvoid AHealthDestroyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AHealthDestroyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tCheckHealth();\n}\n\nvoid AHealthDestroyActor::OnHealthChanged()\n{\n\tif (Health <= 0)\n\t{\n\t\tDestroy();\n\t}\n}\n\nvoid AHealthDestroyActor::CheckHealth()\n{\n\tOnHealthChanged();\n}\n```"}
{"requirement": "Implement a UMG button widget that submits the player's name.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UPlayerNameSubmitWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UPlayerNameSubmitWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPlayerNameSubmitWidget(const FObjectInitializer& ObjectInitializer);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnSubmitButtonClicked();\n\n\tUPROPERTY(meta = (BindWidget))\n\tclass UButton* SubmitButton;\n\n\tUPROPERTY(meta = (BindWidget))\n\tclass UEditableTextBox* NameTextBox;\n};\n```", "cpp_code": "```cpp\n#include \"UPlayerNameSubmitWidget.h\"\n#include \"Components/Button.h\"\n#include \"Components/EditableTextBox.h\"\n\nUPlayerNameSubmitWidget::UPlayerNameSubmitWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UPlayerNameSubmitWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\n\tif (SubmitButton)\n\t{\n\t\tSubmitButton->OnClicked.AddDynamic(this, &UPlayerNameSubmitWidget::OnSubmitButtonClicked);\n\t}\n}\n\nvoid UPlayerNameSubmitWidget::OnSubmitButtonClicked()\n{\n\tif (NameTextBox)\n\t{\n\t\tFString PlayerName = NameTextBox->GetText().ToString();\n\t\t// Handle the submission of the player's name\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Player Name Submitted: %s\"), *PlayerName);\n\t}\n}\n```"}
{"requirement": "Create an Actor that rotates based on mouse movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseControlledRotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMouseControlledRotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMouseControlledRotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input components\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Handle Mouse Input\n\tvoid HandleMouseInput(float AxisValue);\n\n\t// Rotation speed\n\tUPROPERTY(EditAnywhere, Category = \"Rotation\")\n\tfloat RotationSpeed;\n\n\t// Static Mesh\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMesh;\n};\n```", "cpp_code": "```cpp\n#include \"MouseControlledRotatingActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAMouseControlledRotatingActor::AMouseControlledRotatingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize rotation speed\n\tRotationSpeed = 100.0f;\n\n\t// Create Static Mesh Component\n\tStaticMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMesh\"));\n\tRootComponent = StaticMesh;\n\n\t// Optionally set a default mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMesh->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMouseControlledRotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMouseControlledRotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input components\nvoid AMouseControlledRotatingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"Turn\", this, &AMouseControlledRotatingActor::HandleMouseInput);\n}\n\n// Handle Mouse Input\nvoid AMouseControlledRotatingActor::HandleMouseInput(float AxisValue)\n{\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += AxisValue * RotationSpeed * GetWorld()->GetDeltaSeconds();\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a simple networking function to replicate an Actor's animation state.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AnimationReplicationActor.generated.h\"\n\nUCLASS()\nclass AAnimationReplicationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAnimationReplicationActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Animation\")\n\tvoid SetAnimationState(float NewState);\n\n\tUFUNCTION(Server, Reliable, WithValidation)\n\tvoid ServerSetAnimationState(float NewState);\n\n\tUPROPERTY(ReplicatedUsing=OnRep_AnimationState, VisibleAnywhere, BlueprintReadOnly, Category=\"Animation\")\n\tfloat AnimationState;\n\n\tUFUNCTION()\n\tvoid OnRep_AnimationState();\n\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n};\n```", "cpp_code": "```cpp\n#include \"AnimationReplicationActor.h\"\n#include \"Net/UnrealNetwork.h\"\n\nAAnimationReplicationActor::AAnimationReplicationActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbReplicates = true;\n}\n\nvoid AAnimationReplicationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAnimationReplicationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AAnimationReplicationActor::SetAnimationState(float NewState)\n{\n\tif (HasAuthority())\n\t{\n\t\tAnimationState = NewState;\n\t\tOnRep_AnimationState();\n\t}\n\telse\n\t{\n\t\tServerSetAnimationState(NewState);\n\t}\n}\n\nvoid AAnimationReplicationActor::ServerSetAnimationState_Implementation(float NewState)\n{\n\tSetAnimationState(NewState);\n}\n\nbool AAnimationReplicationActor::ServerSetAnimationState_Validate(float NewState)\n{\n\treturn true;\n}\n\nvoid AAnimationReplicationActor::OnRep_AnimationState()\n{\n\t// Handle animation state change on clients\n}\n\nvoid AAnimationReplicationActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AAnimationReplicationActor, AnimationState);\n}\n```"}
{"requirement": "Create a class that scales the Actor randomly when initialized.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomScaleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tARandomScaleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tvoid RandomizeScale();\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector MinScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector MaxScale;\n};\n```", "cpp_code": "```cpp\n#include \"RandomScaleActor.h\"\n#include \"Math/UnrealMathUtility.h\"\n\n// Sets default values\nARandomScaleActor::ARandomScaleActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// Initialize default scale range\n\tMinScale = FVector(0.5f, 0.5f, 0.5f);\n\tMaxScale = FVector(2.0f, 2.0f, 2.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ARandomScaleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tRandomizeScale();\n}\n\nvoid ARandomScaleActor::RandomizeScale()\n{\n\tfloat RandomX = FMath::FRandRange(MinScale.X, MaxScale.X);\n\tfloat RandomY = FMath::FRandRange(MinScale.Y, MaxScale.Y);\n\tfloat RandomZ = FMath::FRandRange(MinScale.Z, MaxScale.Z);\n\tFVector NewScale = FVector(RandomX, RandomY, RandomZ);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Develop an Actor with a collision component to detect specific overlapping objects.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Collision component\n\tUPROPERTY(VisibleAnywhere, Category = \"Collision\")\n\tUBoxComponent* CollisionComponent;\n\n\t// Function to handle overlap\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\n\t\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nACollisionActor::ACollisionActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set up the collision component\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\t// Set up overlap event\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle overlap events\nvoid ACollisionActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\n\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\t// Print message to log or any specific logic for overlapping objects\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Overlapping with %s\"), *OtherActor->GetName()));\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION to trigger a custom event and log to the console.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomEventActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomEventActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACustomEventActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"CustomEvent\")\n\tvoid TriggerCustomEvent();\n};\n```", "cpp_code": "```cpp\n#include \"CustomEventActor.h\"\n#include \"Engine/Engine.h\"\n\nACustomEventActor::ACustomEventActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ACustomEventActor::TriggerCustomEvent()\n{\n\tif (GEngine)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Custom event has been triggered!\"));\n\t}\n}\n```"}
{"requirement": "Create an Actor that moves in a wave-like pattern using a timeline.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"WaveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWaveActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWaveActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* FloatCurve;\n\n\tFTimeline WaveTimeline;\n\n\tUFUNCTION()\n\tvoid HandleProgress(float Value);\n\n\tFVector InitialLocation;\n};\n```", "cpp_code": "```cpp\n#include \"WaveActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\nAWaveActor::AWaveActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AWaveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tInitialLocation = GetActorLocation();\n\n\tif (FloatCurve)\n\t{\n\t\tFOnTimelineFloat ProgressFunction;\n\t\tProgressFunction.BindUFunction(this, FName(\"HandleProgress\"));\n\t\tWaveTimeline.AddInterpFloat(FloatCurve, ProgressFunction);\n\t\tWaveTimeline.SetLooping(true);\n\t\tWaveTimeline.PlayFromStart();\n\t}\n}\n\nvoid AWaveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tWaveTimeline.TickTimeline(DeltaTime);\n}\n\nvoid AWaveActor::HandleProgress(float Value)\n{\n\tFVector NewLocation = InitialLocation;\n\tNewLocation.Z += Value;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to pause and resume the Actor's animation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"Animation/AnimMontage.h\"\n#include \"MyAnimatedActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyAnimatedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyAnimatedActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Animation\")\n\tvoid PauseAnimation();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Animation\")\n\tvoid ResumeAnimation();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Animation\")\n\tUAnimMontage* AnimationMontage;\n\n\tUAnimInstance* AnimInstance;\n};\n```", "cpp_code": "```cpp\n#include \"MyAnimatedActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nAMyAnimatedActor::AMyAnimatedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AMyAnimatedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAnimInstance = MeshComponent->GetAnimInstance();\n}\n\nvoid AMyAnimatedActor::PauseAnimation()\n{\n\tif (AnimInstance && AnimationMontage)\n\t{\n\t\tAnimInstance->Montage_Pause(AnimationMontage);\n\t}\n}\n\nvoid AMyAnimatedActor::ResumeAnimation()\n{\n\tif (AnimInstance && AnimationMontage)\n\t{\n\t\tAnimInstance->Montage_Resume(AnimationMontage);\n\t}\n}\n```"}
{"requirement": "Create a UMG widget that shows the player's current level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"ULevelWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ULevelWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Level\")\n\tvoid UpdateLevel(int32 NewLevel);\n\nprotected:\n\tUPROPERTY(BlueprintReadOnly, meta = (BindWidget))\n\tclass UTextBlock* LevelText;\n};\n```", "cpp_code": "```cpp\n#include \"ULevelWidget.h\"\n#include \"Components/TextBlock.h\"\n\nvoid ULevelWidget::UpdateLevel(int32 NewLevel)\n{\n\tif (LevelText)\n\t{\n\t\tLevelText->SetText(FText::FromString(FString::Printf(TEXT(\"Level: %d\"), NewLevel)));\n\t}\n}\n```"}
{"requirement": "Develop a class that changes the Actor's color based on a random choice.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARandomColorActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Function to change the color randomly\n\tvoid ChangeColorRandomly();\n\n\t// Mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"RandomColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nARandomColorActor::ARandomColorActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set the static mesh (assuming the mesh is called 'YourMeshName' in the game's content folder)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/YourMeshPath/YourMeshName.YourMeshName'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ARandomColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tChangeColorRandomly();\n}\n\n// Called every frame\nvoid ARandomColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARandomColorActor::ChangeColorRandomly()\n{\n\tFLinearColor RandomColor = FLinearColor::MakeRandomColor();\n\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"BaseColor\"), RandomColor);\n}\n```"}
{"requirement": "Implement an Actor that spawns a light source when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpawnLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpawnLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpawnLightActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid SpawnLight();\n\n\tUPROPERTY(EditAnywhere)\n\tTSubclassOf<class APointLight> LightClass;\n};\n```", "cpp_code": "```cpp\n#include \"SpawnLightActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/PointLight.h\"\n\nASpawnLightActor::ASpawnLightActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASpawnLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpawnLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpawnLightActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"SpawnLight\", IE_Pressed, this, &ASpawnLightActor::SpawnLight);\n}\n\nvoid ASpawnLightActor::SpawnLight()\n{\n\tif (LightClass)\n\t{\n\t\tFVector Location = GetActorLocation();\n\t\tFRotator Rotation = GetActorRotation();\n\t\tGetWorld()->SpawnActor<APointLight>(LightClass, Location, Rotation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh that toggles visibility on interaction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleVisibilityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Mesh component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\t// Function to toggle visibility\n\tvoid ToggleVisibility();\n\n\t// Input setup\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach static mesh component\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Set a default static mesh (Assumes there's a mesh at the specified path)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMeshName\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Ensure the actor is interactable\n\tEnableInput(GetWorld()->GetFirstPlayerController());\n}\n\n// Called every frame\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to toggle visibility\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tbool bIsVisible = StaticMeshComponent->IsVisible();\n\tStaticMeshComponent->SetVisibility(!bIsVisible);\n}\n\n// Setup player input\nvoid AToggleVisibilityActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleVisibilityActor::ToggleVisibility);\n}\n```"}
{"requirement": "Develop a class that logs the Actor's local rotation every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotationLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotationLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotationLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFTimerHandle LoggerTimerHandle;\n\n\tUFUNCTION()\n\tvoid LogRotation();\n};\n```", "cpp_code": "```cpp\n#include \"RotationLoggerActor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n#include \"GameFramework/Actor.h\"\n\nARotationLoggerActor::ARotationLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARotationLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorld()->GetTimerManager().SetTimer(LoggerTimerHandle, this, &ARotationLoggerActor::LogRotation, 1.0f, true);\n}\n\nvoid ARotationLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARotationLoggerActor::LogRotation()\n{\n\tFRotator LocalRotation = GetActorRotation();\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor Local Rotation: Pitch=%f, Yaw=%f, Roll=%f\"), LocalRotation.Pitch, LocalRotation.Yaw, LocalRotation.Roll);\n}\n```"}
{"requirement": "Implement a UFUNCTION to set the Actor's material to an emissive one.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EmissiveMaterialActor.generated.h\"\n\nUCLASS()\nclass AEmissiveMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAEmissiveMaterialActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Material\")\n\tvoid SetEmissiveMaterial(UMaterialInterface* EmissiveMaterial);\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"EmissiveMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAEmissiveMaterialActor::AEmissiveMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AEmissiveMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AEmissiveMaterialActor::SetEmissiveMaterial(UMaterialInterface* EmissiveMaterial)\n{\n\tif (MeshComponent && EmissiveMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, EmissiveMaterial);\n\t}\n}\n```"}
{"requirement": "Create a simple AI Controller to have an AI character idle and then chase the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"AChaseAIController.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AChaseAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAChaseAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ChasePlayer();\n\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tfloat AcceptanceRadius = 100.0f;\n};\n```", "cpp_code": "```cpp\n#include \"AChaseAIController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/Character.h\"\n\nAChaseAIController::AChaseAIController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AChaseAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChaseAIController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tChasePlayer();\n}\n\nvoid AChaseAIController::ChasePlayer()\n{\n\tAPawn* PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n\tif (PlayerPawn)\n\t{\n\t\tMoveToActor(PlayerPawn, AcceptanceRadius);\n\t}\n}\n```"}
{"requirement": "Develop an Actor that enlarges when overlapping with another Actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EnlargeOnOverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AEnlargeOnOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAEnlargeOnOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"EnlargeOnOverlapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nAEnlargeOnOverlapActor::AEnlargeOnOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AEnlargeOnOverlapActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AEnlargeOnOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AEnlargeOnOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AEnlargeOnOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tFVector NewScale = GetActorScale3D();\n\t\tNewScale *= 1.2f; // Increase scale by 20%\n\t\tSetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to change the player's camera view.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PlayerCameraController.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APlayerCameraController : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPlayerCameraController();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Camera\")\n\tvoid ChangeCameraView(AActor* NewViewTarget);\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerCameraController.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAPlayerCameraController::APlayerCameraController()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid APlayerCameraController::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APlayerCameraController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APlayerCameraController::ChangeCameraView(AActor* NewViewTarget)\n{\n\tif (APlayerController* PlayerController = UGameplayStatics::GetPlayerController(this, 0))\n\t{\n\t\tif (NewViewTarget)\n\t\t{\n\t\t\tPlayerController->SetViewTargetWithBlend(NewViewTarget);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a timeline that animates its color from blue to red.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"ColorTimelineActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorTimelineActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorTimelineActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUTimelineComponent* ColorTimeline;\n\n\tFOnTimelineFloat UpdateTimelineFloat;\n\n\tUFUNCTION()\n\tvoid HandleTimelineProgress(float Value);\n\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* ColorCurve;\n};\n```", "cpp_code": "```cpp\n#include \"ColorTimelineActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAColorTimelineActor::AColorTimelineActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tColorTimeline = CreateDefaultSubobject<UTimelineComponent>(TEXT(\"ColorTimeline\"));\n}\n\n// Called when the game starts or when spawned\nvoid AColorTimelineActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (ColorCurve)\n\t{\n\t\tUpdateTimelineFloat.BindUFunction(this, FName(\"HandleTimelineProgress\"));\n\t\tColorTimeline->AddInterpFloat(ColorCurve, UpdateTimelineFloat);\n\t\tColorTimeline->SetLooping(false);\n\t\tColorTimeline->PlayFromStart();\n\t}\n}\n\n// Called every frame\nvoid AColorTimelineActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AColorTimelineActor::HandleTimelineProgress(float Value)\n{\n\tFLinearColor NewColor = FLinearColor::LerpUsingHSV(FLinearColor::Blue, FLinearColor::Red, Value);\n\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"BaseColor\"), NewColor);\n}\n```"}
{"requirement": "Develop a class that triggers an alarm sound when the player enters a restricted area.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/BoxComponent.h\"\n#include \"RestrictedAreaAlarm.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ARestrictedAreaAlarm : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARestrictedAreaAlarm();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUBoxComponent* RestrictedArea;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* AlarmSoundCue;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"RestrictedAreaAlarm.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nARestrictedAreaAlarm::ARestrictedAreaAlarm()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRestrictedArea = CreateDefaultSubobject<UBoxComponent>(TEXT(\"RestrictedArea\"));\n\tRootComponent = RestrictedArea;\n\n\tRestrictedArea->OnComponentBeginOverlap.AddDynamic(this, &ARestrictedAreaAlarm::OnOverlapBegin);\n}\n\nvoid ARestrictedAreaAlarm::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARestrictedAreaAlarm::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARestrictedAreaAlarm::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tif (AlarmSoundCue)\n\t\t{\n\t\t\tUGameplayStatics::PlaySoundAtLocation(this, AlarmSoundCue, GetActorLocation());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a UMG widget that displays the current game time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"GameTimeWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UGameTimeWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUGameTimeWidget(const FObjectInitializer& ObjectInitializer);\n\n\tvirtual void NativeTick(const FGeometry& MyGeometry, float InDeltaTime) override;\n\nprotected:\n\tUPROPERTY(BlueprintReadOnly, meta = (BindWidget))\n\tclass UTextBlock* GameTimeText;\n};\n```", "cpp_code": "```cpp\n#include \"GameTimeWidget.h\"\n#include \"Components/TextBlock.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUGameTimeWidget::UGameTimeWidget(const FObjectInitializer& ObjectInitializer)\n\t: Super(ObjectInitializer)\n{\n}\n\nvoid UGameTimeWidget::NativeTick(const FGeometry& MyGeometry, float InDeltaTime)\n{\n\tSuper::NativeTick(MyGeometry, InDeltaTime);\n\n\tif (GameTimeText)\n\t{\n\t\tfloat CurrentTime = UGameplayStatics::GetTimeSeconds(GetWorld());\n\t\tFText TimeText = FText::AsNumber(CurrentTime);\n\t\tGameTimeText->SetText(TimeText);\n\t}\n}\n```"}
{"requirement": "Create an Actor that moves to a random location when interacted with.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomMover : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  ARandomMover();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  // Interaction function\n  UFUNCTION()\n  void MoveToRandomLocation();\n\nprivate:\n  UPROPERTY(EditAnywhere)\n  UStaticMeshComponent* MeshComponent;\n\n  UFUNCTION()\n  void OnInteract();\n};\n```", "cpp_code": "```cpp\n#include \"RandomMover.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\n// Sets default values\nARandomMover::ARandomMover()\n{\n  // Set this actor to call Tick() every frame.\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Create mesh component\n  MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n  RootComponent = MeshComponent;\n\n  // Bind interaction function\n  OnActorClicked.AddDynamic(this, &ARandomMover::OnInteract);\n}\n\n// Called when the game starts or when spawned\nvoid ARandomMover::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid ARandomMover::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid ARandomMover::OnInteract()\n{\n  MoveToRandomLocation();\n}\n\nvoid ARandomMover::MoveToRandomLocation()\n{\n  if (GetWorld())\n  {\n\tFVector NewLocation = UKismetMathLibrary::RandomPointInBoundingBox(FVector(0.0f, 0.0f, 0.0f), FVector(1000.0f, 1000.0f, 1000.0f));\n\tSetActorLocation(NewLocation);\n  }\n}\n```"}
{"requirement": "Implement a simple networking function to replicate an Actor's material change.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"MyNetworkedActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyNetworkedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyNetworkedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Material\")\n\tvoid ChangeMaterial(UMaterialInterface* NewMaterial);\n\n\tUFUNCTION(Server, Reliable, WithValidation)\n\tvoid ServerChangeMaterial(UMaterialInterface* NewMaterial);\n\nprivate:\n\tUPROPERTY(ReplicatedUsing = OnRep_Material)\n\tUMaterialInterface* CurrentMaterial;\n\n\tUFUNCTION()\n\tvoid OnRep_Material();\n\n\tvoid GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n};\n```", "cpp_code": "```cpp\n#include \"MyNetworkedActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Net/UnrealNetwork.h\"\n\nAMyNetworkedActor::AMyNetworkedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tbReplicates = true;\n}\n\nvoid AMyNetworkedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyNetworkedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyNetworkedActor::ChangeMaterial(UMaterialInterface* NewMaterial)\n{\n\tif (HasAuthority())\n\t{\n\t\tCurrentMaterial = NewMaterial;\n\t\tOnRep_Material();\n\t}\n\telse\n\t{\n\t\tServerChangeMaterial(NewMaterial);\n\t}\n}\n\nvoid AMyNetworkedActor::ServerChangeMaterial_Implementation(UMaterialInterface* NewMaterial)\n{\n\tChangeMaterial(NewMaterial);\n}\n\nbool AMyNetworkedActor::ServerChangeMaterial_Validate(UMaterialInterface* NewMaterial)\n{\n\treturn true;\n}\n\nvoid AMyNetworkedActor::OnRep_Material()\n{\n\tif (MeshComponent)\n\t{\n\t\tMeshComponent->SetMaterial(0, CurrentMaterial);\n\t}\n}\n\nvoid AMyNetworkedActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AMyNetworkedActor, CurrentMaterial);\n}\n```"}
{"requirement": "Create a class that plays a sound when the player's score reaches a multiple of ten.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"ScoreSoundActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AScoreSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAScoreSoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnScoreChanged(int32 NewScore);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* ScoreSoundCue;\n\n\tUFUNCTION()\n\tvoid PlayScoreSound();\n};\n```", "cpp_code": "```cpp\n#include \"ScoreSoundActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAScoreSoundActor::AScoreSoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AScoreSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScoreSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScoreSoundActor::OnScoreChanged(int32 NewScore)\n{\n\tif (NewScore % 10 == 0 && NewScore != 0)\n\t{\n\t\tPlayScoreSound();\n\t}\n}\n\nvoid AScoreSoundActor::PlayScoreSound()\n{\n\tif (ScoreSoundCue)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, ScoreSoundCue, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Develop an Actor that changes its color based on its altitude.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AltitudeColorChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAltitudeColorChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAAltitudeColorChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tfloat AltitudeThreshold;\n\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tFLinearColor LowAltitudeColor;\n\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tFLinearColor HighAltitudeColor;\n\n\tvoid UpdateColor();\n};\n```", "cpp_code": "```cpp\n#include \"AltitudeColorChanger.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAAltitudeColorChanger::AAltitudeColorChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tAltitudeThreshold = 300.0f;\n\tLowAltitudeColor = FLinearColor::Red;\n\tHighAltitudeColor = FLinearColor::Blue;\n}\n\nvoid AAltitudeColorChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AAltitudeColorChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateColor();\n}\n\nvoid AAltitudeColorChanger::UpdateColor()\n{\n\tfloat Altitude = GetActorLocation().Z;\n\tFLinearColor NewColor = Altitude > AltitudeThreshold ? HighAltitudeColor : LowAltitudeColor;\n\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"Color\"), NewColor);\n}\n```"}
{"requirement": "Implement a UFUNCTION to toggle the Actor's collision settings.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleCollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleCollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAToggleCollisionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Collision\")\n\tvoid ToggleCollision();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleCollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAToggleCollisionActor::AToggleCollisionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AToggleCollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleCollisionActor::ToggleCollision()\n{\n\tif (MeshComponent->GetCollisionEnabled() == ECollisionEnabled::NoCollision)\n\t{\n\t\tMeshComponent->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t}\n}\n```"}
{"requirement": "Create an Actor that follows a path defined by a spline component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SplineComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"PathFollowingActor.generated.h\"\n\nUCLASS()\nclass APathFollowingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPathFollowingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUSplineComponent* SplineComponent;\n\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Path\")\n\tfloat MovementSpeed;\n\n\tfloat CurrentSplineDistance;\n};\n```", "cpp_code": "```cpp\n#include \"PathFollowingActor.h\"\n#include \"Components/SplineComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAPathFollowingActor::APathFollowingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSplineComponent = CreateDefaultSubobject<USplineComponent>(TEXT(\"SplineComponent\"));\n\tRootComponent = SplineComponent;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComponent->SetupAttachment(SplineComponent);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMovementSpeed = 100.0f;\n\tCurrentSplineDistance = 0.0f;\n}\n\nvoid APathFollowingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APathFollowingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (SplineComponent)\n\t{\n\t\tCurrentSplineDistance += MovementSpeed * DeltaTime;\n\t\tfloat SplineLength = SplineComponent->GetSplineLength();\n\t\tif (CurrentSplineDistance > SplineLength)\n\t\t{\n\t\t\tCurrentSplineDistance = 0.0f;\n\t\t}\n\n\t\tFVector NewLocation = SplineComponent->GetLocationAtDistanceAlongSpline(CurrentSplineDistance, ESplineCoordinateSpace::World);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to spawn multiple Actors in a grid formation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GridSpawner.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AGridSpawner : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAGridSpawner();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Spawning\")\n\tvoid SpawnActorsInGrid(TSubclassOf<AActor> ActorToSpawn, int32 Rows, int32 Columns, float Spacing);\n\nprotected:\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"GridSpawner.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nAGridSpawner::AGridSpawner()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AGridSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AGridSpawner::SpawnActorsInGrid(TSubclassOf<AActor> ActorToSpawn, int32 Rows, int32 Columns, float Spacing)\n{\n\tif (!ActorToSpawn)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"ActorToSpawn is null.\"));\n\t\treturn;\n\t}\n\n\tUWorld* World = GetWorld();\n\tif (!World)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"World is null.\"));\n\t\treturn;\n\t}\n\n\tfor (int32 Row = 0; Row < Rows; ++Row)\n\t{\n\t\tfor (int32 Column = 0; Column < Columns; ++Column)\n\t\t{\n\t\t\tFVector SpawnLocation = GetActorLocation() + FVector(Row * Spacing, Column * Spacing, 0.0f);\n\t\t\tFRotator SpawnRotation = FRotator::ZeroRotator;\n\t\t\tWorld->SpawnActor<AActor>(ActorToSpawn, SpawnLocation, SpawnRotation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a UMG widget that shows a message when the player collects a power-up.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UPlayerPowerUpWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UPlayerPowerUpWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"PowerUp\")\n\tvoid ShowPowerUpMessage();\n};\n```", "cpp_code": "```cpp\n#include \"UPlayerPowerUpWidget.h\"\n\nvoid UPlayerPowerUpWidget::ShowPowerUpMessage()\n{\n\t// This function would be implemented in Blueprint to show the message on screen\n}\n```"}
{"requirement": "Develop a class that triggers an event when the Actor is clicked on.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ClickableActor.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnActorClickedEvent);\n\nUCLASS()\nclass YOURPROJECT_API AClickableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAClickableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(BlueprintAssignable, Category = \"Interaction\")\n\tFOnActorClickedEvent OnActorClicked;\n\n\tUFUNCTION()\n\tvoid ActorClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed);\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ClickableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nAClickableActor::AClickableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->OnClicked.AddDynamic(this, &AClickableActor::ActorClicked);\n\n\t// Example mesh setup (replace with an actual asset path in your project)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AClickableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AClickableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AClickableActor::ActorClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed)\n{\n\tOnActorClicked.Broadcast();\n}\n```"}
{"requirement": "Implement an Actor that uses a timeline to animate its rotation smoothly.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY()\n\tUTimelineComponent* RotationTimeline;\n\n\tUFUNCTION()\n\tvoid HandleRotationProgress(float Value);\n\n\tUPROPERTY(EditAnywhere, Category=\"Timeline\")\n\tUCurveFloat* RotationCurve;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRotationTimeline = CreateDefaultSubobject<UTimelineComponent>(TEXT(\"RotationTimeline\"));\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (RotationCurve)\n\t{\n\t\tFOnTimelineFloat ProgressFunction;\n\t\tProgressFunction.BindUFunction(this, FName(\"HandleRotationProgress\"));\n\t\tRotationTimeline->AddInterpFloat(RotationCurve, ProgressFunction);\n\t\tRotationTimeline->SetLooping(false);\n\t\tRotationTimeline->PlayFromStart();\n\t}\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRotationTimeline->TickComponent(DeltaTime, ELevelTick::LEVELTICK_TimeOnly, nullptr);\n}\n\nvoid ARotatingActor::HandleRotationProgress(float Value)\n{\n\tFRotator NewRotation = FRotator(0.0f, Value, 0.0f);\n\tMeshComponent->SetRelativeRotation(NewRotation);\n}\n```"}
{"requirement": "Create a simple AI Controller to make an AI character patrol a set route.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"APatrolAIController.generated.h\"\n\nUCLASS()\nclass MYGAME_API APatrolAIController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPatrolAIController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n\tvirtual void OnPossess(APawn* InPawn) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tTArray<AActor*> PatrolPoints;\n\n\tUFUNCTION()\n\tvoid MoveToNextPatrolPoint();\n\n\tint32 CurrentPatrolPointIndex;\n};\n```", "cpp_code": "```cpp\n#include \"APatrolAIController.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"BehaviorTree/BlackboardComponent.h\"\n#include \"GameFramework/Character.h\"\n\nAPatrolAIController::APatrolAIController()\n{\n\tCurrentPatrolPointIndex = 0;\n}\n\nvoid APatrolAIController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAPawn* ControlledPawn = GetPawn();\n\tif (ControlledPawn)\n\t{\n\t\tMoveToNextPatrolPoint();\n\t}\n}\n\nvoid APatrolAIController::OnPossess(APawn* InPawn)\n{\n\tSuper::OnPossess(InPawn);\n\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), AActor::StaticClass(), PatrolPoints);\n\tMoveToNextPatrolPoint();\n}\n\nvoid APatrolAIController::MoveToNextPatrolPoint()\n{\n\tif (PatrolPoints.Num() == 0) return;\n\n\tMoveToActor(PatrolPoints[CurrentPatrolPointIndex]);\n\n\tCurrentPatrolPointIndex = (CurrentPatrolPointIndex + 1) % PatrolPoints.Num();\n}\n```"}
{"requirement": "Develop a class that logs when the Actor's health is modified.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthLoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AHealthLoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHealthLoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Health\")\n\tfloat Health;\n\n\tUFUNCTION()\n\tvoid SetHealth(float NewHealth);\n};\n```", "cpp_code": "```cpp\n#include \"HealthLoggingActor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAHealthLoggingActor::AHealthLoggingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tHealth = 100.0f; // Default health value\n}\n\n// Called when the game starts or when spawned\nvoid AHealthLoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AHealthLoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHealthLoggingActor::SetHealth(float NewHealth)\n{\n\tif (Health != NewHealth)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Health changed from %f to %f\"), Health, NewHealth);\n\t\tHealth = NewHealth;\n\t}\n}\n```"}
{"requirement": "Implement a UFUNCTION to play a random animation montage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimMontage.h\"\n#include \"RandomAnimMontageActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomAnimMontageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARandomAnimMontageActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Animation\")\n\tvoid PlayRandomAnimMontage();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tTArray<UAnimMontage*> AnimMontages;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"RandomAnimMontageActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Animation/AnimInstance.h\"\n\nARandomAnimMontageActor::ARandomAnimMontageActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ARandomAnimMontageActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARandomAnimMontageActor::PlayRandomAnimMontage()\n{\n\tif (AnimMontages.Num() > 0)\n\t{\n\t\tint32 RandomIndex = FMath::RandRange(0, AnimMontages.Num() - 1);\n\t\tUAnimInstance* AnimInstance = MeshComponent->GetAnimInstance();\n\t\tif (AnimInstance && AnimMontages[RandomIndex])\n\t\t{\n\t\t\tAnimInstance->Montage_Play(AnimMontages[RandomIndex]);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an Actor with a collision component to apply damage to the player on impact.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DamageActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADamageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADamageActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUSphereComponent* CollisionComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(EditAnywhere)\n\tfloat DamageAmount;\n};\n```", "cpp_code": "```cpp\n#include \"DamageActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/SphereComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/DamageType.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nADamageActor::ADamageActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tCollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"CollisionComponent\"));\n\tCollisionComponent->SetupAttachment(RootComponent);\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ADamageActor::OnOverlapBegin);\n\n\tDamageAmount = 10.0f;  // Default damage amount\n}\n\n// Called when the game starts or when spawned\nvoid ADamageActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADamageActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADamageActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != this))\n\t{\n\t\tUGameplayStatics::ApplyDamage(OtherActor, DamageAmount, nullptr, this, UDamageType::StaticClass());\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to lock and unlock the player's movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"PlayerMovementController.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API APlayerMovementController : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPlayerMovementController();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid LockMovement();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Movement\")\n\tvoid UnlockMovement();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tbool bIsMovementLocked;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerMovementController.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n\nAPlayerMovementController::APlayerMovementController()\n{\n\t// Set default values\n\tbIsMovementLocked = false;\n}\n\nvoid APlayerMovementController::LockMovement()\n{\n\tbIsMovementLocked = true;\n\tif (GetCharacterMovement())\n\t{\n\t\tGetCharacterMovement()->DisableMovement();\n\t}\n}\n\nvoid APlayerMovementController::UnlockMovement()\n{\n\tbIsMovementLocked = false;\n\tif (GetCharacterMovement())\n\t{\n\t\tGetCharacterMovement()->SetMovementMode(MOVE_Walking);\n\t}\n}\n\nvoid APlayerMovementController::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind input actions here\n\t// Example: PlayerInputComponent->BindAction(\"LockMovement\", IE_Pressed, this, &APlayerMovementController::LockMovement);\n\t// Example: PlayerInputComponent->BindAction(\"UnlockMovement\", IE_Pressed, this, &APlayerMovementController::UnlockMovement);\n}\n```"}
{"requirement": "Create an Actor that emits a sparkle effect every few seconds.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SparkleEmitter.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASparkleEmitter : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASparkleEmitter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Timer handle for sparkle emission\n\tFTimerHandle SparkleTimerHandle;\n\n\t// Function to emit sparkle\n\tvoid EmitSparkle();\n\n\t// Delay between sparkle emissions\n\tUPROPERTY(EditAnywhere, Category = \"Sparkle\")\n\tfloat SparkleInterval;\n};\n```", "cpp_code": "```cpp\n#include \"SparkleEmitter.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nASparkleEmitter::ASparkleEmitter()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSparkleInterval = 2.0f; // Default interval of 2 seconds\n}\n\n// Called when the game starts or when spawned\nvoid ASparkleEmitter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Set timer to emit sparkle\n\tGetWorld()->GetTimerManager().SetTimer(SparkleTimerHandle, this, &ASparkleEmitter::EmitSparkle, SparkleInterval, true);\n}\n\n// Called every frame\nvoid ASparkleEmitter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASparkleEmitter::EmitSparkle()\n{\n\tif (GEngine)\n\t{\n\t\t// Log or trigger particle system for sparkle effect\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Sparkle emitted!\"));\n\n\t\t// Example of playing a particle system at the actor's location\n\t\t// Replace \"YourParticleSystem\" with your actual particle system asset\n\t\tUParticleSystem* SparkleEffect = LoadObject<UParticleSystem>(nullptr, TEXT(\"/Game/YourParticleSystem.YourParticleSystem\"));\n\t\tif (SparkleEffect)\n\t\t{\n\t\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), SparkleEffect, GetActorLocation(), GetActorRotation());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Develop a class that changes the Actor's color to match the player's team.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TeamActor.generated.h\"\n\nUCLASS()\nclass ATeamActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATeamActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to change color based on team\n\tUFUNCTION(BlueprintCallable, Category = \"Team\")\n\tvoid ChangeColorToMatchTeam(int32 TeamID);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Team\")\n\tTMap<int32, FLinearColor> TeamColors;\n};\n```", "cpp_code": "```cpp\n#include \"TeamActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nATeamActor::ATeamActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Example Team Colors\n\tTeamColors.Add(1, FLinearColor::Red);\n\tTeamColors.Add(2, FLinearColor::Blue);\n\tTeamColors.Add(3, FLinearColor::Green);\n}\n\n// Called when the game starts or when spawned\nvoid ATeamActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATeamActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATeamActor::ChangeColorToMatchTeam(int32 TeamID)\n{\n\tif(TeamColors.Contains(TeamID))\n\t{\n\t\tFLinearColor* Color = TeamColors.Find(TeamID);\n\t\tif (Color)\n\t\t{\n\t\t\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"BaseColor\"), Color->ToFVector());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a UMG button widget that toggles the game's music on and off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"UMusicToggleWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UUMusicToggleWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Music\")\n\tvoid ToggleMusic();\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\nprivate:\n\tbool bIsMusicPlaying;\n};\n```", "cpp_code": "```cpp\n#include \"UMusicToggleWidget.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nvoid UUMusicToggleWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\tbIsMusicPlaying = true;\n}\n\nvoid UUMusicToggleWidget::ToggleMusic()\n{\n\tif (bIsMusicPlaying)\n\t{\n\t\tUGameplayStatics::SetGlobalTimeDilation(GetWorld(), 0.0f);\n\t}\n\telse\n\t{\n\t\tUGameplayStatics::SetGlobalTimeDilation(GetWorld(), 1.0f);\n\t}\n\tbIsMusicPlaying = !bIsMusicPlaying;\n}\n```"}
{"requirement": "Create an Actor that moves to a target location when spawned.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector TargetLocation;\n\tfloat MoveSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tTargetLocation = FVector(1000.f, 0.f, 0.f); // Example target location\n\tMoveSpeed = 100.f; // Movement speed in units per second\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentLocation = GetActorLocation();\n\tFVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n\tFVector NewLocation = CurrentLocation + Direction * MoveSpeed * DeltaTime;\n\n\tSetActorLocation(NewLocation);\n\n\t// Optionally check if the actor is close enough to the target to stop moving\n\tif (FVector::Dist(CurrentLocation, TargetLocation) < KINDA_SMALL_NUMBER)\n\t{\n\t\t// Stop moving or perform any action you need\n\t}\n}\n```"}
{"requirement": "Implement a simple networking function to replicate an Actor's visibility toggle.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"VisibilityToggleActor.generated.h\"\n\nUCLASS()\nclass AVisibilityToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAVisibilityToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visibility\")\n\tvoid ToggleVisibility();\n\n\tUFUNCTION(Server, Reliable, WithValidation)\n\tvoid ServerToggleVisibility();\n\n\tUFUNCTION()\n\tvoid OnRep_VisibilityChanged();\n\n\tUPROPERTY(ReplicatedUsing=OnRep_VisibilityChanged)\n\tbool bIsVisible;\n\n\tvoid GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\n};\n```", "cpp_code": "```cpp\n#include \"VisibilityToggleActor.h\"\n#include \"Net/UnrealNetwork.h\"\n\nAVisibilityToggleActor::AVisibilityToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsVisible = true;\n\tSetReplicates(true);\n}\n\nvoid AVisibilityToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AVisibilityToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AVisibilityToggleActor::ToggleVisibility()\n{\n\tif (HasAuthority())\n\t{\n\t\tbIsVisible = !bIsVisible;\n\t\tOnRep_VisibilityChanged();\n\t}\n\telse\n\t{\n\t\tServerToggleVisibility();\n\t}\n}\n\nvoid AVisibilityToggleActor::ServerToggleVisibility_Implementation()\n{\n\tToggleVisibility();\n}\n\nbool AVisibilityToggleActor::ServerToggleVisibility_Validate()\n{\n\treturn true;\n}\n\nvoid AVisibilityToggleActor::OnRep_VisibilityChanged()\n{\n\tSetActorHiddenInGame(!bIsVisible);\n}\n\nvoid AVisibilityToggleActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AVisibilityToggleActor, bIsVisible);\n}\n```"}
{"requirement": "Create a class that spawns a shield Actor around the player on command.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ShieldSpawner.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AShieldSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAShieldSpawner();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Shield\")\n\tvoid SpawnShield();\n\nprivate:\n\tUPROPERTY(EditDefaultsOnly, Category=\"Shield\")\n\tTSubclassOf<AActor> ShieldClass;\n};\n```", "cpp_code": "```cpp\n#include \"ShieldSpawner.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Character.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAShieldSpawner::AShieldSpawner()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tstatic ConstructorHelpers::FClassFinder<AActor> ShieldBPClass(TEXT(\"/Game/Blueprints/ShieldBP\"));\n\tif (ShieldBPClass.Class != nullptr)\n\t{\n\t\tShieldClass = ShieldBPClass.Class;\n\t}\n}\n\nvoid AShieldSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AShieldSpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AShieldSpawner::SpawnShield()\n{\n\tif (ShieldClass != nullptr)\n\t{\n\t\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\t\tif (PlayerController != nullptr)\n\t\t{\n\t\t\tACharacter* PlayerCharacter = Cast<ACharacter>(PlayerController->GetPawn());\n\t\t\tif (PlayerCharacter != nullptr)\n\t\t\t{\n\t\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\t\tSpawnParams.Owner = this;\n\t\t\t\tFVector SpawnLocation = PlayerCharacter->GetActorLocation();\n\t\t\t\tFRotator SpawnRotation = PlayerCharacter->GetActorRotation();\n\t\t\t\tGetWorld()->SpawnActor<AActor>(ShieldClass, SpawnLocation, SpawnRotation, SpawnParams);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Develop an Actor with a timeline to animate the Actor's scale from small to large.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY()\n\tUTimelineComponent* ScaleTimeline;\n\n\tUFUNCTION()\n\tvoid HandleScaling(float Value);\n\n\tFOnTimelineFloat InterpFunction{};\n\n\tUPROPERTY(EditAnywhere, Category = \"Timeline\")\n\tUCurveFloat* ScaleCurve;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n#include \"Curves/CurveFloat.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tScaleTimeline = CreateDefaultSubobject<UTimelineComponent>(TEXT(\"ScaleTimeline\"));\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (ScaleCurve)\n\t{\n\t\tInterpFunction.BindUFunction(this, FName(\"HandleScaling\"));\n\t\tScaleTimeline->AddInterpFloat(ScaleCurve, InterpFunction);\n\t\tScaleTimeline->SetLooping(false);\n\t\tScaleTimeline->PlayFromStart();\n\t}\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (ScaleTimeline)\n\t{\n\t\tScaleTimeline->TickComponent(DeltaTime, ELevelTick::LEVELTICK_TimeOnly, nullptr);\n\t}\n}\n\nvoid AScalingActor::HandleScaling(float Value)\n{\n\tFVector NewScale = FMath::Lerp(FVector(0.1f, 0.1f, 0.1f), FVector(1.0f, 1.0f, 1.0f), Value);\n\tMeshComponent->SetWorldScale3D(NewScale);\n}\n```"}
{"requirement": "Implement a UFUNCTION to teleport the player to a safe zone.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TeleportPlayer.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ATeleportPlayer : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATeleportPlayer();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Teleportation\")\n\tvoid TeleportToSafeZone();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Teleportation\")\n\tFVector SafeZoneLocation;\n};\n```", "cpp_code": "```cpp\n#include \"TeleportPlayer.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nATeleportPlayer::ATeleportPlayer()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSafeZoneLocation = FVector(0.0f, 0.0f, 0.0f); // Default SafeZone location\n}\n\nvoid ATeleportPlayer::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATeleportPlayer::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATeleportPlayer::TeleportToSafeZone()\n{\n\tAActor* PlayerActor = UGameplayStatics::GetPlayerPawn(this, 0);\n\tif (PlayerActor)\n\t{\n\t\tPlayerActor->SetActorLocation(SafeZoneLocation);\n\t}\n}\n```"}
{"requirement": "Create an Actor with a static mesh that plays a sound when touched.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnMeshBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* TouchSound;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/EngineTypes.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyActor::OnMeshBeginOverlap);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyActor::OnMeshBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (TouchSound && OtherActor != this)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, TouchSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Develop a class that logs when the Actor enters a danger zone.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DangerZoneLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADangerZoneLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tADangerZoneLogger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor,\n\t\t\t\t\t\tclass UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,\n\t\t\t\t\t\tbool bFromSweep, const FHitResult & SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* DangerZoneTrigger;\n};\n```", "cpp_code": "```cpp\n#include \"DangerZoneLogger.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nADangerZoneLogger::ADangerZoneLogger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set up the danger zone trigger box\n\tDangerZoneTrigger = CreateDefaultSubobject<UBoxComponent>(TEXT(\"DangerZoneTrigger\"));\n\tRootComponent = DangerZoneTrigger;\n\n\tDangerZoneTrigger->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tDangerZoneTrigger->SetCollisionObjectType(ECollisionChannel::ECC_WorldStatic);\n\tDangerZoneTrigger->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap);\n\n\tDangerZoneTrigger->OnComponentBeginOverlap.AddDynamic(this, &ADangerZoneLogger::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ADangerZoneLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADangerZoneLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADangerZoneLogger::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor,\n\t\t\t\t\t\t\t\t\t   UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,\n\t\t\t\t\t\t\t\t\t   bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s has entered the danger zone!\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Implement a BlueprintCallable function to increase the player's jump height temporarily.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"PlayerCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APlayerCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPlayerCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Character|Movement\")\n\tvoid IncreaseJumpHeight(float Multiplier, float Duration);\n\nprivate:\n\tFTimerHandle JumpHeightTimerHandle;\n\tfloat OriginalJumpZVelocity;\n\n\tvoid ResetJumpHeight();\n};\n```", "cpp_code": "```cpp\n#include \"PlayerCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"TimerManager.h\"\n\nAPlayerCharacter::APlayerCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APlayerCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tOriginalJumpZVelocity = GetCharacterMovement()->JumpZVelocity;\n}\n\nvoid APlayerCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APlayerCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\nvoid APlayerCharacter::IncreaseJumpHeight(float Multiplier, float Duration)\n{\n\tif (Multiplier > 0.0f && Duration > 0.0f)\n\t{\n\t\tGetCharacterMovement()->JumpZVelocity = OriginalJumpZVelocity * Multiplier;\n\t\tGetWorldTimerManager().SetTimer(JumpHeightTimerHandle, this, &APlayerCharacter::ResetJumpHeight, Duration, false);\n\t}\n}\n\nvoid APlayerCharacter::ResetJumpHeight()\n{\n\tGetCharacterMovement()->JumpZVelocity = OriginalJumpZVelocity;\n}\n```"}
{"requirement": "Create a UMG widget that shows the player's remaining lives.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"ULivesWidget.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ULivesWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tULivesWidget(const FObjectInitializer& ObjectInitializer);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Lives\")\n\tvoid UpdateLives(int32 NewLives);\n\nprotected:\n\tvirtual void NativeConstruct() override;\n\n\tUPROPERTY(BlueprintReadOnly, meta=(BindWidget))\n\tclass UTextBlock* LivesText;\n};\n```", "cpp_code": "```cpp\n#include \"ULivesWidget.h\"\n#include \"Components/TextBlock.h\"\n\nULivesWidget::ULivesWidget(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)\n{\n}\n\nvoid ULivesWidget::NativeConstruct()\n{\n\tSuper::NativeConstruct();\n\t// Example initialization if needed\n\tUpdateLives(3); // Assume player starts with 3 lives\n}\n\nvoid ULivesWidget::UpdateLives(int32 NewLives)\n{\n\tif (LivesText)\n\t{\n\t\tLivesText->SetText(FText::FromString(FString::Printf(TEXT(\"Lives: %d\"), NewLives)));\n\t}\n}\n```"}
{"requirement": "Implement a class to change the Actor's material to a glowing texture.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AGlowingMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AGlowingMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAGlowingMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Material\")\n\tvoid SetGlowingMaterial();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Material\")\n\tUMaterialInterface* GlowingMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"AGlowingMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAGlowingMaterialActor::AGlowingMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialAsset(TEXT(\"/Game/Path/To/Your/GlowingMaterial.GlowingMaterial\"));\n\tif (MaterialAsset.Succeeded())\n\t{\n\t\tGlowingMaterial = MaterialAsset.Object;\n\t}\n}\n\nvoid AGlowingMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetGlowingMaterial();\n}\n\nvoid AGlowingMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AGlowingMaterialActor::SetGlowingMaterial()\n{\n\tif (GlowingMaterial && MeshComponent)\n\t{\n\t\tMeshComponent->SetMaterial(0, GlowingMaterial);\n\t}\n}\n```"}
{"requirement": "Create an Actor that plays an animation on receiving damage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"DamageableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ADamageableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADamageableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle damage\n\tUFUNCTION()\n\tvoid ReceiveDamage(float DamageAmount);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\", meta=(AllowPrivateAccess=\"true\"))\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Animation\")\n\tUAnimSequence* DamageAnimation;\n\n\tUFUNCTION()\n\tvoid PlayDamageAnimation();\n};\n```", "cpp_code": "```cpp\n#include \"DamageableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Animation/AnimSequence.h\"\n\n// Sets default values\nADamageableActor::ADamageableActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize MeshComponent\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Optionally set a default mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Optionally set a default animation\n\tstatic ConstructorHelpers::FObjectFinder<UAnimSequence> AnimAsset(TEXT(\"/Game/Path/To/Your/Animation.Animation\"));\n\tif (AnimAsset.Succeeded())\n\t{\n\t\tDamageAnimation = AnimAsset.Object;\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ADamageableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADamageableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADamageableActor::ReceiveDamage(float DamageAmount)\n{\n\t// Logic to handle damage can be added here\n\n\t// Play damage animation\n\tPlayDamageAnimation();\n}\n\nvoid ADamageableActor::PlayDamageAnimation()\n{\n\tif (DamageAnimation && MeshComponent)\n\t{\n\t\tMeshComponent->PlayAnimation(DamageAnimation, false);\n\t}\n}\n```"}
{"requirement": "Develop a simple AI Controller to make an AI character circle the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AIController.h\"\n#include \"AICirclePlayerController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAICirclePlayerController : public AAIController\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAICirclePlayerController();\n\t\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAPawn* PlayerPawn;\n\tfloat CircleRadius;\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"AICirclePlayerController.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAAICirclePlayerController::AAICirclePlayerController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCircleRadius = 300.0f;\n\tRotationSpeed = 50.0f;\n}\n\nvoid AAICirclePlayerController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid AAICirclePlayerController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerPawn)\n\t{\n\t\tAPawn* ControlledPawn = GetPawn();\n\t\tif (ControlledPawn)\n\t\t{\n\t\t\tFVector DirectionToPlayer = ControlledPawn->GetActorLocation() - PlayerPawn->GetActorLocation();\n\t\t\tDirectionToPlayer.Z = 0.0f; // Keep it in the horizontal plane\n\t\t\tDirectionToPlayer.Normalize();\n\n\t\t\tFVector PerpendicularDirection = FVector::CrossProduct(DirectionToPlayer, FVector::UpVector);\n\t\t\tFVector NewLocation = PlayerPawn->GetActorLocation() + DirectionToPlayer * CircleRadius;\n\t\t\tNewLocation += PerpendicularDirection * FMath::Sin(GetWorld()->TimeSeconds * RotationSpeed);\n\n\t\t\tControlledPawn->SetActorLocation(NewLocation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement an Actor that changes its size based on the player's distance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceBasedSizeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceBasedSizeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADistanceBasedSizeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Size\")\n\tfloat MinScale;\n\n\tUPROPERTY(EditAnywhere, Category = \"Size\")\n\tfloat MaxScale;\n\n\tUPROPERTY(EditAnywhere, Category = \"Size\")\n\tfloat DistanceThreshold;\n\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"DistanceBasedSizeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nADistanceBasedSizeActor::ADistanceBasedSizeActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tMinScale = 0.5f;\n\tMaxScale = 2.0f;\n\tDistanceThreshold = 1000.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ADistanceBasedSizeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\n// Called every frame\nvoid ADistanceBasedSizeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerActor)\n\t{\n\t\tfloat Distance = FVector::Dist(PlayerActor->GetActorLocation(), GetActorLocation());\n\t\tfloat ScaleFactor = FMath::Clamp(Distance / DistanceThreshold, MinScale, MaxScale);\n\n\t\tSetActorScale3D(FVector(ScaleFactor));\n\t}\n}\n```"}
