{"requirement": "Create an actor with a visible mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VisibleMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVisibleMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAVisibleMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"VisibleMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAVisibleMeshActor::AVisibleMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AVisibleMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AVisibleMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a rotating actor that spins continuously.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Rotation speed in degrees per second\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize rotation speed\n\tRotationSpeed = FRotator(0.0f, 180.0f, 0.0f);  // Yaw rotation at 180 degrees per second\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Add rotation\n\tAddActorLocalRotation(RotationSpeed * DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY integer variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:  \n  // Sets default values for this actor's properties\n  AMyActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:  \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"My Variables\")\n  int32 MyInteger;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  MyInteger = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n  Super::BeginPlay();\n\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create an actor that changes color over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\tfloat TimeAccumulator;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nAColorChangingActor::AColorChangingActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize variables\n\tTimeAccumulator = 0.0f;\n\n\t// Create and attach a static mesh component\n\tUStaticMeshComponent* MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Create a dynamic material instance\n\tUStaticMeshComponent* MeshComponent = Cast<UStaticMeshComponent>(RootComponent);\n\tif (MeshComponent && MeshComponent->GetMaterial(0))\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\n// Called every frame\nvoid AColorChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterialInstance)\n\t{\n\t\t// Accumulate time\n\t\tTimeAccumulator += DeltaTime;\n\n\t\t// Change color over time\n\t\tFLinearColor NewColor = FLinearColor::MakeFromHSV8((uint8)(TimeAccumulator * 10) % 256, 255, 255);\n\t\tDynamicMaterialInstance->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t}\n}\n```"}
{"requirement": "Bind a key input to print a message to the screen.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintMessageActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API APrintMessageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPrintMessageActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tvoid PrintMessage();\n};\n```", "cpp_code": "```cpp\n#include \"PrintMessageActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n\nAPrintMessageActor::APrintMessageActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid APrintMessageActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APrintMessageActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"PrintMessage\", IE_Pressed, this, &APrintMessageActor::PrintMessage);\n\t}\n}\n\nvoid APrintMessageActor::PrintMessage()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Hello, Unreal Engine!\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that moves upwards every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat UpwardSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tUpwardSpeed = 100.0f; // Default speed value\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation();\n\tNewLocation.Z += UpwardSpeed * DeltaTime; // Move upwards\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that scales up over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic: \n  // Sets default values for this actor's properties\n  AScalingActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic: \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  // The rate at which the actor scales up\n  UPROPERTY(EditAnywhere, Category = \"Scaling\")\n  float ScaleRate;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n\n// Sets default values\nAScalingActor::AScalingActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Initialize the scale rate\n  ScaleRate = 0.1f;\n}\n\n// Called when the game starts or when spawned\nvoid AScalingActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid AScalingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  // Get current scale\n  FVector CurrentScale = GetActorScale3D();\n\n  // Increase scale over time\n  FVector NewScale = CurrentScale + FVector(ScaleRate * DeltaTime);\n\n  // Set the new scale\n  SetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a UPROPERTY boolean variable in a component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"MyComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass MYPROJECT_API UMyComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMyComponent();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MyCategory\")\n\tbool bMyBoolean;\n};\n```", "cpp_code": "```cpp\n#include \"MyComponent.h\"\n\nUMyComponent::UMyComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tbMyBoolean = false;\n}\n```"}
{"requirement": "Create a simple sphere actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimpleSphereActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimpleSphereActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tASimpleSphereActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* SphereMesh;\n};\n```", "cpp_code": "```cpp\n#include \"SimpleSphereActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASimpleSphereActor::ASimpleSphereActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a sphere mesh component\n\tSphereMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"SphereMesh\"));\n\tRootComponent = SphereMesh;\n\n\t// Find and set the static mesh of the sphere\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> SphereAsset(TEXT(\"/Engine/BasicShapes/Sphere.Sphere\"));\n\tif (SphereAsset.Succeeded())\n\t{\n\t\tSphereMesh->SetStaticMesh(SphereAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ASimpleSphereActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ASimpleSphereActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that logs a message on begin play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyLoggingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyLoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyLoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"MyLoggingActor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAMyLoggingActor::AMyLoggingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid AMyLoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Begin Play: Logging Actor\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that moves forward every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMovingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat Speed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n\n// Sets default values\nAMovingActor::AMovingActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSpeed = 100.0f; // Default speed value\n}\n\n// Called when the game starts or when spawned\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Move the actor forward every tick\n\tFVector NewLocation = GetActorLocation() + (GetActorForwardVector() * Speed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a component that changes its color based on a UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ColorChangingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UColorChangingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUColorChangingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void OnRegister() override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Color\")\n\tFLinearColor ComponentColor;\n\nprivate:\n\tvoid UpdateColor();\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nUColorChangingComponent::UColorChangingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tComponentColor = FLinearColor::Red; // Default Color\n}\n\nvoid UColorChangingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateColor();\n}\n\nvoid UColorChangingComponent::OnRegister()\n{\n\tSuper::OnRegister();\n\tUpdateColor();\n}\n\nvoid UColorChangingComponent::UpdateColor()\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tTArray<UStaticMeshComponent*> MeshComponents;\n\t\tOwner->GetComponents<UStaticMeshComponent>(MeshComponents);\n\t\tfor (UStaticMeshComponent* MeshComponent : MeshComponents)\n\t\t{\n\t\t\tif (MeshComponent)\n\t\t\t{\n\t\t\t\tfor (int32 i = 0; i < MeshComponent->GetNumMaterials(); ++i)\n\t\t\t\t{\n\t\t\t\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(i);\n\t\t\t\t\tif (DynamicMaterial)\n\t\t\t\t\t{\n\t\t\t\t\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", ComponentColor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a class with a custom constructor.", "header_code": "```cpp\nclass MYPROJECT_API ACustomActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Custom constructor\n\tACustomActor(float InitialValue);\n\n\t// Example property\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Custom\")\n\tfloat CustomValue;\n};\n```", "cpp_code": "```cpp\n#include \"CustomActor.h\"\n\nACustomActor::ACustomActor(float InitialValue)\n{\n\t// Initialize the custom value with the provided initial value\n\tCustomValue = InitialValue;\n}\n```"}
{"requirement": "Create a UPROPERTY float variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MyCategory\")\n\tfloat MyFloatVariable;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMyFloatVariable = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that disappears after 5 seconds.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DisappearingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ADisappearingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADisappearingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tFTimerHandle TimerHandle;\n\tvoid Disappear();\n};\n```", "cpp_code": "```cpp\n#include \"DisappearingActor.h\"\n#include \"TimerManager.h\"\n\nADisappearingActor::ADisappearingActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ADisappearingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorldTimerManager().SetTimer(TimerHandle, this, &ADisappearingActor::Disappear, 5.0f, false);\n}\n\nvoid ADisappearingActor::Disappear()\n{\n\tDestroy();\n}\n```"}
{"requirement": "Bind a key input to toggle visibility of an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAToggleVisibilityActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid ToggleVisibility();\n\nprivate:\n\tvoid SetupInputComponent();\n\n\tUPROPERTY()\n\tUInputComponent* InputComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/InputComponent.h\"\n\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetupInputComponent();\n}\n\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tSetActorHiddenInGame(!bHidden);\n}\n\nvoid AToggleVisibilityActor::SetupInputComponent()\n{\n\tif (InputComponent == nullptr)\n\t{\n\t\tInputComponent = NewObject<UInputComponent>(this);\n\t\tInputComponent->RegisterComponent();\n\t}\n\n\tif (InputComponent)\n\t{\n\t\tInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleVisibilityActor::ToggleVisibility);\n\t\tEnableInput(GetWorld()->GetFirstPlayerController());\n\t}\n}\n```"}
{"requirement": "Create an actor with a collision box.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionBoxActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ACollisionBoxActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionBoxActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Collision\")\n\tclass UBoxComponent* CollisionBox;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionBoxActor.h\"\n#include \"Components/BoxComponent.h\"\n\n// Sets default values\nACollisionBoxActor::ACollisionBoxActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the collision box and set it as the root component\n\tCollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionBox\"));\n\tRootComponent = CollisionBox;\n\n\t// Set the collision profile\n\tCollisionBox->SetCollisionProfileName(TEXT(\"BlockAllDynamic\"));\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionBoxActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACollisionBoxActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Create a simple cube actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CubeActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACubeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACubeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* CubeMesh;\n};\n```", "cpp_code": "```cpp\n#include \"CubeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACubeActor::ACubeActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the static mesh component\n\tCubeMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"CubeMesh\"));\n\tRootComponent = CubeMesh;\n\n\t// Find and set the cube static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> CubeAsset(TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n\tif (CubeAsset.Succeeded())\n\t{\n\t\tCubeMesh->SetStaticMesh(CubeAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ACubeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACubeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a component with a tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TickComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UTickComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUTickComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n};\n```", "cpp_code": "```cpp\n#include \"TickComponent.h\"\n\n// Sets default values for this component's properties\nUTickComponent::UTickComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\n// Called when the game starts\nvoid UTickComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid UTickComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Add your tick code here\n}\n```"}
{"requirement": "Create a UPROPERTY vector variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  AMyActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Vector\")\n  FVector MyVector;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n  // Set this actor to call Tick() every frame.\n  PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that rotates based on a UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:  \n  // Sets default values for this actor's properties\n  ARotatingActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:  \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n  FRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  RotationRate = FRotator(0.f, 0.f, 0.f);\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  FRotator NewRotation = GetActorRotation() + (RotationRate * DeltaTime);\n  SetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an actor that bounces on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BouncingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ABouncingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tABouncingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat BounceStrength;\n};\n```", "cpp_code": "```cpp\n#include \"BouncingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nABouncingActor::ABouncingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->SetNotifyRigidBodyCollision(true);\n\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ABouncingActor::OnHit);\n\n\tBounceStrength = 500.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ABouncingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n}\n\n// Called every frame\nvoid ABouncingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ABouncingActor::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tFVector Bounce = -NormalImpulse.GetSafeNormal() * BounceStrength;\n\t\tMeshComponent->AddImpulse(Bounce, NAME_None, true);\n\t}\n}\n```"}
{"requirement": "Create a UFUNCTION to reset an actor's position.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetPositionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetPositionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAResetPositionActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"Position\")\n\tvoid ResetActorPosition();\n\nprivate:\n\tFVector InitialPosition;\n};\n```", "cpp_code": "```cpp\n#include \"ResetPositionActor.h\"\n\n// Sets default values\nAResetPositionActor::AResetPositionActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Store the initial position of the actor\n\tInitialPosition = GetActorLocation();\n}\n\nvoid AResetPositionActor::ResetActorPosition()\n{\n\tSetActorLocation(InitialPosition);\n}\n```"}
{"requirement": "Create a class that changes scale based on time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleChanger : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAScaleChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat ScaleFactor;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat TimeScaleMultiplier;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChanger.h\"\n\nAScaleChanger::AScaleChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScaleFactor = 1.0f;\n\tTimeScaleMultiplier = 1.0f;\n}\n\nvoid AScaleChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialScale = GetActorScale3D();\n}\n\nvoid AScaleChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat Time = GetWorld()->GetTimeSeconds();\n\tfloat ScaleChange = FMath::Sin(Time * TimeScaleMultiplier) * ScaleFactor;\n\tFVector NewScale = InitialScale + FVector(ScaleChange, ScaleChange, ScaleChange);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Bind a key input to change an actor's scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeScaleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeScaleActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AChangeScaleActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\n  void ChangeScale();\n\nprivate:\n  void SetupInputComponent();\n\nprivate:\n  UPROPERTY(EditAnywhere)\n  FVector NewScale;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeScaleActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\nAChangeScaleActor::AChangeScaleActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n  NewScale = FVector(2.0f, 2.0f, 2.0f);\n}\n\nvoid AChangeScaleActor::BeginPlay()\n{\n  Super::BeginPlay();\n  SetupInputComponent();\n}\n\nvoid AChangeScaleActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AChangeScaleActor::ChangeScale()\n{\n  SetActorScale3D(NewScale);\n}\n\nvoid AChangeScaleActor::SetupInputComponent()\n{\n  if (InputComponent == nullptr)\n  {\n\tInputComponent = NewObject<UInputComponent>(this);\n\tInputComponent->RegisterComponent();\n\tInputComponent->BindAction(\"ChangeScale\", IE_Pressed, this, &AChangeScaleActor::ChangeScale);\n  }\n}\n```"}
{"requirement": "Create an actor with a light component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Light component\n\tUPROPERTY(VisibleAnywhere, Category = \"Light\")\n\tclass UPointLightComponent* PointLight;\n};\n```", "cpp_code": "```cpp\n#include \"LightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nALightActor::ALightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a point light component\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n}\n\n// Called when the game starts or when spawned\nvoid ALightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a simple plane actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimplePlaneActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimplePlaneActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASimplePlaneActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* PlaneMesh;\n};\n```", "cpp_code": "```cpp\n#include \"SimplePlaneActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nASimplePlaneActor::ASimplePlaneActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create plane mesh component\n\tPlaneMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"PlaneMesh\"));\n\tRootComponent = PlaneMesh;\n\n\t// Optionally set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> PlaneMeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Plane.Shape_Plane\"));\n\tif (PlaneMeshAsset.Succeeded())\n\t{\n\t\tPlaneMesh->SetStaticMesh(PlaneMeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ASimplePlaneActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASimplePlaneActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY string variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  AMyActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Custom\")\n  FString MyString;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that shrinks over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ShrinkingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AShrinkingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAShrinkingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Shrinking\")\n\tfloat ShrinkRate;\n};\n```", "cpp_code": "```cpp\n#include \"ShrinkingActor.h\"\n\nAShrinkingActor::AShrinkingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tShrinkRate = 0.1f; // Default shrink rate\n}\n\nvoid AShrinkingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AShrinkingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tFVector NewScale = GetActorScale3D();\n\tNewScale -= FVector(ShrinkRate * DeltaTime);\n\tNewScale = NewScale.GetClampedToMin(FVector(0.1f, 0.1f, 0.1f)); // Prevent scaling below a certain size\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a component that logs a message every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LoggingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULoggingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tULoggingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nULoggingComponent::ULoggingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid ULoggingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ULoggingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tUE_LOG(LogTemp, Warning, TEXT(\"LoggingComponent is ticking on actor: %s\"), *GetOwner()->GetName());\n}\n```"}
{"requirement": "Create an actor with a sound component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Components/AudioComponent.h\"\n#include \"SoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tASoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Audio\")\n\tUAudioComponent* AudioComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Audio\")\n\tUSoundBase* Sound;\n};\n```", "cpp_code": "```cpp\n#include \"SoundActor.h\"\n\nASoundActor::ASoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n}\n\nvoid ASoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (Sound)\n\t{\n\t\tAudioComponent->SetSound(Sound);\n\t\tAudioComponent->Play();\n\t}\n}\n\nvoid ASoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its material on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAChangeMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Materials\")\n\tUMaterialInterface* Material1;\n\n\tUPROPERTY(EditAnywhere, Category=\"Materials\")\n\tUMaterialInterface* Material2;\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n\tbool bUseMaterial1;\n\n\tvoid ChangeMaterial();\n\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerInput.h\"\n#include \"Engine/Engine.h\"\n\nAChangeMaterialActor::AChangeMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tbUseMaterial1 = true;\n}\n\nvoid AChangeMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Material1 && Material2)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n}\n\nvoid AChangeMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tInputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AChangeMaterialActor::ChangeMaterial);\n}\n\nvoid AChangeMaterialActor::ChangeMaterial()\n{\n\tif (bUseMaterial1)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material2);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n\tbUseMaterial1 = !bUseMaterial1;\n}\n```"}
{"requirement": "Create a class that sets its location on begin play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SetLocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASetLocationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tASetLocationActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Location to set on Begin Play\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Location\")\n\tFVector InitialLocation;\n};\n```", "cpp_code": "```cpp\n#include \"SetLocationActor.h\"\n\n// Sets default values\nASetLocationActor::ASetLocationActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t // Initialize default location\n\t InitialLocation = FVector(0.0f, 0.0f, 0.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ASetLocationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Set the actor's location\n\tSetActorLocation(InitialLocation);\n}\n```"}
{"requirement": "Create an actor that moves in a circle every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CircularMovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ACircularMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACircularMovingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector Center;\n\tfloat Radius;\n\tfloat AngularSpeed;\n\tfloat CurrentAngle;\n};\n```", "cpp_code": "```cpp\n#include \"CircularMovingActor.h\"\n\n// Sets default values\nACircularMovingActor::ACircularMovingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCenter = FVector(0.0f, 0.0f, 0.0f);\n\tRadius = 100.0f;\n\tAngularSpeed = 1.0f; // Radians per second\n\tCurrentAngle = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ACircularMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Optionally set the center to the actor's initial location\n\tCenter = GetActorLocation();\n}\n\n// Called every frame\nvoid ACircularMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tCurrentAngle += AngularSpeed * DeltaTime;\n\tfloat X = Center.X + Radius * FMath::Cos(CurrentAngle);\n\tfloat Y = Center.Y + Radius * FMath::Sin(CurrentAngle);\n\tfloat Z = Center.Z;\n\n\tSetActorLocation(FVector(X, Y, Z));\n}\n```"}
{"requirement": "Create a UFUNCTION to change an actor's color.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Color\")\n\tvoid ChangeColor(FLinearColor NewColor);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAColorChangeActor::AColorChangeActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AColorChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AColorChangeActor::ChangeColor(FLinearColor NewColor)\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that looks at the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LookAtPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALookAtPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tALookAtPlayerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"LookAtPlayerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nALookAtPlayerActor::ALookAtPlayerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ALookAtPlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid ALookAtPlayerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tif (PlayerActor)\n\t{\n\t\tFVector PlayerLocation = PlayerActor->GetActorLocation();\n\t\tFVector ActorLocation = GetActorLocation();\n\t\tFRotator LookAtRotation = FRotationMatrix::MakeFromX(PlayerLocation - ActorLocation).Rotator();\n\t\tSetActorRotation(LookAtRotation);\n\t}\n}\n```"}
{"requirement": "Create a simple cone actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimpleConeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimpleConeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASimpleConeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* ConeMesh;\n};\n```", "cpp_code": "```cpp\n#include \"SimpleConeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASimpleConeActor::ASimpleConeActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a StaticMeshComponent\n\tConeMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"ConeMesh\"));\n\tRootComponent = ConeMesh;\n\n\t// Set the cone mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> ConeMeshAsset(TEXT(\"/Engine/BasicShapes/Cone.Cone\"));\n\tif (ConeMeshAsset.Succeeded())\n\t{\n\t\tConeMesh->SetStaticMesh(ConeMeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ASimpleConeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASimpleConeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY array variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MyCategory\")\n\tTArray<int32> MyIntArray;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that plays a sound on begin play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"SoundActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundActor::ASoundActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that changes color when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ColorChangeComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UColorChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUColorChangeComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\t// Handle mouse click event\n\tUFUNCTION()\n\tvoid OnMouseClicked();\n\n\t// Change color function\n\tvoid ChangeColor();\n\n\t// Current color of the component\n\tFLinearColor CurrentColor;\n\n\t// Mesh component to change color\n\tUMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values for this component's properties\nUColorChangeComponent::UColorChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCurrentColor = FLinearColor::White;\n}\n\n// Called when the game starts\nvoid UColorChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tMeshComponent = Cast<UMeshComponent>(Owner->GetComponentByClass(UMeshComponent::StaticClass()));\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tMeshComponent->OnClicked.AddDynamic(this, &UColorChangeComponent::OnMouseClicked);\n\t\t}\n\t}\n}\n\n// Called every frame\nvoid UColorChangeComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UColorChangeComponent::OnMouseClicked()\n{\n\tChangeColor();\n}\n\nvoid UColorChangeComponent::ChangeColor()\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* MaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (MaterialInstance)\n\t\t{\n\t\t\tCurrentColor = FLinearColor(FMath::FRand(), FMath::FRand(), FMath::FRand(), 1.0f);\n\t\t\tMaterialInstance->SetVectorParameterValue(\"BaseColor\", CurrentColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a camera component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"MyCameraActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyCameraActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyCameraActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Camera component\n\tUPROPERTY(VisibleAnywhere)\n\tUCameraComponent* CameraComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyCameraActor.h\"\n\n// Sets default values\nAMyCameraActor::AMyCameraActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a CameraComponent and attach it to the root component\n\tCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"CameraComponent\"));\n\tRootComponent = CameraComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AMyCameraActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyCameraActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that logs its position every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ALoggingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  ALoggingActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic: \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingActor::ALoggingActor()\n{\n  // Set this actor to call Tick() every frame\n  PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  FVector Position = GetActorLocation();\n  UE_LOG(LogTemp, Log, TEXT(\"Actor Position: %s\"), *Position.ToString());\n}\n```"}
{"requirement": "Bind a key input to change an actor's material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AChangeMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAChangeMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n\n\tvoid ChangeMaterial();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInterface.h\"\n\nAChangeMaterialActor::AChangeMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AChangeMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AChangeMaterialActor::ChangeMaterial);\n}\n\nvoid AChangeMaterialActor::ChangeMaterial()\n{\n\tif (NewMaterial)\n\t{\n\t\tUStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that orbits around a point.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OrbitingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOrbitingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAOrbitingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Orbit\")\n\tFVector OrbitCenter;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Orbit\")\n\tfloat OrbitRadius;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Orbit\")\n\tfloat OrbitSpeed;\n\nprivate:\n\tfloat CurrentAngle;\n};\n```", "cpp_code": "```cpp\n#include \"OrbitingActor.h\"\n\nAOrbitingActor::AOrbitingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tOrbitCenter = FVector::ZeroVector;\n\tOrbitRadius = 300.0f;\n\tOrbitSpeed = 50.0f;\n\tCurrentAngle = 0.0f;\n}\n\nvoid AOrbitingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOrbitingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tCurrentAngle += OrbitSpeed * DeltaTime;\n\tif (CurrentAngle >= 360.0f)\n\t{\n\t\tCurrentAngle -= 360.0f;\n\t}\n\n\tfloat RadAngle = FMath::DegreesToRadians(CurrentAngle);\n\tFVector NewLocation;\n\tNewLocation.X = OrbitCenter.X + OrbitRadius * FMath::Cos(RadAngle);\n\tNewLocation.Y = OrbitCenter.Y + OrbitRadius * FMath::Sin(RadAngle);\n\tNewLocation.Z = OrbitCenter.Z; // Assuming orbit in XY plane only\n\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a simple cylinder actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CylinderActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ACylinderActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tACylinderActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* CylinderMesh;\n};\n```", "cpp_code": "```cpp\n#include \"CylinderActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACylinderActor::ACylinderActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create cylinder mesh component\n\tCylinderMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"CylinderMesh\"));\n\tRootComponent = CylinderMesh;\n\n\t// Set mesh to a cylinder\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> CylinderAsset(TEXT(\"/Engine/BasicShapes/Cylinder.Cylinder\"));\n\tif (CylinderAsset.Succeeded())\n\t{\n\t\tCylinderMesh->SetStaticMesh(CylinderAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ACylinderActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACylinderActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Create a UPROPERTY map variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMapActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAMapActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Map\")\n\tTMap<FString, int32> StringToIntMap;\n};\n```", "cpp_code": "```cpp\n#include \"MapActor.h\"\n\n// Sets default values\nAMapActor::AMapActor()\n{\n\t // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that spawns another actor on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpawnActorOnKeyPress.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpawnActorOnKeyPress : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASpawnActorOnKeyPress();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere)\n\tTSubclassOf<AActor> ActorToSpawn;\n\n\tUPROPERTY(EditAnywhere)\n\tFKey SpawnKey;\n\nprivate:\n\tvoid HandleKeyPress();\n};\n```", "cpp_code": "```cpp\n#include \"SpawnActorOnKeyPress.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nASpawnActorOnKeyPress::ASpawnActorOnKeyPress()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASpawnActorOnKeyPress::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpawnActorOnKeyPress::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tHandleKeyPress();\n}\n\nvoid ASpawnActorOnKeyPress::HandleKeyPress()\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController && PlayerController->WasInputKeyJustPressed(SpawnKey))\n\t{\n\t\tif (ActorToSpawn)\n\t\t{\n\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\tGetWorld()->SpawnActor<AActor>(ActorToSpawn, GetActorLocation(), GetActorRotation(), SpawnParams);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a component that rotates around its parent.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"RotatingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API URotatingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tURotatingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingComponent.h\"\n\nURotatingComponent::URotatingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tRotationRate = FRotator(0.f, 45.f, 0.f); // Default rotation rate\n}\n\nvoid URotatingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotatingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFRotator NewRotation = Owner->GetActorRotation() + (RotationRate * DeltaTime);\n\t\tOwner->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY transform variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Transform\")\n\tFTransform MyTransform;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class with a custom tick interval.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomTickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomTickActor : public AActor\n{\n  GENERATED_BODY()\n  \npublic:  \n  ACustomTickActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:  \n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  float CustomTickInterval;\n  float TimeSinceLastTick;\n};\n```", "cpp_code": "```cpp\n#include \"CustomTickActor.h\"\n\nACustomTickActor::ACustomTickActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n  CustomTickInterval = 1.0f; // Set your desired tick interval here\n  TimeSinceLastTick = 0.0f;\n}\n\nvoid ACustomTickActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid ACustomTickActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  TimeSinceLastTick += DeltaTime;\n  if (TimeSinceLastTick >= CustomTickInterval)\n  {\n\tTimeSinceLastTick -= CustomTickInterval;\n\t// Place your custom tick logic here\n  }\n}\n```"}
{"requirement": "Create an actor that scales down to a minimum size.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat MinScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat ScalingSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMinScale = 0.1f;\n\tScalingSpeed = 0.1f;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentScale = GetActorScale3D();\n\n\tif (CurrentScale.GetMin() > MinScale)\n\t{\n\t\tFVector NewScale = CurrentScale - FVector(ScalingSpeed * DeltaTime);\n\t\tNewScale.X = FMath::Max(NewScale.X, MinScale);\n\t\tNewScale.Y = FMath::Max(NewScale.Y, MinScale);\n\t\tNewScale.Z = FMath::Max(NewScale.Z, MinScale);\n\n\t\tSetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Create a UFUNCTION to destroy an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DestroyActorFunction.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADestroyActorFunction : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Actor\")\n\tvoid DestroyActor();\n};\n```", "cpp_code": "```cpp\n#include \"DestroyActorFunction.h\"\n\nvoid ADestroyActorFunction::DestroyActor()\n{\n\tif (IsValid(this))\n\t{\n\t\tDestroy();\n\t}\n}\n```"}
{"requirement": "Create an actor that moves towards the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MoveToPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMoveToPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMoveToPlayerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MoveSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MoveToPlayerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Character.h\"\n\nAMoveToPlayerActor::AMoveToPlayerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMoveSpeed = 300.0f; // Default move speed\n}\n\nvoid AMoveToPlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMoveToPlayerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tACharacter* PlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);\n\tif (PlayerCharacter)\n\t{\n\t\tFVector Direction = (PlayerCharacter->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n\t\tFVector NewLocation = GetActorLocation() + (Direction * MoveSpeed * DeltaTime);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create a simple capsule actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimpleCapsuleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimpleCapsuleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASimpleCapsuleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUCapsuleComponent* CapsuleComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SimpleCapsuleActor.h\"\n#include \"Components/CapsuleComponent.h\"\n\n// Sets default values\nASimpleCapsuleActor::ASimpleCapsuleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create capsule component and attach it to the root\n\tCapsuleComponent = CreateDefaultSubobject<UCapsuleComponent>(TEXT(\"CapsuleComponent\"));\n\tRootComponent = CapsuleComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ASimpleCapsuleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASimpleCapsuleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY enum variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUENUM(BlueprintType)\nenum class EMyEnum : uint8\n{\n\tOption1 UMETA(DisplayName = \"Option 1\"),\n\tOption2 UMETA(DisplayName = \"Option 2\"),\n\tOption3 UMETA(DisplayName = \"Option 3\")\n};\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"MyEnum\")\n\tEMyEnum MyEnumVariable;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes mesh on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ChangeMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAChangeMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Mesh components\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Meshes to switch between\n\tUPROPERTY(EditAnywhere)\n\tUStaticMesh* Mesh1;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMesh* Mesh2;\n\n\t// Function to change the mesh\n\tvoid ChangeMesh();\n\nprivate:\n\t// Boolean to track the current mesh\n\tbool bUsingMesh1;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMeshActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAChangeMeshActor::AChangeMeshActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tbUsingMesh1 = true;\n}\n\n// Called when the game starts or when spawned\nvoid AChangeMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (InputComponent)\n\t{\n\t\tInputComponent->BindAction(\"ChangeMesh\", IE_Pressed, this, &AChangeMeshActor::ChangeMesh);\n\t}\n\n\tif (Mesh1)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh1);\n\t}\n}\n\n// Called every frame\nvoid AChangeMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to change the mesh\nvoid AChangeMeshActor::ChangeMesh()\n{\n\tif (bUsingMesh1 && Mesh2)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh2);\n\t\tbUsingMesh1 = false;\n\t}\n\telse if (Mesh1)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh1);\n\t\tbUsingMesh1 = true;\n\t}\n}\n```"}
{"requirement": "Create a component that changes scale when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleOnClickComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECTNAME_API UScaleOnClickComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUScaleOnClickComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFVector OriginalScale;\n\tFVector TargetScale;\n\tbool bIsScaled;\n\n\tUFUNCTION()\n\tvoid OnMouseClicked(AActor* TouchedActor, FKey ButtonPressed);\n\n\tvoid ToggleScale();\n};\n```", "cpp_code": "```cpp\n#include \"ScaleOnClickComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values for this component's properties\nUScaleOnClickComponent::UScaleOnClickComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tbIsScaled = false;\n\tTargetScale = FVector(2.0f, 2.0f, 2.0f);\n}\n\n// Called when the game starts\nvoid UScaleOnClickComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOriginalScale = Owner->GetActorScale3D();\n\n\t\tOwner->OnClicked.AddDynamic(this, &UScaleOnClickComponent::OnMouseClicked);\n\t}\n}\n\n// Called every frame\nvoid UScaleOnClickComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UScaleOnClickComponent::OnMouseClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tToggleScale();\n}\n\nvoid UScaleOnClickComponent::ToggleScale()\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tif (bIsScaled)\n\t\t{\n\t\t\tOwner->SetActorScale3D(OriginalScale);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOwner->SetActorScale3D(TargetScale);\n\t\t}\n\t\tbIsScaled = !bIsScaled;\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store another actor reference.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAYourActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"References\")\n\tAActor* OtherActorReference;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\n// Sets default values\nAYourActor::AYourActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create an actor with an audio component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"MyAudioActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyAudioActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMyAudioActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Audio\")\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyAudioActor.h\"\n\n// Sets default values\nAMyAudioActor::AMyAudioActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach an audio component\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n}\n\n// Called when the game starts or when spawned\nvoid AMyAudioActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyAudioActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that reverses movement on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReversibleMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AReversibleMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAReversibleMovementActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tFVector MovementDirection;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MovementSpeed;\n\n\tUFUNCTION()\n\tvoid OnCollision(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"ReversibleMovementActor.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nAReversibleMovementActor::AReversibleMovementActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementDirection = FVector(1.0f, 0.0f, 0.0f);\n\tMovementSpeed = 100.0f;\n\n\tUPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(RootComponent);\n\tif (PrimitiveComponent)\n\t{\n\t\tPrimitiveComponent->OnComponentHit.AddDynamic(this, &AReversibleMovementActor::OnCollision);\n\t}\n}\n\nvoid AReversibleMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AReversibleMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation() + (MovementDirection * MovementSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n\nvoid AReversibleMovementActor::OnCollision(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tMovementDirection = -MovementDirection;\n}\n```"}
{"requirement": "Create an actor that toggles visibility every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAToggleVisibilityActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ToggleVisibility();\n\tFTimerHandle VisibilityToggleTimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"TimerManager.h\"\n\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorld()->GetTimerManager().SetTimer(VisibilityToggleTimerHandle, this, &AToggleVisibilityActor::ToggleVisibility, 1.0f, true);\n}\n\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tSetActorHiddenInGame(!bHidden);\n}\n```"}
{"requirement": "Bind a key input to play a sound.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundPlayer.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayer : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundPlayer();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere)\n\tUSoundCue* SoundToPlay;\n\n\tvoid PlaySound();\n};\n```", "cpp_code": "```cpp\n#include \"SoundPlayer.h\"\n#include \"Components/InputComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundPlayer::ASoundPlayer()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASoundPlayer::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (InputComponent)\n\t{\n\t\tInputComponent->BindAction(\"PlaySound\", IE_Pressed, this, &ASoundPlayer::PlaySound);\n\t}\n}\n\nvoid ASoundPlayer::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundPlayer::PlaySound()\n{\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create an actor with a spotlight component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpotlightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpotlightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpotlightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUSpotLightComponent* SpotlightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SpotlightActor.h\"\n#include \"Components/SpotLightComponent.h\"\n\n// Sets default values\nASpotlightActor::ASpotlightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the spotlight component and attach it to the root\n\tSpotlightComponent = CreateDefaultSubobject<USpotLightComponent>(TEXT(\"SpotlightComponent\"));\n\tRootComponent = SpotlightComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ASpotlightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ASpotlightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a mesh component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAYourActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAYourActor::AYourActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that respawns at a location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RespawnActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARespawnActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARespawnActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Respawn location\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Respawn\")\n\tFVector RespawnLocation;\n\n\t// Respawn the actor at the specified location\n\tUFUNCTION(BlueprintCallable, Category=\"Respawn\")\n\tvoid Respawn();\n};\n```", "cpp_code": "```cpp\n#include \"RespawnActor.h\"\n\n// Sets default values\nARespawnActor::ARespawnActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ARespawnActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARespawnActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARespawnActor::Respawn()\n{\n\tSetActorLocation(RespawnLocation);\n}\n```"}
{"requirement": "Create a component with a boolean flag to toggle behavior.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleBehaviorComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UToggleBehaviorComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUToggleBehaviorComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\t// Boolean flag to toggle behavior\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Toggle\")\n\tbool bToggleBehavior;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleBehaviorComponent.h\"\n\n// Sets default values for this component's properties\nUToggleBehaviorComponent::UToggleBehaviorComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\t// Initialize the toggle flag\n\tbToggleBehavior = false;\n}\n\n// Called when the game starts\nvoid UToggleBehaviorComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Custom initialization can be added here\n}\n\n// Called every frame\nvoid UToggleBehaviorComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Toggle behavior based on the flag\n\tif (bToggleBehavior)\n\t{\n\t\t// Add code for the behavior when the flag is true\n\t}\n\telse\n\t{\n\t\t// Add code for the behavior when the flag is false\n\t}\n}\n```"}
{"requirement": "Create an actor that moves randomly every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARandomMover();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFTimerHandle MovementTimerHandle;\n\n\tvoid MoveRandomly();\n};\n```", "cpp_code": "```cpp\n#include \"RandomMover.h\"\n#include \"TimerManager.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\n// Sets default values\nARandomMover::ARandomMover()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ARandomMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Set timer to call MoveRandomly every second\n\tGetWorldTimerManager().SetTimer(MovementTimerHandle, this, &ARandomMover::MoveRandomly, 1.0f, true);\n}\n\n// Called every frame\nvoid ARandomMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Move the actor to a random location\nvoid ARandomMover::MoveRandomly()\n{\n\tFVector NewLocation = UKismetMathLibrary::RandomUnitVector() * 100.0f + GetActorLocation();\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a dynamic material instance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Materials\")\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nAYourActor::AYourActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Example of initializing the dynamic material instance\n\tUMaterialInterface* Material = LoadObject<UMaterialInterface>(nullptr, TEXT(\"/Game/YourMaterialPath.YourMaterialName\"));\n\tif (Material)\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(Material, this);\n\t}\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that reports its scale every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleReporter.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleReporter : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAScaleReporter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ReportScale() const;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleReporter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n\n// Sets default values\nAScaleReporter::AScaleReporter()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AScaleReporter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScaleReporter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tReportScale();\n}\n\nvoid AScaleReporter::ReportScale() const\n{\n\tFVector Scale = GetActorScale3D();\n\tUE_LOG(LogTemp, Log, TEXT(\"Scale: X=%f, Y=%f, Z=%f\"), Scale.X, Scale.Y, Scale.Z);\n}\n```"}
{"requirement": "Create an actor that changes light intensity over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightIntensityChanger.generated.h\"\n\nUCLASS()\nclass ALightIntensityChanger : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  ALightIntensityChanger();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Light\")\n  class UPointLightComponent* PointLight;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Light\")\n  float IntensityChangeRate;\n};\n```", "cpp_code": "```cpp\n#include \"LightIntensityChanger.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nALightIntensityChanger::ALightIntensityChanger()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  PointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n  RootComponent = PointLight;\n\n  IntensityChangeRate = 50.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ALightIntensityChanger::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid ALightIntensityChanger::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  if (PointLight)\n  {\n\tfloat NewIntensity = PointLight->Intensity + (IntensityChangeRate * DeltaTime);\n\tPointLight->SetIntensity(NewIntensity);\n  }\n}\n```"}
{"requirement": "Create a simple torus actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TorusActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATorusActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATorusActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Torus mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* TorusMesh;\n};\n```", "cpp_code": "```cpp\n#include \"TorusActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nATorusActor::ATorusActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set the static mesh component\n\tTorusMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"TorusMesh\"));\n\tRootComponent = TorusMesh;\n\n\t// Find the torus mesh asset\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> TorusAsset(TEXT(\"/Engine/BasicShapes/Torus.Torus\"));\n\tif (TorusAsset.Succeeded())\n\t{\n\t\tTorusMesh->SetStaticMesh(TorusAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ATorusActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATorusActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY FText variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"My Category\")\n\tFText MyTextVariable;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes location with a timeline.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"LocationTimelineActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALocationTimelineActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALocationTimelineActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFTimeline LocationTimeline;\n\n\tUFUNCTION()\n\tvoid HandleProgress(float Value);\n\n\tUPROPERTY(EditAnywhere, Category = \"Timeline\")\n\tUCurveFloat* LocationCurve;\n\n\tFVector StartLocation;\n\tFVector EndLocation;\n};\n```", "cpp_code": "```cpp\n#include \"LocationTimelineActor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nALocationTimelineActor::ALocationTimelineActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALocationTimelineActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (LocationCurve)\n\t{\n\t\tFOnTimelineFloat ProgressFunction;\n\t\tProgressFunction.BindUFunction(this, FName(\"HandleProgress\"));\n\n\t\tLocationTimeline.AddInterpFloat(LocationCurve, ProgressFunction);\n\t\tLocationTimeline.SetLooping(false);\n\n\t\tStartLocation = GetActorLocation();\n\t\tEndLocation = StartLocation + FVector(100.0f, 0.0f, 0.0f); // Example end location\n\n\t\tLocationTimeline.PlayFromStart();\n\t}\n}\n\n// Called every frame\nvoid ALocationTimelineActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tLocationTimeline.TickTimeline(DeltaTime);\n}\n\nvoid ALocationTimelineActor::HandleProgress(float Value)\n{\n\tFVector NewLocation = FMath::Lerp(StartLocation, EndLocation, Value);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a component that logs its parent actor's name.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LogParentActorComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API ULogParentActorComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tULogParentActorComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"LogParentActorComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values for this component's properties\nULogParentActorComponent::ULogParentActorComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid ULogParentActorComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Parent Actor Name: %s\"), *Owner->GetName());\n\t}\n}\n```"}
{"requirement": "Create an actor that plays an animation on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"AnimationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAnimationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAAnimationActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Animation\")\n\tUAnimSequence* AnimationToPlay;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Animation\")\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n\n\tvoid PlayAnimation();\n\nprotected:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n};\n```", "cpp_code": "```cpp\n#include \"AnimationActor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/InputSettings.h\"\n\nAAnimationActor::AAnimationActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n}\n\nvoid AAnimationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tEnableInput(PlayerController);\n\t\tSetupPlayerInputComponent(InputComponent);\n\t}\n}\n\nvoid AAnimationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AAnimationActor::PlayAnimation()\n{\n\tif (SkeletalMeshComponent && AnimationToPlay)\n\t{\n\t\tSkeletalMeshComponent->PlayAnimation(AnimationToPlay, false);\n\t}\n}\n\nvoid AAnimationActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"PlayAnimation\", IE_Pressed, this, &AAnimationActor::PlayAnimation);\n\t}\n}\n```"}
{"requirement": "Create a class that rotates to face a specified direction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Rotation\")\n\tvoid RotateToFaceDirection(const FVector& TargetDirection);\n\nprivate:\n\tFVector CurrentDirection;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tCurrentDirection = GetActorForwardVector();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARotatingActor::RotateToFaceDirection(const FVector& TargetDirection)\n{\n\tif (!TargetDirection.IsNearlyZero())\n\t{\n\t\tFRotator TargetRotation = UKismetMathLibrary::MakeRotFromX(TargetDirection);\n\t\tSetActorRotation(TargetRotation);\n\t\tCurrentDirection = TargetDirection;\n\t}\n}\n```"}
{"requirement": "Create an actor that orbits another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OrbitingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOrbitingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOrbitingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAActor* TargetActor;\n\tfloat OrbitRadius;\n\tfloat OrbitSpeed;\n\tfloat CurrentAngle;\n\npublic:\n\tvoid SetTargetActor(AActor* NewTarget);\n\tvoid SetOrbitRadius(float NewRadius);\n\tvoid SetOrbitSpeed(float NewSpeed);\n};\n```", "cpp_code": "```cpp\n#include \"OrbitingActor.h\"\n\nAOrbitingActor::AOrbitingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tTargetActor = nullptr;\n\tOrbitRadius = 300.0f;\n\tOrbitSpeed = 50.0f;\n\tCurrentAngle = 0.0f;\n}\n\nvoid AOrbitingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOrbitingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tCurrentAngle += OrbitSpeed * DeltaTime;\n\t\tif (CurrentAngle >= 360.0f)\n\t\t{\n\t\t\tCurrentAngle -= 360.0f;\n\t\t}\n\n\t\tfloat RadAngle = FMath::DegreesToRadians(CurrentAngle);\n\t\tFVector NewLocation = TargetActor->GetActorLocation();\n\t\tNewLocation.X += OrbitRadius * FMath::Cos(RadAngle);\n\t\tNewLocation.Y += OrbitRadius * FMath::Sin(RadAngle);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n\nvoid AOrbitingActor::SetTargetActor(AActor* NewTarget)\n{\n\tTargetActor = NewTarget;\n}\n\nvoid AOrbitingActor::SetOrbitRadius(float NewRadius)\n{\n\tOrbitRadius = NewRadius;\n}\n\nvoid AOrbitingActor::SetOrbitSpeed(float NewSpeed)\n{\n\tOrbitSpeed = NewSpeed;\n}\n```"}
{"requirement": "Create an actor that moves in a zig-zag pattern.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ZigZagActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AZigZagActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAZigZagActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector StartLocation;\n\tfloat MoveSpeed;\n\tfloat ZigZagAmplitude;\n\tfloat ZigZagFrequency;\n\tfloat RunningTime;\n};\n```", "cpp_code": "```cpp\n#include \"ZigZagActor.h\"\n\nAZigZagActor::AZigZagActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMoveSpeed = 100.0f;\n\tZigZagAmplitude = 100.0f;\n\tZigZagFrequency = 1.0f;\n\tRunningTime = 0.0f;\n}\n\nvoid AZigZagActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartLocation = GetActorLocation();\n}\n\nvoid AZigZagActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tRunningTime += DeltaTime;\n\tFVector NewLocation = StartLocation;\n\tNewLocation.X += MoveSpeed * RunningTime;\n\tNewLocation.Y += ZigZagAmplitude * FMath::Sin(ZigZagFrequency * RunningTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a simple tetrahedron actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TetrahedronActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ATetrahedronActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATetrahedronActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUProceduralMeshComponent* Mesh;\n\n\tvoid CreateTetrahedron();\n};\n```", "cpp_code": "```cpp\n#include \"TetrahedronActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\n// Sets default values\nATetrahedronActor::ATetrahedronActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"TetrahedronMesh\"));\n\tRootComponent = Mesh;\n\n\tCreateTetrahedron();\n}\n\n// Called when the game starts or when spawned\nvoid ATetrahedronActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATetrahedronActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATetrahedronActor::CreateTetrahedron()\n{\n\tTArray<FVector> Vertices;\n\tTArray<int32> Triangles;\n\n\t// Define vertices for a tetrahedron\n\tVertices.Add(FVector(0, 0, 0));  // Vertex 0\n\tVertices.Add(FVector(100, 0, 0));  // Vertex 1\n\tVertices.Add(FVector(50, 87, 0));  // Vertex 2\n\tVertices.Add(FVector(50, 29, 80));  // Vertex 3\n\n\t// Define triangles\n\tTriangles.Add(0);\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\n\tTriangles.Add(0);\n\tTriangles.Add(1);\n\tTriangles.Add(3);\n\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\tTriangles.Add(3);\n\n\tTriangles.Add(2);\n\tTriangles.Add(0);\n\tTriangles.Add(3);\n\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\tTArray<FProcMeshTangent> Tangents;\n\tTArray<FColor> VertexColors;\n\n\tMesh->CreateMeshSection_LinearColor(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a pointer to a player controller.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY()\n\tAPlayerController* PlayerController;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that creates a light beam.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightBeamActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALightBeamActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALightBeamActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* BeamMesh;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUSpotLightComponent* LightBeam;\n};\n```", "cpp_code": "```cpp\n#include \"LightBeamActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/SpotLightComponent.h\"\n\n// Sets default values\nALightBeamActor::ALightBeamActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component\n\tBeamMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"BeamMesh\"));\n\tRootComponent = BeamMesh;\n\n\t// Create light component\n\tLightBeam = CreateDefaultSubobject<USpotLightComponent>(TEXT(\"LightBeam\"));\n\tLightBeam->SetupAttachment(RootComponent);\n\tLightBeam->Intensity = 5000.0f;\n\tLightBeam->AttenuationRadius = 1000.0f;\n\tLightBeam->OuterConeAngle = 25.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ALightBeamActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALightBeamActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a component that checks for overlaps.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"OverlapCheckerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UOverlapCheckerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUOverlapCheckerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n\nprivate:\n\tUPROPERTY()\n\tUPrimitiveComponent* OwnerPrimitive;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapCheckerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUOverlapCheckerComponent::UOverlapCheckerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UOverlapCheckerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwnerPrimitive = Owner->FindComponentByClass<UPrimitiveComponent>();\n\t\tif (OwnerPrimitive)\n\t\t{\n\t\t\tOwnerPrimitive->OnComponentBeginOverlap.AddDynamic(this, &UOverlapCheckerComponent::OnOverlapBegin);\n\t\t\tOwnerPrimitive->OnComponentEndOverlap.AddDynamic(this, &UOverlapCheckerComponent::OnOverlapEnd);\n\t\t}\n\t}\n}\n\nvoid UOverlapCheckerComponent::OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && (OtherActor != GetOwner()))\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlap Begin with %s\"), *OtherActor->GetName());\n\t}\n}\n\nvoid UOverlapCheckerComponent::OnOverlapEnd(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (OtherActor && (OtherActor != GetOwner()))\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlap End with %s\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Create a class with a custom destructor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n\nclass FMyCustomClass\n{\npublic:\n\tFMyCustomClass();\n\t~FMyCustomClass();\n};\n```", "cpp_code": "```cpp\n#include \"MyCustomClass.h\"\n\nFMyCustomClass::FMyCustomClass()\n{\n\t// Constructor logic\n}\n\nFMyCustomClass::~FMyCustomClass()\n{\n\t// Custom destructor logic\n}\n```"}
{"requirement": "Create an actor that stops moving after a collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionStopActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionStopActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tACollisionStopActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called when the actor hits something\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector MovementVelocity;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionStopActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nACollisionStopActor::ACollisionStopActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->OnComponentHit.AddDynamic(this, &ACollisionStopActor::OnHit);\n\n\tMovementVelocity = FVector(100.0f, 0.0f, 0.0f); // Example initial velocity\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionStopActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionStopActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!MovementVelocity.IsZero())\n\t{\n\t\tFVector NewLocation = GetActorLocation() + (MovementVelocity * DeltaTime);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n\nvoid ACollisionStopActor::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\t// Stop movement upon collision\n\tMovementVelocity = FVector::ZeroVector;\n}\n```"}
{"requirement": "Create a UPROPERTY FColor variable in an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Color\")\n\tFColor MyColor;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\t// Set default values\n\tMyColor = FColor::White;\n}\n```"}
{"requirement": "Create an actor that changes mesh every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MeshChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMeshChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMeshChangeActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tTArray<UStaticMesh*> Meshes;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tint32 CurrentMeshIndex;\n\tfloat TimeSinceLastChange;\n};\n```", "cpp_code": "```cpp\n#include \"MeshChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nAMeshChangeActor::AMeshChangeActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tCurrentMeshIndex = 0;\n\tTimeSinceLastChange = 0.0f;\n}\n\nvoid AMeshChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Meshes.Num() > 0)\n\t{\n\t\tMeshComponent->SetStaticMesh(Meshes[CurrentMeshIndex]);\n\t}\n}\n\nvoid AMeshChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (Meshes.Num() > 0)\n\t{\n\t\tTimeSinceLastChange += DeltaTime;\n\t\tif (TimeSinceLastChange >= 1.0f)\n\t\t{\n\t\t\tTimeSinceLastChange = 0.0f;\n\t\t\tCurrentMeshIndex = (CurrentMeshIndex + 1) % Meshes.Num();\n\t\t\tMeshComponent->SetStaticMesh(Meshes[CurrentMeshIndex]);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a component that can be toggled on/off with a key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleableComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UToggleableComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUToggleableComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void SetupInputComponent();\n\n\tUFUNCTION()\n\tvoid ToggleActive();\n\nprivate:\n\tbool bIsActive;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleableComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nUToggleableComponent::UToggleableComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbIsActive = true;\n}\n\nvoid UToggleableComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetupInputComponent();\n}\n\nvoid UToggleableComponent::SetupInputComponent()\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tInputComponent = NewObject<UInputComponent>(this);\n\t\tInputComponent->RegisterComponent();\n\t\tInputComponent->BindAction(\"ToggleComponent\", IE_Pressed, this, &UToggleableComponent::ToggleActive);\n\t\tPlayerController->PushInputComponent(InputComponent);\n\t}\n}\n\nvoid UToggleableComponent::ToggleActive()\n{\n\tbIsActive = !bIsActive;\n\tSetComponentTickEnabled(bIsActive);\n\tUE_LOG(LogTemp, Warning, TEXT(\"Component is now %s\"), bIsActive ? TEXT(\"Active\") : TEXT(\"Inactive\"));\n}\n```"}
{"requirement": "Create a UFUNCTION to set an actor's scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScaleActor();\n\n\tUFUNCTION(BlueprintCallable, Category=\"ActorScale\")\n\tvoid SetActorScale(FVector NewScale);\n};\n```", "cpp_code": "```cpp\n#include \"ScaleActor.h\"\n\nAScaleActor::AScaleActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AScaleActor::SetActorScale(FVector NewScale)\n{\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create an actor that follows a spline path.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SplineComponent.h\"\n#include \"SplineFollowerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ASplineFollowerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tASplineFollowerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUSplineComponent* SplineComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Spline\")\n\tfloat Speed = 100.0f;\n\n\tfloat DistanceAlongSpline;\n};\n```", "cpp_code": "```cpp\n#include \"SplineFollowerActor.h\"\n#include \"Components/SplineComponent.h\"\n\nASplineFollowerActor::ASplineFollowerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSplineComponent = CreateDefaultSubobject<USplineComponent>(TEXT(\"SplineComponent\"));\n\tRootComponent = SplineComponent;\n\n\tDistanceAlongSpline = 0.0f;\n}\n\nvoid ASplineFollowerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASplineFollowerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (SplineComponent)\n\t{\n\t\tDistanceAlongSpline += Speed * DeltaTime;\n\t\tconst float SplineLength = SplineComponent->GetSplineLength();\n\t\tif (DistanceAlongSpline > SplineLength)\n\t\t{\n\t\t\tDistanceAlongSpline = 0.0f;\n\t\t}\n\n\t\tconst FVector NewLocation = SplineComponent->GetLocationAtDistanceAlongSpline(DistanceAlongSpline, ESplineCoordinateSpace::World);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create a simple icosahedron actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"IcosahedronActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AIcosahedronActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAIcosahedronActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* IcosahedronMesh;\n};\n```", "cpp_code": "```cpp\n#include \"IcosahedronActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAIcosahedronActor::AIcosahedronActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tIcosahedronMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"IcosahedronMesh\"));\n\tRootComponent = IcosahedronMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> IcosahedronAsset(TEXT(\"/Engine/BasicShapes/Icosahedron.Icosahedron\"));\n\tif (IcosahedronAsset.Succeeded())\n\t{\n\t\tIcosahedronMesh->SetStaticMesh(IcosahedronAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AIcosahedronActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AIcosahedronActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a sound cue.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"MySoundActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMySoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMySoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundCue* SoundCueReference;\n};\n```", "cpp_code": "```cpp\n#include \"MySoundActor.h\"\n\n// Sets default values\nAMySoundActor::AMySoundActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMySoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMySoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create an actor that changes its material every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUMaterialInterface* CurrentMaterial;\n\tTArray<UMaterialInterface*> MaterialList;\n\tint32 MaterialIndex;\n\n\tvoid InitializeMaterials();\n};\n```", "cpp_code": "```cpp\n#include \"MaterialChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMaterialChangingActor::AMaterialChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMaterialIndex = 0;\n\n\tInitializeMaterials();\n}\n\nvoid AMaterialChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMaterialChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (MaterialList.Num() > 0)\n\t{\n\t\tMaterialIndex = (MaterialIndex + 1) % MaterialList.Num();\n\t\tCurrentMaterial = MaterialList[MaterialIndex];\n\n\t\tUStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tMeshComponent->SetMaterial(0, CurrentMaterial);\n\t\t}\n\t}\n}\n\nvoid AMaterialChangingActor::InitializeMaterials()\n{\n\t// Example of adding materials. Replace with your actual materials.\n\tConstructorHelpers::FObjectFinder<UMaterialInterface> Material1(TEXT(\"/Game/Materials/Material1.Material1\"));\n\tConstructorHelpers::FObjectFinder<UMaterialInterface> Material2(TEXT(\"/Game/Materials/Material2.Material2\"));\n\n\tif (Material1.Succeeded())\n\t{\n\t\tMaterialList.Add(Material1.Object);\n\t}\n\n\tif (Material2.Succeeded())\n\t{\n\t\tMaterialList.Add(Material2.Object);\n\t}\n}\n```"}
{"requirement": "Create a component that changes mesh based on UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"MeshChangerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UMeshChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUMeshChangerComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\t// UPROPERTY to change the mesh\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mesh\")\n\tUStaticMesh* NewMesh;\n\n\t// Function to change the mesh\n\tUFUNCTION(BlueprintCallable, Category = \"Mesh\")\n\tvoid ChangeMesh();\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MeshChangerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values for this component's properties\nUMeshChangerComponent::UMeshChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\n// Called when the game starts\nvoid UMeshChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tMeshComponent = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t}\n}\n\n// Called every frame\nvoid UMeshChangerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UMeshChangerComponent::ChangeMesh()\n{\n\tif (MeshComponent && NewMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(NewMesh);\n\t}\n}\n```"}
{"requirement": "Create an actor with a visual effect component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VisualEffectActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVisualEffectActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAVisualEffectActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Visual effect component\n\tUParticleSystemComponent* VisualEffectComponent;\n};\n```", "cpp_code": "```cpp\n#include \"VisualEffectActor.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n\n// Sets default values\nAVisualEffectActor::AVisualEffectActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach the visual effect component\n\tVisualEffectComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"VisualEffectComponent\"));\n\tRootComponent = VisualEffectComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AVisualEffectActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AVisualEffectActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that adjusts its transparency over time.", "header_code": "```cpp\nUCLASS()\nclass YOURPROJECT_API ATransparencyAdjuster : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATransparencyAdjuster();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat TransparencyChangeRate;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\n\tfloat CurrentOpacity;\n};\n```", "cpp_code": "```cpp\n#include \"TransparencyAdjuster.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nATransparencyAdjuster::ATransparencyAdjuster()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTransparencyChangeRate = 0.1f;\n\tCurrentOpacity = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ATransparencyAdjuster::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tUStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInterface* Material = MeshComponent->GetMaterial(0);\n\t\tif (Material)\n\t\t{\n\t\t\tDynamicMaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamicFromMaterial(0, Material);\n\t\t}\n\t}\n}\n\n// Called every frame\nvoid ATransparencyAdjuster::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterialInstance)\n\t{\n\t\tCurrentOpacity -= TransparencyChangeRate * DeltaTime;\n\t\tif (CurrentOpacity < 0.0f)\n\t\t{\n\t\t\tCurrentOpacity = 0.0f;\n\t\t}\n\t\tDynamicMaterialInstance->SetScalarParameterValue(TEXT(\"Opacity\"), CurrentOpacity);\n\t}\n}\n```"}
{"requirement": "Create an actor that can be picked up on click.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PickupActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APickupActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPickupActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"PickupActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nAPickupActor::APickupActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetSimulatePhysics(true);\n\tMeshComponent->OnClicked.AddDynamic(this, &APickupActor::OnClicked);\n}\n\nvoid APickupActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APickupActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APickupActor::OnClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed)\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tFVector Location;\n\t\tFRotator Rotation;\n\t\tPlayerController->GetPlayerViewPoint(Location, Rotation);\n\n\t\tFVector ForwardVector = Rotation.Vector();\n\t\tFVector PickupLocation = Location + ForwardVector * 200.f;\n\n\t\tMeshComponent->SetWorldLocation(PickupLocation);\n\t}\n}\n```"}
{"requirement": "Create an actor that moves with a sine wave pattern.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SineWaveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASineWaveActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tASineWaveActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialLocation;\n\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Amplitude;\n\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Frequency;\n\n\tfloat RunningTime;\n};\n```", "cpp_code": "```cpp\n#include \"SineWaveActor.h\"\n\nASineWaveActor::ASineWaveActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tAmplitude = 100.0f;\n\tFrequency = 1.0f;\n\tRunningTime = 0.0f;\n}\n\nvoid ASineWaveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialLocation = GetActorLocation();\n}\n\nvoid ASineWaveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRunningTime += DeltaTime;\n\tfloat DeltaHeight = Amplitude * FMath::Sin(Frequency * RunningTime);\n\tFVector NewLocation = InitialLocation;\n\tNewLocation.Z += DeltaHeight;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a simple dodecahedron actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DodecahedronActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADodecahedronActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tADodecahedronActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* DodecahedronMesh;\n};\n```", "cpp_code": "```cpp\n#include \"DodecahedronActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nADodecahedronActor::ADodecahedronActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tDodecahedronMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"DodecahedronMesh\"));\n\tRootComponent = DodecahedronMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Engine/BasicShapes/Dodecahedron.Dodecahedron'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tDodecahedronMesh->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ADodecahedronActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADodecahedronActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a light component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Components/LightComponent.h\"\n#include \"MyLightComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass MYPROJECT_API UMyLightComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUMyLightComponent();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light\")\n\tULightComponent* LightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyLightComponent.h\"\n\nUMyLightComponent::UMyLightComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n```"}
{"requirement": "Create an actor that changes its shape with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ShapeShifter.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AShapeShifter : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAShapeShifter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ChangeShape();\n\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMesh* CubeMesh;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMesh* SphereMesh;\n\n\tbool bIsCube;\n\n\tvoid SetupInputComponent();\n\n};\n```", "cpp_code": "```cpp\n#include \"ShapeShifter.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAShapeShifter::AShapeShifter()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> CubeMeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> SphereMeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere\"));\n\n\tif (CubeMeshAsset.Succeeded())\n\t{\n\t\tCubeMesh = CubeMeshAsset.Object;\n\t}\n\n\tif (SphereMeshAsset.Succeeded())\n\t{\n\t\tSphereMesh = SphereMeshAsset.Object;\n\t}\n\n\tbIsCube = true;\n\tMeshComponent->SetStaticMesh(CubeMesh);\n}\n\n// Called when the game starts or when spawned\nvoid AShapeShifter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tSetupInputComponent();\n}\n\nvoid AShapeShifter::SetupInputComponent()\n{\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tEnableInput(PlayerController);\n\t\tInputComponent->BindAction(\"ChangeShape\", IE_Pressed, this, &AShapeShifter::ChangeShape);\n\t}\n}\n\n// Called every frame\nvoid AShapeShifter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AShapeShifter::ChangeShape()\n{\n\tbIsCube = !bIsCube;\n\n\tif (bIsCube)\n\t{\n\t\tMeshComponent->SetStaticMesh(CubeMesh);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetStaticMesh(SphereMesh);\n\t}\n}\n```"}
{"requirement": "Create a component that emits particles on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"ParticleEmitterComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UParticleEmitterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUParticleEmitterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void OnComponentHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\n\tUPROPERTY(EditAnywhere, Category=\"Effects\")\n\tUParticleSystem* ParticleEffect;\n};\n```", "cpp_code": "```cpp\n#include \"ParticleEmitterComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nUParticleEmitterComponent::UParticleEmitterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UParticleEmitterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif(AActor* Owner = GetOwner())\n\t{\n\t\tif(UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(Owner->GetComponentByClass(UPrimitiveComponent::StaticClass())))\n\t\t{\n\t\t\tPrimitiveComponent->OnComponentHit.AddDynamic(this, &UParticleEmitterComponent::OnComponentHit);\n\t\t}\n\t}\n}\n\nvoid UParticleEmitterComponent::OnComponentHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif(ParticleEffect)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ParticleEffect, Hit.ImpactPoint, FRotator::ZeroRotator);\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a particle system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"MyParticleActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyParticleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyParticleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Particles\")\n\tUParticleSystem* ParticleSystemReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyParticleActor.h\"\n\n// Sets default values\nAMyParticleActor::AMyParticleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyParticleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyParticleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create an actor that deactivates on a specific key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DeactivatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ADeactivatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADeactivatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Function to handle deactivation\n\tvoid DeactivateActor();\n};\n```", "cpp_code": "```cpp\n#include \"DeactivatingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nADeactivatingActor::ADeactivatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ADeactivatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind the input action\n\tif (APlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0))\n\t{\n\t\tInputComponent = NewObject<UInputComponent>(this);\n\t\tInputComponent->RegisterComponent();\n\t\tInputComponent->BindAction(\"Deactivate\", IE_Pressed, this, &ADeactivatingActor::DeactivateActor);\n\t\tPlayerController->PushInputComponent(InputComponent);\n\t}\n}\n\n// Called every frame\nvoid ADeactivatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle deactivation\nvoid ADeactivatingActor::DeactivateActor()\n{\n\tSetActorTickEnabled(false);\n\tSetActorHiddenInGame(true);\n\tSetActorEnableCollision(false);\n}\n```"}
{"requirement": "Create a class that changes location based on keyboard input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMovableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyMovableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyMovableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Input functions\n\tvoid MoveForward(float Value);\n\tvoid MoveRight(float Value);\n\n\t// Movement speed\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MovementSpeed;\n\nprivate:\n\t// Input component\n\tUInputComponent* InputComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyMovableActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAMyMovableActor::AMyMovableActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize movement speed\n\tMovementSpeed = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMyMovableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind input functions\n\tInputComponent = NewObject<UInputComponent>(this);\n\tInputComponent->BindAxis(\"MoveForward\", this, &AMyMovableActor::MoveForward);\n\tInputComponent->BindAxis(\"MoveRight\", this, &AMyMovableActor::MoveRight);\n\tInputComponent->RegisterComponent();\n}\n\n// Called every frame\nvoid AMyMovableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Add any custom tick logic here\n}\n\nvoid AMyMovableActor::MoveForward(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tFVector Direction = FVector::ForwardVector;\n\t\tAddActorLocalOffset(Direction * Value * MovementSpeed * GetWorld()->GetDeltaSeconds(), true);\n\t}\n}\n\nvoid AMyMovableActor::MoveRight(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tFVector Direction = FVector::RightVector;\n\t\tAddActorLocalOffset(Direction * Value * MovementSpeed * GetWorld()->GetDeltaSeconds(), true);\n\t}\n}\n```"}
{"requirement": "Create an actor with a mesh that fades over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FadingMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFadingMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFadingMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Fading\")\n\tfloat FadeDuration;\n\n\tfloat CurrentFadeTime;\n};\n```", "cpp_code": "```cpp\n#include \"FadingMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nAFadingMeshActor::AFadingMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tFadeDuration = 5.0f;\n\tCurrentFadeTime = 0.0f;\n}\n\nvoid AFadingMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AFadingMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (CurrentFadeTime < FadeDuration)\n\t{\n\t\tCurrentFadeTime += DeltaTime;\n\t\tfloat Alpha = 1.0f - (CurrentFadeTime / FadeDuration);\n\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\t\tif (DynamicMaterial)\n\t\t\t{\n\t\t\t\tDynamicMaterial->SetScalarParameterValue(\"Opacity\", Alpha);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a simple helix actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HelixActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AHelixActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAHelixActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Helix\")\n\tfloat Radius = 100.0f;\n\n\tUPROPERTY(EditAnywhere, Category=\"Helix\")\n\tfloat Height = 200.0f;\n\n\tUPROPERTY(EditAnywhere, Category=\"Helix\")\n\tint32 NumPoints = 100;\n\n\tUPROPERTY(EditAnywhere, Category=\"Helix\")\n\tUStaticMeshComponent* HelixMesh;\n};\n```", "cpp_code": "```cpp\n#include \"HelixActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nAHelixActor::AHelixActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHelixMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"HelixMesh\"));\n\tRootComponent = HelixMesh;\n}\n\nvoid AHelixActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tTArray<FVector> HelixPoints;\n\tfor (int32 i = 0; i < NumPoints; ++i)\n\t{\n\t\tfloat Angle = i * 2 * PI / NumPoints;\n\t\tfloat X = Radius * FMath::Cos(Angle);\n\t\tfloat Y = Radius * FMath::Sin(Angle);\n\t\tfloat Z = (Height / NumPoints) * i;\n\t\tHelixPoints.Add(FVector(X, Y, Z));\n\t}\n\n\t// Logic to use HelixPoints to create a visual helix can be added here\n}\n\nvoid AHelixActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Any dynamic updates to the helix can be added here\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a blueprint class.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"BlueprintClass\")\n\tTSubclassOf<AActor> BlueprintClassReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes sound pitch over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"SoundPitchChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPitchChanger : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tASoundPitchChanger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUAudioComponent* AudioComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Pitch\")\n\tfloat PitchChangeRate;\n};\n```", "cpp_code": "```cpp\n#include \"SoundPitchChanger.h\"\n\n// Sets default values\nASoundPitchChanger::ASoundPitchChanger()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tRootComponent = AudioComponent;\n\n\tPitchChangeRate = 0.1f; // default pitch change rate\n}\n\n// Called when the game starts or when spawned\nvoid ASoundPitchChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AudioComponent->Sound)\n\t{\n\t\tAudioComponent->Play();\n\t}\n}\n\n// Called every frame\nvoid ASoundPitchChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (AudioComponent->IsPlaying())\n\t{\n\t\tfloat NewPitch = AudioComponent->PitchMultiplier + PitchChangeRate * DeltaTime;\n\t\tAudioComponent->SetPitchMultiplier(NewPitch);\n\t}\n}\n```"}
{"requirement": "Create a component that can be activated with a trigger.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TriggerActivatableComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTriggerActivatableComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUTriggerActivatableComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category=\"Activation\")\n\tvoid ActivateComponent();\n\n\tUFUNCTION()\n\tvoid OnTriggerEnter();\n\nprivate:\n\tbool bIsActive;\n};\n```", "cpp_code": "```cpp\n#include \"TriggerActivatableComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUTriggerActivatableComponent::UTriggerActivatableComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbIsActive = false;\n}\n\nvoid UTriggerActivatableComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Assuming a trigger event is set up in the game environment\n\t// OnTriggerEnter would be bound to the actual event\n}\n\nvoid UTriggerActivatableComponent::ActivateComponent()\n{\n\tif (!bIsActive)\n\t{\n\t\tbIsActive = true;\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Component Activated\"));\n\t}\n}\n\nvoid UTriggerActivatableComponent::OnTriggerEnter()\n{\n\tActivateComponent();\n}\n```"}
{"requirement": "Create an actor with a looping sound effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"LoopingSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoopingSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoopingSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundCue;\n\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"LoopingSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n\n// Sets default values\nALoopingSoundActor::ALoopingSoundActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->bAutoActivate = false; // Prevent it from starting automatically\n\tRootComponent = AudioComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ALoopingSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (SoundCue)\n\t{\n\t\tAudioComponent->SetSound(SoundCue);\n\t\tAudioComponent->Play();\n\t\tAudioComponent->bIsUISound = false;\n\t\tAudioComponent->bLooping = true; // Set looping to true\n\t}\n}\n\n// Called every frame\nvoid ALoopingSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that toggles between two meshes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Mesh\")\n\tvoid ToggleMesh();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMesh* Mesh1;\n\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMesh* Mesh2;\n\n\tbool bIsMesh1Active;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleMeshActor.h\"\n\n// Sets default values\nAToggleMeshActor::AToggleMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tbIsMesh1Active = true;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Mesh1)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh1);\n\t}\n}\n\n// Called every frame\nvoid AToggleMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleMeshActor::ToggleMesh()\n{\n\tif (bIsMesh1Active && Mesh2)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh2);\n\t\tbIsMesh1Active = false;\n\t}\n\telse if (!bIsMesh1Active && Mesh1)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh1);\n\t\tbIsMesh1Active = true;\n\t}\n}\n```"}
{"requirement": "Create an actor that slides on a surface.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SlidingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASlidingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASlidingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat SlideSpeed;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector SlideDirection;\n\n\tvoid Slide(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"SlidingActor.h\"\n\n// Sets default values\nASlidingActor::ASlidingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSlideSpeed = 200.0f;\n\tSlideDirection = FVector(1.0f, 0.0f, 0.0f); // Slide along the X-axis by default\n}\n\n// Called when the game starts or when spawned\nvoid ASlidingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASlidingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tSlide(DeltaTime);\n}\n\nvoid ASlidingActor::Slide(float DeltaTime)\n{\n\tFVector NewLocation = GetActorLocation() + (SlideDirection * SlideSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a simple knot actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"KnotActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AKnotActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAKnotActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* KnotMesh;\n};\n```", "cpp_code": "```cpp\n#include \"KnotActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAKnotActor::AKnotActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the static mesh component\n\tKnotMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"KnotMesh\"));\n\tRootComponent = KnotMesh;\n\n\t// Load a simple knot mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> KnotMeshAsset(TEXT(\"StaticMesh'/Game/Geometry/Meshes/SimpleKnot.SimpleKnot'\"));\n\tif (KnotMeshAsset.Succeeded())\n\t{\n\t\tKnotMesh->SetStaticMesh(KnotMeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AKnotActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AKnotActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a camera actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Camera\")\n\tACameraActor* CameraActor;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its location with a timer.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"LocationChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALocationChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALocationChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFTimerHandle LocationChangeTimerHandle;\n\n\tvoid ChangeLocation();\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tFVector LocationOffset;\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat TimerInterval;\n};\n```", "cpp_code": "```cpp\n#include \"LocationChangingActor.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nALocationChangingActor::ALocationChangingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tLocationOffset = FVector(100.f, 0.f, 0.f);\n\tTimerInterval = 1.0f; // Default to change location every second\n}\n\n// Called when the game starts or when spawned\nvoid ALocationChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGetWorldTimerManager().SetTimer(LocationChangeTimerHandle, this, &ALocationChangingActor::ChangeLocation, TimerInterval, true);\n}\n\n// Called every frame\nvoid ALocationChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ALocationChangingActor::ChangeLocation()\n{\n\tFVector NewLocation = GetActorLocation() + LocationOffset;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a component that changes light color on activation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LightColorChangerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API ULightColorChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tULightColorChangerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION(BlueprintCallable, Category=\"Light\")\n\tvoid ChangeLightColor();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Light\")\n\tFLinearColor NewLightColor;\n};\n```", "cpp_code": "```cpp\n#include \"LightColorChangerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PointLightComponent.h\"\n\nULightColorChangerComponent::ULightColorChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid ULightColorChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ULightColorChangerComponent::ChangeLightColor()\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUPointLightComponent* LightComponent = Owner->FindComponentByClass<UPointLightComponent>();\n\t\tif (LightComponent)\n\t\t{\n\t\t\tLightComponent->SetLightColor(NewLightColor);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomMaterialActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Customizable material property\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Custom\")\n\tUMaterialInterface* CustomMaterial;\n\nprivate:\n\t// Static mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CustomMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nACustomMaterialActor::ACustomMaterialActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set up the static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Allow the material to be customized\n\tCustomMaterial = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Apply the custom material if it's set\n\tif (CustomMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, CustomMaterial);\n\t}\n}\n\n// Called every frame\nvoid ACustomMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that changes its dimension over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResizableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResizableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAResizableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialScale;\n\tfloat TimeElapsed;\n\n\tUPROPERTY(EditAnywhere, Category=\"Resize\")\n\tfloat ResizeSpeed = 1.0f;\n\n\tUPROPERTY(EditAnywhere, Category=\"Resize\")\n\tfloat MaxScaleMultiplier = 2.0f;\n};\n```", "cpp_code": "```cpp\n#include \"ResizableActor.h\"\n\n// Sets default values\nAResizableActor::AResizableActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tInitialScale = FVector(1.0f, 1.0f, 1.0f);\n\tTimeElapsed = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AResizableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tInitialScale = GetActorScale3D();\n}\n\n// Called every frame\nvoid AResizableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeElapsed += DeltaTime;\n\n\tfloat ScaleFactor = FMath::Sin(ResizeSpeed * TimeElapsed) * 0.5f + 0.5f; // Generates a value between 0 and 1\n\tFVector NewScale = InitialScale * FMath::Lerp(1.0f, MaxScaleMultiplier, ScaleFactor);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create an actor that toggles between two colors.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAColorToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tFLinearColor Color1;\n\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tFLinearColor Color2;\n\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tfloat ToggleInterval;\n\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\tfloat TimeSinceLastToggle;\n\tbool bUseColor1;\n\n\tvoid ToggleColor();\n};\n```", "cpp_code": "```cpp\n#include \"ColorToggleActor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nAColorToggleActor::AColorToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tColor1 = FLinearColor::Red;\n\tColor2 = FLinearColor::Blue;\n\tToggleInterval = 1.0f;\n\tTimeSinceLastToggle = 0.0f;\n\tbUseColor1 = true;\n\n\tUStaticMeshComponent* MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tDynamicMaterial = UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this);\n\tMeshComponent->SetMaterial(0, DynamicMaterial);\n}\n\nvoid AColorToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tToggleColor();\n}\n\nvoid AColorToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeSinceLastToggle += DeltaTime;\n\tif (TimeSinceLastToggle >= ToggleInterval)\n\t{\n\t\tToggleColor();\n\t\tTimeSinceLastToggle = 0.0f;\n\t}\n}\n\nvoid AColorToggleActor::ToggleColor()\n{\n\tif (DynamicMaterial)\n\t{\n\t\tFLinearColor CurrentColor = bUseColor1 ? Color1 : Color2;\n\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), CurrentColor);\n\t\tbUseColor1 = !bUseColor1;\n\t}\n}\n```"}
{"requirement": "Create an actor that follows a player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FollowerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFollowerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAFollowerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAActor* PlayerActor;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat FollowSpeed = 300.0f;\n};\n```", "cpp_code": "```cpp\n#include \"FollowerActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAFollowerActor::AFollowerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AFollowerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tPlayerActor = PlayerController->GetPawn();\n\t}\n}\n\nvoid AFollowerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerActor)\n\t{\n\t\tFVector Direction = PlayerActor->GetActorLocation() - GetActorLocation();\n\t\tDirection.Normalize();\n\t\tFVector NewLocation = GetActorLocation() + Direction * FollowSpeed * DeltaTime;\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create a simple grid actor.", "header_code": "```cpp\nUCLASS()\nclass YOURPROJECT_API AGridActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAGridActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tint32 Rows;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tint32 Columns;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tfloat CellSize;\n};\n```", "cpp_code": "```cpp\n#include \"GridActor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nAGridActor::AGridActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\t\n\tRows = 10;\n\tColumns = 10;\n\tCellSize = 100.0f;\n}\n\nvoid AGridActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tfor (int32 i = 0; i <= Rows; ++i)\n\t{\n\t\tfor (int32 j = 0; j <= Columns; ++j)\n\t\t{\n\t\t\tFVector Start = GetActorLocation() + FVector(i * CellSize, j * CellSize, 0);\n\t\t\tFVector End = Start + FVector(0, 0, 10);\n\t\t\tDrawDebugLine(GetWorld(), Start, End, FColor::Red, true, -1, 0, 5);\n\t\t}\n\t}\n}\n\nvoid AGridActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a texture.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"MyTextureObject.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API UMyTextureObject : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Texture\")\n\tUTexture2D* MyTexture;\n};\n```", "cpp_code": "```cpp\n#include \"MyTextureObject.h\"\n\n// No additional implementation needed at this time\n```"}
{"requirement": "Create an actor that spawns another actor with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpawnActorExample.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpawnActorExample : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpawnActorExample();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// The actor to spawn\n\tUPROPERTY(EditAnywhere, Category = \"Spawning\")\n\tTSubclassOf<AActor> ActorToSpawn;\n\nprivate:\n\t// Function to handle spawning\n\tvoid SpawnActor();\n};\n```", "cpp_code": "```cpp\n#include \"SpawnActorExample.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASpawnActorExample::ASpawnActorExample()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASpawnActorExample::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind the input\n\tif (APlayerController* PC = UGameplayStatics::GetPlayerController(this, 0))\n\t{\n\t\tPC->InputComponent->BindAction(\"SpawnActor\", IE_Pressed, this, &ASpawnActorExample::SpawnActor);\n\t}\n}\n\nvoid ASpawnActorExample::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpawnActorExample::SpawnActor()\n{\n\tif (ActorToSpawn)\n\t{\n\t\tFVector Location = GetActorLocation();\n\t\tFRotator Rotation = GetActorRotation();\n\t\tGetWorld()->SpawnActor<AActor>(ActorToSpawn, Location, Rotation);\n\t}\n}\n```"}
{"requirement": "Create a component with a custom constructor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUCustomComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Custom constructor with parameters\n\tUCustomComponent(float InCustomValue);\n\nprivate:\n\tfloat CustomValue;\n};\n```", "cpp_code": "```cpp\n#include \"CustomComponent.h\"\n\nUCustomComponent::UCustomComponent()\n\t: CustomValue(0.0f) // Initialize default value\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nUCustomComponent::UCustomComponent(float InCustomValue)\n\t: CustomValue(InCustomValue)\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UCustomComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Additional initialization\n}\n```"}
{"requirement": "Create an actor with a spotlight that follows the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpotlightFollower.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpotlightFollower : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpotlightFollower();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Spotlight component\n\tUPROPERTY(VisibleAnywhere)\n\tUSpotLightComponent* Spotlight;\n\n\t// Player reference\n\tAPawn* PlayerPawn;\n};\n```", "cpp_code": "```cpp\n#include \"SpotlightFollower.h\"\n#include \"Components/SpotLightComponent.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASpotlightFollower::ASpotlightFollower()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach spotlight component\n\tSpotlight = CreateDefaultSubobject<USpotLightComponent>(TEXT(\"Spotlight\"));\n\tRootComponent = Spotlight;\n}\n\n// Called when the game starts or when spawned\nvoid ASpotlightFollower::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Get the player pawn\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\n// Called every frame\nvoid ASpotlightFollower::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerPawn)\n\t{\n\t\t// Update spotlight's location to follow the player\n\t\tFVector PlayerLocation = PlayerPawn->GetActorLocation();\n\t\tSetActorLocation(PlayerLocation + FVector(0.0f, 0.0f, 500.0f));\n\t}\n}\n```"}
{"requirement": "Create a class that logs when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ClickableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AClickableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAClickableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called when the actor is clicked\n\tUFUNCTION()\n\tvoid OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n};\n```", "cpp_code": "```cpp\n#include \"ClickableActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAClickableActor::AClickableActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Enable click events\n\tbEnableClickEvents = true;\n}\n\n// Called when the game starts or when spawned\nvoid AClickableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind the OnClicked function to the OnClicked event\n\tOnClicked.AddDynamic(this, &AClickableActor::OnClicked);\n}\n\n// Called every frame\nvoid AClickableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AClickableActor::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tif (GEngine)\n\t{\n\t\t// Log a message when the actor is clicked\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Actor Clicked\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that moves in the direction of the camera.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"CameraMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACameraMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tACameraMovementActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUCameraComponent* CameraComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"CameraMovementActor.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nACameraMovementActor::ACameraMovementActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"CameraComponent\"));\n\tCameraComponent->SetupAttachment(RootComponent);\n\n\tMovementSpeed = 100.0f;\n}\n\nvoid ACameraMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACameraMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (CameraComponent)\n\t{\n\t\tFVector ForwardVector = CameraComponent->GetForwardVector();\n\t\tFVector NewLocation = GetActorLocation() + (ForwardVector * MovementSpeed * DeltaTime);\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create a simple fractal actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FractalActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFractalActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAFractalActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to draw the fractal\n\tvoid DrawFractal(int32 Depth, FVector Location, float Size);\n\n\t// Recursive function to create the fractal\n\tvoid CreateFractal(int32 CurrentDepth, FVector Location, float Size);\n\n\t// Maximum depth of the fractal\n\tUPROPERTY(EditAnywhere, Category = \"Fractal\")\n\tint32 MaxDepth;\n\n\t// Initial size of the fractal\n\tUPROPERTY(EditAnywhere, Category = \"Fractal\")\n\tfloat InitialSize;\n};\n```", "cpp_code": "```cpp\n#include \"FractalActor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\n// Sets default values\nAFractalActor::AFractalActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMaxDepth = 3;\n\tInitialSize = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AFractalActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tDrawFractal(MaxDepth, GetActorLocation(), InitialSize);\n}\n\n// Called every frame\nvoid AFractalActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AFractalActor::DrawFractal(int32 Depth, FVector Location, float Size)\n{\n\tCreateFractal(Depth, Location, Size);\n}\n\nvoid AFractalActor::CreateFractal(int32 CurrentDepth, FVector Location, float Size)\n{\n\tif (CurrentDepth <= 0)\n\t{\n\t\treturn;\n\t}\n\n\t// Draw a box for the current level\n\tDrawDebugBox(GetWorld(), Location, FVector(Size * 0.5f), FColor::Blue, true, -1.0f, 0, 2.0f);\n\n\t// Calculate new size and offset for the next depth level\n\tfloat NewSize = Size * 0.5f;\n\tFVector Offset = FVector(NewSize, 0, 0);\n\n\t// Recurse to create smaller fractals\n\tCreateFractal(CurrentDepth - 1, Location + Offset, NewSize);\n\tCreateFractal(CurrentDepth - 1, Location - Offset, NewSize);\n\tCreateFractal(CurrentDepth - 1, Location + FVector(0, NewSize, 0), NewSize);\n\tCreateFractal(CurrentDepth - 1, Location - FVector(0, NewSize, 0), NewSize);\n\tCreateFractal(CurrentDepth - 1, Location + FVector(0, 0, NewSize), NewSize);\n\tCreateFractal(CurrentDepth - 1, Location - FVector(0, 0, NewSize), NewSize);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a music track.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MusicTrackActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMusicTrackActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAMusicTrackActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Audio\")\n\tUSoundBase* MusicTrack;\n};\n```", "cpp_code": "```cpp\n#include \"MusicTrackActor.h\"\n\nAMusicTrackActor::AMusicTrackActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMusicTrackActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMusicTrackActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that logs its movement every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoggingMovementActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Time accumulator for logging\n\tfloat TimeAccumulator;\n\n\t// Logs the current position of the actor\n\tvoid LogMovement();\n};\n```", "cpp_code": "```cpp\n#include \"LoggingMovementActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingMovementActor::ALoggingMovementActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tTimeAccumulator = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALoggingMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeAccumulator += DeltaTime;\n\n\tif (TimeAccumulator >= 1.0f)\n\t{\n\t\tLogMovement();\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n\nvoid ALoggingMovementActor::LogMovement()\n{\n\tFVector ActorLocation = GetActorLocation();\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Actor Location: %s\"), *ActorLocation.ToString());\n}\n```"}
{"requirement": "Create a component that adjusts its scale based on distance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleByDistanceComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UScaleByDistanceComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUScaleByDistanceComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tAActor* TargetActor;\n\tfloat BaseScale;\n\tfloat ScaleFactor;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Scale\")\n\tvoid SetTargetActor(AActor* NewTarget);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Scale\")\n\tvoid SetScaleFactor(float NewScaleFactor);\n};\n```", "cpp_code": "```cpp\n#include \"ScaleByDistanceComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUScaleByDistanceComponent::UScaleByDistanceComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tBaseScale = 1.0f;\n\tScaleFactor = 0.01f;\n\tTargetActor = nullptr;\n}\n\nvoid UScaleByDistanceComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UScaleByDistanceComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (TargetActor)\n\t{\n\t\tfloat Distance = FVector::Dist(GetOwner()->GetActorLocation(), TargetActor->GetActorLocation());\n\t\tfloat NewScale = BaseScale + (Distance * ScaleFactor);\n\t\tGetOwner()->SetActorScale3D(FVector(NewScale));\n\t}\n}\n\nvoid UScaleByDistanceComponent::SetTargetActor(AActor* NewTarget)\n{\n\tTargetActor = NewTarget;\n}\n\nvoid UScaleByDistanceComponent::SetScaleFactor(float NewScaleFactor)\n{\n\tScaleFactor = NewScaleFactor;\n}\n```"}
{"requirement": "Create an actor with a customizable sound effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundEffectActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundEffectActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tASoundEffectActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sound effect property\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* SoundEffect;\n\n\t// Function to play the sound effect\n\tUFUNCTION(BlueprintCallable, Category = \"Sound\")\n\tvoid PlaySoundEffect();\n};\n```", "cpp_code": "```cpp\n#include \"SoundEffectActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundEffectActor::ASoundEffectActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the sound effect\n\tSoundEffect = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundEffectActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASoundEffectActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to play the sound effect\nvoid ASoundEffectActor::PlaySoundEffect()\n{\n\tif (SoundEffect)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundEffect, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a class that changes its rotation speed over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat InitialRotationSpeed;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationAcceleration;\n\n\tfloat CurrentRotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tInitialRotationSpeed = 10.0f;\n\tRotationAcceleration = 5.0f;\n\tCurrentRotationSpeed = InitialRotationSpeed;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update the current rotation speed\n\tCurrentRotationSpeed += RotationAcceleration * DeltaTime;\n\n\t// Calculate new rotation\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += CurrentRotationSpeed * DeltaTime;\n\n\t// Set the updated rotation\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an actor that can be thrown with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ThrowableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AThrowableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAThrowableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Throw\")\n\tfloat ThrowForce;\n\n\tUFUNCTION()\n\tvoid Throw();\n};\n```", "cpp_code": "```cpp\n#include \"ThrowableActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nAThrowableActor::AThrowableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tThrowForce = 1000.0f; // Default force value\n}\n\nvoid AThrowableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Bind the throw function to a key press\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tif (InputComponent)\n\t\t{\n\t\t\tInputComponent->BindAction(\"Throw\", IE_Pressed, this, &AThrowableActor::Throw);\n\t\t}\n\t}\n}\n\nvoid AThrowableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AThrowableActor::Throw()\n{\n\tif (UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(GetRootComponent()))\n\t{\n\t\tFVector ForwardVector = GetActorForwardVector();\n\t\tPrimitiveComponent->AddImpulse(ForwardVector * ThrowForce, NAME_None, true);\n\t}\n}\n```"}
{"requirement": "Create a simple star actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"StarActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AStarActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAStarActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Star mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StarMesh;\n};\n```", "cpp_code": "```cpp\n#include \"StarActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAStarActor::AStarActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the mesh component\n\tStarMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StarMesh\"));\n\tRootComponent = StarMesh;\n\n\t// Optionally, set the mesh here\n\t// static ConstructorHelpers::FObjectFinder<UStaticMesh> StarAsset(TEXT(\"/Game/Path/To/Your/StarMesh.StarMesh\"));\n\t// if (StarAsset.Succeeded())\n\t// {\n\t// \tStarMesh->SetStaticMesh(StarAsset.Object);\n\t// }\n}\n\n// Called when the game starts or when spawned\nvoid AStarActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AStarActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a light component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyLightActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyLightActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Light\")\n\tclass ULightComponent* LightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyLightActor.h\"\n#include \"Components/LightComponent.h\"\n\nAMyLightActor::AMyLightActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tLightComponent = CreateDefaultSubobject<ULightComponent>(TEXT(\"LightComponent\"));\n\tRootComponent = LightComponent;\n}\n\nvoid AMyLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that plays a sound when entering a volume.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundVolumeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundVolumeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundVolumeActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* TriggerVolume;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"SoundVolumeActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundVolumeActor::ASoundVolumeActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n\tRootComponent = TriggerVolume;\n\n\tTriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &ASoundVolumeActor::OnOverlapBegin);\n}\n\nvoid ASoundVolumeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundVolumeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundVolumeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (SoundToPlay && OtherActor != this)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that changes its mesh on click.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"MeshSwitcherComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UMeshSwitcherComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUMeshSwitcherComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void OnComponentClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed);\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MeshSwitch\")\n\tUStaticMesh* FirstMesh;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MeshSwitch\")\n\tUStaticMesh* SecondMesh;\n\nprivate:\n\tUPROPERTY()\n\tUStaticMeshComponent* MeshComponent;\n\n\tbool bUsingFirstMesh;\n};\n```", "cpp_code": "```cpp\n#include \"MeshSwitcherComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nUMeshSwitcherComponent::UMeshSwitcherComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbUsingFirstMesh = true;\n}\n\nvoid UMeshSwitcherComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tMeshComponent = GetOwner()->FindComponentByClass<UStaticMeshComponent>();\n\tif (MeshComponent && FirstMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(FirstMesh);\n\t}\n\n\tif (MeshComponent)\n\t{\n\t\tMeshComponent->OnClicked.AddDynamic(this, &UMeshSwitcherComponent::OnComponentClicked);\n\t}\n}\n\nvoid UMeshSwitcherComponent::OnComponentClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed)\n{\n\tif (!MeshComponent)\n\t{\n\t\treturn;\n\t}\n\n\tif (bUsingFirstMesh && SecondMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(SecondMesh);\n\t}\n\telse if (!bUsingFirstMesh && FirstMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(FirstMesh);\n\t}\n\n\tbUsingFirstMesh = !bUsingFirstMesh;\n}\n```"}
{"requirement": "Create an actor with a changing texture.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"TextureChangerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tATextureChangerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category = \"Texture\")\n\tTArray<UTexture*> Textures;\n\nprivate:\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\tint32 CurrentTextureIndex;\n\tfloat TimeSinceLastChange;\n\t\n\tUPROPERTY(EditAnywhere, Category = \"Texture\")\n\tfloat ChangeInterval;\n};\n```", "cpp_code": "```cpp\n#include \"TextureChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/Material.h\"\n\n// Sets default values\nATextureChangerActor::ATextureChangerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tUStaticMeshComponent* MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Initialize variables\n\tCurrentTextureIndex = 0;\n\tTimeSinceLastChange = 0.0f;\n\tChangeInterval = 2.0f; // Change texture every 2 seconds\n}\n\n// Called when the game starts or when spawned\nvoid ATextureChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tUStaticMeshComponent* MeshComponent = Cast<UStaticMeshComponent>(RootComponent);\n\tif (MeshComponent && MeshComponent->GetMaterial(0))\n\t{\n\t\tDynamicMaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t}\n}\n\n// Called every frame\nvoid ATextureChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterialInstance && Textures.Num() > 0)\n\t{\n\t\tTimeSinceLastChange += DeltaTime;\n\n\t\tif (TimeSinceLastChange >= ChangeInterval)\n\t\t{\n\t\t\tCurrentTextureIndex = (CurrentTextureIndex + 1) % Textures.Num();\n\t\t\tDynamicMaterialInstance->SetTextureParameterValue(FName(\"BaseTexture\"), Textures[CurrentTextureIndex]);\n\t\t\tTimeSinceLastChange = 0.0f;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a class that scales based on player proximity.", "header_code": "```cpp\nUCLASS()\nclass AProximityScaler : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAProximityScaler();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat MaxScale;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MinScale;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat ScaleDistanceThreshold;\n\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"ProximityScaler.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAProximityScaler::AProximityScaler()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMaxScale = 3.0f;\n\tMinScale = 1.0f;\n\tScaleDistanceThreshold = 1000.0f;\n}\n\nvoid AProximityScaler::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid AProximityScaler::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!PlayerActor)\n\t\treturn;\n\n\tfloat Distance = FVector::Dist(PlayerActor->GetActorLocation(), GetActorLocation());\n\tfloat ScaleFactor = FMath::Clamp(1.0f - (Distance / ScaleDistanceThreshold), 0.0f, 1.0f);\n\tfloat NewScale = FMath::Lerp(MinScale, MaxScale, ScaleFactor);\n\n\tSetActorScale3D(FVector(NewScale));\n}\n```"}
{"requirement": "Create an actor that emits a sound when destroyed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundEmitterActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundEmitterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundEmitterActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void Destroyed() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* DestroySound;\n};\n```", "cpp_code": "```cpp\n#include \"SoundEmitterActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundEmitterActor::ASoundEmitterActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASoundEmitterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundEmitterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundEmitterActor::Destroyed()\n{\n\tSuper::Destroyed();\n\n\tif (DestroySound != nullptr)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, DestroySound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a simple wave actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WaveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWaveActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAWaveActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Wave Settings\")\n\tfloat Amplitude;\n\n\tUPROPERTY(EditAnywhere, Category=\"Wave Settings\")\n\tfloat Frequency;\n\n\tFVector StartLocation;\n};\n```", "cpp_code": "```cpp\n#include \"WaveActor.h\"\n\n// Sets default values\nAWaveActor::AWaveActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAmplitude = 100.0f;\n\tFrequency = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AWaveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid AWaveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat Time = GetWorld()->GetTimeSeconds();\n\tFVector NewLocation = StartLocation;\n\tNewLocation.Z += Amplitude * FMath::Sin(Frequency * Time);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a player character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Player\")\n\tAPlayerCharacter* PlayerCharacterReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its emission over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EmissionChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AEmissionChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAEmissionChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\t// Time accumulator for emission change\n\tfloat TimeAccumulator;\n\n\t// Frequency of the emission change\n\tUPROPERTY(EditAnywhere, Category = \"Emission\")\n\tfloat EmissionFrequency;\n};\n```", "cpp_code": "```cpp\n#include \"EmissionChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nAEmissionChangingActor::AEmissionChangingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize variables\n\tTimeAccumulator = 0.0f;\n\tEmissionFrequency = 1.0f; // Default frequency\n\n\t// Create and set up the static mesh component\n\tUStaticMeshComponent* Mesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh\"));\n\tRootComponent = Mesh;\n\n\t// Create a dynamic material instance\n\tDynamicMaterial = Mesh->CreateAndSetMaterialInstanceDynamic(0);\n}\n\n// Called when the game starts or when spawned\nvoid AEmissionChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AEmissionChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (DynamicMaterial)\n\t{\n\t\t// Update the time accumulator\n\t\tTimeAccumulator += DeltaTime;\n\n\t\t// Calculate a new emission value using a sine wave\n\t\tfloat EmissionValue = FMath::Abs(FMath::Sin(TimeAccumulator * EmissionFrequency));\n\n\t\t// Set the emission value to the material (assuming the material has a parameter named \"Emission\")\n\t\tDynamicMaterial->SetScalarParameterValue(TEXT(\"Emission\"), EmissionValue);\n\t}\n}\n```"}
{"requirement": "Create a component that logs its status when activated.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LoggingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULoggingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tULoggingComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called to activate the component\n\tUFUNCTION(BlueprintCallable, Category=\"Activation\")\n\tvoid ActivateComponent();\n};\n```", "cpp_code": "```cpp\n#include \"LoggingComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values for this component's properties\nULoggingComponent::ULoggingComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame. You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid ULoggingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called to activate the component\nvoid ULoggingComponent::ActivateComponent()\n{\n\tUE_LOG(LogTemp, Log, TEXT(\"ULoggingComponent activated on: %s\"), *GetOwner()->GetName());\n}\n```"}
{"requirement": "Create an actor with a color-changing light.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingLight.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AColorChangingLight : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAColorChangingLight();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPointLightComponent* PointLight;\n\n\tUPROPERTY(EditAnywhere, Category=\"Lighting\")\n\tfloat ColorChangeSpeed;\n\n\tFLinearColor CurrentColor;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingLight.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAColorChangingLight::AColorChangingLight()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\tColorChangeSpeed = 1.0f;\n\n\tCurrentColor = FLinearColor::Red;\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangingLight::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AColorChangingLight::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat Time = GetWorld()->GetTimeSeconds();\n\tCurrentColor.R = FMath::Abs(FMath::Sin(Time * ColorChangeSpeed));\n\tCurrentColor.G = FMath::Abs(FMath::Sin((Time + PI / 3) * ColorChangeSpeed));\n\tCurrentColor.B = FMath::Abs(FMath::Sin((Time + 2 * PI / 3) * ColorChangeSpeed));\n\n\tPointLight->SetLightColor(CurrentColor);\n}\n```"}
{"requirement": "Create a class that rotates based on mouse input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseRotatableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMouseRotatableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMouseRotatableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to rotate based on mouse input\n\tvoid RotateWithMouseInput();\n\nprivate:\n\t// Sensitivity for mouse rotation\n\tUPROPERTY(EditAnywhere, Category = \"Mouse Rotation\")\n\tfloat MouseSensitivity;\n\n\t// Stores the current rotation\n\tFRotator CurrentRotation;\n};\n```", "cpp_code": "```cpp\n#include \"MouseRotatableActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAMouseRotatableActor::AMouseRotatableActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize variables\n\tMouseSensitivity = 0.1f;\n\tCurrentRotation = FRotator::ZeroRotator;\n}\n\n// Called when the game starts or when spawned\nvoid AMouseRotatableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMouseRotatableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRotateWithMouseInput();\n}\n\nvoid AMouseRotatableActor::RotateWithMouseInput()\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tfloat MouseX, MouseY;\n\t\tPlayerController->GetInputMouseDelta(MouseX, MouseY);\n\n\t\t// Calculate rotation\n\t\tCurrentRotation.Yaw += MouseX * MouseSensitivity;\n\t\tCurrentRotation.Pitch += MouseY * MouseSensitivity;\n\n\t\t// Apply rotation\n\t\tSetActorRotation(CurrentRotation);\n\t}\n}\n```"}
{"requirement": "Create an actor that plays a sound on component hit.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"MySoundActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMySoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMySoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sound to play on hit\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* HitSound;\n\n\t// Root component\n\tUPROPERTY(VisibleAnywhere)\n\tUSceneComponent* RootComp;\n\n\t// Box collision component\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* BoxComponent;\n\n\t// Function to handle hit events\n\tUFUNCTION()\n\tvoid OnComponentHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"MySoundActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAMySoundActor::AMySoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create root component\n\tRootComp = CreateDefaultSubobject<USceneComponent>(TEXT(\"RootComponent\"));\n\tRootComponent = RootComp;\n\n\t// Create box component and attach to root\n\tBoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tBoxComponent->SetupAttachment(RootComp);\n\n\t// Bind the OnComponentHit function\n\tBoxComponent->OnComponentHit.AddDynamic(this, &AMySoundActor::OnComponentHit);\n}\n\n// Called when the game starts or when spawned\nvoid AMySoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMySoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle hit events\nvoid AMySoundActor::OnComponentHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (HitSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, HitSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a simple starfield actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"StarfieldActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AStarfieldActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAStarfieldActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Starfield\")\n\tint32 NumberOfStars;\n\n\tUPROPERTY(EditAnywhere, Category=\"Starfield\")\n\tfloat StarfieldRadius;\n\n\tUPROPERTY(EditAnywhere, Category=\"Starfield\")\n\tUStaticMesh* StarMesh;\n\n\tvoid CreateStarfield();\n};\n```", "cpp_code": "```cpp\n#include \"StarfieldActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n\nAStarfieldActor::AStarfieldActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tNumberOfStars = 100;\n\tStarfieldRadius = 1000.0f;\n\tStarMesh = nullptr;\n}\n\nvoid AStarfieldActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tCreateStarfield();\n}\n\nvoid AStarfieldActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AStarfieldActor::CreateStarfield()\n{\n\tif (!StarMesh)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Star mesh not set!\"));\n\t\treturn;\n\t}\n\n\tfor (int32 i = 0; i < NumberOfStars; ++i)\n\t{\n\t\tFVector RandomPosition = FMath::VRand() * FMath::FRandRange(0.0f, StarfieldRadius);\n\t\tUStaticMeshComponent* StarComponent = NewObject<UStaticMeshComponent>(this);\n\t\tStarComponent->SetStaticMesh(StarMesh);\n\t\tStarComponent->SetWorldLocation(RandomPosition);\n\t\tStarComponent->RegisterComponent();\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a static mesh.", "header_code": "```cpp\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyStaticMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Mesh\")\n\tUStaticMesh* StaticMeshReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyStaticMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its position with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PositionChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APositionChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tAPositionChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid MoveActor();\n\nprivate:\n\tFVector NewLocation;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MoveDistance;\n};\n```", "cpp_code": "```cpp\n#include \"PositionChanger.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAPositionChanger::APositionChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMoveDistance = 100.0f;\n}\n\nvoid APositionChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tNewLocation = GetActorLocation();\n}\n\nvoid APositionChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tif (PlayerController->IsInputKeyDown(EKeys::P))\n\t\t{\n\t\t\tMoveActor();\n\t\t}\n\t}\n}\n\nvoid APositionChanger::MoveActor()\n{\n\tNewLocation.X += MoveDistance;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a component with a custom tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomTickComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomTickComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUCustomTickComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void CustomTickFunction(float DeltaTime);\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tick\")\n\tbool bEnableCustomTick;\n};\n```", "cpp_code": "```cpp\n#include \"CustomTickComponent.h\"\n\nUCustomTickComponent::UCustomTickComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tbEnableCustomTick = true;\n}\n\nvoid UCustomTickComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCustomTickComponent::CustomTickFunction(float DeltaTime)\n{\n\tif (bEnableCustomTick)\n\t{\n\t\t// Custom tick logic here\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"CustomTickFunction called with DeltaTime: %f\"), DeltaTime);\n\t}\n}\n\nvoid UCustomTickComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// Call the custom tick function\n\tCustomTickFunction(DeltaTime);\n}\n```"}
{"requirement": "Create an actor with a customizable light intensity.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightIntensityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ALightIntensityActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tALightIntensityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Light\")\n\tfloat LightIntensity;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPointLightComponent* PointLight;\n};\n```", "cpp_code": "```cpp\n#include \"LightIntensityActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nALightIntensityActor::ALightIntensityActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create PointLight component and attach it to the RootComponent\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\t// Set default light intensity\n\tLightIntensity = 3000.0f;\n\tPointLight->Intensity = LightIntensity;\n}\n\n// Called when the game starts or when spawned\nvoid ALightIntensityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Ensure the light intensity is set at the start\n\tPointLight->SetIntensity(LightIntensity);\n}\n\n// Called every frame\nvoid ALightIntensityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update the light intensity if it changes\n\tif (PointLight->Intensity != LightIntensity)\n\t{\n\t\tPointLight->SetIntensity(LightIntensity);\n\t}\n}\n```"}
{"requirement": "Create a class that adjusts its position with time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PositionAdjuster.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APositionAdjuster : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAPositionAdjuster();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialPosition;\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tFVector MovementPerSecond;\n};\n```", "cpp_code": "```cpp\n#include \"PositionAdjuster.h\"\n\nAPositionAdjuster::APositionAdjuster()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APositionAdjuster::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialPosition = GetActorLocation();\n}\n\nvoid APositionAdjuster::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFVector NewPosition = InitialPosition + (MovementPerSecond * DeltaTime);\n\tSetActorLocation(NewPosition);\n}\n```"}
{"requirement": "Create an actor that can be resized with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResizableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResizableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAResizableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to resize the actor\n\tvoid ResizeActor(float ScaleFactor);\n\nprivate:\n\t// Function to handle input\n\tvoid SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\n\t// Current scale factor\n\tfloat CurrentScaleFactor;\n};\n```", "cpp_code": "```cpp\n#include \"ResizableActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAResizableActor::AResizableActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCurrentScaleFactor = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AResizableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetupPlayerInputComponent(InputComponent);\n}\n\n// Called every frame\nvoid AResizableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResizableActor::ResizeActor(float ScaleFactor)\n{\n\tCurrentScaleFactor *= ScaleFactor;\n\tSetActorScale3D(FVector(CurrentScaleFactor));\n}\n\nvoid AResizableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ResizeActor\", IE_Pressed, this, &AResizableActor::ResizeActor, 1.1f);\n}\n```"}
{"requirement": "Create a simple vortex actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VortexActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVortexActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAVortexActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Vortex\")\n\tfloat VortexStrength = 1000.0f;\n\n\tUPROPERTY(EditAnywhere, Category=\"Vortex\")\n\tfloat VortexRadius = 500.0f;\n\n\tvoid ApplyVortexForce();\n};\n```", "cpp_code": "```cpp\n#include \"VortexActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAVortexActor::AVortexActor()\n{\n\t // Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AVortexActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AVortexActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tApplyVortexForce();\n}\n\nvoid AVortexActor::ApplyVortexForce()\n{\n\tFVector VortexLocation = GetActorLocation();\n\tfor (TActorIterator<AActor> It(GetWorld()); It; ++It)\n\t{\n\t\tAActor* Actor = *It;\n\t\tif (Actor != this)\n\t\t{\n\t\t\tUPrimitiveComponent* PrimitiveComponent = Actor->FindComponentByClass<UPrimitiveComponent>();\n\t\t\tif (PrimitiveComponent && PrimitiveComponent->IsSimulatingPhysics())\n\t\t\t{\n\t\t\t\tFVector Direction = (Actor->GetActorLocation() - VortexLocation);\n\t\t\t\tfloat Distance = Direction.Size();\n\t\t\t\tif (Distance < VortexRadius)\n\t\t\t\t{\n\t\t\t\t\tDirection.Normalize();\n\t\t\t\t\tFVector Force = Direction ^ FVector::UpVector * VortexStrength;\n\t\t\t\t\tPrimitiveComponent->AddForce(Force);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store the lifespan of an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Lifespan\")\n\tfloat Lifespan;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\t// Set default lifespan value\n\tLifespan = 0.0f;\n}\n```"}
{"requirement": "Create an actor that logs a message on destruction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Logging/LogMacros.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void BeginDestroy() override;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Engine/Engine.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyActor::BeginDestroy()\n{\n\tSuper::BeginDestroy();\n\tUE_LOG(LogTemp, Warning, TEXT(\"AMyActor is being destroyed\"));\n}\n```"}
{"requirement": "Create a component that changes color on proximity.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ColorChangeOnProximityComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UColorChangeOnProximityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUColorChangeOnProximityComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat ProximityRadius = 300.0f;\n\n\tUPROPERTY(EditAnywhere)\n\tFLinearColor CloseColor = FLinearColor::Red;\n\n\tUPROPERTY(EditAnywhere)\n\tFLinearColor FarColor = FLinearColor::Blue;\n\n\tUPROPERTY() \n\tUMaterialInstanceDynamic* DynamicMaterial;\n\n\tvoid ChangeColorBasedOnProximity();\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeOnProximityComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUColorChangeOnProximityComponent::UColorChangeOnProximityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UColorChangeOnProximityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUMeshComponent* MeshComp = Owner->FindComponentByClass<UMeshComponent>();\n\t\tif (MeshComp)\n\t\t{\n\t\t\tDynamicMaterial = MeshComp->CreateAndSetMaterialInstanceDynamic(0);\n\t\t}\n\t}\n}\n\nvoid UColorChangeOnProximityComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tChangeColorBasedOnProximity();\n}\n\nvoid UColorChangeOnProximityComponent::ChangeColorBasedOnProximity()\n{\n\tif (!DynamicMaterial) return;\n\n\tAActor* PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n\tif (!PlayerPawn) return;\n\n\tfloat Distance = FVector::Dist(PlayerPawn->GetActorLocation(), GetOwner()->GetActorLocation());\n\n\tFLinearColor NewColor = (Distance < ProximityRadius) ? CloseColor : FarColor;\n\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", NewColor);\n}\n```"}
{"requirement": "Create an actor with a scalable mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalableMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AScalableMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAScalableMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Static Mesh Component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Mesh\")\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\t// Method to scale the mesh\n\tUFUNCTION(BlueprintCallable, Category = \"Mesh\")\n\tvoid ScaleMesh(FVector NewScale);\n};\n```", "cpp_code": "```cpp\n#include \"ScalableMeshActor.h\"\n\n// Sets default values\nAScalableMeshActor::AScalableMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the static mesh component and attach it to the root\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AScalableMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AScalableMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\n// Method to scale the mesh\nvoid AScalableMeshActor::ScaleMesh(FVector NewScale)\n{\n\tif (StaticMeshComponent)\n\t{\n\t\tStaticMeshComponent->SetWorldScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Create a class that moves towards a specified target.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MoveTowardsTarget.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMoveTowardsTarget : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMoveTowardsTarget();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tAActor* TargetActor;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat Speed;\n};\n```", "cpp_code": "```cpp\n#include \"MoveTowardsTarget.h\"\n#include \"GameFramework/Actor.h\"\n\nAMoveTowardsTarget::AMoveTowardsTarget()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSpeed = 100.0f;\n}\n\nvoid AMoveTowardsTarget::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMoveTowardsTarget::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tFVector CurrentLocation = GetActorLocation();\n\t\tFVector TargetLocation = TargetActor->GetActorLocation();\n\t\tFVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n\t\tFVector NewLocation = CurrentLocation + Direction * Speed * DeltaTime;\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create an actor that plays a sound when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"ClickableSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AClickableSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAClickableSoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* ClickSound;\n\n\tUFUNCTION()\n\tvoid OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n};\n```", "cpp_code": "```cpp\n#include \"ClickableSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAClickableSoundActor::AClickableSoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Enable input to detect clicks\n\tEnableInput(GetWorld()->GetFirstPlayerController());\n\tOnClicked.AddDynamic(this, &AClickableSoundActor::OnClicked);\n}\n\nvoid AClickableSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AClickableSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AClickableSoundActor::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tif (ClickSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, ClickSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a simple black hole actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BlackHoleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ABlackHoleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tABlackHoleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The sphere component for the black hole's gravitational field\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUSphereComponent* BlackHoleSphere;\n\n\t// The strength of the black hole's pull\n\tUPROPERTY(EditAnywhere, Category = \"Black Hole\")\n\tfloat GravityStrength;\n\n\t// Function to apply gravitational pull\n\tvoid PullOverlappingActors();\n};\n```", "cpp_code": "```cpp\n#include \"BlackHoleActor.h\"\n#include \"Components/SphereComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Character.h\"\n\n// Sets default values\nABlackHoleActor::ABlackHoleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the sphere component and attach it to the root\n\tBlackHoleSphere = CreateDefaultSubobject<USphereComponent>(TEXT(\"BlackHoleSphere\"));\n\tRootComponent = BlackHoleSphere;\n\n\t// Initialize the gravity strength\n\tGravityStrength = 2000.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ABlackHoleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ABlackHoleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Apply gravitational pull to overlapping actors\n\tPullOverlappingActors();\n}\n\nvoid ABlackHoleActor::PullOverlappingActors()\n{\n\tTArray<AActor*> OverlappingActors;\n\tBlackHoleSphere->GetOverlappingActors(OverlappingActors);\n\n\tfor (AActor* Actor : OverlappingActors)\n\t{\n\t\tif (Actor && Actor != this)\n\t\t{\n\t\t\tUPrimitiveComponent* Component = Cast<UPrimitiveComponent>(Actor->GetRootComponent());\n\t\t\tif (Component && Component->IsSimulatingPhysics())\n\t\t\t{\n\t\t\t\t// Calculate direction and apply force\n\t\t\t\tFVector Direction = GetActorLocation() - Actor->GetActorLocation();\n\t\t\t\tDirection.Normalize();\n\t\t\t\tComponent->AddForce(Direction * GravityStrength);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store a velocity vector.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VelocityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVelocityActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAVelocityActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector Velocity;\n};\n```", "cpp_code": "```cpp\n#include \"VelocityActor.h\"\n\nAVelocityActor::AVelocityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AVelocityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AVelocityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that rotates around the camera.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Rotation speed around the camera\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationSpeed = 20.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tAActor* PlayerCameraManager = PlayerController->GetViewTarget();\n\t\tif (PlayerCameraManager)\n\t\t{\n\t\t\tFVector CameraLocation = PlayerCameraManager->GetActorLocation();\n\t\t\tFVector ActorLocation = GetActorLocation();\n\n\t\t\t// Calculate the rotation around the camera\n\t\t\tFVector Direction = ActorLocation - CameraLocation;\n\t\t\tDirection = Direction.RotateAngleAxis(RotationSpeed * DeltaTime, FVector::UpVector);\n\n\t\t\tSetActorLocation(CameraLocation + Direction);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a component with a custom start function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomStartComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomStartComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUCustomStartComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Custom start function\n\tUFUNCTION(BlueprintCallable, Category=\"Custom\")\n\tvoid CustomStartFunction();\n};\n```", "cpp_code": "```cpp\n#include \"CustomStartComponent.h\"\n\n// Sets default values for this component's properties\nUCustomStartComponent::UCustomStartComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\n// Called when the game starts\nvoid UCustomStartComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Custom initialization code here\n}\n\n// Custom start function\nvoid UCustomStartComponent::CustomStartFunction()\n{\n\t// Custom start logic here\n\tUE_LOG(LogTemp, Warning, TEXT(\"Custom start function called.\"));\n}\n```"}
{"requirement": "Create an actor with a customizable sound pitch.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"CustomSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* Sound;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tfloat PitchMultiplier;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Sound\")\n\tvoid PlaySound();\n};\n```", "cpp_code": "```cpp\n#include \"CustomSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n\n// Sets default values\nACustomSoundActor::ACustomSoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPitchMultiplier = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACustomSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ACustomSoundActor::PlaySound()\n{\n\tif (Sound)\n\t{\n\t\tUAudioComponent* AudioComponent = UGameplayStatics::SpawnSoundAtLocation(this, Sound, GetActorLocation());\n\t\tif (AudioComponent)\n\t\t{\n\t\t\tAudioComponent->SetPitchMultiplier(PitchMultiplier);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a class with a log message on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyOverlapActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* CollisionBox;\n};\n```", "cpp_code": "```cpp\n#include \"MyOverlapActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\nAMyOverlapActor::AMyOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionBox\"));\n\tRootComponent = CollisionBox;\n\tCollisionBox->SetGenerateOverlapEvents(true);\n\tCollisionBox->OnComponentBeginOverlap.AddDynamic(this, &AMyOverlapActor::OnOverlapBegin);\n}\n\nvoid AMyOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor != this && OtherComp)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Overlap began with: %s\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Create an actor that expands with a timeline.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TimelineComponent.h\"\n#include \"ExpandingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AExpandingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAExpandingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUCurveFloat* ExpansionCurve;\n\n\tFTimeline ExpansionTimeline;\n\n\tUFUNCTION()\n\tvoid HandleExpansionProgress(float Value);\n\n\tvoid SetupTimeline();\n};\n```", "cpp_code": "```cpp\n#include \"ExpandingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nAExpandingActor::AExpandingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AExpandingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tSetupTimeline();\n\tif (ExpansionTimeline.IsValid())\n\t{\n\t\tExpansionTimeline.PlayFromStart();\n\t}\n}\n\nvoid AExpandingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tif (ExpansionTimeline.IsValid())\n\t{\n\t\tExpansionTimeline.TickTimeline(DeltaTime);\n\t}\n}\n\nvoid AExpandingActor::SetupTimeline()\n{\n\tif (ExpansionCurve)\n\t{\n\t\tFOnTimelineFloat TimelineProgress;\n\t\tTimelineProgress.BindUFunction(this, FName(\"HandleExpansionProgress\"));\n\t\tExpansionTimeline.AddInterpFloat(ExpansionCurve, TimelineProgress);\n\t\tExpansionTimeline.SetLooping(false);\n\t}\n}\n\nvoid AExpandingActor::HandleExpansionProgress(float Value)\n{\n\tFVector NewScale = FMath::Lerp(FVector(1.0f, 1.0f, 1.0f), FVector(2.0f, 2.0f, 2.0f), Value);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a simple pyramid actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PyramidActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APyramidActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAPyramidActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* PyramidMesh;\n};\n```", "cpp_code": "```cpp\n#include \"PyramidActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAPyramidActor::APyramidActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component and set as root\n\tPyramidMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"PyramidMesh\"));\n\tRootComponent = PyramidMesh;\n\n\t// Load a simple pyramid mesh (assuming you have a pyramid mesh asset named 'PyramidMesh')\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh/PyramidMesh.PyramidMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tPyramidMesh->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid APyramidActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid APyramidActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a skeletal mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Mesh\")\n\tUSkeletalMesh* SkeletalMeshReference;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that flashes lights on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FlashLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFlashLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAFlashLightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Input function to toggle light\n\tvoid ToggleLight();\n\nprivate:\n\t// Point Light Component\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPointLightComponent* PointLight;\n\n\t// Light toggling state\n\tbool bIsLightOn;\n};\n```", "cpp_code": "```cpp\n#include \"FlashLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAFlashLightActor::AFlashLightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create PointLight component and attach to actor\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\t// Initialize light state\n\tbIsLightOn = false;\n\n\t// Initially, turn off the light\n\tPointLight->SetVisibility(bIsLightOn);\n}\n\n// Called when the game starts or when spawned\nvoid AFlashLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind the ToggleLight function to the input\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tInputComponent = NewObject<UInputComponent>(this);\n\t\tInputComponent->RegisterComponent();\n\t\tInputComponent->BindAction(\"ToggleLight\", IE_Pressed, this, &AFlashLightActor::ToggleLight);\n\t\tPlayerController->PushInputComponent(InputComponent);\n\t}\n}\n\n// Called every frame\nvoid AFlashLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Toggle the light on and off\nvoid AFlashLightActor::ToggleLight()\n{\n\tbIsLightOn = !bIsLightOn;\n\tPointLight->SetVisibility(bIsLightOn);\n}\n```"}
{"requirement": "Create a component that toggles visibility on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleVisibilityComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UToggleVisibilityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUToggleVisibilityComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPrimitiveComponent* OwnerPrimitive;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n\n// Sets default values for this component's properties\nUToggleVisibilityComponent::UToggleVisibilityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\n// Called when the game starts\nvoid UToggleVisibilityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Attempt to get the primitive component of the owner\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwnerPrimitive = Cast<UPrimitiveComponent>(Owner->GetComponentByClass(UPrimitiveComponent::StaticClass()));\n\t\tif (OwnerPrimitive)\n\t\t{\n\t\t\tOwnerPrimitive->OnComponentBeginOverlap.AddDynamic(this, &UToggleVisibilityComponent::OnOverlapBegin);\n\t\t}\n\t}\n}\n\n// Called every frame\nvoid UToggleVisibilityComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UToggleVisibilityComponent::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OwnerPrimitive)\n\t{\n\t\tbool bIsVisible = OwnerPrimitive->IsVisible();\n\t\tOwnerPrimitive->SetVisibility(!bIsVisible);\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable particle effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"CustomParticleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomParticleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomParticleActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Particle System Component\n\tUParticleSystemComponent* ParticleSystemComponent;\n\n\t// Function to set the particle system\n\tUFUNCTION(BlueprintCallable, Category=\"Particles\")\n\tvoid SetParticleEffect(UParticleSystem* NewParticleSystem);\n};\n```", "cpp_code": "```cpp\n#include \"CustomParticleActor.h\"\n\n// Sets default values\nACustomParticleActor::ACustomParticleActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the particle system component and attach it to the root\n\tParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystem\"));\n\tRootComponent = ParticleSystemComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomParticleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACustomParticleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to set the particle system\nvoid ACustomParticleActor::SetParticleEffect(UParticleSystem* NewParticleSystem)\n{\n\tif (ParticleSystemComponent)\n\t{\n\t\tParticleSystemComponent->SetTemplate(NewParticleSystem);\n\t}\n}\n```"}
{"requirement": "Create a class that logs a message on tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALoggingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"Engine/Engine.h\"\n\nALoggingActor::ALoggingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Logging message every tick\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that spins around the Z-axis.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpinningActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpinningActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpinningActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Rotation speed in degrees per second\n\tUPROPERTY(EditAnywhere, Category = \"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"SpinningActor.h\"\n\n// Sets default values\nASpinningActor::ASpinningActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationSpeed = 90.0f; // Default rotation speed\n}\n\n// Called when the game starts or when spawned\nvoid ASpinningActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpinningActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create a simple prism actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrismActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API APrismActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAPrismActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUProceduralMeshComponent* MeshComponent;\n\n\tvoid CreatePrism();\n};\n```", "cpp_code": "```cpp\n#include \"PrismActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\nAPrismActor::APrismActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"PrismMesh\"));\n\tRootComponent = MeshComponent;\n\n\tCreatePrism();\n}\n\nvoid APrismActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APrismActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APrismActor::CreatePrism()\n{\n\tTArray<FVector> Vertices;\n\tTArray<int32> Triangles;\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\tTArray<FColor> VertexColors;\n\tTArray<FProcMeshTangent> Tangents;\n\n\t// Define vertices for a simple triangular prism\n\tVertices.Add(FVector(0, 0, 0)); // Base triangle\n\tVertices.Add(FVector(100, 0, 0));\n\tVertices.Add(FVector(50, 100, 0));\n\n\tVertices.Add(FVector(0, 0, 100)); // Top triangle\n\tVertices.Add(FVector(100, 0, 100));\n\tVertices.Add(FVector(50, 100, 100));\n\n\t// Base face\n\tTriangles.Add(0);\n\tTriangles.Add(2);\n\tTriangles.Add(1);\n\n\t// Top face\n\tTriangles.Add(3);\n\tTriangles.Add(4);\n\tTriangles.Add(5);\n\n\t// Side faces\n\tTriangles.Add(0);\n\tTriangles.Add(1);\n\tTriangles.Add(4);\n\tTriangles.Add(0);\n\tTriangles.Add(4);\n\tTriangles.Add(3);\n\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\tTriangles.Add(5);\n\tTriangles.Add(1);\n\tTriangles.Add(5);\n\tTriangles.Add(4);\n\n\tTriangles.Add(2);\n\tTriangles.Add(0);\n\tTriangles.Add(3);\n\tTriangles.Add(2);\n\tTriangles.Add(3);\n\tTriangles.Add(5);\n\n\tMeshComponent->CreateMeshSection_LinearColor(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a material instance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Materials\")\n\tUMaterialInstance* MaterialInstanceReference;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that plays a sound on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/BoxComponent.h\"\n#include \"SoundOverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundOverlapActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  ASoundOverlapActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n  UBoxComponent* OverlapBox;\n\n  UPROPERTY(EditAnywhere, Category=\"Sound\")\n  USoundCue* SoundToPlay;\n\n  UFUNCTION()\n  void OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"SoundOverlapActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundOverlapActor::ASoundOverlapActor()\n{\n  PrimaryActorTick.bCanEverTick = false;\n\n  OverlapBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"OverlapBox\"));\n  RootComponent = OverlapBox;\n  OverlapBox->SetCollisionProfileName(TEXT(\"Trigger\"));\n  OverlapBox->OnComponentBeginOverlap.AddDynamic(this, &ASoundOverlapActor::OnOverlapBegin);\n}\n\nvoid ASoundOverlapActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid ASoundOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n  if (SoundToPlay != nullptr)\n  {\n\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n  }\n}\n```"}
{"requirement": "Create a component that changes material when activated.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"MaterialChangerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UMaterialChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUMaterialChangerComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Change material when activated\n\tUFUNCTION(BlueprintCallable, Category = \"Material\")\n\tvoid ChangeMaterial();\n\nprivate:\n\t// The material to change to\n\tUPROPERTY(EditAnywhere, Category = \"Material\")\n\tUMaterialInterface* NewMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialChangerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values for this component's properties\nUMaterialChangerComponent::UMaterialChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid UMaterialChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Change material when activated\nvoid UMaterialChangerComponent::ChangeMaterial()\n{\n\tif (!NewMaterial)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"NewMaterial is not set.\"));\n\t\treturn;\n\t}\n\n\tAActor* Owner = GetOwner();\n\tif (!Owner)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Owner not found.\"));\n\t\treturn;\n\t}\n\n\tTArray<UStaticMeshComponent*> StaticMeshComponents;\n\tOwner->GetComponents<UStaticMeshComponent>(StaticMeshComponents);\n\n\tfor (UStaticMeshComponent* MeshComponent : StaticMeshComponents)\n\t{\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a variable light intensity.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightIntensityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALightIntensityActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tALightIntensityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Lighting\")\n\tfloat LightIntensity;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPointLightComponent* PointLight;\n};\n```", "cpp_code": "```cpp\n#include \"LightIntensityActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nALightIntensityActor::ALightIntensityActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a point light component and attach it to the root\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\t// Set default light intensity\n\tLightIntensity = 3000.0f;\n\tPointLight->Intensity = LightIntensity;\n}\n\n// Called when the game starts or when spawned\nvoid ALightIntensityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Ensure the light intensity is set at the start\n\tPointLight->SetIntensity(LightIntensity);\n}\n\n// Called every frame\nvoid ALightIntensityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update light intensity if needed\n\tif (PointLight->Intensity != LightIntensity)\n\t{\n\t\tPointLight->SetIntensity(LightIntensity);\n\t}\n}\n```"}
{"requirement": "Create a class that scales up when near another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAScalingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat ScaleFactor = 1.5f;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat DetectionRadius = 500.0f;\n\n\tUFUNCTION()\n\tvoid CheckProximityAndScale();\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAScalingActor::AScalingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tCheckProximityAndScale();\n}\n\nvoid AScalingActor::CheckProximityAndScale()\n{\n\tTArray<AActor*> OverlappingActors;\n\tGetOverlappingActors(OverlappingActors);\n\n\tfor (AActor* Actor : OverlappingActors)\n\t{\n\t\tif (Actor && Actor != this)\n\t\t{\n\t\t\tfloat DistanceToActor = FVector::Dist(Actor->GetActorLocation(), GetActorLocation());\n\t\t\tif (DistanceToActor <= DetectionRadius)\n\t\t\t{\n\t\t\t\tSetActorScale3D(FVector(ScaleFactor));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tSetActorScale3D(FVector(1.0f));\n}\n```"}
{"requirement": "Create an actor that rotates towards a light source.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotateTowardsLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ARotateTowardsLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotateTowardsLightActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector GetDirectionToLight() const;\n\n\tUPROPERTY(EditAnywhere)\n\tAActor* LightSource;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed = 45.0f;\n};\n```", "cpp_code": "```cpp\n#include \"RotateTowardsLightActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\nARotateTowardsLightActor::ARotateTowardsLightActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARotateTowardsLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotateTowardsLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (LightSource)\n\t{\n\t\tFVector DirectionToLight = GetDirectionToLight();\n\t\tFRotator TargetRotation = UKismetMathLibrary::MakeRotFromX(DirectionToLight);\n\t\tFRotator NewRotation = FMath::RInterpTo(GetActorRotation(), TargetRotation, DeltaTime, RotationSpeed);\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n\nFVector ARotateTowardsLightActor::GetDirectionToLight() const\n{\n\tif (!LightSource)\n\t{\n\t\treturn FVector::ZeroVector;\n\t}\n\n\treturn (LightSource->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n}\n```"}
{"requirement": "Create a simple hexagon actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HexagonActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHexagonActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAHexagonActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* HexagonMesh;\n};\n```", "cpp_code": "```cpp\n#include \"HexagonActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAHexagonActor::AHexagonActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tHexagonMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"HexagonMesh\"));\n\tRootComponent = HexagonMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> HexagonAsset(TEXT(\"/Game/PathToYourHexagonMesh.HexagonMesh\"));\n\tif (HexagonAsset.Succeeded())\n\t{\n\t\tHexagonMesh->SetStaticMesh(HexagonAsset.Object);\n\t}\n}\n\nvoid AHexagonActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHexagonActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a HUD widget.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"YourPlayerController.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AYourPlayerController : public APlayerController\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"UI\")\n\tTSubclassOf<class UUserWidget> HUDWidgetClass;\n\n\tUPROPERTY(VisibleInstanceOnly, BlueprintReadOnly, Category=\"UI\")\n\tUUserWidget* HUDWidget;\n\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"YourPlayerController.h\"\n#include \"Blueprint/UserWidget.h\"\n\nvoid AYourPlayerController::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (HUDWidgetClass)\n\t{\n\t\tHUDWidget = CreateWidget<UUserWidget>(this, HUDWidgetClass);\n\t\tif (HUDWidget)\n\t\t{\n\t\t\tHUDWidget->AddToViewport();\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that logs its distance from the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistanceLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADistanceLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADistanceLoggerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAActor* PlayerActor;\n\n\tvoid LogDistanceToPlayer();\n};\n```", "cpp_code": "```cpp\n#include \"DistanceLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nADistanceLoggerActor::ADistanceLoggerActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ADistanceLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Get the player actor\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\n// Called every frame\nvoid ADistanceLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tLogDistanceToPlayer();\n}\n\nvoid ADistanceLoggerActor::LogDistanceToPlayer()\n{\n\tif (PlayerActor)\n\t{\n\t\tfloat Distance = FVector::Dist(PlayerActor->GetActorLocation(), GetActorLocation());\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Distance to player: %f\"), Distance);\n\t}\n}\n```"}
{"requirement": "Create a component with a custom activation function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomActivationComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomActivationComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUCustomActivationComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Custom Activation\")\n\tvoid CustomActivate();\n};\n```", "cpp_code": "```cpp\n#include \"CustomActivationComponent.h\"\n\nUCustomActivationComponent::UCustomActivationComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UCustomActivationComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCustomActivationComponent::CustomActivate()\n{\n\t// Implement your custom activation logic here\n\tUE_LOG(LogTemp, Warning, TEXT(\"CustomActivate function called.\"));\n}\n```"}
{"requirement": "Create an actor with a customizable rotation speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 180.0f; // Default rotation speed\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create a class that changes mesh based on a condition.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MeshChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMeshChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMeshChanger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMesh* FirstMesh;\n\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMesh* SecondMesh;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Mesh\")\n\tvoid ChangeMesh(bool bUseFirstMesh);\n};\n```", "cpp_code": "```cpp\n#include \"MeshChanger.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAMeshChanger::AMeshChanger()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AMeshChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMeshChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMeshChanger::ChangeMesh(bool bUseFirstMesh)\n{\n\tif (MeshComponent)\n\t{\n\t\tif (bUseFirstMesh && FirstMesh)\n\t\t{\n\t\t\tMeshComponent->SetStaticMesh(FirstMesh);\n\t\t}\n\t\telse if (SecondMesh)\n\t\t{\n\t\t\tMeshComponent->SetStaticMesh(SecondMesh);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that plays a sound when destroyed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundOnDestroyActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundOnDestroyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundOnDestroyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sound to play when destroyed\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* DestroySound;\n\n\t// Override the EndPlay function\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n};\n```", "cpp_code": "```cpp\n#include \"SoundOnDestroyActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundOnDestroyActor::ASoundOnDestroyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundOnDestroyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASoundOnDestroyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called when the actor is destroyed\nvoid ASoundOnDestroyActor::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// Check if the destroy sound is set\n\tif (DestroySound && EndPlayReason == EEndPlayReason::Destroyed)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, DestroySound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a simple octagon actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OctagonActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AOctagonActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOctagonActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Function to create the octagon shape\n\tvoid CreateOctagon();\n\n\t// Component to hold the octagon mesh\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* OctagonMesh;\n};\n```", "cpp_code": "```cpp\n#include \"OctagonActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAOctagonActor::AOctagonActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the StaticMeshComponent\n\tOctagonMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"OctagonMesh\"));\n\tRootComponent = OctagonMesh;\n\n\t// Find and set the octagon mesh (assuming you have an octagon mesh asset)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> OctagonAsset(TEXT(\"StaticMesh'/Game/PathToYourMesh/OctagonMesh.OctagonMesh'\"));\n\tif (OctagonAsset.Succeeded())\n\t{\n\t\tOctagonMesh->SetStaticMesh(OctagonAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AOctagonActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOctagonActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to create the octagon shape\nvoid AOctagonActor::CreateOctagon()\n{\n\t// Implementation for creating an octagon shape would go here if needed.\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a sound wave.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundWave.h\"\n#include \"YourClass.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourClass : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourClass();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Audio\")\n\tUSoundWave* SoundWaveReference;\n};\n```", "cpp_code": "```cpp\n#include \"YourClass.h\"\n\nAYourClass::AYourClass()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourClass::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourClass::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that moves up and down with a sine wave.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SineWaveMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASineWaveMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tASineWaveMover();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialLocation;\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Amplitude;\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Frequency;\n\tfloat RunningTime;\n};\n```", "cpp_code": "```cpp\n#include \"SineWaveMover.h\"\n\n// Sets default values\nASineWaveMover::ASineWaveMover()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAmplitude = 100.0f;\n\tFrequency = 1.0f;\n\tRunningTime = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASineWaveMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid ASineWaveMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tRunningTime += DeltaTime;\n\tfloat DeltaHeight = Amplitude * FMath::Sin(Frequency * RunningTime);\n\tFVector NewLocation = InitialLocation;\n\tNewLocation.Z += DeltaHeight;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a component that logs its activation time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TimeLoggingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTimeLoggingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUTimeLoggingComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called when the component is activated\n\tvirtual void Activate(bool bReset = false) override;\n};\n```", "cpp_code": "```cpp\n#include \"TimeLoggingComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values for this component's properties\nUTimeLoggingComponent::UTimeLoggingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid UTimeLoggingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called when the component is activated\nvoid UTimeLoggingComponent::Activate(bool bReset)\n{\n\tSuper::Activate(bReset);\n\n\tFDateTime ActivationTime = FDateTime::Now();\n\tUE_LOG(LogTemp, Log, TEXT(\"Component activated at: %s\"), *ActivationTime.ToString());\n}\n```"}
{"requirement": "Create an actor with a customizable movement direction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomizableMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomizableMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomizableMovementActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Movement speed of the actor\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MovementSpeed;\n\n\t// Movement direction of the actor\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector MovementDirection;\n};\n```", "cpp_code": "```cpp\n#include \"CustomizableMovementActor.h\"\n\n// Sets default values\nACustomizableMovementActor::ACustomizableMovementActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default values\n\tMovementSpeed = 100.0f;\n\tMovementDirection = FVector(1.0f, 0.0f, 0.0f); // Default to moving along the X-axis\n}\n\n// Called when the game starts or when spawned\nvoid ACustomizableMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACustomizableMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Move the actor in the specified direction\n\tFVector NewLocation = GetActorLocation() + (MovementDirection * MovementSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a class that rotates based on player input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotationActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n\n\tvoid RotateActor(float Value);\n\nprivate:\n\tFRotator CurrentRotation;\n};\n```", "cpp_code": "```cpp\n#include \"RotationActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nARotationActor::ARotationActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 45.0f; // Default rotation speed\n}\n\nvoid ARotationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tfloat RotationInput;\n\t\tPlayerController->GetInputAxisValue(TEXT(\"Rotate\"), RotationInput);\n\t\tRotateActor(RotationInput);\n\t}\n}\n\nvoid ARotationActor::RotateActor(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tCurrentRotation = GetActorRotation();\n\t\tCurrentRotation.Yaw += Value * RotationSpeed * GetWorld()->GetDeltaSeconds();\n\t\tSetActorRotation(CurrentRotation);\n\t}\n}\n```"}
{"requirement": "Create an actor that can be toggled on/off with a key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to toggle the visibility\n\tvoid ToggleVisibility();\n\nprivate:\n\t// Tracks whether the actor is visible or not\n\tbool bIsVisible;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleableActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAToggleableActor::AToggleableActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsVisible = true; // Initially visible\n}\n\n// Called when the game starts or when spawned\nvoid AToggleableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AToggleableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Check if the player is pressing the 'T' key\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tif (PlayerController->WasInputKeyJustPressed(EKeys::T))\n\t\t{\n\t\t\tToggleVisibility();\n\t\t}\n\t}\n}\n\nvoid AToggleableActor::ToggleVisibility()\n{\n\tbIsVisible = !bIsVisible;\n\tSetActorHiddenInGame(!bIsVisible);\n\tSetActorEnableCollision(bIsVisible);\n}\n```"}
{"requirement": "Create a simple cylinder grid actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CylinderGridActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ACylinderGridActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tACylinderGridActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tint32 GridRows;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tint32 GridColumns;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tfloat CylinderHeight;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tfloat CylinderRadius;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Grid\")\n\tfloat Spacing;\n\nprivate:\n\tvoid CreateCylinderGrid();\n};\n```", "cpp_code": "```cpp\n#include \"CylinderGridActor.h\"\n#include \"Engine/World.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACylinderGridActor::ACylinderGridActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tGridRows = 5;\n\tGridColumns = 5;\n\tCylinderHeight = 100.0f;\n\tCylinderRadius = 50.0f;\n\tSpacing = 150.0f;\n\n\tCreateCylinderGrid();\n}\n\n// Called when the game starts or when spawned\nvoid ACylinderGridActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACylinderGridActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACylinderGridActor::CreateCylinderGrid()\n{\n\tUStaticMesh* CylinderMesh = LoadObject<UStaticMesh>(nullptr, TEXT(\"/Engine/BasicShapes/Cylinder.Cylinder\"));\n\n\tif (CylinderMesh)\n\t{\n\t\tfor (int32 Row = 0; Row < GridRows; ++Row)\n\t\t{\n\t\t\tfor (int32 Col = 0; Col < GridColumns; ++Col)\n\t\t\t{\n\t\t\t\tFVector Position(Row * Spacing, Col * Spacing, 0);\n\t\t\t\tFTransform Transform(FRotator::ZeroRotator, Position);\n\n\t\t\t\tUStaticMeshComponent* CylinderComponent = NewObject<UStaticMeshComponent>(this);\n\t\t\t\tCylinderComponent->SetStaticMesh(CylinderMesh);\n\t\t\t\tCylinderComponent->SetWorldScale3D(FVector(CylinderRadius / 50.0f, CylinderRadius / 50.0f, CylinderHeight / 100.0f));\n\t\t\t\tCylinderComponent->SetWorldTransform(Transform);\n\t\t\t\tCylinderComponent->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepWorldTransform);\n\t\t\t\tCylinderComponent->RegisterComponent();\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a skybox.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SkyboxActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASkyboxActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tASkyboxActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Skybox\")\n\tclass UMaterialInterface* SkyboxMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"SkyboxActor.h\"\n\nASkyboxActor::ASkyboxActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASkyboxActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASkyboxActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that logs a message when activated.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Custom function to activate the actor\n\tUFUNCTION(BlueprintCallable, Category=\"Activation\")\n\tvoid ActivateActor();\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingActor::ALoggingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Custom function to activate the actor\nvoid ALoggingActor::ActivateActor()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Actor Activated!\"));\n\t}\n}\n```"}
{"requirement": "Create a component that rotates when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"RotatingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API URotatingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tURotatingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tvoid RotateActor();\n\n\tUPROPERTY(EditAnywhere)\n\tFRotator RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\nURotatingComponent::URotatingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tRotationSpeed = FRotator(0.f, 100.f, 0.f); // Default rotation speed\n}\n\nvoid URotatingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotatingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (GEngine && GEngine->GameViewport)\n\t{\n\t\tAPlayerController* PlayerController = GEngine->GetFirstLocalPlayerController(GetWorld());\n\t\tif (PlayerController)\n\t\t{\n\t\t\tif (PlayerController->IsInputKeyDown(EKeys::R)) // Change 'R' to any key you want to use\n\t\t\t{\n\t\t\t\tRotateActor();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid URotatingComponent::RotateActor()\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->AddActorLocalRotation(RotationSpeed * GetWorld()->GetDeltaSeconds());\n\t}\n}\n```"}
{"requirement": "Create an actor with a scalable light effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalableLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalableLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScalableLightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Point light component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Light\")\n\tclass UPointLightComponent* PointLight;\n\n\t// Function to scale light intensity\n\tUFUNCTION(BlueprintCallable, Category=\"Light\")\n\tvoid ScaleLightIntensity(float ScaleFactor);\n};\n```", "cpp_code": "```cpp\n#include \"ScalableLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nAScalableLightActor::AScalableLightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a point light component\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\t// Set default intensity\n\tPointLight->Intensity = 3000.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AScalableLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScalableLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to scale light intensity\nvoid AScalableLightActor::ScaleLightIntensity(float ScaleFactor)\n{\n\tif (PointLight)\n\t{\n\t\tPointLight->SetIntensity(PointLight->Intensity * ScaleFactor);\n\t}\n}\n```"}
{"requirement": "Create a class that changes its location with a trigger.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TriggerableMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATriggerableMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATriggerableMover();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnTriggerOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(EditAnywhere)\n\tFVector NewLocation;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* TriggerVolume;\n};\n```", "cpp_code": "```cpp\n#include \"TriggerableMover.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nATriggerableMover::ATriggerableMover()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n\tRootComponent = TriggerVolume;\n\n\tTriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &ATriggerableMover::OnTriggerOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ATriggerableMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATriggerableMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATriggerableMover::OnTriggerOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that spins at a constant rate.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpinningActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpinningActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tASpinningActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Spinning\")\n\tfloat RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"SpinningActor.h\"\n\nASpinningActor::ASpinningActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationRate = 45.0f; // degrees per second\n}\n\nvoid ASpinningActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpinningActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationRate * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create a simple octahedron actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OctahedronActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOctahedronActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAOctahedronActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUProceduralMeshComponent* MeshComponent;\n\n\tvoid CreateOctahedron();\n};\n```", "cpp_code": "```cpp\n#include \"OctahedronActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\n// Sets default values\nAOctahedronActor::AOctahedronActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"GeneratedMesh\"));\n\tRootComponent = MeshComponent;\n\n\tCreateOctahedron();\n}\n\n// Called when the game starts or when spawned\nvoid AOctahedronActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AOctahedronActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOctahedronActor::CreateOctahedron()\n{\n\tTArray<FVector> Vertices;\n\tTArray<int32> Triangles;\n\n\t// Define the vertices of the octahedron\n\tVertices.Add(FVector(0, 0, 1));  // Top vertex\n\tVertices.Add(FVector(1, 0, 0));  // Right vertex\n\tVertices.Add(FVector(-1, 0, 0)); // Left vertex\n\tVertices.Add(FVector(0, 1, 0));  // Front vertex\n\tVertices.Add(FVector(0, -1, 0)); // Back vertex\n\tVertices.Add(FVector(0, 0, -1)); // Bottom vertex\n\n\t// Top half triangles\n\tTriangles.Add(0); Triangles.Add(2); Triangles.Add(3);\n\tTriangles.Add(0); Triangles.Add(3); Triangles.Add(1);\n\tTriangles.Add(0); Triangles.Add(1); Triangles.Add(4);\n\tTriangles.Add(0); Triangles.Add(4); Triangles.Add(2);\n\n\t// Bottom half triangles\n\tTriangles.Add(5); Triangles.Add(3); Triangles.Add(2);\n\tTriangles.Add(5); Triangles.Add(1); Triangles.Add(3);\n\tTriangles.Add(5); Triangles.Add(4); Triangles.Add(1);\n\tTriangles.Add(5); Triangles.Add(2); Triangles.Add(4);\n\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UVs;\n\tTArray<FProcMeshTangent> Tangents;\n\tTArray<FLinearColor> VertexColors;\n\n\t// Generate empty arrays for now\n\tfor (int32 i = 0; i < Vertices.Num(); i++)\n\t{\n\t\tNormals.Add(FVector(1, 0, 0));\n\t\tUVs.Add(FVector2D(0, 0));\n\t\tTangents.Add(FProcMeshTangent(0, 1, 0));\n\t\tVertexColors.Add(FLinearColor(1, 1, 1, 1));\n\t}\n\n\t// Create the mesh section\n\tMeshComponent->CreateMeshSection_LinearColor(0, Vertices, Triangles, Normals, UVs, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to an animation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Animation\")\n\tUAnimSequence* AnimationReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that plays a sound on interaction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundInteractionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundInteractionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundInteractionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundCue* InteractionSound;\n\n\tUFUNCTION()\n\tvoid PlaySound();\n};\n```", "cpp_code": "```cpp\n#include \"SoundInteractionActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundInteractionActor::ASoundInteractionActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundInteractionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASoundInteractionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundInteractionActor::PlaySound()\n{\n\tif (InteractionSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, InteractionSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that changes scale based on input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleChangerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UScaleChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUScaleChangerComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \t\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\t// Function to modify scale\n\tvoid ChangeScale(float ScaleFactor);\n\nprivate:\n\t// Input binding function\n\tvoid SetupInputComponent();\n\n\t// Reference to the input component\n\tUInputComponent* InputComponent;\n\n\t// Scale factor\n\tfloat CurrentScale;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values for this component's properties\nUScaleChangerComponent::UScaleChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCurrentScale = 1.0f;\n}\n\n// Called when the game starts\nvoid UScaleChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetupInputComponent();\n}\n\n// Called every frame\nvoid UScaleChangerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UScaleChangerComponent::ChangeScale(float ScaleFactor)\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tFVector NewScale = Owner->GetActorScale3D() * ScaleFactor;\n\t\tOwner->SetActorScale3D(NewScale);\n\t\tCurrentScale *= ScaleFactor;\n\t}\n}\n\nvoid UScaleChangerComponent::SetupInputComponent()\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tInputComponent = Owner->FindComponentByClass<UInputComponent>();\n\t\tif (InputComponent)\n\t\t{\n\t\t\tInputComponent->BindAction(\"IncreaseScale\", IE_Pressed, this, &UScaleChangerComponent::ChangeScale).bConsumeInput = false;\n\t\t\tInputComponent->BindAction(\"DecreaseScale\", IE_Pressed, this, &UScaleChangerComponent::ChangeScale).bConsumeInput = false;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable mesh switcher.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MeshSwitcherActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMeshSwitcherActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMeshSwitcherActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to switch mesh\n\tUFUNCTION(BlueprintCallable, Category=\"Mesh\")\n\tvoid SwitchMesh(UStaticMesh* NewMesh);\n\nprivate:\n\t// Static mesh component\n\tUPROPERTY(VisibleAnywhere, Category=\"Mesh\")\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MeshSwitcherActor.h\"\n\n// Sets default values\nAMeshSwitcherActor::AMeshSwitcherActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AMeshSwitcherActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMeshSwitcherActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Switch the mesh\nvoid AMeshSwitcherActor::SwitchMesh(UStaticMesh* NewMesh)\n{\n\tif (NewMesh && MeshComponent)\n\t{\n\t\tMeshComponent->SetStaticMesh(NewMesh);\n\t}\n}\n```"}
{"requirement": "Create a class that changes material based on time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMaterialChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ChangeMaterial();\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* Material1;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* Material2;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat ChangeInterval;\n\n\tfloat TimeSinceLastChange;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialChanger.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n\nAMaterialChanger::AMaterialChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tChangeInterval = 5.0f; // Default interval of 5 seconds\n\tTimeSinceLastChange = 0.0f;\n}\n\nvoid AMaterialChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMaterialChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeSinceLastChange += DeltaTime;\n\n\tif (TimeSinceLastChange >= ChangeInterval)\n\t{\n\t\tChangeMaterial();\n\t\tTimeSinceLastChange = 0.0f;\n\t}\n}\n\nvoid AMaterialChanger::ChangeMaterial()\n{\n\tUStaticMeshComponent* Mesh = FindComponentByClass<UStaticMeshComponent>();\n\n\tif (Mesh)\n\t{\n\t\tUMaterialInterface* CurrentMaterial = Mesh->GetMaterial(0);\n\t\tUMaterialInterface* NewMaterial = (CurrentMaterial == Material1) ? Material2 : Material1;\n\t\tMesh->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Create an actor that follows mouse movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseFollowerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMouseFollowerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic: \n\tAMouseFollowerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector2D GetMousePosition() const;\n};\n```", "cpp_code": "```cpp\n#include \"MouseFollowerActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Actor.h\"\n\nAMouseFollowerActor::AMouseFollowerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMouseFollowerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMouseFollowerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector2D MousePosition = GetMousePosition();\n\tFVector WorldLocation, WorldDirection;\n\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController && PlayerController->DeprojectScreenPositionToWorld(MousePosition.X, MousePosition.Y, WorldLocation, WorldDirection))\n\t{\n\t\tFVector NewLocation = WorldLocation + WorldDirection * 100.0f; // Adjust distance as needed\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n\nFVector2D AMouseFollowerActor::GetMousePosition() const\n{\n\tFVector2D MousePosition;\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tPlayerController->GetMousePosition(MousePosition.X, MousePosition.Y);\n\t}\n\treturn MousePosition;\n}\n```"}
{"requirement": "Create a simple rhombus actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RhombusActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARhombusActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARhombusActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* RhombusMesh;\n};\n```", "cpp_code": "```cpp\n#include \"RhombusActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nARhombusActor::ARhombusActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRhombusMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"RhombusMesh\"));\n\tRootComponent = RhombusMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> RhombusMeshAsset(TEXT(\"/Game/Path/To/Your/RhombusMesh.RhombusMesh\"));\n\tif (RhombusMeshAsset.Succeeded())\n\t{\n\t\tRhombusMesh->SetStaticMesh(RhombusMeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ARhombusActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARhombusActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a blueprint event.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"YourClass.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UYourClass : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPROPERTY(BlueprintAssignable, Category = \"Events\")\n\tFYourEventDelegate OnYourEvent;\n};\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FYourEventDelegate);\n```", "cpp_code": "```cpp\n#include \"YourClass.h\"\n\n// Implementation of any necessary methods or logic for UYourClass can be added here.\n\n// Example of calling the event\nvoid UYourClass::TriggerEvent()\n{\n\tOnYourEvent.Broadcast();\n}\n```"}
{"requirement": "Create an actor that emits particles on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ParticleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AParticleActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  AParticleActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  // Particle system component\n  UPROPERTY(VisibleAnywhere, Category = \"Particles\")\n  UParticleSystemComponent* ParticleSystem;\n\n  // Function to handle key press\n  void OnKeyPress();\n\nprotected:\n  // Input handling\n  virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ParticleActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAParticleActor::AParticleActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Create particle system component and attach to root\n  ParticleSystem = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystem\"));\n  RootComponent = ParticleSystem;\n}\n\n// Called when the game starts or when spawned\nvoid AParticleActor::BeginPlay()\n{\n  Super::BeginPlay();\n\n  // Ensure the input component is enabled\n  EnableInput(GetWorld()->GetFirstPlayerController());\n}\n\n// Called every frame\nvoid AParticleActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\n// Input setup\nvoid AParticleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n  Super::SetupPlayerInputComponent(PlayerInputComponent);\n  PlayerInputComponent->BindAction(\"EmitParticles\", IE_Pressed, this, &AParticleActor::OnKeyPress);\n}\n\n// Function to handle key press\nvoid AParticleActor::OnKeyPress()\n{\n  if (ParticleSystem && !ParticleSystem->IsActive())\n  {\n\tParticleSystem->ActivateSystem();\n  }\n}\n```"}
{"requirement": "Create a component that toggles light on/off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleLightComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UToggleLightComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this component's properties\n\tUToggleLightComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Function to toggle the light\n\tUFUNCTION(BlueprintCallable, Category=\"Light\")\n\tvoid ToggleLight();\n\nprivate:\n\t// Pointer to the light component\n\tUPROPERTY()\n\tclass ULightComponent* LightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleLightComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/LightComponent.h\"\n\n// Sets default values for this component's properties\nUToggleLightComponent::UToggleLightComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid UToggleLightComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Try to find the light component in the owner actor\n\tLightComponent = GetOwner()->FindComponentByClass<ULightComponent>();\n}\n\nvoid UToggleLightComponent::ToggleLight()\n{\n\tif (LightComponent)\n\t{\n\t\tLightComponent->ToggleVisibility();\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable spline path.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SplineComponent.h\"\n#include \"CustomSplineActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomSplineActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tACustomSplineActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Spline component to define the path\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Spline\")\n\tUSplineComponent* SplineComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CustomSplineActor.h\"\n#include \"Components/SplineComponent.h\"\n\n// Sets default values\nACustomSplineActor::ACustomSplineActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create spline component and attach it to the root\n\tSplineComponent = CreateDefaultSubobject<USplineComponent>(TEXT(\"SplineComponent\"));\n\tRootComponent = SplineComponent;\n\tSplineComponent->bEditableWhenInherited = true;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomSplineActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACustomSplineActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create a class that logs a message on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyLoggingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyLoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyLoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Logs a message when a key is pressed\n\tvoid LogMessage();\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"MyLoggingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAMyLoggingActor::AMyLoggingActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyLoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyLoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Logs a message when a key is pressed\nvoid AMyLoggingActor::LogMessage()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Key Pressed!\"));\n\t}\n}\n\n// Setup player input component\nvoid AMyLoggingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the LogMessage function to a key press event\n\tPlayerInputComponent->BindAction(\"LogKey\", IE_Pressed, this, &AMyLoggingActor::LogMessage);\n}\n```"}
{"requirement": "Create an actor that changes its scale with a button press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleChangingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  AScaleChangingActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  // Function to change scale\n  void ChangeScale();\n\nprivate:\n  // Scale factor\n  UPROPERTY(EditAnywhere, Category=\"Scale\")\n  FVector ScaleFactor;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangingActor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAScaleChangingActor::AScaleChangingActor()\n{\n  // Set this actor to call Tick() every frame\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Initialize scale factor\n  ScaleFactor = FVector(1.1f, 1.1f, 1.1f);\n}\n\n// Called when the game starts or when spawned\nvoid AScaleChangingActor::BeginPlay()\n{\n  Super::BeginPlay();\n\n  // Enable input\n  EnableInput(GetWorld()->GetFirstPlayerController());\n\n  // Bind input action\n  InputComponent->BindAction(\"ChangeScale\", IE_Pressed, this, &AScaleChangingActor::ChangeScale);\n}\n\n// Called every frame\nvoid AScaleChangingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\n// Change the scale of the actor\nvoid AScaleChangingActor::ChangeScale()\n{\n  FVector NewScale = GetActorScale3D() * ScaleFactor;\n  SetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a simple parallelogram actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ParallelogramActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AParallelogramActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAParallelogramActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* ParallelogramMesh;\n\n\tvoid CreateParallelogramMesh();\n};\n```", "cpp_code": "```cpp\n#include \"ParallelogramActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAParallelogramActor::AParallelogramActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tParallelogramMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"ParallelogramMesh\"));\n\tRootComponent = ParallelogramMesh;\n\n\t// Assuming a basic plane mesh is a placeholder for the parallelogram\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Engine/BasicShapes/Plane\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tParallelogramMesh->SetStaticMesh(MeshAsset.Object);\n\t\tCreateParallelogramMesh();\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AParallelogramActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AParallelogramActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid AParallelogramActor::CreateParallelogramMesh()\n{\n\t// Logic to modify the mesh to resemble a parallelogram\n\t// This could involve manipulating vertices if a custom mesh is created\n\t// For this placeholder, assume it's already a parallelogram shape\n\tParallelogramMesh->SetRelativeScale3D(FVector(1.0f, 1.0f, 0.1f));\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a sound component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundComponentExample.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API USoundComponentExample : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUSoundComponentExample();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* SoundComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SoundComponentExample.h\"\n\nUSoundComponentExample::USoundComponentExample()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid USoundComponentExample::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid USoundComponentExample::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n```"}
{"requirement": "Create an actor that changes its size over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SizeChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ASizeChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tASizeChangingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The rate at which the actor changes its size\n\tUPROPERTY(EditAnywhere, Category=\"Size\")\n\tfloat SizeChangeRate;\n\n\t// The maximum scale the actor can reach\n\tUPROPERTY(EditAnywhere, Category=\"Size\")\n\tFVector MaxScale;\n\n\t// The minimum scale the actor can reach\n\tUPROPERTY(EditAnywhere, Category=\"Size\")\n\tFVector MinScale;\n\n\t// Current scaling direction\n\tbool bIsIncreasing;\n};\n```", "cpp_code": "```cpp\n#include \"SizeChangingActor.h\"\n\n// Sets default values\nASizeChangingActor::ASizeChangingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSizeChangeRate = 0.5f;\n\tMaxScale = FVector(2.0f, 2.0f, 2.0f);\n\tMinScale = FVector(1.0f, 1.0f, 1.0f);\n\tbIsIncreasing = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASizeChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASizeChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentScale = GetActorScale3D();\n\n\tif (bIsIncreasing)\n\t{\n\t\tCurrentScale += FVector(SizeChangeRate * DeltaTime);\n\t\tif (CurrentScale.X >= MaxScale.X || CurrentScale.Y >= MaxScale.Y || CurrentScale.Z >= MaxScale.Z)\n\t\t{\n\t\t\tbIsIncreasing = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tCurrentScale -= FVector(SizeChangeRate * DeltaTime);\n\t\tif (CurrentScale.X <= MinScale.X || CurrentScale.Y <= MinScale.Y || CurrentScale.Z <= MinScale.Z)\n\t\t{\n\t\t\tbIsIncreasing = true;\n\t\t}\n\t}\n\n\tSetActorScale3D(CurrentScale);\n}\n```"}
{"requirement": "Create a component with a custom reset function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ResettableComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UResettableComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUResettableComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Custom reset function\n\tUFUNCTION(BlueprintCallable, Category=\"Reset\")\n\tvoid ResetComponent();\n\nprivate:\n\t// Example private property to reset\n\tUPROPERTY()\n\tint32 ExampleProperty;\n};\n```", "cpp_code": "```cpp\n#include \"ResettableComponent.h\"\n\n// Sets default values for this component's properties\nUResettableComponent::UResettableComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\t// Initialize the example property\n\tExampleProperty = 0;\n}\n\n// Called when the game starts\nvoid UResettableComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Custom reset function\nvoid UResettableComponent::ResetComponent()\n{\n\t// Reset the example property to its initial value\n\tExampleProperty = 0;\n\t// Additional reset logic can be added here\n}\n```"}
{"requirement": "Create an actor with a customizable light color.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomLightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Light component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Light\")\n\tclass UPointLightComponent* PointLight;\n\n\t// Light color property\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Light\")\n\tFColor LightColor;\n};\n```", "cpp_code": "```cpp\n#include \"CustomLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nACustomLightActor::ACustomLightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach the light component\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\t// Set default light color\n\tLightColor = FColor::White;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Set the initial light color\n\tPointLight->SetLightColor(LightColor);\n}\n\n// Called every frame\nvoid ACustomLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update the light color if it changes\n\tPointLight->SetLightColor(LightColor);\n}\n```"}
{"requirement": "Create a class that moves towards the camera.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MoveTowardsCamera.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMoveTowardsCamera : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMoveTowardsCamera();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat MovementSpeed = 100.0f;\n};\n```", "cpp_code": "```cpp\n#include \"MoveTowardsCamera.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAMoveTowardsCamera::AMoveTowardsCamera()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMoveTowardsCamera::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMoveTowardsCamera::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tFVector CameraLocation;\n\t\tFRotator CameraRotation;\n\t\tPlayerController->GetPlayerViewPoint(CameraLocation, CameraRotation);\n\n\t\tFVector Direction = (CameraLocation - GetActorLocation()).GetSafeNormal();\n\t\tFVector NewLocation = GetActorLocation() + Direction * MovementSpeed * DeltaTime;\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create an actor that can be interacted with using the mouse.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InteractiveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AInteractiveActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAInteractiveActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnMouseClicked();\n\n\tUFUNCTION()\n\tvoid OnMouseOverBegin();\n\n\tUFUNCTION()\n\tvoid OnMouseOverEnd();\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"InteractiveActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAInteractiveActor::AInteractiveActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetCollisionProfileName(TEXT(\"BlockAll\"));\n\tMeshComponent->SetGenerateOverlapEvents(true);\n\n\tMeshComponent->OnClicked.AddDynamic(this, &AInteractiveActor::OnMouseClicked);\n\tMeshComponent->OnBeginCursorOver.AddDynamic(this, &AInteractiveActor::OnMouseOverBegin);\n\tMeshComponent->OnEndCursorOver.AddDynamic(this, &AInteractiveActor::OnMouseOverEnd);\n}\n\n// Called when the game starts or when spawned\nvoid AInteractiveActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AInteractiveActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AInteractiveActor::OnMouseClicked()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Mesh Clicked\"));\n\t}\n}\n\nvoid AInteractiveActor::OnMouseOverBegin()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Mouse Over Begin\"));\n\t}\n}\n\nvoid AInteractiveActor::OnMouseOverEnd()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Blue, TEXT(\"Mouse Over End\"));\n\t}\n}\n```"}
{"requirement": "Create a simple cuboid actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CuboidActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACuboidActor : public AActor\n{\n  GENERATED_BODY()\n  \npublic: \n  // Sets default values for this actor's properties\n  ACuboidActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic: \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  UPROPERTY(VisibleAnywhere)\n  UStaticMeshComponent* CuboidMesh;\n};\n```", "cpp_code": "```cpp\n#include \"CuboidActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACuboidActor::ACuboidActor()\n{\n  // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  CuboidMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"CuboidMesh\"));\n  RootComponent = CuboidMesh;\n\n  // Set the static mesh for the cuboid\n  static ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n  if (MeshAsset.Succeeded())\n  {\n\tCuboidMesh->SetStaticMesh(MeshAsset.Object);\n\tCuboidMesh->SetWorldScale3D(FVector(1.0f, 2.0f, 0.5f)); // Example scale for a cuboid\n  }\n}\n\n// Called when the game starts or when spawned\nvoid ACuboidActor::BeginPlay()\n{\n  Super::BeginPlay();\n  \n}\n\n// Called every frame\nvoid ACuboidActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a dynamic array.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY()\n\tTArray<int32> MyDynamicArray;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that plays an animation on a key event.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"AnimationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAnimationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAAnimationActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Animation to play\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Animation\")\n\tUAnimSequence* AnimationToPlay;\n\n\t// Skeletal Mesh Component\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Animation\")\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n\n\t// Function to play animation\n\tUFUNCTION()\n\tvoid PlayAnimation();\n\n\t// Input function\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"AnimationActor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAAnimationActor::AAnimationActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the skeletal mesh component\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AAnimationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AAnimationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AAnimationActor::PlayAnimation()\n{\n\tif (SkeletalMeshComponent && AnimationToPlay)\n\t{\n\t\tUAnimInstance* AnimInstance = SkeletalMeshComponent->GetAnimInstance();\n\t\tif (AnimInstance)\n\t\t{\n\t\t\tAnimInstance->Montage_Play(AnimationToPlay);\n\t\t}\n\t}\n}\n\nvoid AAnimationActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the PlayAnimation function to a key event\n\tPlayerInputComponent->BindAction(\"PlayAnimation\", IE_Pressed, this, &AAnimationActor::PlayAnimation);\n}\n```"}
{"requirement": "Create a component that scales when a key is held down.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UScaleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUScaleComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFVector InitialScale;\n\tfloat ScaleFactor;\n\n\tvoid StartScaling();\n\tvoid StopScaling();\n};\n```", "cpp_code": "```cpp\n#include \"ScaleComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nUScaleComponent::UScaleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tScaleFactor = 1.01f;\n}\n\nvoid UScaleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialScale = GetOwner()->GetActorScale3D();\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tPlayerController->InputComponent->BindAction(\"Scale\", IE_Pressed, this, &UScaleComponent::StartScaling);\n\t\tPlayerController->InputComponent->BindAction(\"Scale\", IE_Released, this, &UScaleComponent::StopScaling);\n\t}\n}\n\nvoid UScaleComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (bIsScaling)\n\t{\n\t\tFVector NewScale = GetOwner()->GetActorScale3D() * ScaleFactor;\n\t\tGetOwner()->SetActorScale3D(NewScale);\n\t}\n}\n\nvoid UScaleComponent::StartScaling()\n{\n\tbIsScaling = true;\n}\n\nvoid UScaleComponent::StopScaling()\n{\n\tbIsScaling = false;\n}\n```"}
{"requirement": "Create an actor with a customizable material instance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tACustomMaterialActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Material Instance\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Material\")\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\n\t// Base Material\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Material\")\n\tUMaterialInterface* BaseMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"CustomMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nACustomMaterialActor::ACustomMaterialActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ACustomMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (BaseMaterial)\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(BaseMaterial, this);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\n// Called every frame\nvoid ACustomMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that changes its sound based on location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundLocationActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASoundLocationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundLocationActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tUSoundCue* DefaultSoundCue;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tUSoundCue* LocationSpecificSoundCue;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tFVector TargetLocation;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tfloat LocationThreshold;\n\nprivate:\n\tvoid UpdateSoundBasedOnLocation();\n};\n```", "cpp_code": "```cpp\n#include \"SoundLocationActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundLocationActor::ASoundLocationActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tLocationThreshold = 100.0f; // Default value, can be adjusted\n}\n\nvoid ASoundLocationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateSoundBasedOnLocation();\n}\n\nvoid ASoundLocationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateSoundBasedOnLocation();\n}\n\nvoid ASoundLocationActor::UpdateSoundBasedOnLocation()\n{\n\tif (!DefaultSoundCue || !LocationSpecificSoundCue)\n\t{\n\t\treturn;\n\t}\n\n\tFVector CurrentLocation = GetActorLocation();\n\tfloat Distance = FVector::Dist(CurrentLocation, TargetLocation);\n\n\tUSoundCue* SoundToPlay = (Distance <= LocationThreshold) ? LocationSpecificSoundCue : DefaultSoundCue;\n\n\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, CurrentLocation);\n}\n```"}
{"requirement": "Create an actor that changes rotation with arrow keys.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Input functions\n\tvoid RotateYaw(float Value);\n\tvoid RotatePitch(float Value);\n\nprivate:\n\t// Rotation speed\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationSpeed = 100.0f; // Default rotation speed\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Enable input for this actor\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tEnableInput(PlayerController);\n\n\t\tInputComponent->BindAxis(\"RotateYaw\", this, &ARotatingActor::RotateYaw);\n\t\tInputComponent->BindAxis(\"RotatePitch\", this, &ARotatingActor::RotatePitch);\n\t}\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARotatingActor::RotateYaw(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Yaw += Value * RotationSpeed * GetWorld()->GetDeltaSeconds();\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n\nvoid ARotatingActor::RotatePitch(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Pitch += Value * RotationSpeed * GetWorld()->GetDeltaSeconds();\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create a simple trapezoid actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TrapezoidActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATrapezoidActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tATrapezoidActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n#if WITH_EDITOR\n\tvirtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;\n#endif\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Trapezoid\")\n\tfloat TopWidth;\n\n\tUPROPERTY(EditAnywhere, Category=\"Trapezoid\")\n\tfloat BottomWidth;\n\n\tUPROPERTY(EditAnywhere, Category=\"Trapezoid\")\n\tfloat Height;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUProceduralMeshComponent* MeshComponent;\n\n\tvoid GenerateMesh();\n};\n```", "cpp_code": "```cpp\n#include \"TrapezoidActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\n// Sets default values\nATrapezoidActor::ATrapezoidActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"GeneratedMesh\"));\n\tRootComponent = MeshComponent;\n\n\tTopWidth = 100.0f;\n\tBottomWidth = 200.0f;\n\tHeight = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ATrapezoidActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGenerateMesh();\n}\n\nvoid ATrapezoidActor::GenerateMesh()\n{\n\tTArray<FVector> Vertices;\n\tTArray<int32> Triangles;\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\tTArray<FProcMeshTangent> Tangents;\n\tTArray<FColor> VertexColors;\n\n\t// Define vertices of the trapezoid\n\tVertices.Add(FVector(-TopWidth / 2, 0, Height)); // Top left\n\tVertices.Add(FVector(TopWidth / 2, 0, Height));  // Top right\n\tVertices.Add(FVector(-BottomWidth / 2, 0, 0));   // Bottom left\n\tVertices.Add(FVector(BottomWidth / 2, 0, 0));\t// Bottom right\n\n\t// Define two triangles\n\tTriangles.Add(0);\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\n\tTriangles.Add(1);\n\tTriangles.Add(3);\n\tTriangles.Add(2);\n\n\t// Normals\n\tfor (int32 i = 0; i < 4; ++i)\n\t{\n\t\tNormals.Add(FVector(0, -1, 0));\n\t}\n\n\t// UVs\n\tUV0.Add(FVector2D(0.0f, 0.0f));\n\tUV0.Add(FVector2D(1.0f, 0.0f));\n\tUV0.Add(FVector2D(0.0f, 1.0f));\n\tUV0.Add(FVector2D(1.0f, 1.0f));\n\n\t// Tangents\n\tfor (int32 i = 0; i < 4; ++i)\n\t{\n\t\tTangents.Add(FProcMeshTangent(1, 0, 0));\n\t}\n\n\t// Vertex colors\n\tfor (int32 i = 0; i < 4; ++i)\n\t{\n\t\tVertexColors.Add(FColor::White);\n\t}\n\n\tMeshComponent->CreateMeshSection_LinearColor(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n\n// Called every frame\nvoid ATrapezoidActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n#if WITH_EDITOR\nvoid ATrapezoidActor::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)\n{\n\tSuper::PostEditChangeProperty(PropertyChangedEvent);\n\n\tGenerateMesh();\n}\n#endif\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a visibility setting.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VisibilitySettings.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVisibilitySettings : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAVisibilitySettings();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Visibility Settings\")\n\tbool bIsVisible;\n};\n```", "cpp_code": "```cpp\n#include \"VisibilitySettings.h\"\n\nAVisibilitySettings::AVisibilitySettings()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsVisible = true; // Default value\n}\n\nvoid AVisibilitySettings::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AVisibilitySettings::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t// Update visibility based on bIsVisible\n\tSetActorHiddenInGame(!bIsVisible);\n}\n```"}
{"requirement": "Create an actor that logs its rotation every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingActor::ALoggingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator ActorRotation = GetActorRotation();\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor Rotation: Pitch=%f, Yaw=%f, Roll=%f\"), ActorRotation.Pitch, ActorRotation.Yaw, ActorRotation.Roll);\n}\n```"}
{"requirement": "Create a component that emits particles at intervals.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"ParticleEmitterComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECTNAME_API UParticleEmitterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUParticleEmitterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Activate(bool bReset = false) override;\n\tvirtual void Deactivate() override;\n\nprivate:\n\tUParticleSystemComponent* ParticleSystemComponent;\n\n\tFTimerHandle TimerHandle;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat EmissionInterval;\n\n\tUPROPERTY(EditAnywhere)\n\tUParticleSystem* ParticleSystemTemplate;\n\n\tvoid EmitParticles();\n};\n```", "cpp_code": "```cpp\n#include \"ParticleEmitterComponent.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n\nUParticleEmitterComponent::UParticleEmitterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tEmissionInterval = 1.0f; // Default interval\n\tParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystemComponent\"));\n}\n\nvoid UParticleEmitterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (ParticleSystemTemplate)\n\t{\n\t\tParticleSystemComponent->SetTemplate(ParticleSystemTemplate);\n\t}\n}\n\nvoid UParticleEmitterComponent::Activate(bool bReset)\n{\n\tSuper::Activate(bReset);\n\tif (GetWorld())\n\t{\n\t\tGetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &UParticleEmitterComponent::EmitParticles, EmissionInterval, true);\n\t}\n}\n\nvoid UParticleEmitterComponent::Deactivate()\n{\n\tSuper::Deactivate();\n\tGetWorld()->GetTimerManager().ClearTimer(TimerHandle);\n}\n\nvoid UParticleEmitterComponent::EmitParticles()\n{\n\tif (ParticleSystemComponent && ParticleSystemTemplate)\n\t{\n\t\tParticleSystemComponent->ActivateSystem();\n\t}\n}\n```"}
{"requirement": "Create an actor with customizable tick behavior.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomTickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomTickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACustomTickActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\t\n\tUFUNCTION(BlueprintCallable, Category=\"CustomTick\")\n\tvoid SetTickEnabled(bool bEnabled);\n\n\tUFUNCTION(BlueprintCallable, Category=\"CustomTick\")\n\tbool IsTickEnabled() const;\n\nprivate:\n\tbool bCanTick;\n};\n```", "cpp_code": "```cpp\n#include \"CustomTickActor.h\"\n\nACustomTickActor::ACustomTickActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbCanTick = true;\n}\n\nvoid ACustomTickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\t\n}\n\nvoid ACustomTickActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!bCanTick)\n\t{\n\t\treturn;\n\t}\n\n\t// Custom tick functionality here\n}\n\nvoid ACustomTickActor::SetTickEnabled(bool bEnabled)\n{\n\tbCanTick = bEnabled;\n\tPrimaryActorTick.SetTickFunctionEnable(bEnabled);\n}\n\nbool ACustomTickActor::IsTickEnabled() const\n{\n\treturn bCanTick;\n}\n```"}
{"requirement": "Create a class that logs a message on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACollisionLogger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnCollision(AActor* OverlappedActor, AActor* OtherActor);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionLogger.h\"\n#include \"GameFramework/Actor.h\"\n\nACollisionLogger::ACollisionLogger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tOnActorBeginOverlap.AddDynamic(this, &ACollisionLogger::OnCollision);\n}\n\nvoid ACollisionLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionLogger::OnCollision(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && OtherActor != this)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Collision detected with %s\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Create an actor that moves in a square path.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SquarePathActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASquarePathActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASquarePathActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector StartLocation;\n\tFVector CurrentTarget;\n\tTArray<FVector> PathPoints;\n\tint32 CurrentPathIndex;\n\tfloat MoveSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"SquarePathActor.h\"\n\nASquarePathActor::ASquarePathActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMoveSpeed = 100.0f;\n\tCurrentPathIndex = 0;\n}\n\nvoid ASquarePathActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartLocation = GetActorLocation();\n\tPathPoints.Add(StartLocation);\n\tPathPoints.Add(StartLocation + FVector(100, 0, 0));\n\tPathPoints.Add(StartLocation + FVector(100, 100, 0));\n\tPathPoints.Add(StartLocation + FVector(0, 100, 0));\n\tCurrentTarget = PathPoints[CurrentPathIndex];\n}\n\nvoid ASquarePathActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (FVector::Dist(GetActorLocation(), CurrentTarget) < KINDA_SMALL_NUMBER)\n\t{\n\t\tCurrentPathIndex = (CurrentPathIndex + 1) % PathPoints.Num();\n\t\tCurrentTarget = PathPoints[CurrentPathIndex];\n\t}\n\n\tFVector Direction = (CurrentTarget - GetActorLocation()).GetSafeNormal();\n\tSetActorLocation(GetActorLocation() + Direction * MoveSpeed * DeltaTime);\n}\n```"}
{"requirement": "Create a simple rhomboid actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RhomboidActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARhomboidActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARhomboidActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Rhomboid mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* RhomboidMesh;\n};\n```", "cpp_code": "```cpp\n#include \"RhomboidActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nARhomboidActor::ARhomboidActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach the rhomboid mesh component\n\tRhomboidMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"RhomboidMesh\"));\n\tRootComponent = RhomboidMesh;\n\n\t// Load a basic shape mesh (e.g., a cube) and scale it to form a rhomboid\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tRhomboidMesh->SetStaticMesh(MeshAsset.Object);\n\n\t\t// Set the scale to form a rhomboid shape\n\t\tRhomboidMesh->SetRelativeScale3D(FVector(1.0f, 0.5f, 0.5f));\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ARhomboidActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARhomboidActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to an input event.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Input\")\n\tFName InputEventName;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its texture on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TextureSwapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureSwapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATextureSwapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Texture\")\n\tUTexture* NewTexture;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"TextureSwapActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nATextureSwapActor::ATextureSwapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ATextureSwapActor::OnOverlapBegin);\n}\n\nvoid ATextureSwapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATextureSwapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATextureSwapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (NewTexture && MeshComponent)\n\t{\n\t\tMeshComponent->SetMaterial(0, UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this));\n\t\tUMaterialInstanceDynamic* DynamicMaterial = Cast<UMaterialInstanceDynamic>(MeshComponent->GetMaterial(0));\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tDynamicMaterial->SetTextureParameterValue(TEXT(\"TextureParameter\"), NewTexture);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a component that toggles mesh visibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleVisibilityComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UToggleVisibilityComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUToggleVisibilityComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void ToggleVisibility();\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values for this component's properties\nUToggleVisibilityComponent::UToggleVisibilityComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid UToggleVisibilityComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tMeshComponent = GetOwner()->FindComponentByClass<UStaticMeshComponent>();\n\tif (!MeshComponent)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"No StaticMeshComponent found on %s\"), *GetOwner()->GetName());\n\t}\n}\n\nvoid UToggleVisibilityComponent::ToggleVisibility()\n{\n\tif (MeshComponent)\n\t{\n\t\tbool bIsVisible = MeshComponent->IsVisible();\n\t\tMeshComponent->SetVisibility(!bIsVisible);\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable light flicker effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FlickeringLight.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFlickeringLight : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAFlickeringLight();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPointLightComponent* PointLight;\n\n\tUPROPERTY(EditAnywhere, Category=\"Flicker\")\n\tfloat FlickerIntensityMin;\n\n\tUPROPERTY(EditAnywhere, Category=\"Flicker\")\n\tfloat FlickerIntensityMax;\n\n\tUPROPERTY(EditAnywhere, Category=\"Flicker\")\n\tfloat FlickerSpeed;\n\n\tvoid FlickerLight(float DeltaTime);\n\n\tfloat CurrentIntensity;\n};\n```", "cpp_code": "```cpp\n#include \"FlickeringLight.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"Engine/World.h\"\n\nAFlickeringLight::AFlickeringLight()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\tFlickerIntensityMin = 1000.0f;\n\tFlickerIntensityMax = 3000.0f;\n\tFlickerSpeed = 5.0f;\n\n\tCurrentIntensity = FlickerIntensityMax;\n}\n\nvoid AFlickeringLight::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AFlickeringLight::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFlickerLight(DeltaTime);\n}\n\nvoid AFlickeringLight::FlickerLight(float DeltaTime)\n{\n\tfloat TargetIntensity = FMath::Lerp(FlickerIntensityMin, FlickerIntensityMax, FMath::FRand());\n\tCurrentIntensity = FMath::FInterpTo(CurrentIntensity, TargetIntensity, DeltaTime, FlickerSpeed);\n\tPointLight->SetIntensity(CurrentIntensity);\n}\n```"}
{"requirement": "Create a class that changes its scale based on time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScaleChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t/** Initial scale of the actor */\n\tFVector InitialScale;\n\n\t/** Time elapsed since start */\n\tfloat TimeElapsed;\n\n\t/** Scale factor per second */\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tfloat ScaleFactorPerSecond;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangingActor.h\"\n\nAScaleChangingActor::AScaleChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tInitialScale = FVector(1.0f, 1.0f, 1.0f);\n\tTimeElapsed = 0.0f;\n\tScaleFactorPerSecond = 0.1f; // Example scale factor\n}\n\nvoid AScaleChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialScale = GetActorScale3D();\n}\n\nvoid AScaleChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeElapsed += DeltaTime;\n\n\tfloat ScaleFactor = 1.0f + (ScaleFactorPerSecond * TimeElapsed);\n\n\tSetActorScale3D(InitialScale * ScaleFactor);\n}\n```"}
{"requirement": "Create an actor that plays a sound when overlapping another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapSoundActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AOverlapSoundActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n  class UBoxComponent* OverlapComponent;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n  class USoundBase* SoundToPlay;\n\n  UFUNCTION()\n  void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapSoundActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAOverlapSoundActor::AOverlapSoundActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n\n  OverlapComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"OverlapComponent\"));\n  RootComponent = OverlapComponent;\n  OverlapComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapSoundActor::OnOverlapBegin);\n}\n\nvoid AOverlapSoundActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AOverlapSoundActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AOverlapSoundActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n  if (SoundToPlay && OtherActor != this)\n  {\n\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n  }\n}\n```"}
{"requirement": "Create a simple polyhedron actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimplePolyhedronActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimplePolyhedronActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASimplePolyhedronActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The procedural mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUProceduralMeshComponent* ProceduralMesh;\n\n\t// Function to create a simple polyhedron\n\tvoid CreatePolyhedron();\n};\n```", "cpp_code": "```cpp\n#include \"SimplePolyhedronActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\n// Sets default values\nASimplePolyhedronActor::ASimplePolyhedronActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the procedural mesh component\n\tProceduralMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"ProceduralMesh\"));\n\tRootComponent = ProceduralMesh;\n\n\t// Create the polyhedron\n\tCreatePolyhedron();\n}\n\n// Called when the game starts or when spawned\nvoid ASimplePolyhedronActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASimplePolyhedronActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASimplePolyhedronActor::CreatePolyhedron()\n{\n\t// Define vertices for a simple tetrahedron (a type of polyhedron)\n\tTArray<FVector> Vertices;\n\tVertices.Add(FVector(0, 0, 0));\n\tVertices.Add(FVector(100, 0, 0));\n\tVertices.Add(FVector(50, 100, 0));\n\tVertices.Add(FVector(50, 50, 100));\n\n\t// Define triangles for the tetrahedron\n\tTArray<int32> Triangles;\n\tTriangles.Add(0);\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\tTriangles.Add(0);\n\tTriangles.Add(2);\n\tTriangles.Add(3);\n\tTriangles.Add(0);\n\tTriangles.Add(3);\n\tTriangles.Add(1);\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\tTriangles.Add(3);\n\n\t// Empty arrays for normals, UVs, vertex colors, tangents\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\tTArray<FColor> VertexColors;\n\tTArray<FProcMeshTangent> Tangents;\n\n\t// Create the mesh section\n\tProceduralMesh->CreateMeshSection(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a spline component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/SplineComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MySplineActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMySplineActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMySplineActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Spline\")\n\tUSplineComponent* SplineComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MySplineActor.h\"\n\nAMySplineActor::AMySplineActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSplineComponent = CreateDefaultSubobject<USplineComponent>(TEXT(\"SplineComponent\"));\n\tRootComponent = SplineComponent;\n}\n\nvoid AMySplineActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMySplineActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes location with mouse movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseControlledActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMouseControlledActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMouseControlledActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid UpdateLocationWithMouse();\n\n\tFVector2D MousePosition;\n};\n```", "cpp_code": "```cpp\n#include \"MouseControlledActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAMouseControlledActor::AMouseControlledActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMouseControlledActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMouseControlledActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tUpdateLocationWithMouse();\n}\n\nvoid AMouseControlledActor::UpdateLocationWithMouse()\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\t// Get mouse position\n\t\tPlayerController->GetMousePosition(MousePosition.X, MousePosition.Y);\n\n\t\t// Convert mouse position to world position\n\t\tFVector WorldLocation, WorldDirection;\n\t\tPlayerController->DeprojectScreenPositionToWorld(MousePosition.X, MousePosition.Y, WorldLocation, WorldDirection);\n\n\t\t// Move the actor to the mouse world location\n\t\tSetActorLocation(WorldLocation);\n\t}\n}\n```"}
{"requirement": "Create a component with a custom toggle function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ToggleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UToggleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUToggleComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION(BlueprintCallable, Category=\"Toggle\")\n\tvoid Toggle();\n\nprivate:\n\tbool bIsToggled;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleComponent.h\"\n\nUToggleComponent::UToggleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbIsToggled = false;\n}\n\nvoid UToggleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UToggleComponent::Toggle()\n{\n\tbIsToggled = !bIsToggled;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Toggle State: %s\"), bIsToggled ? TEXT(\"On\") : TEXT(\"Off\"));\n}\n```"}
{"requirement": "Create an actor with a customizable sound volume.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"CustomSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACustomSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sound Component\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tUSoundBase* Sound;\n\n\t// Volume Multiplier\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tfloat VolumeMultiplier;\n};\n```", "cpp_code": "```cpp\n#include \"CustomSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundBase.h\"\n\n// Sets default values\nACustomSoundActor::ACustomSoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tVolumeMultiplier = 1.0f; // Default volume multiplier\n}\n\n// Called when the game starts or when spawned\nvoid ACustomSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Sound)\n\t{\n\t\tUGameplayStatics::SpawnSoundAtLocation(this, Sound, GetActorLocation(), FRotator::ZeroRotator, VolumeMultiplier);\n\t}\n}\n\n// Called every frame\nvoid ACustomSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that logs a message on mouse click.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogOnClickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALogOnClickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tALogOnClickActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to log a message on mouse click\n\tUFUNCTION()\n\tvoid OnMouseClick();\n};\n```", "cpp_code": "```cpp\n#include \"LogOnClickActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALogOnClickActor::ALogOnClickActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALogOnClickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tEnableInput(PlayerController);\n\t\tInputComponent->BindAction(\"LeftMouseClick\", IE_Pressed, this, &ALogOnClickActor::OnMouseClick);\n\t}\n}\n\n// Called every frame\nvoid ALogOnClickActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to log a message on mouse click\nvoid ALogOnClickActor::OnMouseClick()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Mouse Clicked!\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that rotates with mouse drag.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent);\n\nprivate:\n\tvoid RotateActor(float AxisValue);\n\n\tFVector2D InitialMousePosition;\n\tbool bIsDragging;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsDragging = false;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (APlayerController* PC = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tEnableInput(PC);\n\t\tSetupPlayerInputComponent(InputComponent);\n\t}\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsDragging)\n\t{\n\t\tFVector2D CurrentMousePosition;\n\t\tif (APlayerController* PC = GetWorld()->GetFirstPlayerController())\n\t\t{\n\t\t\tPC->GetMousePosition(CurrentMousePosition.X, CurrentMousePosition.Y);\n\n\t\t\tfloat DeltaX = CurrentMousePosition.X - InitialMousePosition.X;\n\n\t\t\tFRotator NewRotation = FRotator(0.f, DeltaX, 0.f);\n\t\t\tAddActorLocalRotation(NewRotation);\n\n\t\t\tInitialMousePosition = CurrentMousePosition;\n\t\t}\n\t}\n}\n\nvoid ARotatingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"Turn\", this, &ARotatingActor::RotateActor);\n\tPlayerInputComponent->BindAction(\"Drag\", IE_Pressed, this, &ARotatingActor::StartDrag);\n\tPlayerInputComponent->BindAction(\"Drag\", IE_Released, this, &ARotatingActor::StopDrag);\n}\n\nvoid ARotatingActor::RotateActor(float AxisValue)\n{\n\tif (bIsDragging && AxisValue != 0.0f)\n\t{\n\t\tAddActorLocalRotation(FRotator(0.f, AxisValue, 0.f));\n\t}\n}\n\nvoid ARotatingActor::StartDrag()\n{\n\tbIsDragging = true;\n\n\tif (APlayerController* PC = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tPC->GetMousePosition(InitialMousePosition.X, InitialMousePosition.Y);\n\t}\n}\n\nvoid ARotatingActor::StopDrag()\n{\n\tbIsDragging = false;\n}\n```"}
{"requirement": "Create a simple polygon actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimplePolygonActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimplePolygonActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASimplePolygonActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* PolygonMesh;\n\n\tvoid CreatePolygonMesh();\n};\n```", "cpp_code": "```cpp\n#include \"SimplePolygonActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n\n// Sets default values\nASimplePolygonActor::ASimplePolygonActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a static mesh component\n\tPolygonMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"PolygonMesh\"));\n\tRootComponent = PolygonMesh;\n\n\t// Create polygon mesh\n\tCreatePolygonMesh();\n}\n\n// Called when the game starts or when spawned\nvoid ASimplePolygonActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASimplePolygonActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASimplePolygonActor::CreatePolygonMesh()\n{\n\t// Load a simple polygon mesh from a file or create a custom mesh\n\t// For simplicity, we're using an existing engine mesh\n\tUStaticMesh* Mesh = LoadObject<UStaticMesh>(nullptr, TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n\tif (Mesh)\n\t{\n\t\tPolygonMesh->SetStaticMesh(Mesh);\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a material array.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AYourActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Materials\")\n  TArray<UMaterialInterface*> MaterialArray;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that plays a sound when entering a trigger box.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundTriggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundTriggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundTriggerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Trigger box component\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* TriggerBox;\n\n\t// Sound to play\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundToPlay;\n\n\t// Function to handle the trigger box overlap\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"SoundTriggerActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundTriggerActor::ASoundTriggerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and configure a trigger box component\n\tTriggerBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerBox\"));\n\tRootComponent = TriggerBox;\n\tTriggerBox->SetCollisionProfileName(TEXT(\"Trigger\"));\n\tTriggerBox->OnComponentBeginOverlap.AddDynamic(this, &ASoundTriggerActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ASoundTriggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASoundTriggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundTriggerActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (SoundToPlay && OtherActor != this)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that changes its scale when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleOnClickComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UScaleOnClickComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUScaleOnClickComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFVector OriginalScale;\n\tFVector TargetScale;\n\tbool bIsScaled;\n\n\tUFUNCTION()\n\tvoid OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n};\n```", "cpp_code": "```cpp\n#include \"ScaleOnClickComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Components/PrimitiveComponent.h\"\n\n// Sets default values for this component's properties\nUScaleOnClickComponent::UScaleOnClickComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tbIsScaled = false;\n\tTargetScale = FVector(2.0f, 2.0f, 2.0f); // Example scale factor\n}\n\n// Called when the game starts\nvoid UScaleOnClickComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOriginalScale = Owner->GetActorScale3D();\n\t\tOwner->OnClicked.AddDynamic(this, &UScaleOnClickComponent::OnClicked);\n\t}\n}\n\n// Called every frame\nvoid UScaleOnClickComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UScaleOnClickComponent::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tif (bIsScaled)\n\t\t{\n\t\t\tOwner->SetActorScale3D(OriginalScale);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOwner->SetActorScale3D(TargetScale);\n\t\t}\n\t\tbIsScaled = !bIsScaled;\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable collision response.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomCollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ACustomCollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tACustomCollisionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Collision\")\n\tclass UBoxComponent* CollisionComponent;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Collision\")\n\tvoid SetCollisionResponse(ECollisionChannel Channel, ECollisionResponse NewResponse);\n};\n```", "cpp_code": "```cpp\n#include \"CustomCollisionActor.h\"\n#include \"Components/BoxComponent.h\"\n\n// Sets default values\nACustomCollisionActor::ACustomCollisionActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the collision component\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\t// Set default collision responses\n\tCollisionComponent->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);\n}\n\n// Called when the game starts or when spawned\nvoid ACustomCollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACustomCollisionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ACustomCollisionActor::SetCollisionResponse(ECollisionChannel Channel, ECollisionResponse NewResponse)\n{\n\tif (CollisionComponent)\n\t{\n\t\tCollisionComponent->SetCollisionResponseToChannel(Channel, NewResponse);\n\t}\n}\n```"}
{"requirement": "Create a class that logs when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"KeyPressLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AKeyPressLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAKeyPressLogger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle key press\n\tvoid OnKeyPress(FKey Key);\n};\n```", "cpp_code": "```cpp\n#include \"KeyPressLogger.h\"\n#include \"Engine/Engine.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nAKeyPressLogger::AKeyPressLogger()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AKeyPressLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (APlayerController* PC = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tPC->InputComponent->BindKey(EKeys::AnyKey, IE_Pressed, this, &AKeyPressLogger::OnKeyPress);\n\t}\n}\n\n// Called every frame\nvoid AKeyPressLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AKeyPressLogger::OnKeyPress(FKey Key)\n{\n\tif (GEngine)\n\t{\n\t\tFString KeyString = Key.GetDisplayName().ToString();\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Key Pressed: %s\"), *KeyString));\n\t}\n}\n```"}
{"requirement": "Create an actor that moves according to a path.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PathFollowingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APathFollowingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tAPathFollowingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Path\")\n\tTArray<FVector> PathPoints;\n\n\tint32 CurrentPathIndex;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"PathFollowingActor.h\"\n\nAPathFollowingActor::APathFollowingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentPathIndex = 0;\n\tMovementSpeed = 100.0f;\n}\n\nvoid APathFollowingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Initialize PathPoints with some example data\n\tPathPoints.Add(FVector(0, 0, 0));\n\tPathPoints.Add(FVector(300, 0, 0));\n\tPathPoints.Add(FVector(300, 300, 0));\n\tPathPoints.Add(FVector(0, 300, 0));\n}\n\nvoid APathFollowingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PathPoints.Num() == 0 || CurrentPathIndex >= PathPoints.Num())\n\t{\n\t\treturn;\n\t}\n\n\tFVector CurrentLocation = GetActorLocation();\n\tFVector TargetLocation = PathPoints[CurrentPathIndex];\n\n\tFVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n\tFVector NewLocation = CurrentLocation + Direction * MovementSpeed * DeltaTime;\n\n\tSetActorLocation(NewLocation);\n\n\tif (FVector::Dist(NewLocation, TargetLocation) < 10.0f)\n\t{\n\t\tCurrentPathIndex++;\n\t}\n\n\tif (CurrentPathIndex >= PathPoints.Num())\n\t{\n\t\tCurrentPathIndex = 0; // Loop back to start\n\t}\n}\n```"}
{"requirement": "Create a simple disc actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DiscActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADiscActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADiscActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* DiscMesh;\n};\n```", "cpp_code": "```cpp\n#include \"DiscActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nADiscActor::ADiscActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tDiscMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"DiscMesh\"));\n\tRootComponent = DiscMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> DiscMeshAsset(TEXT(\"/Game/Geometry/Meshes/DiscMesh.DiscMesh\"));\n\tif (DiscMeshAsset.Succeeded())\n\t{\n\t\tDiscMesh->SetStaticMesh(DiscMeshAsset.Object);\n\t}\n}\n\nvoid ADiscActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADiscActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a streaming level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category=\"Level\")\n\tULevelStreaming* StreamingLevelReference;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\t// Constructor logic here\n\tStreamingLevelReference = nullptr;\n}\n```"}
{"requirement": "Create an actor that logs a message when leaving a volume.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tALoggingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* Volume;\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\nALoggingActor::ALoggingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"Volume\"));\n\tRootComponent = Volume;\n\n\tVolume->OnComponentEndOverlap.AddDynamic(this, &ALoggingActor::OnOverlapEnd);\n}\n\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ALoggingActor::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (OtherActor && (OtherActor != this))\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Actor %s has left the volume.\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Create a component with a custom initialization function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomInitComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomInitComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUCustomInitComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION(BlueprintCallable, Category=\"Initialization\")\n\tvoid CustomInitialize();\n};\n```", "cpp_code": "```cpp\n#include \"CustomInitComponent.h\"\n\nUCustomInitComponent::UCustomInitComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UCustomInitComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Optionally call CustomInitialize here or elsewhere as needed\n}\n\nvoid UCustomInitComponent::CustomInitialize()\n{\n\t// Custom initialization logic here\n}\n```"}
{"requirement": "Create an actor with a customizable sound attenuation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundAttenuation.h\"\n#include \"Sound/SoundCue.h\"\n#include \"CustomSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tACustomSoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundCue* SoundCue;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundAttenuation* SoundAttenuation;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Sound\")\n\tvoid PlaySound();\n};\n```", "cpp_code": "```cpp\n#include \"CustomSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n\nACustomSoundActor::ACustomSoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ACustomSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACustomSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACustomSoundActor::PlaySound()\n{\n\tif (SoundCue)\n\t{\n\t\tUAudioComponent* AudioComponent = UGameplayStatics::SpawnSoundAtLocation(this, SoundCue, GetActorLocation(), FRotator::ZeroRotator, 1.0f, 1.0f, 0.0f, SoundAttenuation);\n\t}\n}\n```"}
{"requirement": "Create a class that moves towards a light source.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MoveTowardsLight.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMoveTowardsLight : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMoveTowardsLight();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Function to move towards the light source\n\tvoid MoveTowardsLight(float DeltaTime);\n\n\t// The target light actor to move towards\n\tAActor* TargetLight;\n\n\t// Movement speed\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MoveTowardsLight.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAMoveTowardsLight::AMoveTowardsLight()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementSpeed = 100.0f; // default movement speed\n}\n\n// Called when the game starts or when spawned\nvoid AMoveTowardsLight::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Find the first light source in the world\n\tTArray<AActor*> FoundActors;\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), AActor::StaticClass(), FoundActors);\n\n\tfor (AActor* Actor : FoundActors)\n\t{\n\t\tif (Actor->ActorHasTag(\"Light\")) // Assuming the light source has been tagged as \"Light\"\n\t\t{\n\t\t\tTargetLight = Actor;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// Called every frame\nvoid AMoveTowardsLight::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetLight)\n\t{\n\t\tMoveTowardsLight(DeltaTime);\n\t}\n}\n\nvoid AMoveTowardsLight::MoveTowardsLight(float DeltaTime)\n{\n\tif (!TargetLight) return;\n\n\tFVector Direction = (TargetLight->GetActorLocation() - GetActorLocation()).GetSafeNormal();\n\tFVector NewLocation = GetActorLocation() + (Direction * MovementSpeed * DeltaTime);\n\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that can be highlighted with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HighlightableActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AHighlightableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHighlightableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to toggle highlight\n\tvoid ToggleHighlight();\n\nprivate:\n\t// Material to apply when highlighted\n\tUMaterialInterface* HighlightMaterial;\n\n\t// Original material of the actor\n\tUMaterialInterface* OriginalMaterial;\n\n\t// Mesh component to apply the material to\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Whether the actor is currently highlighted\n\tbool bIsHighlighted;\n};\n```", "cpp_code": "```cpp\n#include \"HighlightableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAHighlightableActor::AHighlightableActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create MeshComponent and set as root\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Load the highlight material\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> MaterialFinder(TEXT(\"Material'/Game/HighlightMaterial.HighlightMaterial'\"));\n\tif (MaterialFinder.Succeeded())\n\t{\n\t\tHighlightMaterial = MaterialFinder.Object;\n\t}\n\n\t// Initialize the highlight state\n\tbIsHighlighted = false;\n}\n\n// Called when the game starts or when spawned\nvoid AHighlightableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Store the original material\n\tif (MeshComponent && MeshComponent->GetMaterial(0))\n\t{\n\t\tOriginalMaterial = MeshComponent->GetMaterial(0);\n\t}\n}\n\n// Called every frame\nvoid AHighlightableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to toggle highlight\nvoid AHighlightableActor::ToggleHighlight()\n{\n\tif (bIsHighlighted)\n\t{\n\t\t// Revert to the original material\n\t\tMeshComponent->SetMaterial(0, OriginalMaterial);\n\t}\n\telse\n\t{\n\t\t// Apply the highlight material\n\t\tMeshComponent->SetMaterial(0, HighlightMaterial);\n\t}\n\n\t// Toggle the highlight state\n\tbIsHighlighted = !bIsHighlighted;\n}\n```"}
{"requirement": "Create a simple square actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SquareActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASquareActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASquareActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* SquareMesh;\n};\n```", "cpp_code": "```cpp\n#include \"SquareActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASquareActor::ASquareActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a static mesh component\n\tSquareMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"SquareMesh\"));\n\tRootComponent = SquareMesh;\n\n\t// Find and set the static mesh for the square\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> SquareMeshAsset(TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n\tif (SquareMeshAsset.Succeeded())\n\t{\n\t\tSquareMesh->SetStaticMesh(SquareMeshAsset.Object);\n\t\tSquareMesh->SetWorldScale3D(FVector(1.f, 1.f, 0.01f)); // Scale to make it a square\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ASquareActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASquareActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a mesh array.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Meshes\")\n\tTArray<UStaticMeshComponent*> MeshArray;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Create an actor that changes its sound based on proximity.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ProximitySoundActor.generated.h\"\n\nclass UAudioComponent;\nclass USphereComponent;\n\nUCLASS()\nclass YOURPROJECT_API AProximitySoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAProximitySoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Function to handle proximity sound change\n\tvoid UpdateSoundBasedOnProximity();\n\n\t// Sphere component to detect proximity\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUSphereComponent* ProximitySphere;\n\n\t// Audio component to play sound\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUAudioComponent* AudioComponent;\n\n\t// Maximum distance at which the sound changes\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tfloat MaxProximityDistance;\n\n\t// The player character\n\tAPawn* PlayerPawn;\n};\n```", "cpp_code": "```cpp\n#include \"ProximitySoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAProximitySoundActor::AProximitySoundActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize components\n\tProximitySphere = CreateDefaultSubobject<USphereComponent>(TEXT(\"ProximitySphere\"));\n\tRootComponent = ProximitySphere;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n\n\tMaxProximityDistance = 1000.0f; // Example value, can be changed in editor\n}\n\n// Called when the game starts or when spawned\nvoid AProximitySoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\n// Called every frame\nvoid AProximitySoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tUpdateSoundBasedOnProximity();\n}\n\nvoid AProximitySoundActor::UpdateSoundBasedOnProximity()\n{\n\tif (!PlayerPawn) return;\n\n\tfloat DistanceToPlayer = FVector::Dist(PlayerPawn->GetActorLocation(), GetActorLocation());\n\n\tif (DistanceToPlayer <= MaxProximityDistance)\n\t{\n\t\t// Calculate volume based on distance\n\t\tfloat Volume = 1.0f - (DistanceToPlayer / MaxProximityDistance);\n\t\tAudioComponent->SetVolumeMultiplier(Volume);\n\t\tif (!AudioComponent->IsPlaying())\n\t\t{\n\t\t\tAudioComponent->Play();\n\t\t}\n\t}\n\telse\n\t{\n\t\tAudioComponent->Stop();\n\t}\n}\n```"}
{"requirement": "Create a component that logs its position every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"PositionLoggerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UPositionLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPositionLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tvoid LogPosition();\n\n\tFTimerHandle TimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"PositionLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nUPositionLoggerComponent::UPositionLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UPositionLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &UPositionLoggerComponent::LogPosition, 1.0f, true);\n}\n\nvoid UPositionLoggerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid UPositionLoggerComponent::LogPosition()\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector Position = Owner->GetActorLocation();\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Actor Position: %s\"), *Position.ToString());\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable light spotlight.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SpotLightComponent.h\"\n#include \"CustomSpotlightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomSpotlightActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tACustomSpotlightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUSpotLightComponent* SpotLight;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light Settings\")\n\tfloat LightIntensity;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light Settings\")\n\tFColor LightColor;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light Settings\")\n\tfloat LightInnerConeAngle;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light Settings\")\n\tfloat LightOuterConeAngle;\n};\n```", "cpp_code": "```cpp\n#include \"CustomSpotlightActor.h\"\n\n// Sets default values\nACustomSpotlightActor::ACustomSpotlightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSpotLight = CreateDefaultSubobject<USpotLightComponent>(TEXT(\"SpotLight\"));\n\tRootComponent = SpotLight;\n\n\t// Set default values\n\tLightIntensity = 3000.0f;\n\tLightColor = FColor::White;\n\tLightInnerConeAngle = 20.0f;\n\tLightOuterConeAngle = 40.0f;\n\n\tSpotLight->SetIntensity(LightIntensity);\n\tSpotLight->SetLightColor(LightColor);\n\tSpotLight->SetInnerConeAngle(LightInnerConeAngle);\n\tSpotLight->SetOuterConeAngle(LightOuterConeAngle);\n}\n\n// Called when the game starts or when spawned\nvoid ACustomSpotlightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Initialize spotlight settings\n\tSpotLight->SetIntensity(LightIntensity);\n\tSpotLight->SetLightColor(LightColor);\n\tSpotLight->SetInnerConeAngle(LightInnerConeAngle);\n\tSpotLight->SetOuterConeAngle(LightOuterConeAngle);\n}\n\n// Called every frame\nvoid ACustomSpotlightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\t// If you want to update the spotlight properties dynamically, you can update here\n\tSpotLight->SetIntensity(LightIntensity);\n\tSpotLight->SetLightColor(LightColor);\n\tSpotLight->SetInnerConeAngle(LightInnerConeAngle);\n\tSpotLight->SetOuterConeAngle(LightOuterConeAngle);\n}\n```"}
{"requirement": "Create a class that changes its rotation based on tick time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = FRotator(0.f, 50.f, 0.f); // Example rotation speed\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFRotator NewRotation = GetActorRotation() + RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an actor that scales with mouse scroll.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid SetupInputComponent();\n\tvoid OnMouseWheelScrolled(float AxisValue);\n\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tfloat ScaleFactor;\n\n\tFVector InitialScale;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScaleFactor = 0.1f;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialScale = GetActorScale3D();\n\tSetupInputComponent();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AScalingActor::SetupInputComponent()\n{\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tEnableInput(PlayerController);\n\t\tif (InputComponent)\n\t\t{\n\t\t\tInputComponent->BindAxis(\"MouseWheel\", this, &AScalingActor::OnMouseWheelScrolled);\n\t\t}\n\t}\n}\n\nvoid AScalingActor::OnMouseWheelScrolled(float AxisValue)\n{\n\tFVector NewScale = GetActorScale3D() + FVector(AxisValue * ScaleFactor);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a simple rectangular prism actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RectangularPrismActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARectangularPrismActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARectangularPrismActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* PrismMesh;\n};\n```", "cpp_code": "```cpp\n#include \"RectangularPrismActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nARectangularPrismActor::ARectangularPrismActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPrismMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"PrismMesh\"));\n\tRootComponent = PrismMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> PrismAsset(TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n\tif (PrismAsset.Succeeded())\n\t{\n\t\tPrismMesh->SetStaticMesh(PrismAsset.Object);\n\t\tPrismMesh->SetWorldScale3D(FVector(1.0f, 2.0f, 0.5f)); // Example scale to make it rectangular\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ARectangularPrismActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARectangularPrismActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a physics material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PhysicsEngine/PhysicsMaterial.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Physics\")\n\tUPhysicalMaterial* PhysicsMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\n// Add default functionality here for any IYourActor functions that are not pure virtual.\n```"}
{"requirement": "Create an actor that logs a message when a key is released.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"KeyReleaseLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AKeyReleaseLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAKeyReleaseLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tvoid OnKeyReleased();\n};\n```", "cpp_code": "```cpp\n#include \"KeyReleaseLoggerActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nAKeyReleaseLoggerActor::AKeyReleaseLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AKeyReleaseLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AKeyReleaseLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AKeyReleaseLoggerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"YourActionName\", IE_Released, this, &AKeyReleaseLoggerActor::OnKeyReleased);\n\t}\n}\n\nvoid AKeyReleaseLoggerActor::OnKeyReleased()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Key Released!\"));\n}\n```"}
{"requirement": "Create a component that changes color each second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ColorChangeComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UColorChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUColorChangeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tFTimerHandle ColorChangeTimerHandle;\n\tvoid ChangeColor();\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"TimerManager.h\"\n\nUColorChangeComponent::UColorChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UColorChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorld()->GetTimerManager().SetTimer(ColorChangeTimerHandle, this, &UColorChangeComponent::ChangeColor, 1.0f, true);\n}\n\nvoid UColorChangeComponent::ChangeColor()\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUMeshComponent* MeshComp = Owner->FindComponentByClass<UMeshComponent>();\n\t\tif (MeshComp)\n\t\t{\n\t\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComp->CreateAndSetMaterialInstanceDynamic(0);\n\t\t\tif (DynamicMaterial)\n\t\t\t{\n\t\t\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\t\t\tDynamicMaterial->SetVectorParameterValue(\"Color\", NewColor);\n\t\t\t}\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable mesh rotation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tARotatingMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mesh\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Rotation\")\n\tFRotator RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingMeshActor.h\"\n\n// Sets default values\nARotatingMeshActor::ARotatingMeshActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tRotationSpeed = FRotator(0.0f, 0.0f, 0.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ARotatingMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!RotationSpeed.IsZero())\n\t{\n\t\tFRotator NewRotation = GetActorRotation() + (RotationSpeed * DeltaTime);\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create a class that rotates with mouse input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationSpeed;\n\nprivate:\n\tvoid RotateWithMouseInput(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 100.0f; // Default rotation speed\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tRotateWithMouseInput(DeltaTime);\n}\n\nvoid ARotatingActor::RotateWithMouseInput(float DeltaTime)\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tfloat MouseX, MouseY;\n\t\tPlayerController->GetInputMouseDelta(MouseX, MouseY);\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Yaw += MouseX * RotationSpeed * DeltaTime;\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an actor that plays a sound on any interaction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Sound/SoundBase.h\"\n#include \"MyInteractiveSoundActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyInteractiveSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyInteractiveSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* InteractionSound;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Interaction\")\n\tvoid Interact();\n};\n```", "cpp_code": "```cpp\n#include \"MyInteractiveSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAMyInteractiveSoundActor::AMyInteractiveSoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyInteractiveSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyInteractiveSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid AMyInteractiveSoundActor::Interact()\n{\n\tif (InteractionSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, InteractionSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a simple spherical actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimpleSphericalActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASimpleSphericalActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tASimpleSphericalActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* SphereMesh;\n};\n```", "cpp_code": "```cpp\n#include \"SimpleSphericalActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nASimpleSphericalActor::ASimpleSphericalActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSphereMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"SphereMesh\"));\n\tRootComponent = SphereMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> SphereMeshAsset(TEXT(\"/Engine/BasicShapes/Sphere.Sphere\"));\n\tif (SphereMeshAsset.Succeeded())\n\t{\n\t\tSphereMesh->SetStaticMesh(SphereMeshAsset.Object);\n\t}\n}\n\nvoid ASimpleSphericalActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASimpleSphericalActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a default material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Materials\")\n\tUMaterialInterface* DefaultMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the default material reference to null\n\tDefaultMaterial = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes its material on a key event.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMaterialChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* Material1;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* Material2;\n\n\tUFUNCTION()\n\tvoid ChangeMaterial();\n\n\tvoid SetupInputComponent();\n\nprivate:\n\tbool bUseMaterial1;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"Engine/Engine.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/InputSettings.h\"\n\nAMaterialChangingActor::AMaterialChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tbUseMaterial1 = true;\n}\n\nvoid AMaterialChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tSetupInputComponent();\n}\n\nvoid AMaterialChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMaterialChangingActor::ChangeMaterial()\n{\n\tif (bUseMaterial1)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material2);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n\tbUseMaterial1 = !bUseMaterial1;\n}\n\nvoid AMaterialChangingActor::SetupInputComponent()\n{\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tPlayerController->InputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AMaterialChangingActor::ChangeMaterial);\n\t}\n}\n```"}
{"requirement": "Create a component with a custom scale function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomScaleComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UCustomScaleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUCustomScaleComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Custom scale function\n\tUFUNCTION(BlueprintCallable, Category=\"Custom Scale\")\n\tvoid SetCustomScale(FVector NewScale);\n};\n```", "cpp_code": "```cpp\n#include \"CustomScaleComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values for this component's properties\nUCustomScaleComponent::UCustomScaleComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid UCustomScaleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Custom scale function\nvoid UCustomScaleComponent::SetCustomScale(FVector NewScale)\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->SetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable audio loop.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"CustomAudioLoopActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomAudioLoopActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tACustomAudioLoopActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Audio\")\n\tUSoundCue* AudioCue;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Audio\")\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CustomAudioLoopActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n\nACustomAudioLoopActor::ACustomAudioLoopActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tRootComponent = AudioComponent;\n\tAudioComponent->bAutoActivate = false;\n\tAudioComponent->bLooping = true;\n}\n\nvoid ACustomAudioLoopActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (AudioCue)\n\t{\n\t\tAudioComponent->SetSound(AudioCue);\n\t\tAudioComponent->Play();\n\t}\n}\n\nvoid ACustomAudioLoopActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that logs a message when touched by the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingTouchActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingTouchActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tALoggingTouchActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* CollisionBox;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingTouchActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingTouchActor::ALoggingTouchActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionBox\"));\n\tRootComponent = CollisionBox;\n\n\tCollisionBox->OnComponentBeginOverlap.AddDynamic(this, &ALoggingTouchActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingTouchActor::BeginPlay()\n{\n\tSuper::BeginPlay();\t\n}\n\n// Called every frame\nvoid ALoggingTouchActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ALoggingTouchActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tif (APlayerController* PlayerController = Cast<APlayerController>(OtherActor->GetInstigatorController()))\n\t\t{\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Player touched the actor!\"));\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that moves randomly in a defined space.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ARandomMover : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tARandomMover();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector GetRandomLocation() const;\n\tFVector MovementBounds;\n\tfloat MoveSpeed;\n\tFVector TargetLocation;\n};\n```", "cpp_code": "```cpp\n#include \"RandomMover.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nARandomMover::ARandomMover()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementBounds = FVector(1000.0f, 1000.0f, 1000.0f); // Set the bounds for random movement\n\tMoveSpeed = 100.0f; // Set the movement speed\n}\n\nvoid ARandomMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tTargetLocation = GetRandomLocation();\n}\n\nvoid ARandomMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentLocation = GetActorLocation();\n\tif (FVector::Dist(CurrentLocation, TargetLocation) <= 10.0f) // If close to target, get a new target\n\t{\n\t\tTargetLocation = GetRandomLocation();\n\t}\n\n\tFVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n\tFVector NewLocation = CurrentLocation + Direction * MoveSpeed * DeltaTime;\n\tSetActorLocation(NewLocation);\n}\n\nFVector ARandomMover::GetRandomLocation() const\n{\n\tfloat RandomX = FMath::FRandRange(-MovementBounds.X, MovementBounds.X);\n\tfloat RandomY = FMath::FRandRange(-MovementBounds.Y, MovementBounds.Y);\n\tfloat RandomZ = FMath::FRandRange(-MovementBounds.Z, MovementBounds.Z);\n\treturn FVector(RandomX, RandomY, RandomZ);\n}\n```"}
{"requirement": "Create a simple pyramid mesh actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PyramidMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APyramidMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAPyramidMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUProceduralMeshComponent* ProceduralMesh;\n\n\tvoid CreatePyramidMesh();\n};\n```", "cpp_code": "```cpp\n#include \"PyramidMeshActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\nAPyramidMeshActor::APyramidMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tProceduralMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"ProceduralMesh\"));\n\tRootComponent = ProceduralMesh;\n\n\tCreatePyramidMesh();\n}\n\nvoid APyramidMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APyramidMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APyramidMeshActor::CreatePyramidMesh()\n{\n\tTArray<FVector> Vertices;\n\tTArray<int32> Triangles;\n\n\t// Define vertices\n\tVertices.Add(FVector(0, 0, 100)); // Top vertex\n\tVertices.Add(FVector(-100, -100, 0)); // Base - bottom left\n\tVertices.Add(FVector(100, -100, 0)); // Base - bottom right\n\tVertices.Add(FVector(100, 100, 0)); // Base - top right\n\tVertices.Add(FVector(-100, 100, 0)); // Base - top left\n\n\t// Define triangles\n\tTriangles.Add(0); Triangles.Add(2); Triangles.Add(1); // Side 1\n\tTriangles.Add(0); Triangles.Add(3); Triangles.Add(2); // Side 2\n\tTriangles.Add(0); Triangles.Add(4); Triangles.Add(3); // Side 3\n\tTriangles.Add(0); Triangles.Add(1); Triangles.Add(4); // Side 4\n\tTriangles.Add(1); Triangles.Add(2); Triangles.Add(3); // Base\n\tTriangles.Add(1); Triangles.Add(3); Triangles.Add(4); // Base\n\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\tTArray<FProcMeshTangent> Tangents;\n\tTArray<FLinearColor> VertexColors;\n\n\tProceduralMesh->CreateMeshSection_LinearColor(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a light map.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyLightMapActor.generated.h\"\n\nclass ULightMapTexture;\n\nUCLASS()\nclass MYPROJECT_API AMyLightMapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyLightMapActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Lighting\")\n\tULightMapTexture* LightMapReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyLightMapActor.h\"\n\nAMyLightMapActor::AMyLightMapActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n```"}
{"requirement": "Create an actor that plays a sound on start.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundPlayingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayingActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tASoundPlayingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Sound to play at start\n\tUPROPERTY(EditAnywhere, Category=\"Sound\")\n\tUSoundBase* StartSound;\n};\n```", "cpp_code": "```cpp\n#include \"SoundPlayingActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundPlayingActor::ASoundPlayingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundPlayingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (StartSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, StartSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that changes its mesh on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ChangeMeshOnCollisionComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UChangeMeshOnCollisionComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUChangeMeshOnCollisionComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION()\n\tvoid OnCollision(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\n\tUPROPERTY(EditAnywhere, Category = \"Mesh\")\n\tUStaticMesh* NewMesh;\n\nprivate:\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMeshOnCollisionComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nUChangeMeshOnCollisionComponent::UChangeMeshOnCollisionComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UChangeMeshOnCollisionComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tMeshComponent = Owner->FindComponentByClass<UStaticMeshComponent>();\n\t\tif (MeshComponent)\n\t\t{\n\t\t\tMeshComponent->OnComponentHit.AddDynamic(this, &UChangeMeshOnCollisionComponent::OnCollision);\n\t\t}\n\t}\n}\n\nvoid UChangeMeshOnCollisionComponent::OnCollision(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (MeshComponent && NewMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(NewMesh);\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable tick rate.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomTickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomTickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACustomTickActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Tick\")\n\tfloat CustomTickInterval;\n\nprivate:\n\tfloat TimeSinceLastTick;\n};\n```", "cpp_code": "```cpp\n#include \"CustomTickActor.h\"\n\nACustomTickActor::ACustomTickActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCustomTickInterval = 1.0f; // Default tick interval\n\tTimeSinceLastTick = 0.0f;\n}\n\nvoid ACustomTickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACustomTickActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeSinceLastTick += DeltaTime;\n\tif (TimeSinceLastTick >= CustomTickInterval)\n\t{\n\t\tTimeSinceLastTick = 0.0f;\n\n\t\t// Custom tick logic here\n\t}\n}\n```"}
{"requirement": "Create a class that changes position based on tick time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TickPositionChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATickPositionChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATickPositionChanger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector MovementVector;\n\tfloat Speed;\n};\n```", "cpp_code": "```cpp\n#include \"TickPositionChanger.h\"\n\n// Sets default values\nATickPositionChanger::ATickPositionChanger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize movement vector and speed\n\tMovementVector = FVector(1.0f, 0.0f, 0.0f);\n\tSpeed = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ATickPositionChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATickPositionChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate new position\n\tFVector NewLocation = GetActorLocation() + (MovementVector * Speed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that can change scale with arrow keys.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScaleChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScaleChangingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic: \n  AScaleChangingActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic: \n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  void ChangeScale(float ScaleDelta);\n\n  UPROPERTY(EditAnywhere)\n  float ScaleStep;\n\n  void SetupInputComponent();\n  void IncreaseScale();\n  void DecreaseScale();\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangingActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAScaleChangingActor::AScaleChangingActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n  ScaleStep = 0.1f; \n}\n\nvoid AScaleChangingActor::BeginPlay()\n{\n  Super::BeginPlay();\n  SetupInputComponent();\n}\n\nvoid AScaleChangingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AScaleChangingActor::ChangeScale(float ScaleDelta)\n{\n  FVector NewScale = GetActorScale3D() + FVector(ScaleDelta);\n  SetActorScale3D(NewScale);\n}\n\nvoid AScaleChangingActor::SetupInputComponent()\n{\n  if (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n  {\n\tEnableInput(PlayerController);\n\tInputComponent->BindAction(\"IncreaseScale\", IE_Pressed, this, &AScaleChangingActor::IncreaseScale);\n\tInputComponent->BindAction(\"DecreaseScale\", IE_Pressed, this, &AScaleChangingActor::DecreaseScale);\n  }\n}\n\nvoid AScaleChangingActor::IncreaseScale()\n{\n  ChangeScale(ScaleStep);\n}\n\nvoid AScaleChangingActor::DecreaseScale()\n{\n  ChangeScale(-ScaleStep);\n}\n```"}
{"requirement": "Create a simple hexagonal actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HexagonalActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AHexagonalActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHexagonalActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Function to create hexagonal mesh\n\tvoid CreateHexagonalMesh();\n\n\t// Hexagonal mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUProceduralMeshComponent* HexMesh;\n};\n```", "cpp_code": "```cpp\n#include \"HexagonalActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\n// Sets default values\nAHexagonalActor::AHexagonalActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create procedural mesh component\n\tHexMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"HexMesh\"));\n\tRootComponent = HexMesh;\n\n\t// Create hexagonal mesh\n\tCreateHexagonalMesh();\n}\n\n// Called when the game starts or when spawned\nvoid AHexagonalActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AHexagonalActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHexagonalActor::CreateHexagonalMesh()\n{\n\t// Define vertices for a hexagon\n\tTArray<FVector> Vertices;\n\tfloat Radius = 100.0f;\n\tfor (int32 i = 0; i < 6; ++i)\n\t{\n\t\tfloat Angle = FMath::DegreesToRadians(60.f * i);\n\t\tVertices.Add(FVector(Radius * FMath::Cos(Angle), Radius * FMath::Sin(Angle), 0.f));\n\t}\n\n\t// Add center vertex\n\tVertices.Add(FVector(0.f, 0.f, 0.f));\n\n\t// Define triangles (two for each side of the hexagon)\n\tTArray<int32> Triangles;\n\tfor (int32 i = 0; i < 6; ++i)\n\t{\n\t\tTriangles.Add(i);\n\t\tTriangles.Add((i + 1) % 6);\n\t\tTriangles.Add(6); // center vertex\n\t}\n\n\t// Create mesh section\n\tTArray<FVector> Normals;\n\tTArray<FVector2D> UV0;\n\tTArray<FColor> VertexColors;\n\tTArray<FProcMeshTangent> Tangents;\n\n\tHexMesh->CreateMeshSection(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a volume control.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"VolumeControl.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API UVolumeControl : public UObject\n{\n\tGENERATED_BODY()\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Audio\")\n\tfloat VolumeLevel;\n\n\tUVolumeControl();\n};\n```", "cpp_code": "```cpp\n#include \"VolumeControl.h\"\n\nUVolumeControl::UVolumeControl()\n{\n\tVolumeLevel = 1.0f; // Default volume level\n}\n```"}
{"requirement": "Create an actor that logs a message on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAOverlapLoggerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tclass UBoxComponent* BoxComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLoggerActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nAOverlapLoggerActor::AOverlapLoggerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tBoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tRootComponent = BoxComponent;\n\n\tBoxComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapLoggerActor::OnOverlapBegin);\n}\n\nvoid AOverlapLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AOverlapLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AOverlapLoggerActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Overlap Event Occurred!\"));\n\t}\n}\n```"}
{"requirement": "Create a component that toggles an audio effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"AudioEffectTogglerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UAudioEffectTogglerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUAudioEffectTogglerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Audio\")\n\tvoid ToggleAudioEffect();\n\nprivate:\n\tbool bIsEffectActive;\n\n\tUPROPERTY(EditAnywhere, Category=\"Audio\")\n\tUSoundCue* EffectSoundCue;\n\n\tUAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"AudioEffectTogglerComponent.h\"\n#include \"Components/AudioComponent.h\"\n\nUAudioEffectTogglerComponent::UAudioEffectTogglerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tbIsEffectActive = false;\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n}\n\nvoid UAudioEffectTogglerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (EffectSoundCue)\n\t{\n\t\tAudioComponent->SetSound(EffectSoundCue);\n\t}\n}\n\nvoid UAudioEffectTogglerComponent::ToggleAudioEffect()\n{\n\tif (!EffectSoundCue)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"EffectSoundCue is not set!\"));\n\t\treturn;\n\t}\n\n\tif (bIsEffectActive)\n\t{\n\t\tAudioComponent->Stop();\n\t}\n\telse\n\t{\n\t\tAudioComponent->Play();\n\t}\n\n\tbIsEffectActive = !bIsEffectActive;\n}\n```"}
{"requirement": "Create an actor with a customizable physics property.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomPhysicsActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomPhysicsActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tACustomPhysicsActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Physics\")\n\tfloat CustomMass;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Physics\")\n\tvoid SetMass(float NewMass);\n};\n```", "cpp_code": "```cpp\n#include \"CustomPhysicsActor.h\"\n\nACustomPhysicsActor::ACustomPhysicsActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCustomMass = 1.0f; // Default mass value\n}\n\nvoid ACustomPhysicsActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Set the initial mass\n\tif (UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(GetRootComponent()))\n\t{\n\t\tPrimitiveComponent->SetMassOverrideInKg(NAME_None, CustomMass);\n\t}\n}\n\nvoid ACustomPhysicsActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACustomPhysicsActor::SetMass(float NewMass)\n{\n\tCustomMass = NewMass;\n\tif (UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(GetRootComponent()))\n\t{\n\t\tPrimitiveComponent->SetMassOverrideInKg(NAME_None, CustomMass);\n\t}\n}\n```"}
{"requirement": "Create a class that logs a message when the game ends.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameEndLogger.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AGameEndLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAGameEndLogger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION()\n\tvoid OnGameEnd();\n};\n```", "cpp_code": "```cpp\n#include \"GameEndLogger.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAGameEndLogger::AGameEndLogger()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AGameEndLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AGameModeBase* GameMode = UGameplayStatics::GetGameMode(GetWorld()))\n\t{\n\t\tGameMode->OnEndPlay.AddDynamic(this, &AGameEndLogger::OnGameEnd);\n\t}\n}\n\nvoid AGameEndLogger::OnGameEnd()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"The game has ended.\"));\n}\n```"}
{"requirement": "Create an actor that follows a predefined path.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PathFollowingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APathFollowingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPathFollowingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Path\")\n\tTArray<FVector> PathPoints;\n\n\tint32 CurrentTargetIndex;\n\tfloat MovementSpeed;\n\n\tvoid FollowPath(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"PathFollowingActor.h\"\n\nAPathFollowingActor::APathFollowingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentTargetIndex = 0;\n\tMovementSpeed = 200.0f; // Default speed, can be adjusted\n}\n\nvoid APathFollowingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APathFollowingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFollowPath(DeltaTime);\n}\n\nvoid APathFollowingActor::FollowPath(float DeltaTime)\n{\n\tif (PathPoints.Num() == 0 || CurrentTargetIndex >= PathPoints.Num())\n\t{\n\t\treturn;\n\t}\n\n\tFVector CurrentLocation = GetActorLocation();\n\tFVector TargetLocation = PathPoints[CurrentTargetIndex];\n\tFVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n\n\tFVector NewLocation = CurrentLocation + Direction * MovementSpeed * DeltaTime;\n\tSetActorLocation(NewLocation);\n\n\tif (FVector::Dist(NewLocation, TargetLocation) < 10.0f)\n\t{\n\t\tCurrentTargetIndex++;\n\t}\n\n\tif (CurrentTargetIndex >= PathPoints.Num())\n\t{\n\t\tCurrentTargetIndex = 0; // Loop back to the start of the path\n\t}\n}\n```"}
{"requirement": "Create a simple ovoid actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OvoidActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AOvoidActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAOvoidActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* OvoidMesh;\n};\n```", "cpp_code": "```cpp\n#include \"OvoidActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAOvoidActor::AOvoidActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tOvoidMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"OvoidMesh\"));\n\tRootComponent = OvoidMesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> OvoidAsset(TEXT(\"StaticMesh'/Engine/BasicShapes/Sphere.Sphere'\"));\n\tif (OvoidAsset.Succeeded())\n\t{\n\t\tOvoidMesh->SetStaticMesh(OvoidAsset.Object);\n\t\t// Scale the sphere to create an ovoid\n\t\tOvoidMesh->SetWorldScale3D(FVector(1.0f, 0.6f, 0.6f));\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AOvoidActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AOvoidActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a camera component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"CameraActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACameraActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACameraActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Camera\")\n\tUCameraComponent* CameraComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CameraActor.h\"\n\n// Sets default values\nACameraActor::ACameraActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the camera component\n\tCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"CameraComponent\"));\n\t// Attach the camera component to the root component\n\tRootComponent = CameraComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ACameraActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ACameraActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Create an actor that plays a sound on a key release.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"SoundOnKeyReleaseActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundOnKeyReleaseActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundOnKeyReleaseActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sound to play on key release\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* SoundToPlay;\n\n\t// Function to bind to input\n\tvoid OnKeyReleased();\n};\n```", "cpp_code": "```cpp\n#include \"SoundOnKeyReleaseActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nASoundOnKeyReleaseActor::ASoundOnKeyReleaseActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundOnKeyReleaseActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind the OnKeyReleased function to the input action\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tInputComponent = NewObject<UInputComponent>(this);\n\t\tInputComponent->RegisterComponent();\n\t\tInputComponent->BindAction(\"PlaySound\", IE_Released, this, &ASoundOnKeyReleaseActor::OnKeyReleased);\n\t\tPlayerController->PushInputComponent(InputComponent);\n\t}\n}\n\n// Called every frame\nvoid ASoundOnKeyReleaseActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to play the sound\nvoid ASoundOnKeyReleaseActor::OnKeyReleased()\n{\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that changes its light based on input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LightComponent.h\"\n#include \"LightChangerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULightChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tULightChangerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Light\")\n\tvoid ChangeLightIntensity(float NewIntensity);\n\n\tUFUNCTION(BlueprintCallable, Category=\"Light\")\n\tvoid ChangeLightColor(FLinearColor NewColor);\n\nprivate:\n\tULightComponent* LightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"LightChangerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/LightComponent.h\"\n\nULightChangerComponent::ULightChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid ULightChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tLightComponent = GetOwner()->FindComponentByClass<ULightComponent>();\n\tif (!LightComponent)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"No LightComponent found on %s!\"), *GetOwner()->GetName());\n\t}\n}\n\nvoid ULightChangerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n}\n\nvoid ULightChangerComponent::ChangeLightIntensity(float NewIntensity)\n{\n\tif (LightComponent)\n\t{\n\t\tLightComponent->SetIntensity(NewIntensity);\n\t}\n}\n\nvoid ULightChangerComponent::ChangeLightColor(FLinearColor NewColor)\n{\n\tif (LightComponent)\n\t{\n\t\tLightComponent->SetLightColor(NewColor);\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable sound effect on collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"CollisionSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sound to play upon collision\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundCue* CollisionSoundCue;\n\n\t// Function to handle collision\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\t// Root component\n\tUSceneComponent* RootComp;\n\n\t// Static mesh component\n\tUStaticMeshComponent* MeshComp;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionSoundActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nACollisionSoundActor::ACollisionSoundActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a root component\n\tRootComp = CreateDefaultSubobject<USceneComponent>(TEXT(\"RootComponent\"));\n\tRootComponent = RootComp;\n\n\t// Create a static mesh component\n\tMeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComp->SetupAttachment(RootComp);\n\n\t// Set up collision\n\tMeshComp->SetNotifyRigidBodyCollision(true);\n\tMeshComp->BodyInstance.SetCollisionProfileName(\"BlockAllDynamic\");\n\tMeshComp->OnComponentHit.AddDynamic(this, &ACollisionSoundActor::OnHit);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle collision\nvoid ACollisionSoundActor::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tif (CollisionSoundCue)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, CollisionSoundCue, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a class that changes its texture over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"TextureChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureChanger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATextureChanger();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tTArray<UTexture*> Textures;\n\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n\n\tint32 CurrentTextureIndex;\n\tfloat TimeAccumulator;\n\tUPROPERTY(EditAnywhere)\n\tfloat ChangeInterval;\n\n\tvoid ChangeTexture();\n};\n```", "cpp_code": "```cpp\n#include \"TextureChanger.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n\nATextureChanger::ATextureChanger()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\tCurrentTextureIndex = 0;\n\tTimeAccumulator = 0.0f;\n\tChangeInterval = 2.0f; // Default change interval is 2 seconds\n}\n\nvoid ATextureChanger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MeshComponent && MeshComponent->GetMaterial(0))\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\nvoid ATextureChanger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeAccumulator += DeltaTime;\n\tif (TimeAccumulator >= ChangeInterval && Textures.Num() > 0)\n\t{\n\t\tChangeTexture();\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n\nvoid ATextureChanger::ChangeTexture()\n{\n\tif (!DynamicMaterialInstance || Textures.Num() == 0)\n\t{\n\t\treturn;\n\t}\n\n\tCurrentTextureIndex = (CurrentTextureIndex + 1) % Textures.Num();\n\tDynamicMaterialInstance->SetTextureParameterValue(TEXT(\"Texture\"), Textures[CurrentTextureIndex]);\n}\n```"}
{"requirement": "Create an actor that moves towards another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMovingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Target actor to move towards\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tAActor* TargetActor;\n\n\t// Speed of movement\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\n// Sets default values\nAMovingActor::AMovingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementSpeed = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tFVector CurrentLocation = GetActorLocation();\n\t\tFVector TargetLocation = TargetActor->GetActorLocation();\n\t\tFVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n\t\tFVector NewLocation = CurrentLocation + Direction * MovementSpeed * DeltaTime;\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Create a simple pentagon actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PentagonActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APentagonActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAPentagonActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* PentagonMesh;\n\n\tvoid CreatePentagon();\n};\n```", "cpp_code": "```cpp\n#include \"PentagonActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAPentagonActor::APentagonActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPentagonMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"PentagonMesh\"));\n\tRootComponent = PentagonMesh;\n\n\tCreatePentagon();\n}\n\n// Called when the game starts or when spawned\nvoid APentagonActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid APentagonActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid APentagonActor::CreatePentagon()\n{\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> PentagonMeshAsset(TEXT(\"StaticMesh'/Engine/BasicShapes/Cylinder.Cylinder'\"));\n\tif (PentagonMeshAsset.Succeeded())\n\t{\n\t\tPentagonMesh->SetStaticMesh(PentagonMeshAsset.Object);\n\t\tPentagonMesh->SetWorldScale3D(FVector(1.0f, 1.0f, 0.1f)); // Flatten the cylinder to make it appear as a 2D shape\n\t}\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to a light array.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Lighting\")\n\tTArray<ALight*> LightArray;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that logs a message on a specific event.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tALoggingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"Engine/Engine.h\"\n\nALoggingActor::ALoggingActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tUE_LOG(LogTemp, Warning, TEXT(\"LoggingActor has begun play!\"));\n}\n```"}
{"requirement": "Create a component with a custom rotation function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"CustomRotationComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomRotationComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUCustomRotationComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category=\"Rotation\")\n\tvoid RotateActor(float DeltaTime);\n\nprivate:\n\tFRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"CustomRotationComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUCustomRotationComponent::UCustomRotationComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tRotationRate = FRotator(0.f, 90.f, 0.f); // Example rotation rate\n}\n\nvoid UCustomRotationComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCustomRotationComponent::RotateActor(float DeltaTime)\n{\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFRotator NewRotation = Owner->GetActorRotation() + (RotationRate * DeltaTime);\n\t\tOwner->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Create an actor with a customizable particle trail.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CustomParticleTrailActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACustomParticleTrailActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACustomParticleTrailActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Particle Trail\")\n\tUParticleSystem* ParticleTrail;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Particle Trail\")\n\tUParticleSystemComponent* ParticleSystemComponent;\n};\n```", "cpp_code": "```cpp\n#include \"CustomParticleTrailActor.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n\nACustomParticleTrailActor::ACustomParticleTrailActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystemComponent\"));\n\tParticleSystemComponent->SetupAttachment(RootComponent);\n}\n\nvoid ACustomParticleTrailActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (ParticleTrail)\n\t{\n\t\tParticleSystemComponent->SetTemplate(ParticleTrail);\n\t}\n}\n\nvoid ACustomParticleTrailActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a class that logs a message when the actor is destroyed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALoggingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called when the actor is being destroyed\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingActor::ALoggingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called when the actor is being destroyed\nvoid ALoggingActor::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Actor is being destroyed\"));\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Actor is being destroyed\"));\n\t}\n}\n```"}
{"requirement": "Create an actor that can scale continuously over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScalingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The rate at which the actor scales over time\n\tUPROPERTY(EditAnywhere, Category=\"Scaling\")\n\tFVector ScalingRate;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n\n// Sets default values\nAScalingActor::AScalingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the scaling rate\n\tScalingRate = FVector(0.1f, 0.1f, 0.1f);\n}\n\n// Called when the game starts or when spawned\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate new scale\n\tFVector NewScale = GetActorScale3D() + (ScalingRate * DeltaTime);\n\n\t// Set the new scale\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create a simple triangle actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TriangleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATriangleActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tATriangleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY()\n\tclass UProceduralMeshComponent* ProceduralMesh;\n\n\tvoid CreateTriangle();\n};\n```", "cpp_code": "```cpp\n#include \"TriangleActor.h\"\n#include \"ProceduralMeshComponent.h\"\n\nATriangleActor::ATriangleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tProceduralMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"ProceduralMesh\"));\n\tRootComponent = ProceduralMesh;\n\n\tCreateTriangle();\n}\n\nvoid ATriangleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATriangleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATriangleActor::CreateTriangle()\n{\n\tTArray<FVector> Vertices;\n\tVertices.Add(FVector(0, 0, 0));\n\tVertices.Add(FVector(100, 0, 0));\n\tVertices.Add(FVector(0, 100, 0));\n\n\tTArray<int32> Triangles;\n\tTriangles.Add(0);\n\tTriangles.Add(1);\n\tTriangles.Add(2);\n\n\tTArray<FVector> Normals;\n\tNormals.Add(FVector(0, 0, 1));\n\tNormals.Add(FVector(0, 0, 1));\n\tNormals.Add(FVector(0, 0, 1));\n\n\tTArray<FVector2D> UV0;\n\tUV0.Add(FVector2D(0, 0));\n\tUV0.Add(FVector2D(1, 0));\n\tUV0.Add(FVector2D(0, 1));\n\n\tTArray<FProcMeshTangent> Tangents;\n\tTangents.Add(FProcMeshTangent(1, 0, 0));\n\tTangents.Add(FProcMeshTangent(1, 0, 0));\n\tTangents.Add(FProcMeshTangent(1, 0, 0));\n\n\tTArray<FLinearColor> VertexColors;\n\tVertexColors.Add(FLinearColor(1, 0, 0, 1));\n\tVertexColors.Add(FLinearColor(0, 1, 0, 1));\n\tVertexColors.Add(FLinearColor(0, 0, 1, 1));\n\n\tProceduralMesh->CreateMeshSection_LinearColor(0, Vertices, Triangles, Normals, UV0, VertexColors, Tangents, true);\n}\n```"}
{"requirement": "Create a UPROPERTY to store a reference to an ambient sound.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/AmbientSound.h\"\n#include \"MyAmbientSoundActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyAmbientSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyAmbientSoundActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tAAmbientSound* AmbientSoundReference;\n};\n```", "cpp_code": "```cpp\n#include \"MyAmbientSoundActor.h\"\n\n// Sets default values\nAMyAmbientSoundActor::AMyAmbientSoundActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyAmbientSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Initialize or manipulate the AmbientSoundReference here if necessary\n}\n\n// Called every frame\nvoid AMyAmbientSoundActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Logic to use the AmbientSoundReference can be added here\n}\n```"}
{"requirement": "Create an actor that plays a sound on component begin overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Components/BoxComponent.h\"\n#include \"SoundOverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUBoxComponent* OverlapComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* SoundToPlay;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"SoundOverlapActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundOverlapActor::ASoundOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tOverlapComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"OverlapComponent\"));\n\tRootComponent = OverlapComponent;\n\n\tOverlapComponent->OnComponentBeginOverlap.AddDynamic(this, &ASoundOverlapActor::OnOverlapBegin);\n}\n\nvoid ASoundOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (SoundToPlay && OtherActor != this)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create a component that adjusts its position by input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"InputPositionAdjusterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UInputPositionAdjusterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUInputPositionAdjusterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void SetupInputComponent();\n\n\tUFUNCTION()\n\tvoid AdjustPosition(float Value);\n\nprivate:\n\tFVector MovementVector;\n\tclass APlayerController* PlayerController;\n};\n```", "cpp_code": "```cpp\n#include \"InputPositionAdjusterComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nUInputPositionAdjusterComponent::UInputPositionAdjusterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tMovementVector = FVector::ZeroVector;\n}\n\nvoid UInputPositionAdjusterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tPlayerController->InputComponent->BindAxis(\"MoveForward\", this, &UInputPositionAdjusterComponent::AdjustPosition);\n\t}\n}\n\nvoid UInputPositionAdjusterComponent::SetupInputComponent()\n{\n\tif (PlayerController && PlayerController->InputComponent)\n\t{\n\t\tPlayerController->InputComponent->BindAxis(\"MoveForward\", this, &UInputPositionAdjusterComponent::AdjustPosition);\n\t}\n}\n\nvoid UInputPositionAdjusterComponent::AdjustPosition(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tMovementVector.X = Value;\n\t\tAActor* Owner = GetOwner();\n\t\tif (Owner)\n\t\t{\n\t\t\tOwner->AddActorLocalOffset(MovementVector, true);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with an adjustable tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AdjustableTickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAdjustableTickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAAdjustableTickActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sets whether the actor should tick\n\tUFUNCTION(BlueprintCallable, Category=\"Tick\")\n\tvoid SetActorTickEnabled(bool bEnabled);\n\nprivate:\n\tbool bShouldTick;\n};\n```", "cpp_code": "```cpp\n#include \"AdjustableTickActor.h\"\n\n// Sets default values\nAAdjustableTickActor::AAdjustableTickActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tbShouldTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AAdjustableTickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AAdjustableTickActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!bShouldTick)\n\t{\n\t\treturn;\n\t}\n\n\t// Your tick code here\n}\n\nvoid AAdjustableTickActor::SetActorTickEnabled(bool bEnabled)\n{\n\tbShouldTick = bEnabled;\n\tSetActorTickEnabled(bShouldTick);\n}\n```"}
