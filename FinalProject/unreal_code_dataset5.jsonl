{"requirement": "Create an actor class with a static mesh component and set its mesh in the constructor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"StaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAStaticMeshActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Components\")\n\tUStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"StaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAStaticMeshActor::AStaticMeshActor()\n{\n\t// Initialize the Static Mesh Component\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Set the static mesh for the component\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n```"}
{"requirement": "Implement an actor that moves forward constantly each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMovingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n\nAMovingActor::AMovingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementSpeed = 100.0f; // default speed\n}\n\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation() + (GetActorForwardVector() * MovementSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that rotates around its own axis on Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Rotation speed in degrees per second\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize rotation speed\n\tRotationSpeed = 45.0f; // default rotation speed in degrees per second\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate rotation for this frame\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\n\t// Apply rotation\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to allow the speed of an actor to be adjusted in the editor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedAdjustableActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASpeedAdjustableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedAdjustableActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat Speed;\n\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedAdjustableActor.h\"\n\nASpeedAdjustableActor::ASpeedAdjustableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tSpeed = 100.0f; // Default speed value\n}\n\nvoid ASpeedAdjustableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpeedAdjustableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Example usage of Speed\n\tFVector NewLocation = GetActorLocation() + FVector(Speed * DeltaTime, 0, 0);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Bind the 'V' key to a function that prints 'Hello Unreal!' to the screen.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintHelloActor.generated.h\"\n\nUCLASS()\nclass APrintHelloActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPrintHelloActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid PrintHelloUnreal();\n};\n```", "cpp_code": "```cpp\n#include \"PrintHelloActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/Engine.h\"\n\nAPrintHelloActor::APrintHelloActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APrintHelloActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APrintHelloActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APrintHelloActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"PrintHello\", IE_Pressed, this, &APrintHelloActor::PrintHelloUnreal);\n}\n\nvoid APrintHelloActor::PrintHelloUnreal()\n{\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Hello Unreal!\"));\n\t}\n}\n```"}
{"requirement": "Implement a component with a float property exposed to Blueprints called 'MovementSpeed'.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UMovementSpeedComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UMovementSpeedComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUMovementSpeedComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"UMovementSpeedComponent.h\"\n\nUMovementSpeedComponent::UMovementSpeedComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tMovementSpeed = 600.0f;  // Default value\n}\n\nvoid UMovementSpeedComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n```"}
{"requirement": "Set up a BlueprintAssignable delegate that broadcasts when an actor is destroyed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ActorDestroyedNotifier.generated.h\"\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnActorDestroyed);\n\nUCLASS()\nclass YOURPROJECT_API AActorDestroyedNotifier : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAActorDestroyedNotifier();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\npublic:\n\tUPROPERTY(BlueprintAssignable, Category = \"Events\")\n\tFOnActorDestroyed OnActorDestroyed;\n};\n```", "cpp_code": "```cpp\n#include \"ActorDestroyedNotifier.h\"\n\nAActorDestroyedNotifier::AActorDestroyedNotifier()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AActorDestroyedNotifier::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AActorDestroyedNotifier::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tif (EndPlayReason == EEndPlayReason::Destroyed)\n\t{\n\t\tOnActorDestroyed.Broadcast();\n\t}\n\tSuper::EndPlay(EndPlayReason);\n}\n```"}
{"requirement": "Load a static mesh asset using ConstructorHelpers in the constructor of an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\t// Sets default values for this actor's properties\n\tAMyStaticMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Mesh\")\n\tUStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a StaticMeshComponent\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Load a static mesh asset\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/MeshAsset.MeshAsset\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tStaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyStaticMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a component that prints a log message when an actor overlaps with it using OnBeginOverlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"OverlapLoggerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UOverlapLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUOverlapLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION()\n\tvoid OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor);\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUOverlapLoggerComponent::UOverlapLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UOverlapLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->OnActorBeginOverlap.AddDynamic(this, &UOverlapLoggerComponent::OnBeginOverlap);\n\t}\n}\n\nvoid UOverlapLoggerComponent::OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && OtherActor != OverlappedActor)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s overlapped with %s\"), *OverlappedActor->GetName(), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Implement an actor that scales uniformly over time each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScalingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Scale factor per second\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tfloat ScaleFactorPerSecond;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n\n// Sets default values\nAScalingActor::AScalingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the scale factor\n\tScaleFactorPerSecond = 0.1f; // Example scale factor\n}\n\n// Called when the game starts or when spawned\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate new scale\n\tFVector NewScale = GetActorScale3D() * (1.0f + ScaleFactorPerSecond * DeltaTime);\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Add a UPROPERTY with ClampMin metadata to limit a variable to positive values only.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PositiveValueActor.generated.h\"\n\nUCLASS()\nclass APositiveValueActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPositiveValueActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Positive Value\", meta=(ClampMin=\"0.0\"))\n\tfloat PositiveValue;\n};\n```", "cpp_code": "```cpp\n#include \"PositiveValueActor.h\"\n\nAPositiveValueActor::APositiveValueActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tPositiveValue = 1.0f; // Default positive value\n}\n```"}
{"requirement": "Bind the 'Space' key to toggle visibility of an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleVisibilityActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid ToggleVisibility();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/InputSettings.h\"\n\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\nvoid AToggleVisibilityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleVisibilityActor::ToggleVisibility);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n\tif (MeshComponent)\n\t{\n\t\tbool bIsVisible = MeshComponent->IsVisible();\n\t\tMeshComponent->SetVisibility(!bIsVisible);\n\t}\n}\n```"}
{"requirement": "Create an actor with a collision component that reacts to OnBeginOverlap by changing color.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionColorChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionColorChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionColorChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\t\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tclass UBoxComponent* CollisionComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACollisionColorChangeActor::ACollisionColorChangeActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create the static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Create the collision component\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tCollisionComponent->SetupAttachment(RootComponent);\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionColorChangeActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionColorChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionColorChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionColorChangeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tDynamicMaterial->SetVectorParameterValue(\"BaseColor\", FLinearColor::MakeRandomColor());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Expose a boolean UPROPERTY to Blueprints that controls whether an actor rotates on Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Rotation\")\n\tbool bShouldRotate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tbShouldRotate = true;\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bShouldRotate)\n\t{\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Yaw += DeltaTime * 45.0f; // Rotate 45 degrees per second\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Implement a component that triggers a sound when an actor overlaps with it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Sound/SoundBase.h\"\n#include \"UTriggerSoundComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UTriggerSoundComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tUTriggerSoundComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called when an actor overlaps with the component\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);\n\n\t// Sound to play on overlap\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* OverlapSound;\n\n};\n```", "cpp_code": "```cpp\n#include \"UTriggerSoundComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUTriggerSoundComponent::UTriggerSoundComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UTriggerSoundComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->OnActorBeginOverlap.AddDynamic(this, &UTriggerSoundComponent::OnOverlapBegin);\n\t}\n}\n\nvoid UTriggerSoundComponent::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OverlapSound && OtherActor != GetOwner())\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, OverlapSound, GetOwner()->GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Bind the 'P' key to pause and resume Tick-based movement of an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PauseableActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API APauseableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPauseableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tbool bIsPaused;\n\n\tvoid TogglePause();\n};\n```", "cpp_code": "```cpp\n#include \"PauseableActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAPauseableActor::APauseableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsPaused = false;\n}\n\nvoid APauseableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APauseableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (!bIsPaused)\n\t{\n\t\t// Place movement logic here\n\t}\n}\n\nvoid APauseableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"TogglePause\", IE_Pressed, this, &APauseableActor::TogglePause);\n}\n\nvoid APauseableActor::TogglePause()\n{\n\tbIsPaused = !bIsPaused;\n}\n```"}
{"requirement": "Create an actor that increases its size incrementally when the 'G' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"IncrementalSizeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AIncrementalSizeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAIncrementalSizeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to increase the size\n\tvoid IncreaseSize();\n\n\t// Static Mesh Component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Scale increment value\n\tUPROPERTY(EditAnywhere)\n\tFVector ScaleIncrement;\n};\n```", "cpp_code": "```cpp\n#include \"IncrementalSizeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAIncrementalSizeActor::AIncrementalSizeActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach the static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set default scale increment\n\tScaleIncrement = FVector(0.1f, 0.1f, 0.1f);\n}\n\n// Called when the game starts or when spawned\nvoid AIncrementalSizeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AIncrementalSizeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input\nvoid AIncrementalSizeActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the IncreaseSize function to the 'G' key\n\tPlayerInputComponent->BindAction(\"IncreaseSize\", IE_Pressed, this, &AIncrementalSizeActor::IncreaseSize);\n}\n\n// Function to increase the size\nvoid AIncrementalSizeActor::IncreaseSize()\n{\n\tFVector NewScale = GetActorScale3D() + ScaleIncrement;\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Implement an actor that changes its material when overlapping with another specific actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMaterialChangingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyMaterialChangingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyMaterialChangingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUPROPERTY(EditAnywhere)\n\tTSubclassOf<AActor> SpecificActorClass;\n};\n```", "cpp_code": "```cpp\n#include \"MyMaterialChangingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyMaterialChangingActor::AMyMaterialChangingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMyMaterialChangingActor::OnOverlapBegin);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AMyMaterialChangingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyMaterialChangingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyMaterialChangingActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor->IsA(SpecificActorClass))\n\t{\n\t\tif (NewMaterial)\n\t\t{\n\t\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Set up a UFUNCTION that prints the position of an actor each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PositionPrinterActor.generated.h\"\n\nUCLASS()\nclass APositionPrinterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAPositionPrinterActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid PrintPosition();\n};\n```", "cpp_code": "```cpp\n#include \"PositionPrinterActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\nAPositionPrinterActor::APositionPrinterActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APositionPrinterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid APositionPrinterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tPrintPosition();\n}\n\nvoid APositionPrinterActor::PrintPosition()\n{\n\tif (GEngine)\n\t{\n\t\tFVector ActorLocation = GetActorLocation();\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Actor Position: %s\"), *ActorLocation.ToString()));\n\t}\n}\n```"}
{"requirement": "Create a component with a UPROPERTY that can be edited in the Blueprint editor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UCustomComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCustomComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUCustomComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Custom\")\n\tfloat CustomFloat;\n};\n```", "cpp_code": "```cpp\n#include \"UCustomComponent.h\"\n\n// Sets default values for this component's properties\nUCustomComponent::UCustomComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\t// Initialize default value\n\tCustomFloat = 0.0f;\n}\n\n// Called when the game starts\nvoid UCustomComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// ...\n}\n\n// Called every frame\nvoid UCustomComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// ...\n}\n```"}
{"requirement": "Bind a function to the 'R' key that resets an actor's position to a start location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetPositionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetPositionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResetPositionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tFVector StartLocation;\n\n\tvoid ResetPosition();\n};\n```", "cpp_code": "```cpp\n#include \"ResetPositionActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAResetPositionActor::AResetPositionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetPositionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartLocation = GetActorLocation();\n}\n\nvoid AResetPositionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetPositionActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetPosition\", IE_Pressed, this, &AResetPositionActor::ResetPosition);\n}\n\nvoid AResetPositionActor::ResetPosition()\n{\n\tSetActorLocation(StartLocation);\n}\n```"}
{"requirement": "Implement an actor that toggles between two materials each time it's clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAToggleMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Materials\")\n\tUMaterialInterface* MaterialOne;\n\n\tUPROPERTY(EditAnywhere, Category = \"Materials\")\n\tUMaterialInterface* MaterialTwo;\n\n\tUFUNCTION()\n\tvoid OnMeshClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed);\n\n\tbool bUseMaterialOne;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAToggleMaterialActor::AToggleMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->OnClicked.AddDynamic(this, &AToggleMaterialActor::OnMeshClicked);\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/Path/To/Your/Mesh.YourMesh'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tbUseMaterialOne = true;\n}\n\nvoid AToggleMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MaterialOne && MaterialTwo)\n\t{\n\t\tMeshComponent->SetMaterial(0, MaterialOne);\n\t}\n}\n\nvoid AToggleMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleMaterialActor::OnMeshClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed)\n{\n\tif (MaterialOne && MaterialTwo)\n\t{\n\t\tbUseMaterialOne = !bUseMaterialOne;\n\t\tUMaterialInterface* CurrentMaterial = bUseMaterialOne ? MaterialOne : MaterialTwo;\n\t\tMeshComponent->SetMaterial(0, CurrentMaterial);\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere for a color property and change material color on Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAChangeColorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tFLinearColor Color;\n\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAChangeColorActor::AChangeColorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tColor = FLinearColor::White; // Default color\n}\n\nvoid AChangeColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (MeshComponent)\n\t{\n\t\tUMaterialInstanceDynamic* MaterialInstance = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\t\tif (MaterialInstance)\n\t\t{\n\t\t\tMaterialInstance->SetVectorParameterValue(FName(\"BaseColor\"), Color);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a component that rotates the owner actor around a point set in UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"URotationAroundPointComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API URotationAroundPointComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tURotationAroundPointComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tFVector RotationPoint;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"URotationAroundPointComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nURotationAroundPointComponent::URotationAroundPointComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tRotationSpeed = 45.0f; // Default rotation speed in degrees per second\n}\n\nvoid URotationAroundPointComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotationAroundPointComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector OwnerLocation = Owner->GetActorLocation();\n\t\tFVector Direction = OwnerLocation - RotationPoint;\n\t\tDirection = Direction.RotateAngleAxis(RotationSpeed * DeltaTime, FVector::UpVector);\n\t\tFVector NewLocation = RotationPoint + Direction;\n\t\tOwner->SetActorLocation(NewLocation);\n\t}\n}\n```"}
{"requirement": "Load a texture using ConstructorHelpers and apply it to an actor's material in the constructor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UTextureLoaderActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AUTextureLoaderActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tAUTextureLoaderActor();\n\nprotected:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"UTextureLoaderActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/Texture2D.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\nAUTextureLoaderActor::AUTextureLoaderActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UTexture2D> TextureAsset(TEXT(\"/Game/Path/To/Your/Texture.Texture\"));\n\tif (TextureAsset.Succeeded())\n\t{\n\t\tUMaterialInstanceDynamic* DynamicMaterial = UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this);\n\t\tif (DynamicMaterial)\n\t\t{\n\t\t\tDynamicMaterial->SetTextureParameterValue(FName(\"YourTextureParameterName\"), TextureAsset.Object);\n\t\t\tMeshComponent->SetMaterial(0, DynamicMaterial);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that prints its current velocity to the screen each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"VelocityPrinterActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AVelocityPrinterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAVelocityPrinterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"VelocityPrinterActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAVelocityPrinterActor::AVelocityPrinterActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AVelocityPrinterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AVelocityPrinterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector Velocity = GetVelocity();\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Velocity: %s\"), *Velocity.ToString()));\n\t}\n}\n```"}
{"requirement": "Implement a component that doubles an actor's speed when a specific button is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"USpeedBoostComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API USpeedBoostComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUSpeedBoostComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvoid DoubleSpeed();\n\tvoid ResetSpeed();\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat SpeedMultiplier;\n\n\tUPROPERTY()\n\tbool bIsSpeedBoosted;\n\n\tUPROPERTY()\n\tfloat OriginalSpeed;\n\n\tUFUNCTION()\n\tvoid HandleSpeedBoostInput();\n};\n```", "cpp_code": "```cpp\n#include \"USpeedBoostComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nUSpeedBoostComponent::USpeedBoostComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tSpeedMultiplier = 2.0f;\n\tbIsSpeedBoosted = false;\n}\n\nvoid USpeedBoostComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUInputComponent* InputComponent = Owner->FindComponentByClass<UInputComponent>();\n\t\tif (InputComponent)\n\t\t{\n\t\t\tInputComponent->BindAction(\"SpeedBoost\", IE_Pressed, this, &USpeedBoostComponent::HandleSpeedBoostInput);\n\t\t}\n\t}\n}\n\nvoid USpeedBoostComponent::DoubleSpeed()\n{\n\tif (ACharacter* Character = Cast<ACharacter>(GetOwner()))\n\t{\n\t\tUCharacterMovementComponent* MovementComponent = Character->GetCharacterMovement();\n\t\tif (MovementComponent && !bIsSpeedBoosted)\n\t\t{\n\t\t\tOriginalSpeed = MovementComponent->MaxWalkSpeed;\n\t\t\tMovementComponent->MaxWalkSpeed *= SpeedMultiplier;\n\t\t\tbIsSpeedBoosted = true;\n\t\t}\n\t}\n}\n\nvoid USpeedBoostComponent::ResetSpeed()\n{\n\tif (ACharacter* Character = Cast<ACharacter>(GetOwner()))\n\t{\n\t\tUCharacterMovementComponent* MovementComponent = Character->GetCharacterMovement();\n\t\tif (MovementComponent && bIsSpeedBoosted)\n\t\t{\n\t\t\tMovementComponent->MaxWalkSpeed = OriginalSpeed;\n\t\t\tbIsSpeedBoosted = false;\n\t\t}\n\t}\n}\n\nvoid USpeedBoostComponent::HandleSpeedBoostInput()\n{\n\tif (bIsSpeedBoosted)\n\t{\n\t\tResetSpeed();\n\t}\n\telse\n\t{\n\t\tDoubleSpeed();\n\t}\n}\n```"}
{"requirement": "Bind the 'L' key to a function that logs all overlapping actors.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LogOverlappingActors.generated.h\"\n\nUCLASS()\nclass ALogOverlappingActors : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALogOverlappingActors();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid LogOverlappingActors();\n};\n```", "cpp_code": "```cpp\n#include \"LogOverlappingActors.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nALogOverlappingActors::ALogOverlappingActors()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALogOverlappingActors::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALogOverlappingActors::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"LogOverlappingActors\", IE_Pressed, this, &ALogOverlappingActors::LogOverlappingActors);\n}\n\nvoid ALogOverlappingActors::LogOverlappingActors()\n{\n\tTArray<AActor*> OverlappingActors;\n\tGetOverlappingActors(OverlappingActors);\n\tfor (AActor* Actor : OverlappingActors)\n\t{\n\t\tif (Actor)\n\t\t{\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Overlapping Actor: %s\"), *Actor->GetName());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a particle system that activates on BeginPlay.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"MyParticleActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyParticleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyParticleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUParticleSystemComponent* ParticleSystemComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyParticleActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMyParticleActor::AMyParticleActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"ParticleSystemComponent\"));\n\tRootComponent = ParticleSystemComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UParticleSystem> ParticleAsset(TEXT(\"/Game/Particles/MyParticleSystem.MyParticleSystem\"));\n\tif (ParticleAsset.Succeeded())\n\t{\n\t\tParticleSystemComponent->SetTemplate(ParticleAsset.Object);\n\t}\n}\n\nvoid AMyParticleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (ParticleSystemComponent)\n\t{\n\t\tParticleSystemComponent->Activate();\n\t}\n}\n```"}
{"requirement": "Implement an actor that changes its rotation direction when the 'F' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed;\n\n\tbool bRotateClockwise;\n\n\tvoid ToggleRotationDirection();\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"ConstructorHelpers.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/Path/To/Your/Mesh.Mesh'\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tRotationSpeed = 90.0f;\n\tbRotateClockwise = true;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat RotationDirection = bRotateClockwise ? 1.0f : -1.0f;\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * RotationDirection * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n\nvoid ARotatingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleRotation\", IE_Pressed, this, &ARotatingActor::ToggleRotationDirection);\n}\n\nvoid ARotatingActor::ToggleRotationDirection()\n{\n\tbRotateClockwise = !bRotateClockwise;\n}\n```"}
{"requirement": "Create a static mesh actor and set it to be hidden in game via a UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyStaticMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"Mesh\")\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Visibility\")\n\tbool bHiddenInGame;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Set default visibility\n\tbHiddenInGame = true;\n\tStaticMeshComponent->SetHiddenInGame(bHiddenInGame);\n\n\t// Example of setting a static mesh (optional)\n\t// ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\t// if (MeshAsset.Succeeded())\n\t// {\n\t//\t StaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t// }\n}\n\n// Called when the game starts or when spawned\nvoid AMyStaticMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tStaticMeshComponent->SetHiddenInGame(bHiddenInGame);\n}\n\n// Called every frame\nvoid AMyStaticMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create a component that changes the scale of an actor over time based on a UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ScaleChangerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UScaleChangerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUScaleChangerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Scale\")\n\tFVector TargetScale;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Scale\")\n\tfloat ScaleSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"ScaleChangerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUScaleChangerComponent::UScaleChangerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTargetScale = FVector(1.0f, 1.0f, 1.0f);\n\tScaleSpeed = 1.0f;\n}\n\nvoid UScaleChangerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UScaleChangerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tFVector CurrentScale = Owner->GetActorScale3D();\n\t\tFVector NewScale = FMath::VInterpTo(CurrentScale, TargetScale, DeltaTime, ScaleSpeed);\n\t\tOwner->SetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Bind the 'Q' key to a function that quits the game.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"UQuitGamePawn.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AUQuitGamePawn : public APawn\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this pawn's properties\n\tAUQuitGamePawn();\n\nprotected:\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Function to quit the game\n\tvoid QuitGame();\n};\n```", "cpp_code": "```cpp\n#include \"UQuitGamePawn.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAUQuitGamePawn::AUQuitGamePawn()\n{\n\t// Set this pawn to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AUQuitGamePawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the QuitGame function to the 'Q' key\n\tPlayerInputComponent->BindAction(\"QuitGame\", IE_Pressed, this, &AUQuitGamePawn::QuitGame);\n}\n\nvoid AUQuitGamePawn::QuitGame()\n{\n\tif (APlayerController* PC = UGameplayStatics::GetPlayerController(GetWorld(), 0))\n\t{\n\t\tPC->ConsoleCommand(\"quit\");\n\t}\n}\n```"}
{"requirement": "Implement an actor that plays a sound on BeginOverlap and stops it on EndOverlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"ASoundOverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundOverlapActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundOverlapActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUAudioComponent* AudioComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUSoundCue* OverlapSoundCue;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n};\n```", "cpp_code": "```cpp\n#include \"ASoundOverlapActor.h\"\n#include \"Components/BoxComponent.h\"\n\nASoundOverlapActor::ASoundOverlapActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tUBoxComponent* BoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tRootComponent = BoxComponent;\n\n\tBoxComponent->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tBoxComponent->SetCollisionResponseToAllChannels(ECR_Overlap);\n\n\tBoxComponent->OnComponentBeginOverlap.AddDynamic(this, &ASoundOverlapActor::OnOverlapBegin);\n\tBoxComponent->OnComponentEndOverlap.AddDynamic(this, &ASoundOverlapActor::OnOverlapEnd);\n\n\tAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n\tAudioComponent->SetupAttachment(RootComponent);\n}\n\nvoid ASoundOverlapActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundOverlapActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASoundOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OverlapSoundCue && !AudioComponent->IsPlaying())\n\t{\n\t\tAudioComponent->SetSound(OverlapSoundCue);\n\t\tAudioComponent->Play();\n\t}\n}\n\nvoid ASoundOverlapActor::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (AudioComponent->IsPlaying())\n\t{\n\t\tAudioComponent->Stop();\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere for an integer variable and use it to limit movement speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourGameActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AYourGameActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAYourGameActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tint32 MaxMovementSpeed;\n\n\tvoid MoveForward(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"YourGameActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\nAYourGameActor::AYourGameActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMaxMovementSpeed = 600; // Default value\n}\n\nvoid AYourGameActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourGameActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AYourGameActor::MoveForward(float Value)\n{\n\tif (Value != 0.0f)\n\t{\n\t\tFVector Direction = FVector::ForwardVector;\n\t\tFVector NewLocation = GetActorLocation() + Direction * FMath::Clamp(Value, -1.0f, 1.0f) * MaxMovementSpeed * GetWorld()->GetDeltaSeconds();\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n\nvoid AYourGameActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &AYourGameActor::MoveForward);\n}\n```"}
{"requirement": "Create an actor with a timer that prints a message every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"MessagePrinterActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMessagePrinterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMessagePrinterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\t// Timer handle for managing the timer\n\tFTimerHandle TimerHandle;\n\n\t// Function to be called every second by the timer\n\tvoid PrintMessage();\n};\n```", "cpp_code": "```cpp\n#include \"MessagePrinterActor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nAMessagePrinterActor::AMessagePrinterActor()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid AMessagePrinterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Set the timer to call PrintMessage every 1 second\n\tGetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &AMessagePrinterActor::PrintMessage, 1.0f, true);\n}\n\n// Function to print a message every second\nvoid AMessagePrinterActor::PrintMessage()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"This message is printed every second.\"));\n}\n```"}
{"requirement": "Bind the 'O' key to a function that toggles an actor's physics simulation.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TogglePhysicsActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATogglePhysicsActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATogglePhysicsActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tvoid TogglePhysics();\n};\n```", "cpp_code": "```cpp\n#include \"TogglePhysicsActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerInput.h\"\n\nATogglePhysicsActor::ATogglePhysicsActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetSimulatePhysics(false);\n}\n\nvoid ATogglePhysicsActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ATogglePhysicsActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"TogglePhysics\", IE_Pressed, this, &ATogglePhysicsActor::TogglePhysics);\n\t}\n}\n\nvoid ATogglePhysicsActor::TogglePhysics()\n{\n\tif (MeshComponent)\n\t{\n\t\tbool bIsSimulating = MeshComponent->IsSimulatingPhysics();\n\t\tMeshComponent->SetSimulatePhysics(!bIsSimulating);\n\t}\n}\n```"}
{"requirement": "Implement a component that adds a force to an actor each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UForceAdderComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UForceAdderComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUForceAdderComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tFVector ForceToAdd;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"UForceAdderComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nUForceAdderComponent::UForceAdderComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tForceToAdd = FVector(1000.f, 0.f, 0.f); // Default force value\n}\n\nvoid UForceAdderComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tMeshComponent = GetOwner()->FindComponentByClass<UStaticMeshComponent>();\n\tif (!MeshComponent)\n\t{\n\t\tUE_LOG(LogTemp, Error, TEXT(\"No static mesh component found on %s\"), *GetOwner()->GetName());\n\t}\n}\n\nvoid UForceAdderComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (MeshComponent)\n\t{\n\t\tMeshComponent->AddForce(ForceToAdd);\n\t}\n}\n```"}
{"requirement": "Create an actor that changes its mesh when a specific UFUNCTION is called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MeshChangerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMeshChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMeshChangerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Mesh\")\n\tvoid ChangeMesh();\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Mesh\")\n\tUStaticMesh* NewMesh;\n};\n```", "cpp_code": "```cpp\n#include \"MeshChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAMeshChangerActor::AMeshChangerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Example of setting a default mesh, replace with your asset path\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> DefaultMesh(TEXT(\"/Game/Path/To/Your/DefaultMesh.DefaultMesh\"));\n\tif (DefaultMesh.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(DefaultMesh.Object);\n\t}\n}\n\nvoid AMeshChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMeshChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMeshChangerActor::ChangeMesh()\n{\n\tif (NewMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(NewMesh);\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with metadata to ensure a variable is only visible in Blueprint.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tUPROPERTY(BlueprintReadOnly, meta=(AllowPrivateAccess=\"true\"))\n\tint32 MyVariable;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\t// Initialize variable if needed\n\tMyVariable = 0;\n}\n```"}
{"requirement": "Implement an actor that spawns another actor when a specific key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpawnActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpawnActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpawnActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to spawn the actor\n\tvoid SpawnAnotherActor();\n\n\t// Setup player input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// The class of actor to spawn\n\tUPROPERTY(EditAnywhere, Category=\"Spawning\")\n\tTSubclassOf<AActor> ActorToSpawn;\n};\n```", "cpp_code": "```cpp\n#include \"SpawnActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASpawnActor::ASpawnActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASpawnActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpawnActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpawnActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the input action to spawn the actor when the \"SpawnKey\" is pressed\n\tPlayerInputComponent->BindAction(\"SpawnKey\", IE_Pressed, this, &ASpawnActor::SpawnAnotherActor);\n}\n\nvoid ASpawnActor::SpawnAnotherActor()\n{\n\tif (ActorToSpawn)\n\t{\n\t\tUWorld* World = GetWorld();\n\t\tif (World)\n\t\t{\n\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\tSpawnParams.Owner = this;\n\t\t\tSpawnParams.Instigator = GetInstigator();\n\n\t\t\t// Get the location and rotation of the current actor\n\t\t\tFVector SpawnLocation = GetActorLocation();\n\t\t\tFRotator SpawnRotation = GetActorRotation();\n\n\t\t\t// Spawn the actor\n\t\t\tWorld->SpawnActor<AActor>(ActorToSpawn, SpawnLocation, SpawnRotation, SpawnParams);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor with a light component that toggles on and off with the 'B' key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"ToggleLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleLightActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AToggleLightActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\n  virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n  UPROPERTY(VisibleAnywhere, Category = \"Light\")\n  UPointLightComponent* PointLight;\n\n  void ToggleLight();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleLightActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAToggleLightActor::AToggleLightActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n\n  PointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n  RootComponent = PointLight;\n\n  PointLight->SetVisibility(false);\n}\n\nvoid AToggleLightActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AToggleLightActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AToggleLightActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n  Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n  if (PlayerInputComponent)\n  {\n\tPlayerInputComponent->BindAction(\"ToggleLight\", IE_Pressed, this, &AToggleLightActor::ToggleLight);\n  }\n}\n\nvoid AToggleLightActor::ToggleLight()\n{\n  if (PointLight)\n  {\n\tPointLight->ToggleVisibility();\n  }\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere for a timer duration and print a message when it expires.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"ATimerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATimerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tATimerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Timer\")\n\tfloat TimerDuration;\n\n\tFTimerHandle TimerHandle;\n\n\tvoid OnTimerExpire();\n};\n```", "cpp_code": "```cpp\n#include \"ATimerActor.h\"\n#include \"Engine/World.h\"\n\nATimerActor::ATimerActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\tTimerDuration = 5.0f; // Default value\n}\n\nvoid ATimerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &ATimerActor::OnTimerExpire, TimerDuration, false);\n}\n\nvoid ATimerActor::OnTimerExpire()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Timer expired!\"));\n}\n```"}
{"requirement": "Bind the 'M' key to a function that changes the material of an actor to a random color.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomColorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARandomColorActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ChangeMaterialColor();\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"RandomColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Components/InputComponent.h\"\n\nARandomColorActor::ARandomColorActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/StaticMesh.StaticMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tDynamicMaterialInstance = nullptr;\n}\n\nvoid ARandomColorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (MeshComponent && MeshComponent->GetMaterial(0))\n\t{\n\t\tDynamicMaterialInstance = UMaterialInstanceDynamic::Create(MeshComponent->GetMaterial(0), this);\n\t\tMeshComponent->SetMaterial(0, DynamicMaterialInstance);\n\t}\n}\n\nvoid ARandomColorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARandomColorActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ChangeColor\", IE_Pressed, this, &ARandomColorActor::ChangeMaterialColor);\n}\n\nvoid ARandomColorActor::ChangeMaterialColor()\n{\n\tif (DynamicMaterialInstance)\n\t{\n\t\tFLinearColor RandomColor = FLinearColor::MakeRandomColor();\n\t\tDynamicMaterialInstance->SetVectorParameterValue(\"BaseColor\", RandomColor);\n\t}\n}\n```"}
{"requirement": "Implement a component that prints a message each time an actor enters its collision box.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UCollisionMessageComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UCollisionMessageComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUCollisionMessageComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUPROPERTY()\n\tclass UBoxComponent* CollisionBox;\n};\n```", "cpp_code": "```cpp\n#include \"UCollisionMessageComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUCollisionMessageComponent::UCollisionMessageComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\tCollisionBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionBox\"));\n\tCollisionBox->SetupAttachment(this);\n\tCollisionBox->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tCollisionBox->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap);\n\tCollisionBox->OnComponentBeginOverlap.AddDynamic(this, &UCollisionMessageComponent::OnOverlapBegin);\n}\n\nvoid UCollisionMessageComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UCollisionMessageComponent::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && OtherActor != GetOwner())\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Actor %s has entered the collision box.\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Load a sound asset using ConstructorHelpers and play it when a function is called.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Sound/SoundWave.h\"\n#include \"ASoundPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tASoundPlayerActor();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Sound\")\n\tvoid PlaySound();\n\nprotected:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundBase* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"ASoundPlayerActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"ConstructorHelpers.h\"\n\nASoundPlayerActor::ASoundPlayerActor()\n{\n\tstatic ConstructorHelpers::FObjectFinder<USoundBase> SoundAsset(TEXT(\"/Game/Audio/YourSoundCue.YourSoundCue\"));\n\tif (SoundAsset.Succeeded())\n\t{\n\t\tSoundToPlay = SoundAsset.Object;\n\t}\n\telse\n\t{\n\t\tSoundToPlay = nullptr;\n\t}\n}\n\nvoid ASoundPlayerActor::PlaySound()\n{\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create an actor that moves along a spline path each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SplineComponent.h\"\n#include \"SplinePathMover.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASplinePathMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASplinePathMover();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUSplineComponent* SplineComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat Speed;\n\n\tfloat DistanceTraveled;\n};\n```", "cpp_code": "```cpp\n#include \"SplinePathMover.h\"\n#include \"Components/SplineComponent.h\"\n\nASplinePathMover::ASplinePathMover()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSplineComponent = CreateDefaultSubobject<USplineComponent>(TEXT(\"SplineComponent\"));\n\tRootComponent = SplineComponent;\n\n\tSpeed = 100.0f;\n\tDistanceTraveled = 0.0f;\n}\n\nvoid ASplinePathMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASplinePathMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tDistanceTraveled += Speed * DeltaTime;\n\tfloat SplineLength = SplineComponent->GetSplineLength();\n\tFVector NewLocation = SplineComponent->GetLocationAtDistanceAlongSpline(fmod(DistanceTraveled, SplineLength), ESplineCoordinateSpace::World);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Add a UPROPERTY editable in Blueprint for a multiplier affecting an actor's rotation speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotationSpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotationSpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tARotationSpeedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Rotation\")\n\tfloat RotationSpeedMultiplier;\n};\n```", "cpp_code": "```cpp\n#include \"RotationSpeedActor.h\"\n\nARotationSpeedActor::ARotationSpeedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeedMultiplier = 1.0f; // Default value\n}\n\nvoid ARotationSpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotationSpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\t// Example usage: rotate actor based on multiplier\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeedMultiplier * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement an actor that rotates its mesh based on mouse movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseRotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMouseRotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAMouseRotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// The static mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Mouse input functions\n\tvoid RotateMesh(float AxisValue);\n\n\t// Rotation speed\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MouseRotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAMouseRotatingActor::AMouseRotatingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach a static mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set a default static mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Set default rotation speed\n\tRotationSpeed = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMouseRotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMouseRotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Setup player input component\nvoid AMouseRotatingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"Turn\", this, &AMouseRotatingActor::RotateMesh);\n}\n\n// Rotate the mesh based on mouse input\nvoid AMouseRotatingActor::RotateMesh(float AxisValue)\n{\n\tFRotator NewRotation = MeshComponent->GetComponentRotation();\n\tNewRotation.Yaw += AxisValue * RotationSpeed * GetWorld()->GetDeltaSeconds();\n\tMeshComponent->SetWorldRotation(NewRotation);\n}\n```"}
{"requirement": "Create a component that logs when an actor reaches a specific location in the world.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULocationLoggerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API ULocationLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tULocationLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFVector TargetLocation;\n\tfloat Tolerance;\n\n\tvoid CheckLocation();\n};\n```", "cpp_code": "```cpp\n#include \"ULocationLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nULocationLoggerComponent::ULocationLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tTargetLocation = FVector(0.0f, 0.0f, 0.0f);\n\tTolerance = 100.0f; // 100 units tolerance\n}\n\nvoid ULocationLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ULocationLoggerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tCheckLocation();\n}\n\nvoid ULocationLoggerComponent::CheckLocation()\n{\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tFVector CurrentLocation = Owner->GetActorLocation();\n\t\tif (FVector::Dist(CurrentLocation, TargetLocation) <= Tolerance)\n\t\t{\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s has reached the target location!\"), *Owner->GetName());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Bind the 'I' key to a function that inverts the direction of an actor's movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InvertMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AInvertMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAInvertMovementActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid InvertMovementDirection();\n\n\tFVector MovementDirection;\n};\n```", "cpp_code": "```cpp\n#include \"InvertMovementActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAInvertMovementActor::AInvertMovementActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default movement direction\n\tMovementDirection = FVector(1.0f, 0.0f, 0.0f);\n}\n\nvoid AInvertMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AInvertMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Move the actor in the current movement direction\n\tAddActorWorldOffset(MovementDirection * DeltaTime);\n}\n\nvoid AInvertMovementActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the 'I' key to the InvertMovementDirection function\n\tPlayerInputComponent->BindAction(\"InvertDirection\", IE_Pressed, this, &AInvertMovementActor::InvertMovementDirection);\n}\n\nvoid AInvertMovementActor::InvertMovementDirection()\n{\n\tMovementDirection *= -1.0f;\n}\n```"}
{"requirement": "Create an actor with a UPROPERTY to toggle between two movement modes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovementModeActor.generated.h\"\n\nUENUM(BlueprintType)\nenum class EMovementMode : uint8 {\n\tWalking UMETA(DisplayName = \"Walking\"),\n\tRunning UMETA(DisplayName = \"Running\")\n};\n\nUCLASS()\nclass YOURPROJECT_API AMovementModeActor : public AActor {\n\tGENERATED_BODY()\n\npublic:\n\tAMovementModeActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Movement\")\n\tEMovementMode MovementMode;\n};\n```", "cpp_code": "```cpp\n#include \"MovementModeActor.h\"\n\nAMovementModeActor::AMovementModeActor() {\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementMode = EMovementMode::Walking;\n}\n\nvoid AMovementModeActor::BeginPlay() {\n\tSuper::BeginPlay();\n}\n\nvoid AMovementModeActor::Tick(float DeltaTime) {\n\tSuper::Tick(DeltaTime);\n\t\n\tswitch (MovementMode) {\n\t\tcase EMovementMode::Walking:\n\t\t\t// Implement walking behavior here\n\t\t\tbreak;\n\t\tcase EMovementMode::Running:\n\t\t\t// Implement running behavior here\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n```"}
{"requirement": "Implement a component that applies a rotational force to an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"URotationalForceComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API URotationalForceComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tURotationalForceComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Force\")\n\tvoid ApplyRotationalForce(float TorqueMagnitude);\n\nprivate:\n\t// The torque to apply each frame\n\tfloat CurrentTorque;\n};\n```", "cpp_code": "```cpp\n#include \"URotationalForceComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nURotationalForceComponent::URotationalForceComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tCurrentTorque = 0.0f;\n}\n\nvoid URotationalForceComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid URotationalForceComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (CurrentTorque != 0.0f)\n\t{\n\t\tAActor* Owner = GetOwner();\n\t\tif (Owner)\n\t\t{\n\t\t\tUPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(Owner->GetRootComponent());\n\t\t\tif (PrimitiveComponent)\n\t\t\t{\n\t\t\t\tPrimitiveComponent->AddTorqueInRadians(FVector(0.0f, 0.0f, CurrentTorque));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid URotationalForceComponent::ApplyRotationalForce(float TorqueMagnitude)\n{\n\tCurrentTorque = TorqueMagnitude;\n}\n```"}
{"requirement": "Load a blueprint asset using ConstructorHelpers and spawn it at runtime.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditDefaultsOnly, Category=\"Spawning\")\n\tTSubclassOf<AActor> BlueprintActorToSpawn;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/World.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/PathToYourMesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tstatic ConstructorHelpers::FClassFinder<AActor> BlueprintActor(TEXT(\"/Game/PathToYourBlueprintActor.YourBlueprintActor_C\"));\n\tif (BlueprintActor.Succeeded())\n\t{\n\t\tBlueprintActorToSpawn = BlueprintActor.Class;\n\t}\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (BlueprintActorToSpawn)\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tGetWorld()->SpawnActor<AActor>(BlueprintActorToSpawn, GetActorLocation() + FVector(200, 0, 0), FRotator::ZeroRotator, SpawnParams);\n\t}\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that prints the distance from another actor each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DistancePrinterActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADistancePrinterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tADistancePrinterActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Distance\")\n\tAActor* TargetActor;\n};\n```", "cpp_code": "```cpp\n#include \"DistancePrinterActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nADistancePrinterActor::ADistancePrinterActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ADistancePrinterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADistancePrinterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tfloat Distance = FVector::Dist(GetActorLocation(), TargetActor->GetActorLocation());\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Distance to Target: %f\"), Distance);\n\t}\n}\n```"}
{"requirement": "Bind the 'Z' key to toggle an actor's visibility and collision.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityAndCollisionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityAndCollisionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleVisibilityAndCollisionActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* StaticMeshComponent;\n\n\tvoid ToggleVisibilityAndCollision();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityAndCollisionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"Components/InputComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAToggleVisibilityAndCollisionActor::AToggleVisibilityAndCollisionActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tStaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n\tRootComponent = StaticMeshComponent;\n\n\t// Optionally set a default mesh\n\t// ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"StaticMesh'/Game/Path/To/Your/Mesh.Mesh'\"));\n\t// if (MeshAsset.Succeeded())\n\t// {\n\t//\t StaticMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t// }\n}\n\nvoid AToggleVisibilityAndCollisionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleVisibilityAndCollisionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityAndCollisionActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ToggleVisibilityAndCollision\", IE_Pressed, this, &AToggleVisibilityAndCollisionActor::ToggleVisibilityAndCollision);\n}\n\nvoid AToggleVisibilityAndCollisionActor::ToggleVisibilityAndCollision()\n{\n\tbool bNewVisibility = !StaticMeshComponent->IsVisible();\n\tStaticMeshComponent->SetVisibility(bNewVisibility);\n\tStaticMeshComponent->SetCollisionEnabled(bNewVisibility ? ECollisionEnabled::QueryAndPhysics : ECollisionEnabled::NoCollision);\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere for setting an actor's initial velocity.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAMyActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tFVector InitialVelocity;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Example usage of InitialVelocity\n\t// You might want to apply this velocity to a physics component\n\t// if you have one attached to this actor.\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\t// Example code to move actor according to InitialVelocity\n\tFVector NewLocation = GetActorLocation() + (InitialVelocity * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that scales up and down repeatedly each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* Mesh;\n\n\tfloat ScaleDirection;\n\tfloat ScaleSpeed;\n\tFVector InitialScale;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh\"));\n\tRootComponent = Mesh;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMesh->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tScaleDirection = 1.0f;\n\tScaleSpeed = 0.5f;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialScale = GetActorScale3D();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentScale = GetActorScale3D();\n\tCurrentScale += FVector(ScaleSpeed * ScaleDirection * DeltaTime);\n\n\tif (CurrentScale.X > 2.0f * InitialScale.X || CurrentScale.X < 0.5f * InitialScale.X)\n\t{\n\t\tScaleDirection *= -1.0f;\n\t}\n\n\tSetActorScale3D(CurrentScale);\n}\n```"}
{"requirement": "Implement a component that changes an actor's color when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ColorChangeComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UColorChangeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUColorChangeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\nprivate:\n\tUFUNCTION()\n\tvoid OnClicked();\n\n\tUPROPERTY()\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"ConstructorHelpers.h\"\n\nUColorChangeComponent::UColorChangeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComponent->OnClicked.AddDynamic(this, &UColorChangeComponent::OnClicked);\n}\n\nvoid UColorChangeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->AddInstanceComponent(MeshComponent);\n\t\tMeshComponent->RegisterComponent();\n\t}\n}\n\nvoid UColorChangeComponent::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tcheck(PlayerInputComponent);\n}\n\nvoid UColorChangeComponent::OnClicked()\n{\n\tif (MeshComponent)\n\t{\n\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"BaseColor\"), FVector(NewColor));\n\t}\n}\n```"}
{"requirement": "Create an actor with a UPROPERTY to control the amount of time it takes to rotate 360 degrees.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationTime;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationTime = 5.0f; // Default to 5 seconds for a full rotation\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (RotationTime > 0)\n\t{\n\t\tfloat RotationSpeed = 360.0f / RotationTime;\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Bind the 'X' key to a function that resets an actor's scale to default.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetScaleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetScaleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResetScaleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid ResetScale();\n\n\tFVector DefaultScale;\n};\n```", "cpp_code": "```cpp\n#include \"ResetScaleActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nAResetScaleActor::AResetScaleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tDefaultScale = FVector(1.0f, 1.0f, 1.0f);\n}\n\nvoid AResetScaleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AResetScaleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetScaleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetScale\", IE_Pressed, this, &AResetScaleActor::ResetScale);\n}\n\nvoid AResetScaleActor::ResetScale()\n{\n\tSetActorScale3D(DefaultScale);\n}\n```"}
{"requirement": "Implement a component that plays a sound and logs a message when an actor enters its volume.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"UTriggerVolumeComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTriggerVolumeComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUTriggerVolumeComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* EnterSound;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);\n};\n```", "cpp_code": "```cpp\n#include \"UTriggerVolumeComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUTriggerVolumeComponent::UTriggerVolumeComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UTriggerVolumeComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUBoxComponent* BoxComponent = Owner->FindComponentByClass<UBoxComponent>();\n\t\tif (BoxComponent)\n\t\t{\n\t\t\tBoxComponent->OnComponentBeginOverlap.AddDynamic(this, &UTriggerVolumeComponent::OnOverlapBegin);\n\t\t}\n\t}\n}\n\nvoid UTriggerVolumeComponent::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && OtherActor != OverlappedActor)\n\t{\n\t\tif (EnterSound)\n\t\t{\n\t\t\tUGameplayStatics::PlaySoundAtLocation(this, EnterSound, GetOwner()->GetActorLocation());\n\t\t}\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s has entered the trigger volume.\"), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Create an actor with a collision component that changes its speed based on overlaps.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"SpeedChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASpeedChangeActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tUBoxComponent* CollisionComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat NormalSpeed;\n\n\tUPROPERTY(EditAnywhere, Category = \"Movement\")\n\tfloat OverlappedSpeed;\n\n\tfloat CurrentSpeed;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n};\n```", "cpp_code": "```cpp\n#include \"SpeedChangeActor.h\"\n#include \"Components/BoxComponent.h\"\n\nASpeedChangeActor::ASpeedChangeActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ASpeedChangeActor::OnOverlapBegin);\n\tCollisionComponent->OnComponentEndOverlap.AddDynamic(this, &ASpeedChangeActor::OnOverlapEnd);\n\n\tNormalSpeed = 600.0f;\n\tOverlappedSpeed = 300.0f;\n\tCurrentSpeed = NormalSpeed;\n}\n\nvoid ASpeedChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASpeedChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation() + (GetActorForwardVector() * CurrentSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n\nvoid ASpeedChangeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tCurrentSpeed = OverlappedSpeed;\n\t}\n}\n\nvoid ASpeedChangeActor::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tCurrentSpeed = NormalSpeed;\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to determine the maximum size an actor can grow.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GrowableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AGrowableActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\tAGrowableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Growth\")\n\tfloat MaxGrowthSize;\n};\n```", "cpp_code": "```cpp\n#include \"GrowableActor.h\"\n\nAGrowableActor::AGrowableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMaxGrowthSize = 100.0f; // Default value\n}\n\nvoid AGrowableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AGrowableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that logs the number of frames passed each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FrameCounterActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFrameCounterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAFrameCounterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tint32 FrameCount;\n};\n```", "cpp_code": "```cpp\n#include \"FrameCounterActor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAFrameCounterActor::AFrameCounterActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tFrameCount = 0;\n}\n\n// Called when the game starts or when spawned\nvoid AFrameCounterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tFrameCount = 0;\n}\n\n// Called every frame\nvoid AFrameCounterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tFrameCount++;\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT(\"Frames passed: %d\"), FrameCount));\n\t}\n}\n```"}
{"requirement": "Implement a component that applies a gradual slowdown to an actor's movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"USlowdownComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API USlowdownComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUSlowdownComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Slowdown\")\n\tfloat SlowdownRate;\n\n\tUPROPERTY(EditAnywhere, Category = \"Slowdown\")\n\tfloat MinimumSpeed;\n\n\tFVector CurrentVelocity;\n\n\tvoid ApplySlowdown(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"USlowdownComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUSlowdownComponent::USlowdownComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n\tSlowdownRate = 100.0f;\n\tMinimumSpeed = 10.0f;\n}\n\nvoid USlowdownComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tCurrentVelocity = Owner->GetVelocity();\n\t}\n}\n\nvoid USlowdownComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tApplySlowdown(DeltaTime);\n}\n\nvoid USlowdownComponent::ApplySlowdown(float DeltaTime)\n{\n\tAActor* Owner = GetOwner();\n\tif (!Owner)\n\t{\n\t\treturn;\n\t}\n\n\tfloat Speed = CurrentVelocity.Size();\n\tif (Speed > MinimumSpeed)\n\t{\n\t\tfloat NewSpeed = FMath::Max(Speed - SlowdownRate * DeltaTime, MinimumSpeed);\n\t\tCurrentVelocity = CurrentVelocity.GetSafeNormal() * NewSpeed;\n\t\tOwner->SetActorLocation(Owner->GetActorLocation() + CurrentVelocity * DeltaTime);\n\t}\n}\n```"}
{"requirement": "Bind the 'C' key to a function that changes an actor's mesh to a second predefined mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAChangeMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ChangeMesh();\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMesh* SecondMesh;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nAChangeMeshActor::AChangeMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Assume the first mesh is already set in the editor or elsewhere\n\t// Load the second mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tSecondMesh = MeshAsset.Object;\n\t}\n}\n\nvoid AChangeMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMeshActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ChangeMesh\", IE_Pressed, this, &AChangeMeshActor::ChangeMesh);\n}\n\nvoid AChangeMeshActor::ChangeMesh()\n{\n\tif (MeshComponent && SecondMesh)\n\t{\n\t\tMeshComponent->SetStaticMesh(SecondMesh);\n\t}\n}\n```"}
{"requirement": "Create a static mesh actor that automatically rotates to face the player each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AutoRotateActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAutoRotateActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAAutoRotateActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tAActor* PlayerActor;\n};\n```", "cpp_code": "```cpp\n#include \"AutoRotateActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAAutoRotateActor::AAutoRotateActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.YourMesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid AAutoRotateActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerActor = UGameplayStatics::GetPlayerPawn(this, 0);\n}\n\nvoid AAutoRotateActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerActor)\n\t{\n\t\tFVector Direction = PlayerActor->GetActorLocation() - GetActorLocation();\n\t\tFRotator NewRotation = FRotationMatrix::MakeFromX(Direction).Rotator();\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to control the frequency of a looping sound.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SoundFrequencyController.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundFrequencyController : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundFrequencyController();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n\tfloat Frequency;\n};\n```", "cpp_code": "```cpp\n#include \"SoundFrequencyController.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundBase.h\"\n\nASoundFrequencyController::ASoundFrequencyController()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tFrequency = 440.0f; // Default frequency value\n}\n\nvoid ASoundFrequencyController::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundFrequencyController::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Here you would typically adjust the frequency of a sound component\n\t// if you had one attached to this actor.\n}\n```"}
{"requirement": "Implement an actor that reverses movement direction when it reaches a boundary.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ReversingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AReversingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAReversingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tFVector MovementDirection;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat Speed;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector BoundaryMin;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector BoundaryMax;\n\n\tvoid CheckBoundary();\n};\n```", "cpp_code": "```cpp\n#include \"ReversingActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAReversingActor::AReversingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementDirection = FVector(1.0f, 0.0f, 0.0f);\n\tSpeed = 100.0f;\n\tBoundaryMin = FVector(-500.0f, -500.0f, -500.0f);\n\tBoundaryMax = FVector(500.0f, 500.0f, 500.0f);\n}\n\nvoid AReversingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AReversingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n\tFVector NewLocation = GetActorLocation() + (MovementDirection * Speed * DeltaTime);\n\tSetActorLocation(NewLocation);\n\n\tCheckBoundary();\n}\n\nvoid AReversingActor::CheckBoundary()\n{\n\tFVector Location = GetActorLocation();\n\tbool bReversed = false;\n\n\tif (Location.X < BoundaryMin.X || Location.X > BoundaryMax.X)\n\t{\n\t\tMovementDirection.X *= -1;\n\t\tbReversed = true;\n\t}\n\tif (Location.Y < BoundaryMin.Y || Location.Y > BoundaryMax.Y)\n\t{\n\t\tMovementDirection.Y *= -1;\n\t\tbReversed = true;\n\t}\n\tif (Location.Z < BoundaryMin.Z || Location.Z > BoundaryMax.Z)\n\t{\n\t\tMovementDirection.Z *= -1;\n\t\tbReversed = true;\n\t}\n\n\tif (bReversed)\n\t{\n\t\tSetActorLocation(Location - (MovementDirection * Speed * GetWorld()->GetDeltaSeconds()));\n\t}\n}\n```"}
{"requirement": "Create a component that prints a warning when an actor's health drops below a threshold.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"HealthWarningComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UHealthWarningComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUHealthWarningComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUFUNCTION()\n\tvoid CheckHealth(float CurrentHealth);\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Health\")\n\tfloat HealthThreshold;\n};\n```", "cpp_code": "```cpp\n#include \"HealthWarningComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nUHealthWarningComponent::UHealthWarningComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tHealthThreshold = 50.0f; // Default threshold value\n}\n\nvoid UHealthWarningComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Additional initialization if needed\n}\n\nvoid UHealthWarningComponent::CheckHealth(float CurrentHealth)\n{\n\tif (CurrentHealth < HealthThreshold)\n\t{\n\t\tif (GEngine)\n\t\t{\n\t\t\tFString ActorName = GetOwner()->GetName();\n\t\t\tFString WarningMessage = FString::Printf(TEXT(\"Warning: %s's health is below the threshold!\"), *ActorName);\n\t\t\tGEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, WarningMessage);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Bind the 'D' key to a function that deletes an actor from the scene.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ADeletableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADeletableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADeletableActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid DeleteActor();\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ADeletableActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nADeletableActor::ADeletableActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ADeletableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADeletableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADeletableActor::DeleteActor()\n{\n\tDestroy();\n}\n\nvoid ADeletableActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"DeleteActor\", IE_Pressed, this, &ADeletableActor::DeleteActor);\n}\n```"}
{"requirement": "Create an actor with a UPROPERTY to control its starting scale in all directions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Scale\")\n\tFVector StartingScale;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Set default starting scale\n\tStartingScale = FVector(1.0f, 1.0f, 1.0f);\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Apply the starting scale to the actor\n\tSetActorScale3D(StartingScale);\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Implement a component that alters gravity's effect on an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"GravityModifierComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UGravityModifierComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUGravityModifierComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION(BlueprintCallable, Category=\"Gravity\")\n\tvoid SetGravityScale(float NewScale);\n\nprivate:\n\tfloat GravityScale;\n};\n```", "cpp_code": "```cpp\n#include \"GravityModifierComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUGravityModifierComponent::UGravityModifierComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tGravityScale = 1.0f; // Default gravity scale\n}\n\nvoid UGravityModifierComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UGravityModifierComponent::SetGravityScale(float NewScale)\n{\n\tGravityScale = NewScale;\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->GetWorld()->GetGravityZ() * GravityScale;\n\t}\n}\n```"}
{"requirement": "Load a skeletal mesh asset using ConstructorHelpers and apply it to an actor in the constructor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ASkeletalMeshActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AASkeletalMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAASkeletalMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUSkeletalMeshComponent* SkeletalMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ASkeletalMeshActor.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAASkeletalMeshActor::AASkeletalMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n\tRootComponent = SkeletalMeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<USkeletalMesh> SkeletalMeshAsset(TEXT(\"/Game/Path/To/Your/SkeletalMesh.SkeletalMesh\"));\n\tif (SkeletalMeshAsset.Succeeded())\n\t{\n\t\tSkeletalMeshComponent->SetSkeletalMesh(SkeletalMeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AASkeletalMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AASkeletalMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Create an actor that changes its position based on a sine wave function each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SineWaveMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASineWaveMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASineWaveMover();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector InitialPosition;\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Amplitude;\n\tUPROPERTY(EditAnywhere, Category=\"Sine Wave\")\n\tfloat Frequency;\n};\n```", "cpp_code": "```cpp\n#include \"SineWaveMover.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nASineWaveMover::ASineWaveMover()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAmplitude = 100.0f;\n\tFrequency = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASineWaveMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialPosition = GetActorLocation();\n}\n\n// Called every frame\nvoid ASineWaveMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat Time = GetWorld()->GetTimeSeconds();\n\tfloat SineValue = FMath::Sin(Frequency * Time);\n\tFVector NewPosition = InitialPosition;\n\tNewPosition.Z += Amplitude * SineValue;\n\n\tSetActorLocation(NewPosition);\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to define a delay before an actor becomes active.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Activation\")\n\tfloat ActivationDelay;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tActivationDelay = 5.0f; // Default Delay\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t// Logic to handle the delay before activation can be added here\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t// Actor tick logic\n}\n```"}
{"requirement": "Implement an actor that plays a particle effect when its health reaches zero.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"HealthBasedParticleActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AHealthBasedParticleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAHealthBasedParticleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Health\")\n\tfloat Health;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Effects\")\n\tUParticleSystem* DeathParticleEffect;\n\n\tUFUNCTION()\n\tvoid OnHealthChanged();\n};\n```", "cpp_code": "```cpp\n#include \"HealthBasedParticleActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAHealthBasedParticleActor::AHealthBasedParticleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHealth = 100.0f; // Default health value\n}\n\nvoid AHealthBasedParticleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHealthBasedParticleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tOnHealthChanged();\n}\n\nvoid AHealthBasedParticleActor::OnHealthChanged()\n{\n\tif (Health <= 0.0f && DeathParticleEffect)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), DeathParticleEffect, GetActorLocation(), FRotator::ZeroRotator, true);\n\t\t// Optionally destroy the actor if needed\n\t\t// Destroy();\n\t}\n}\n```"}
{"requirement": "Create a component that logs the time every time an actor is clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UTimeLoggerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTimeLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUTimeLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION()\n\tvoid OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n};\n```", "cpp_code": "```cpp\n#include \"UTimeLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Public/TimerManager.h\"\n#include \"GameFramework/PlayerController.h\"\n\nUTimeLoggerComponent::UTimeLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UTimeLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tOwner->OnClicked.AddDynamic(this, &UTimeLoggerComponent::OnClicked);\n\t}\n}\n\nvoid UTimeLoggerComponent::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tFDateTime CurrentTime = FDateTime::Now();\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor clicked at: %s\"), *CurrentTime.ToString());\n}\n```"}
{"requirement": "Bind the 'U' key to a function that unlocks additional speed for an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UnlockSpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AUnlockSpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAUnlockSpeedActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to unlock additional speed\n\tUFUNCTION()\n\tvoid UnlockSpeed();\n\n\t// Speed variables\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Speed\")\n\tfloat NormalSpeed;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Speed\")\n\tfloat UnlockedSpeed;\n\nprivate:\n\t// Input binding\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n};\n```", "cpp_code": "```cpp\n#include \"UnlockSpeedActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAUnlockSpeedActor::AUnlockSpeedActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize speed variables\n\tNormalSpeed = 600.0f;\n\tUnlockedSpeed = 1200.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AUnlockSpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AUnlockSpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to unlock additional speed\nvoid AUnlockSpeedActor::UnlockSpeed()\n{\n\t// Logic to unlock speed\n\t// This can be setting a speed variable or modifying a character movement component's speed\n\tUE_LOG(LogTemp, Warning, TEXT(\"Speed Unlocked!\"));\n\t// Example: CharacterMovement->MaxWalkSpeed = UnlockedSpeed;\n}\n\n// Setup input bindings\nvoid AUnlockSpeedActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (PlayerInputComponent)\n\t{\n\t\tPlayerInputComponent->BindAction(\"UnlockSpeed\", IE_Pressed, this, &AUnlockSpeedActor::UnlockSpeed);\n\t}\n}\n```"}
{"requirement": "Create an actor with a collision component that prints its bounds size on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"CollisionBoundsActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionBoundsActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionBoundsActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* CollisionComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionBoundsActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nACollisionBoundsActor::ACollisionBoundsActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach the collision component\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\n\t// Register the overlap event\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionBoundsActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionBoundsActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionBoundsActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACollisionBoundsActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (GEngine)\n\t{\n\t\t// Get the bounds of the collision component\n\t\tFVector BoundsExtent = CollisionComponent->Bounds.BoxExtent;\n\t\tFString BoundsSize = FString::Printf(TEXT(\"Bounds Size: X=%.2f, Y=%.2f, Z=%.2f\"), BoundsExtent.X, BoundsExtent.Y, BoundsExtent.Z);\n\n\t\t// Print the bounds size to the screen\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, BoundsSize);\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY editable in Blueprint to control an actor's jump strength.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyJumpingActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyJumpingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyJumpingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Jump\")\n\tfloat JumpStrength;\n};\n```", "cpp_code": "```cpp\n#include \"MyJumpingActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAMyJumpingActor::AMyJumpingActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tJumpStrength = 600.0f; // Default jump strength\n}\n\n// Called when the game starts or when spawned\nvoid AMyJumpingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AMyJumpingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Implement an actor that scales down when it overlaps a specific type of actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass ASimpleScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASimpleScalingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tfloat ScaleFactor;\n\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tTSubclassOf<AActor> SpecificActorClass;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASimpleScalingActor::ASimpleScalingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tMeshComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &ASimpleScalingActor::OnOverlapBegin);\n\n\tScaleFactor = 0.5f; // Example scale factor\n}\n\n// Called when the game starts or when spawned\nvoid ASimpleScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASimpleScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASimpleScalingActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && OtherActor->IsA(SpecificActorClass))\n\t{\n\t\tFVector NewScale = GetActorScale3D() * ScaleFactor;\n\t\tSetActorScale3D(NewScale);\n\t}\n}\n```"}
{"requirement": "Create a component that changes the owner's rotation to face another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UFaceActorComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API UFaceActorComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUFaceActorComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void FaceActor(AActor* TargetActor);\n};\n```", "cpp_code": "```cpp\n#include \"UFaceActorComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUFaceActorComponent::UFaceActorComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UFaceActorComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UFaceActorComponent::FaceActor(AActor* TargetActor)\n{\n\tif (TargetActor && GetOwner())\n\t{\n\t\tFVector TargetLocation = TargetActor->GetActorLocation();\n\t\tFVector OwnerLocation = GetOwner()->GetActorLocation();\n\t\tFRotator NewRotation = (TargetLocation - OwnerLocation).Rotation();\n\t\tGetOwner()->SetActorRotation(NewRotation);\n\t}\n}\n```"}
{"requirement": "Bind the 'Y' key to a function that toggles a Boolean property in the actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ToggleBoolean();\n\n\tUPROPERTY()\n\tbool bIsToggled;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleActor.h\"\n#include \"Components/InputComponent.h\"\n\nAToggleActor::AToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsToggled = false;\n}\n\nvoid AToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ToggleBoolean\", IE_Pressed, this, &AToggleActor::ToggleBoolean);\n}\n\nvoid AToggleActor::ToggleBoolean()\n{\n\tbIsToggled = !bIsToggled;\n}\n```"}
{"requirement": "Create an actor that moves randomly within a defined area each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARandomMover();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector GetRandomLocation() const;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tFVector MovementArea;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RandomMover.h\"\n#include \"Engine/World.h\"\n#include \"Math/UnrealMathUtility.h\"\n\n// Sets default values\nARandomMover::ARandomMover()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementArea = FVector(1000.0f, 1000.0f, 1000.0f);\n\tMovementSpeed = 200.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ARandomMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARandomMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetRandomLocation();\n\tFVector CurrentLocation = GetActorLocation();\n\tFVector Direction = (NewLocation - CurrentLocation).GetSafeNormal();\n\n\tSetActorLocation(CurrentLocation + Direction * MovementSpeed * DeltaTime);\n}\n\nFVector ARandomMover::GetRandomLocation() const\n{\n\tfloat RandomX = FMath::FRandRange(-MovementArea.X, MovementArea.X);\n\tfloat RandomY = FMath::FRandRange(-MovementArea.Y, MovementArea.Y);\n\tfloat RandomZ = FMath::FRandRange(-MovementArea.Z, MovementArea.Z);\n\n\treturn FVector(RandomX, RandomY, RandomZ);\n}\n```"}
{"requirement": "Add a UPROPERTY with metadata to specify units for a numeric value in Blueprint.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UnitSpecifierActor.generated.h\"\n\nUCLASS()\nclass AUnitSpecifierActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAUnitSpecifierActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (Units = \"cm\"))\n\tfloat DistanceInCentimeters;\n};\n```", "cpp_code": "```cpp\n#include \"UnitSpecifierActor.h\"\n\n// Sets default values\nAUnitSpecifierActor::AUnitSpecifierActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tDistanceInCentimeters = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AUnitSpecifierActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AUnitSpecifierActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t\n}\n```"}
{"requirement": "Implement a component that logs which actor overlapped with it.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULoggingOverlapComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULoggingOverlapComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tULoggingOverlapComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION()\n\tvoid OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor);\n};\n```", "cpp_code": "```cpp\n#include \"ULoggingOverlapComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nULoggingOverlapComponent::ULoggingOverlapComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid ULoggingOverlapComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->OnActorBeginOverlap.AddDynamic(this, &ULoggingOverlapComponent::OnOverlapBegin);\n\t}\n}\n\nvoid ULoggingOverlapComponent::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor && OtherActor != GetOwner())\n\t{\n\t\tUE_LOG(LogTemp, Log, TEXT(\"%s overlapped with %s\"), *GetOwner()->GetName(), *OtherActor->GetName());\n\t}\n}\n```"}
{"requirement": "Create an actor with a UPROPERTY to set a color that changes on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAColorChangeActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Color\")\n\tFLinearColor Color;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"ConstructorHelpers.h\"\n\nAColorChangeActor::AColorChangeActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tUBoxComponent* BoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n\tBoxComponent->SetupAttachment(RootComponent);\n\tBoxComponent->SetBoxExtent(FVector(50.f));\n\tBoxComponent->OnComponentBeginOverlap.AddDynamic(this, &AColorChangeActor::OnOverlapBegin);\n\n\tColor = FLinearColor::Red;\n}\n\nvoid AColorChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AColorChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AColorChangeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (OtherActor && (OtherActor != this) && OtherComp)\n\t{\n\t\tColor = FLinearColor::MakeRandomColor();\n\t\tMeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"BaseColor\"), FVector(Color));\n\t}\n}\n```"}
{"requirement": "Bind the 'K' key to a function that halves an actor's current health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HalveHealthActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHalveHealthActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAHalveHealthActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid HalveHealth();\n\n\tUPROPERTY(EditAnywhere)\n\tfloat CurrentHealth;\n};\n```", "cpp_code": "```cpp\n#include \"HalveHealthActor.h\"\n#include \"Components/InputComponent.h\"\n\nAHalveHealthActor::AHalveHealthActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tCurrentHealth = 100.0f; // Default health value\n}\n\nvoid AHalveHealthActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AHalveHealthActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHalveHealthActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"HalveHealth\", IE_Pressed, this, &AHalveHealthActor::HalveHealth);\n}\n\nvoid AHalveHealthActor::HalveHealth()\n{\n\tCurrentHealth *= 0.5f;\n\tUE_LOG(LogTemp, Warning, TEXT(\"New Health: %f\"), CurrentHealth);\n}\n```"}
{"requirement": "Create a component that prints the angle between its owner and another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UAnglePrinterComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UAnglePrinterComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUAnglePrinterComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void PrintAngleWithActor(AActor* OtherActor);\n};\n```", "cpp_code": "```cpp\n#include \"UAnglePrinterComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nUAnglePrinterComponent::UAnglePrinterComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UAnglePrinterComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UAnglePrinterComponent::PrintAngleWithActor(AActor* OtherActor)\n{\n\tif (!OtherActor)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"OtherActor is null\"));\n\t\treturn;\n\t}\n\n\tAActor* Owner = GetOwner();\n\tif (!Owner)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Owner is null\"));\n\t\treturn;\n\t}\n\n\tFVector OwnerLocation = Owner->GetActorLocation();\n\tFVector OtherActorLocation = OtherActor->GetActorLocation();\n\n\tFVector DirectionToOther = (OtherActorLocation - OwnerLocation).GetSafeNormal();\n\tFVector ForwardVector = Owner->GetActorForwardVector();\n\n\tfloat DotProduct = FVector::DotProduct(ForwardVector, DirectionToOther);\n\tfloat AngleInRadians = FMath::Acos(DotProduct);\n\tfloat AngleInDegrees = FMath::RadiansToDegrees(AngleInRadians);\n\n\tUE_LOG(LogTemp, Log, TEXT(\"Angle between %s and %s: %f degrees\"), *Owner->GetName(), *OtherActor->GetName(), AngleInDegrees);\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to control an actor's rotation speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotationSpeedActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotationSpeedActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotationSpeedActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotationSpeedActor.h\"\n\nARotationSpeedActor::ARotationSpeedActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tRotationSpeed = 45.0f; // Default rotation speed\n}\n\nvoid ARotationSpeedActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotationSpeedActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement an actor that changes its Z position to simulate jumping each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"JumpingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AJumpingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAJumpingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The speed of the jump\n\tUPROPERTY(EditAnywhere)\n\tfloat JumpSpeed;\n\n\t// The maximum height of the jump\n\tUPROPERTY(EditAnywhere)\n\tfloat MaxJumpHeight;\n\n\t// Original Z position\n\tfloat OriginalZ;\n\n\t// Direction of movement (1 for up, -1 for down)\n\tint32 Direction;\n};\n```", "cpp_code": "```cpp\n#include \"JumpingActor.h\"\n\n// Sets default values\nAJumpingActor::AJumpingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tJumpSpeed = 100.0f;\n\tMaxJumpHeight = 300.0f;\n\tDirection = 1;\n}\n\n// Called when the game starts or when spawned\nvoid AJumpingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tOriginalZ = GetActorLocation().Z;\n}\n\n// Called every frame\nvoid AJumpingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = GetActorLocation();\n\tNewLocation.Z += JumpSpeed * DeltaTime * Direction;\n\n\t// Check if we've reached the max height or returned to the original position\n\tif (Direction == 1 && NewLocation.Z >= OriginalZ + MaxJumpHeight)\n\t{\n\t\tDirection = -1;\n\t}\n\telse if (Direction == -1 && NewLocation.Z <= OriginalZ)\n\t{\n\t\tDirection = 1;\n\t\tNewLocation.Z = OriginalZ; // Reset to original Z to avoid floating point precision issues\n\t}\n\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that plays a different sound based on which key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundPlayerActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASoundPlayerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASoundPlayerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundCueA;\n\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundCueB;\n\n\tUFUNCTION()\n\tvoid PlaySoundA();\n\n\tUFUNCTION()\n\tvoid PlaySoundB();\n};\n```", "cpp_code": "```cpp\n#include \"SoundPlayerActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nASoundPlayerActor::ASoundPlayerActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ASoundPlayerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASoundPlayerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"PlaySoundA\", IE_Pressed, this, &ASoundPlayerActor::PlaySoundA);\n\tPlayerInputComponent->BindAction(\"PlaySoundB\", IE_Pressed, this, &ASoundPlayerActor::PlaySoundB);\n}\n\nvoid ASoundPlayerActor::PlaySoundA()\n{\n\tif (SoundCueA)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundCueA, GetActorLocation());\n\t}\n}\n\nvoid ASoundPlayerActor::PlaySoundB()\n{\n\tif (SoundCueB)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundCueB, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Bind the 'H' key to a function that hides and unhides all actors in a scene.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HideActorsManager.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHideActorsManager : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHideActorsManager();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to toggle visibility of all actors\n\tvoid ToggleActorsVisibility();\n\n\t// Bind input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n\nprivate:\n\tbool bAreActorsHidden;\n};\n```", "cpp_code": "```cpp\n#include \"HideActorsManager.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAHideActorsManager::AHideActorsManager()\n{\n\t// Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tbAreActorsHidden = false;\n}\n\n// Called when the game starts or when spawned\nvoid AHideActorsManager::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AHideActorsManager::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHideActorsManager::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AHideActorsManager::ToggleActorsVisibility);\n}\n\nvoid AHideActorsManager::ToggleActorsVisibility()\n{\n\tUWorld* World = GetWorld();\n\tif (World)\n\t{\n\t\tfor (TActorIterator<AActor> ActorItr(World); ActorItr; ++ActorItr)\n\t\t{\n\t\t\tAActor* Actor = *ActorItr;\n\t\t\tif (Actor && Actor != this) // Ensure we don't hide ourselves\n\t\t\t{\n\t\t\t\tActor->SetActorHiddenInGame(!bAreActorsHidden);\n\t\t\t}\n\t\t}\n\t\tbAreActorsHidden = !bAreActorsHidden;\n\t}\n}\n```"}
{"requirement": "Create a component that applies a random rotation to an actor on BeginPlay.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"URandomRotationComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API URandomRotationComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this component's properties\n\tURandomRotationComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"URandomRotationComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nURandomRotationComponent::URandomRotationComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid URandomRotationComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tFRotator RandomRotation = FRotator(FMath::FRand() * 360.0f, FMath::FRand() * 360.0f, FMath::FRand() * 360.0f);\n\tGetOwner()->SetActorRotation(RandomRotation);\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to set an actor's maximum health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat MaxHealth;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMaxHealth = 100.0f; // Default max health value\n}\n```"}
{"requirement": "Implement an actor that resets its location to a random point when the 'N' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomLocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomLocationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARandomLocationActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to reset location\n\tvoid ResetLocation();\n\n\t// Setup player input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tFVector MinBounds;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector MaxBounds;\n};\n```", "cpp_code": "```cpp\n#include \"RandomLocationActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nARandomLocationActor::ARandomLocationActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMinBounds = FVector(-1000.0f, -1000.0f, 0.0f);\n\tMaxBounds = FVector(1000.0f, 1000.0f, 1000.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ARandomLocationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARandomLocationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Reset location to a random point\nvoid ARandomLocationActor::ResetLocation()\n{\n\tFVector NewLocation;\n\tNewLocation.X = FMath::FRandRange(MinBounds.X, MaxBounds.X);\n\tNewLocation.Y = FMath::FRandRange(MinBounds.Y, MaxBounds.Y);\n\tNewLocation.Z = FMath::FRandRange(MinBounds.Z, MaxBounds.Z);\n\tSetActorLocation(NewLocation);\n}\n\n// Setup player input\nvoid ARandomLocationActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetLocation\", IE_Pressed, this, &ARandomLocationActor::ResetLocation);\n}\n\n// In your project settings, make sure to map the \"ResetLocation\" action to the 'N' key.\n```"}
{"requirement": "Create a static mesh actor with a UPROPERTY to swap between two meshes dynamically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SwapMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASwapMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASwapMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category = \"Mesh\")\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category = \"Mesh\")\n\tUStaticMesh* Mesh1;\n\n\tUPROPERTY(EditAnywhere, Category = \"Mesh\")\n\tUStaticMesh* Mesh2;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Mesh\")\n\tvoid SwapMesh();\n};\n```", "cpp_code": "```cpp\n#include \"SwapMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nASwapMeshActor::ASwapMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Assuming you have two meshes in your project at the specified paths\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> Mesh1Asset(TEXT(\"/Game/Path/To/Your/Mesh1.Mesh1\"));\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> Mesh2Asset(TEXT(\"/Game/Path/To/Your/Mesh2.Mesh2\"));\n\n\tif (Mesh1Asset.Succeeded())\n\t{\n\t\tMesh1 = Mesh1Asset.Object;\n\t}\n\n\tif (Mesh2Asset.Succeeded())\n\t{\n\t\tMesh2 = Mesh2Asset.Object;\n\t}\n\n\t// Set the initial mesh\n\tif (Mesh1)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh1);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ASwapMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASwapMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASwapMeshActor::SwapMesh()\n{\n\tif (MeshComponent->GetStaticMesh() == Mesh1)\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh2);\n\t}\n\telse\n\t{\n\t\tMeshComponent->SetStaticMesh(Mesh1);\n\t}\n}\n```"}
{"requirement": "Bind the 'E' key to increase an actor's movement speed temporarily.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedBoostActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASpeedBoostActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpeedBoostActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Setup player input component\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Function to handle speed boost\n\tvoid BoostSpeed();\n\n\t// Timer handle for resetting speed\n\tFTimerHandle SpeedBoostTimerHandle;\n\n\t// Function to reset speed\n\tvoid ResetSpeed();\n\n\t// Movement speed\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat MovementSpeed;\n\n\t// Boosted speed\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat BoostedSpeed;\n\n\t// Duration of the speed boost\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n\tfloat BoostDuration;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedBoostActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nASpeedBoostActor::ASpeedBoostActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMovementSpeed = 600.0f;\n\tBoostedSpeed = 1200.0f;\n\tBoostDuration = 5.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASpeedBoostActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpeedBoostActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid ASpeedBoostActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"BoostSpeed\", IE_Pressed, this, &ASpeedBoostActor::BoostSpeed);\n}\n\n// Handle speed boost\nvoid ASpeedBoostActor::BoostSpeed()\n{\n\tGetCharacterMovement()->MaxWalkSpeed = BoostedSpeed;\n\tGetWorld()->GetTimerManager().SetTimer(SpeedBoostTimerHandle, this, &ASpeedBoostActor::ResetSpeed, BoostDuration, false);\n}\n\n// Reset speed to normal\nvoid ASpeedBoostActor::ResetSpeed()\n{\n\tGetCharacterMovement()->MaxWalkSpeed = MovementSpeed;\n}\n```"}
{"requirement": "Create an actor with a collision component that changes its material on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"CollisionChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACollisionChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUBoxComponent* CollisionComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* InitialMaterial;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* OverlapMaterial;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionChangeActor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nACollisionChangeActor::ACollisionChangeActor()\n{\n\t// Initialize the mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Find and set a default mesh (assuming a cube is in the engine content)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh>MeshAsset(TEXT(\"/Engine/BasicShapes/Cube.Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Initialize the collision component\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tCollisionComponent->SetupAttachment(RootComponent);\n\tCollisionComponent->SetBoxExtent(FVector(50.f, 50.f, 50.f));\n\tCollisionComponent->SetCollisionProfileName(\"Trigger\");\n\n\t// Bind the overlap event\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollisionChangeActor::OnOverlapBegin);\n\n\t// Set default materials\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> InitialMat(TEXT(\"/Game/Materials/InitialMaterial.InitialMaterial\"));\n\tif (InitialMat.Succeeded())\n\t{\n\t\tInitialMaterial = InitialMat.Object;\n\t\tMeshComponent->SetMaterial(0, InitialMaterial);\n\t}\n\n\tstatic ConstructorHelpers::FObjectFinder<UMaterialInterface> OverlapMat(TEXT(\"/Game/Materials/OverlapMaterial.OverlapMaterial\"));\n\tif (OverlapMat.Succeeded())\n\t{\n\t\tOverlapMaterial = OverlapMat.Object;\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionChangeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OverlapMaterial)\n\t{\n\t\tMeshComponent->SetMaterial(0, OverlapMaterial);\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to adjust an actor's health regeneration rate.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tAMyActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n\tfloat HealthRegenRate;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\nAMyActor::AMyActor()\n{\n\t// Set default health regeneration rate\n\tHealthRegenRate = 1.0f;\n}\n```"}
{"requirement": "Implement a component that logs every time an actor receives damage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UDamageLoggerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UDamageLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUDamageLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUFUNCTION()\n\tvoid OnTakeAnyDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy, AActor* DamageCauser);\n};\n```", "cpp_code": "```cpp\n#include \"UDamageLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUDamageLoggerComponent::UDamageLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UDamageLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->OnTakeAnyDamage.AddDynamic(this, &UDamageLoggerComponent::OnTakeAnyDamage);\n\t}\n}\n\nvoid UDamageLoggerComponent::OnTakeAnyDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, AController* InstigatedBy, AActor* DamageCauser)\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"%s received %f damage from %s\"), *DamagedActor->GetName(), Damage, *DamageCauser->GetName());\n}\n```"}
{"requirement": "Create a static mesh actor that follows another actor each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"StaticMeshActorFollower.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AStaticMeshActorFollower : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAStaticMeshActorFollower();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Static Mesh Component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\t// Actor to follow\n\tUPROPERTY(EditAnywhere)\n\tAActor* ActorToFollow;\n};\n```", "cpp_code": "```cpp\n#include \"StaticMeshActorFollower.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAStaticMeshActorFollower::AStaticMeshActorFollower()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Mesh Component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set static mesh (assuming the mesh is located in the StarterContent package)\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AStaticMeshActorFollower::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AStaticMeshActorFollower::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (ActorToFollow)\n\t{\n\t\tFVector TargetLocation = ActorToFollow->GetActorLocation();\n\t\tSetActorLocation(TargetLocation);\n\t}\n}\n```"}
{"requirement": "Bind the 'W' key to a function that spawns a projectile at an actor's location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/ProjectileMovementComponent.h\"\n#include \"ProjectileSpawner.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AProjectileSpawner : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAProjectileSpawner();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid SpawnProjectile();\n\n\tUPROPERTY(EditAnywhere)\n\tTSubclassOf<AActor> ProjectileClass;\n};\n```", "cpp_code": "```cpp\n#include \"ProjectileSpawner.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAProjectileSpawner::AProjectileSpawner()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AProjectileSpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AProjectileSpawner::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AProjectileSpawner::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"SpawnProjectile\", IE_Pressed, this, &AProjectileSpawner::SpawnProjectile);\n}\n\nvoid AProjectileSpawner::SpawnProjectile()\n{\n\tif (ProjectileClass)\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tSpawnParams.Owner = this;\n\t\tSpawnParams.Instigator = GetInstigator();\n\n\t\tFVector Location = GetActorLocation();\n\t\tFRotator Rotation = GetActorRotation();\n\n\t\tGetWorld()->SpawnActor<AActor>(ProjectileClass, Location, Rotation, SpawnParams);\n\t}\n}\n```"}
{"requirement": "Create an actor with a UPROPERTY to toggle between two movement states.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleMovementActor.generated.h\"\n\nUENUM(BlueprintType)\nenum class EMovementState : uint8\n{\n\tWalking UMETA(DisplayName = \"Walking\"),\n\tRunning UMETA(DisplayName = \"Running\")\n};\n\nUCLASS()\nclass YOURPROJECT_API AToggleMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAToggleMovementActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Movement\")\n\tEMovementState MovementState;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleMovementActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAToggleMovementActor::AToggleMovementActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementState = EMovementState::Walking;\n}\n\nvoid AToggleMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tswitch (MovementState)\n\t{\n\tcase EMovementState::Walking:\n\t\t// Handle Walking state\n\t\tbreak;\n\tcase EMovementState::Running:\n\t\t// Handle Running state\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to determine how often an actor should change direction.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAYourActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat DirectionChangeInterval;\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tDirectionChangeInterval = 5.0f; // Default interval in seconds\n}\n\nvoid AYourActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AYourActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\t// Add logic for changing direction based on DirectionChangeInterval\n}\n```"}
{"requirement": "Implement an actor that changes its material when the 'T' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialChangerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAMaterialChangerActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ChangeMaterial();\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* Material1;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* Material2;\n\n\tbool bUsingMaterial1;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAMaterialChangerActor::AMaterialChangerActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/Path/To/Your/Mesh.Mesh\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tbUsingMaterial1 = true;\n}\n\nvoid AMaterialChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (Material1)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n}\n\nvoid AMaterialChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMaterialChangerActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AMaterialChangerActor::ChangeMaterial);\n}\n\nvoid AMaterialChangerActor::ChangeMaterial()\n{\n\tif (bUsingMaterial1 && Material2)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material2);\n\t}\n\telse if (!bUsingMaterial1 && Material1)\n\t{\n\t\tMeshComponent->SetMaterial(0, Material1);\n\t}\n\tbUsingMaterial1 = !bUsingMaterial1;\n}\n```"}
{"requirement": "Create a component that applies a linear impulse to an actor on BeginPlay.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UImpulseComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UImpulseComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUImpulseComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Impulse\")\n\tFVector Impulse;\n};\n```", "cpp_code": "```cpp\n#include \"UImpulseComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nUImpulseComponent::UImpulseComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tImpulse = FVector(1000.0f, 0.0f, 0.0f);  // Default impulse\n}\n\nvoid UImpulseComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tUPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(Owner->GetRootComponent());\n\t\tif (PrimitiveComponent && PrimitiveComponent->IsSimulatingPhysics())\n\t\t{\n\t\t\tPrimitiveComponent->AddImpulse(Impulse);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Bind the 'S' key to a function that stops all actor movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"StopMovementPawn.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AStopMovementPawn : public APawn\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this pawn's properties\n\tAStopMovementPawn();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Function to stop all actor movement\n\tvoid StopAllMovement();\n};\n```", "cpp_code": "```cpp\n#include \"StopMovementPawn.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAStopMovementPawn::AStopMovementPawn()\n{\n\t// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AStopMovementPawn::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called to bind functionality to input\nvoid AStopMovementPawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the StopAllMovement function to the 'S' key\n\tPlayerInputComponent->BindAction(\"StopMovement\", IE_Pressed, this, &AStopMovementPawn::StopAllMovement);\n}\n\n// Function to stop all actor movement\nvoid AStopMovementPawn::StopAllMovement()\n{\n\tTArray<AActor*> AllActors;\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), AActor::StaticClass(), AllActors);\n\n\tfor (AActor* Actor : AllActors)\n\t{\n\t\tif (Actor)\n\t\t{\n\t\t\tActor->SetActorLocation(Actor->GetActorLocation());\n\t\t\tActor->GetRootComponent()->ComponentVelocity = FVector::ZeroVector;\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that rotates twice as fast when overlapping another specific actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARotatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed;\n\n\tUPROPERTY(EditAnywhere)\n\tAActor* SpecificActor;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor);\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(AActor* OverlappedActor, AActor* OtherActor);\n\n\tUPROPERTY()\n\tbool bIsOverlapping;\n\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(VisibleAnywhere)\n\tclass USphereComponent* OverlapComponent;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/SphereComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/Engine.h\"\n\nARotatingActor::ARotatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tOverlapComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"OverlapComponent\"));\n\tOverlapComponent->SetupAttachment(RootComponent);\n\tOverlapComponent->SetSphereRadius(100.0f);\n\tOverlapComponent->OnComponentBeginOverlap.AddDynamic(this, &ARotatingActor::OnOverlapBegin);\n\tOverlapComponent->OnComponentEndOverlap.AddDynamic(this, &ARotatingActor::OnOverlapEnd);\n\n\tRotationSpeed = 45.0f;\n\tbIsOverlapping = false;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tfloat CurrentRotationSpeed = bIsOverlapping ? RotationSpeed * 2 : RotationSpeed;\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += CurrentRotationSpeed * DeltaTime;\n\tSetActorRotation(NewRotation);\n}\n\nvoid ARotatingActor::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor == SpecificActor)\n\t{\n\t\tbIsOverlapping = true;\n\t}\n}\n\nvoid ARotatingActor::OnOverlapEnd(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OtherActor == SpecificActor)\n\t{\n\t\tbIsOverlapping = false;\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with metadata to describe a float value as a percentage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PercentageActor.generated.h\"\n\nUCLASS()\nclass APercentageActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPercentageActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ClampMin = \"0.0\", ClampMax = \"100.0\", UIMin = \"0.0\", UIMax = \"100.0\", ToolTip = \"Value represented as a percentage\"))\n\tfloat PercentageValue;\n};\n```", "cpp_code": "```cpp\n#include \"PercentageActor.h\"\n\nAPercentageActor::APercentageActor()\n{\n\tPercentageValue = 0.0f;\n}\n```"}
{"requirement": "Implement a component that prints a log message when an actor is destroyed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"UDestructionLoggerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UDestructionLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tUDestructionLoggerComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called when the component is destroyed\n\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n};\n```", "cpp_code": "```cpp\n#include \"UDestructionLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/Engine.h\"\n\nUDestructionLoggerComponent::UDestructionLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid UDestructionLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UDestructionLoggerComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\tif (EndPlayReason == EEndPlayReason::Destroyed)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Actor %s has been destroyed.\"), *GetOwner()->GetName());\n\t}\n}\n```"}
{"requirement": "Create an actor that shrinks and disappears when it reaches a certain scale.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ShrinkingActor.generated.h\"\n\nUCLASS()\nclass AShrinkingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAShrinkingActor();\n\nprotected:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat ShrinkRate;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MinScaleBeforeDisappear;\n};\n```", "cpp_code": "```cpp\n#include \"ShrinkingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAShrinkingActor::AShrinkingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tShrinkRate = 0.1f;\n\tMinScaleBeforeDisappear = 0.1f;\n}\n\nvoid AShrinkingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector CurrentScale = GetActorScale3D();\n\tCurrentScale -= FVector(ShrinkRate * DeltaTime);\n\n\tif (CurrentScale.X <= MinScaleBeforeDisappear || CurrentScale.Y <= MinScaleBeforeDisappear || CurrentScale.Z <= MinScaleBeforeDisappear)\n\t{\n\t\tDestroy();\n\t}\n\telse\n\t{\n\t\tSetActorScale3D(CurrentScale);\n\t}\n}\n```"}
{"requirement": "Bind the 'G' key to a function that grows an actor's mesh by a set factor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GrowMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AGrowMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAGrowMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUFUNCTION()\n\tvoid GrowMesh();\n\n\tUPROPERTY(EditAnywhere, Category = \"Growth\")\n\tfloat GrowthFactor;\n};\n```", "cpp_code": "```cpp\n#include \"GrowMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"Components/InputComponent.h\"\n\nAGrowMeshActor::AGrowMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tGrowthFactor = 1.1f; // Default growth factor\n}\n\nvoid AGrowMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AGrowMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AGrowMeshActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"GrowMesh\", IE_Pressed, this, &AGrowMeshActor::GrowMesh);\n}\n\nvoid AGrowMeshActor::GrowMesh()\n{\n\tFVector NewScale = MeshComponent->GetComponentScale() * GrowthFactor;\n\tMeshComponent->SetWorldScale3D(NewScale);\n}\n```"}
{"requirement": "Create an actor with a collision component that plays a sound when an overlap ends.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"Components/BoxComponent.h\"\n#include \"CollisionSoundActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionSoundActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tACollisionSoundActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n\tUBoxComponent* CollisionComponent;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Sound\")\n\tUSoundBase* OverlapEndSound;\n\n\tUFUNCTION()\n\tvoid OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n};\n```", "cpp_code": "```cpp\n#include \"CollisionSoundActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nACollisionSoundActor::ACollisionSoundActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tCollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\tCollisionComponent->SetCollisionProfileName(TEXT(\"Trigger\"));\n\tCollisionComponent->OnComponentEndOverlap.AddDynamic(this, &ACollisionSoundActor::OnOverlapEnd);\n}\n\nvoid ACollisionSoundActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ACollisionSoundActor::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tif (OverlapEndSound)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, OverlapEndSound, GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to set a delay before an actor's action executes.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Action\")\n\tfloat ActionDelay;\n\n\tUFUNCTION()\n\tvoid ExecuteAction();\n\nprivate:\n\tFTimerHandle ActionTimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"TimerManager.h\"\n\nAMyActor::AMyActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tActionDelay = 0.0f;\n}\n\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGetWorldTimerManager().SetTimer(ActionTimerHandle, this, &AMyActor::ExecuteAction, ActionDelay, false);\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyActor::ExecuteAction()\n{\n\t// Action logic here\n}\n```"}
{"requirement": "Implement a component that adjusts an actor's scale based on time of day.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"TimeOfDayScaleComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UTimeOfDayScaleComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUTimeOfDayScaleComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tvoid AdjustScaleBasedOnTimeOfDay();\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector MorningScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector NoonScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector EveningScale;\n\n\tUPROPERTY(EditAnywhere, Category=\"Scale\")\n\tFVector NightScale;\n};\n```", "cpp_code": "```cpp\n#include \"TimeOfDayScaleComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\nUTimeOfDayScaleComponent::UTimeOfDayScaleComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\t\n\tMorningScale = FVector(1.0f, 1.0f, 1.0f);\n\tNoonScale = FVector(1.5f, 1.5f, 1.5f);\n\tEveningScale = FVector(1.2f, 1.2f, 1.2f);\n\tNightScale = FVector(0.8f, 0.8f, 0.8f);\n}\n\nvoid UTimeOfDayScaleComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tAdjustScaleBasedOnTimeOfDay();\n}\n\nvoid UTimeOfDayScaleComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\tAdjustScaleBasedOnTimeOfDay();\n}\n\nvoid UTimeOfDayScaleComponent::AdjustScaleBasedOnTimeOfDay()\n{\n\tif (!GetOwner())\n\t{\n\t\treturn;\n\t}\n\n\tFDateTime CurrentTime = FDateTime::Now();\n\tint32 Hour = CurrentTime.GetHour();\n\n\tFVector NewScale;\n\n\tif (Hour >= 6 && Hour < 12)\n\t{\n\t\tNewScale = MorningScale;\n\t}\n\telse if (Hour >= 12 && Hour < 18)\n\t{\n\t\tNewScale = NoonScale;\n\t}\n\telse if (Hour >= 18 && Hour < 21)\n\t{\n\t\tNewScale = EveningScale;\n\t}\n\telse\n\t{\n\t\tNewScale = NightScale;\n\t}\n\n\tGetOwner()->SetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Create an actor that duplicates itself when the 'V' key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SelfDuplicatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASelfDuplicatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tASelfDuplicatingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid DuplicateActor();\n};\n```", "cpp_code": "```cpp\n#include \"SelfDuplicatingActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nASelfDuplicatingActor::ASelfDuplicatingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASelfDuplicatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ASelfDuplicatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASelfDuplicatingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"Duplicate\", IE_Pressed, this, &ASelfDuplicatingActor::DuplicateActor);\n}\n\nvoid ASelfDuplicatingActor::DuplicateActor()\n{\n\tif (GetWorld())\n\t{\n\t\tFActorSpawnParameters SpawnParams;\n\t\tGetWorld()->SpawnActor<ASelfDuplicatingActor>(GetClass(), GetActorLocation() + FVector(100, 0, 0), GetActorRotation(), SpawnParams);\n\t}\n}\n```"}
{"requirement": "Bind the 'J' key to a function that resets the game level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Character.h\"\n#include \"ResetLevelActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetLevelActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAResetLevelActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvoid SetupPlayerInputComponent(UInputComponent* PlayerInputComponent);\n\n\tUFUNCTION()\n\tvoid ResetLevel();\n};\n```", "cpp_code": "```cpp\n#include \"ResetLevelActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAResetLevelActor::AResetLevelActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AResetLevelActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AResetLevelActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AResetLevelActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ResetLevel\", IE_Pressed, this, &AResetLevelActor::ResetLevel);\n}\n\nvoid AResetLevelActor::ResetLevel()\n{\n\tUWorld* World = GetWorld();\n\tif (World)\n\t{\n\t\tFName CurrentLevelName = *UGameplayStatics::GetCurrentLevelName(World);\n\t\tUGameplayStatics::OpenLevel(World, CurrentLevelName);\n\t}\n}\n```"}
{"requirement": "Create a static mesh actor with a UPROPERTY to toggle physics on BeginPlay.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PhysicsToggleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APhysicsToggleActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPhysicsToggleActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Physics\")\n\tbool bTogglePhysics;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"PhysicsToggleActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAPhysicsToggleActor::APhysicsToggleActor()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\tbTogglePhysics = false;\n}\n\nvoid APhysicsToggleActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tMeshComponent->SetSimulatePhysics(bTogglePhysics);\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere for a damage multiplier affecting actor interactions.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DamageMultiplierActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADamageMultiplierActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADamageMultiplierActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Damage\")\n\tfloat DamageMultiplier;\n};\n```", "cpp_code": "```cpp\n#include \"DamageMultiplierActor.h\"\n\n// Sets default values\nADamageMultiplierActor::ADamageMultiplierActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\t PrimaryActorTick.bCanEverTick = true;\n\n\t // Initialize default damage multiplier\n\t DamageMultiplier = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ADamageMultiplierActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid ADamageMultiplierActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Implement a component that logs the total number of overlaps with an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"OverlapLoggerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass YOURPROJECT_API UOverlapLoggerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tUOverlapLoggerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\nprivate:\n\tUFUNCTION()\n\tvoid OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor);\n\n\tint32 OverlapCount;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapLoggerComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUOverlapLoggerComponent::UOverlapLoggerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n\tOverlapCount = 0;\n}\n\nvoid UOverlapLoggerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tAActor* Owner = GetOwner();\n\tif (Owner)\n\t{\n\t\tOwner->OnActorBeginOverlap.AddDynamic(this, &UOverlapLoggerComponent::OnOverlapBegin);\n\t}\n}\n\nvoid UOverlapLoggerComponent::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)\n{\n\tif (OverlappedActor && OtherActor && OverlappedActor != OtherActor)\n\t{\n\t\tOverlapCount++;\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Total overlaps with %s: %d\"), *OverlappedActor->GetName(), OverlapCount);\n\t}\n}\n```"}
{"requirement": "Create an actor that moves in a circular path each Tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CircularMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACircularMovementActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACircularMovementActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Radius of the circular path\n\tUPROPERTY(EditAnywhere, Category=\"Circular Movement\")\n\tfloat Radius;\n\n\t// Speed of movement along the circular path\n\tUPROPERTY(EditAnywhere, Category=\"Circular Movement\")\n\tfloat Speed;\n\n\t// Internal angle used for circular movement calculation\n\tfloat CurrentAngle;\n};\n```", "cpp_code": "```cpp\n#include \"CircularMovementActor.h\"\n\n// Sets default values\nACircularMovementActor::ACircularMovementActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default values\n\tRadius = 100.0f;\n\tSpeed = 50.0f;\n\tCurrentAngle = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ACircularMovementActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACircularMovementActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate new position\n\tCurrentAngle += Speed * DeltaTime;\n\tif (CurrentAngle >= 360.0f)\n\t{\n\t\tCurrentAngle -= 360.0f;\n\t}\n\n\tFVector NewLocation;\n\tNewLocation.X = FMath::Cos(FMath::DegreesToRadians(CurrentAngle)) * Radius;\n\tNewLocation.Y = FMath::Sin(FMath::DegreesToRadians(CurrentAngle)) * Radius;\n\tNewLocation.Z = GetActorLocation().Z;\n\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Bind the 'B' key to a function that changes all actors' materials to the same one.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Materials/Material.h\"\n#include \"AChangeMaterialActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AChangeMaterialActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tAChangeMaterialActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid ChangeAllActorsMaterial();\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"AChangeMaterialActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/StaticMeshActor.h\"\n\nAChangeMaterialActor::AChangeMaterialActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tNewMaterial = nullptr;\n}\n\nvoid AChangeMaterialActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AChangeMaterialActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AChangeMaterialActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ChangeMaterial\", IE_Pressed, this, &AChangeMaterialActor::ChangeAllActorsMaterial);\n}\n\nvoid AChangeMaterialActor::ChangeAllActorsMaterial()\n{\n\tif (NewMaterial == nullptr) return;\n\n\tfor (TActorIterator<AStaticMeshActor> ActorItr(GetWorld()); ActorItr; ++ActorItr)\n\t{\n\t\tAStaticMeshActor* StaticMeshActor = *ActorItr;\n\t\tif (StaticMeshActor && StaticMeshActor->GetStaticMeshComponent())\n\t\t{\n\t\t\tStaticMeshActor->GetStaticMeshComponent()->SetMaterial(0, NewMaterial);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that changes direction when it collides with a wall.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeDirectionActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AChangeDirectionActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAChangeDirectionActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called when the actor hits something\n\tUFUNCTION()\n\tvoid OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tFVector MoveDirection;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat MoveSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeDirectionActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAChangeDirectionActor::AChangeDirectionActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create mesh component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Set a default mesh\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tMeshComponent->SetStaticMesh(MeshAsset.Object);\n\t}\n\n\t// Set initial move direction and speed\n\tMoveDirection = FVector(1.0f, 0.0f, 0.0f);\n\tMoveSpeed = 100.0f;\n\n\t// Bind the OnHit function\n\tMeshComponent->OnComponentHit.AddDynamic(this, &AChangeDirectionActor::OnHit);\n}\n\n// Called when the game starts or when spawned\nvoid AChangeDirectionActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AChangeDirectionActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Move the actor in the current direction\n\tFVector NewLocation = GetActorLocation() + (MoveDirection * MoveSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n\n// Called when the actor hits something\nvoid AChangeDirectionActor::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\t// Reverse direction on hit\n\tMoveDirection *= -1.0f;\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to adjust the intensity of an actor's light component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"LightActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ALightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tALightActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Light\")\n\tfloat LightIntensity;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUPointLightComponent* LightComponent;\n};\n```", "cpp_code": "```cpp\n#include \"LightActor.h\"\n\nALightActor::ALightActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tLightComponent = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLightComponent\"));\n\tRootComponent = LightComponent;\n\n\tLightIntensity = 3000.0f;\n\tLightComponent->Intensity = LightIntensity;\n}\n\nvoid ALightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ALightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tLightComponent->SetIntensity(LightIntensity);\n}\n```"}
{"requirement": "Implement a component that logs the distance traveled by an actor each second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"ULogDistanceTraveledComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULogDistanceTraveledComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\t\n\tULogDistanceTraveledComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tFVector LastLocation;\n\tfloat TotalDistanceTraveled;\n};\n```", "cpp_code": "```cpp\n#include \"ULogDistanceTraveledComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nULogDistanceTraveledComponent::ULogDistanceTraveledComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTotalDistanceTraveled = 0.0f;\n}\n\nvoid ULogDistanceTraveledComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tif (GetOwner())\n\t{\n\t\tLastLocation = GetOwner()->GetActorLocation();\n\t}\n\n\tGetWorld()->GetTimerManager().SetTimerForNextTick(this, &ULogDistanceTraveledComponent::TickComponent, 1.0f, true);\n}\n\nvoid ULogDistanceTraveledComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (GetOwner())\n\t{\n\t\tFVector CurrentLocation = GetOwner()->GetActorLocation();\n\t\tfloat DistanceTraveled = FVector::Dist(LastLocation, CurrentLocation);\n\n\t\tTotalDistanceTraveled += DistanceTraveled;\n\n\t\tUE_LOG(LogTemp, Log, TEXT(\"Distance traveled this second: %f. Total distance: %f\"), DistanceTraveled, TotalDistanceTraveled);\n\n\t\tLastLocation = CurrentLocation;\n\t}\n}\n```"}
{"requirement": "Create an actor with a UPROPERTY to define a specific target actor it should follow.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FollowTargetActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFollowTargetActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\t\n\t// Sets default values for this actor's properties\n\tAFollowTargetActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Follow\")\n\tAActor* TargetActor;\n};\n```", "cpp_code": "```cpp\n#include \"FollowTargetActor.h\"\n\n// Sets default values\nAFollowTargetActor::AFollowTargetActor()\n{\n\t // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AFollowTargetActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AFollowTargetActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TargetActor)\n\t{\n\t\tFVector TargetLocation = TargetActor->GetActorLocation();\n\t\t// Logic to move this actor towards the TargetActor can be added here\n\t}\n}\n```"}
{"requirement": "Bind the 'F' key to a function that toggles full-screen mode in the game.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleFullscreenActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AToggleFullscreenActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAToggleFullscreenActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid ToggleFullscreen();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleFullscreenActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n\nAToggleFullscreenActor::AToggleFullscreenActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AToggleFullscreenActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AToggleFullscreenActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleFullscreenActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"ToggleFullscreen\", IE_Pressed, this, &AToggleFullscreenActor::ToggleFullscreen);\n}\n\nvoid AToggleFullscreenActor::ToggleFullscreen()\n{\n\tif (GEngine && GEngine->GameViewport)\n\t{\n\t\tGEngine->GameViewport->Exec(GetWorld(), TEXT(\"fullscreen\"));\n\t}\n}\n```"}
{"requirement": "Create a component that plays a random sound from an array each time it's activated.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"USoundRandomizerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API USoundRandomizerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUSoundRandomizerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tUFUNCTION(BlueprintCallable, Category=\"Sound\")\n\tvoid ActivateComponent();\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Sound\")\n\tTArray<USoundCue*> SoundCues;\n\n\tvoid PlayRandomSound();\n};\n```", "cpp_code": "```cpp\n#include \"USoundRandomizerComponent.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUSoundRandomizerComponent::USoundRandomizerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid USoundRandomizerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid USoundRandomizerComponent::ActivateComponent()\n{\n\tSuper::Activate(true);\n\tPlayRandomSound();\n}\n\nvoid USoundRandomizerComponent::PlayRandomSound()\n{\n\tif (SoundCues.Num() > 0)\n\t{\n\t\tint32 RandomIndex = FMath::RandRange(0, SoundCues.Num() - 1);\n\t\tUSoundCue* SelectedSound = SoundCues[RandomIndex];\n\t\tif (SelectedSound)\n\t\t{\n\t\t\tUGameplayStatics::PlaySoundAtLocation(this, SelectedSound, GetOwner()->GetActorLocation());\n\t\t}\n\t}\n}\n```"}
{"requirement": "Add a UPROPERTY with EditAnywhere to control the length of time before an actor respawns.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RespawnableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARespawnableActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic: \n\tARespawnableActor();\n\nprotected:\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Respawn\")\n\tfloat RespawnTime;\n};\n```", "cpp_code": "```cpp\n#include \"RespawnableActor.h\"\n\nARespawnableActor::ARespawnableActor()\n{\n\t// Set default respawn time\n\tRespawnTime = 5.0f;\n}\n```"}
{"requirement": "Implement an actor that prints a message when it gets too close to another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ProximityActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AProximityActor : public AActor\n{\n\tGENERATED_BODY()\n\t\npublic:\t\n\t// Sets default values for this actor's properties\n\tAProximityActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Proximity\")\n\tfloat ProximityThreshold;\n\n\tvoid CheckProximity();\n};\n```", "cpp_code": "```cpp\n#include \"ProximityActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAProximityActor::AProximityActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tProximityThreshold = 100.0f; // Default proximity threshold\n}\n\n// Called when the game starts or when spawned\nvoid AProximityActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AProximityActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tCheckProximity();\n}\n\nvoid AProximityActor::CheckProximity()\n{\n\tTArray<AActor*> OverlappingActors;\n\tGetOverlappingActors(OverlappingActors);\n\n\tfor (AActor* Actor : OverlappingActors)\n\t{\n\t\tif (Actor != this && FVector::Dist(this->GetActorLocation(), Actor->GetActorLocation()) < ProximityThreshold)\n\t\t{\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Actor %s is too close to %s\"), *Actor->GetName(), *GetName());\n\t\t}\n\t}\n}\n```"}
