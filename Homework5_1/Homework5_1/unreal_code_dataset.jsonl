{"requirement": "Create an actor with a visible mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyVisibleMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMyVisibleMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyVisibleMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* VisibleMesh;\n};\n```", "cpp_code": "```cpp\n#include \"MyVisibleMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAMyVisibleMeshActor::AMyVisibleMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create a Static Mesh Component and attach it to the root\n\tVisibleMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"VisibleMesh\"));\n\tRootComponent = VisibleMesh;\n}\n\n// Called when the game starts or when spawned\nvoid AMyVisibleMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyVisibleMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Implement a simple rotating actor using tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Rotation speed in degrees per second\n\tUPROPERTY(EditAnywhere, Category=\"Rotation\")\n\tFRotator RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the rotation speed\n\tRotationSpeed = FRotator(0.f, 90.f, 0.f); // Rotate 90 degrees per second around Yaw\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update the actor's rotation\n\tAddActorLocalRotation(RotationSpeed * DeltaTime);\n}\n```"}
{"requirement": "Create an actor that changes color when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ClickableColorChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AClickableColorChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAClickableColorChangeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to change color\n\tUFUNCTION()\n\tvoid ChangeColor();\n\n\t// Function to handle mouse click\n\tvirtual void NotifyActorOnClicked(FKey ButtonPressed) override;\n\nprivate:\n\t// Mesh component\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ClickableColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nAClickableColorChangeActor::AClickableColorChangeActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AClickableColorChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AClickableColorChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AClickableColorChangeActor::ChangeColor()\n{\n\tUMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n\tif (DynamicMaterial)\n\t{\n\t\tFLinearColor NewColor = FLinearColor::MakeRandomColor();\n\t\tDynamicMaterial->SetVectorParameterValue(TEXT(\"BaseColor\"), NewColor);\n\t}\n}\n\nvoid AClickableColorChangeActor::NotifyActorOnClicked(FKey ButtonPressed)\n{\n\tSuper::NotifyActorOnClicked(ButtonPressed);\n\tChangeColor();\n}\n```"}
{"requirement": "Set up a basic actor that moves forward continuously.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMovingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMovingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// The speed at which the actor moves forward\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n\n// Sets default values\nAMovingActor::AMovingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize movement speed\n\tMovementSpeed = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMovingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMovingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Move the actor forward continuously\n\tFVector NewLocation = GetActorLocation() + (GetActorForwardVector() * MovementSpeed * DeltaTime);\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor with a public UPROPERTY float variable.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n  GENERATED_BODY()\n\npublic: \n  // Sets default values for this actor's properties\n  AMyActor();\n\n  // Public float variable\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Custom\")\n  float MyFloat;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Initialize the float variable\n  MyFloat = 0.0f;\n}\n```"}
{"requirement": "Implement a character that jumps when spacebar is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this character's properties\n    AMyCharacter();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Called to bind functionality to input\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    // Function to handle jumping\n    void HandleJump();\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAMyCharacter::AMyCharacter()\n{\n    // Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyCharacter::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid AMyCharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid AMyCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    PlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, &AMyCharacter::HandleJump);\n}\n\nvoid AMyCharacter::HandleJump()\n{\n    Jump();\n}\n```"}
{"requirement": "Create an actor that scales up over time using tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScalingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Scale factor per second\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tfloat ScaleFactorPerSecond = 1.0f;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n\n// Sets default values\nAScalingActor::AScalingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate the new scale\n\tFVector NewScale = GetActorScale3D() + FVector(ScaleFactorPerSecond * DeltaTime);\n\n\t// Apply the new scale\n\tSetActorScale3D(NewScale);\n}\n```"}
{"requirement": "Set up an actor with a UPROPERTY editable from the editor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyCustomActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyCustomActor : public AActor\n{\n  GENERATED_BODY()\n  \npublic:  \n  // Sets default values for this actor's properties\n  AMyCustomActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:  \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Custom\")\n  float EditableFloat;\n};\n```", "cpp_code": "```cpp\n#include \"MyCustomActor.h\"\n\n// Sets default values\nAMyCustomActor::AMyCustomActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMyCustomActor::BeginPlay()\n{\n  Super::BeginPlay();\n  \n}\n\n// Called every frame\nvoid AMyCustomActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n  \n}\n```"}
{"requirement": "Create an actor that prints 'Hello, World!' when spawned.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HelloWorldActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHelloWorldActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAHelloWorldActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"HelloWorldActor.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAHelloWorldActor::AHelloWorldActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid AHelloWorldActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Hello, World!\"));\n\t}\n}\n```"}
{"requirement": "Implement a simple input binding to toggle visibility of an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AToggleVisibilityActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    void ToggleVisibility();\n\n    UPROPERTY(EditAnywhere)\n    UInputComponent* InputComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n#include \"Components/InputComponent.h\"\n\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AToggleVisibilityActor::BeginPlay()\n{\n    Super::BeginPlay();\n\n    InputComponent = NewObject<UInputComponent>(this, UInputComponent::StaticClass());\n    InputComponent->RegisterComponent();\n    InputComponent->BindAction(\"ToggleVisibility\", IE_Pressed, this, &AToggleVisibilityActor::ToggleVisibility);\n}\n\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n    SetActorHiddenInGame(!bHidden);\n}\n```"}
{"requirement": "Create an actor that plays a sound when overlapping with another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Components/SphereComponent.h\"\n#include \"SoundOverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundOverlapActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:\n    // Sets default values for this actor's properties\n    ASoundOverlapActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    USphereComponent* SphereComponent;\n\n    UPROPERTY(EditAnywhere)\n    USoundCue* OverlapSound;\n\n    UPROPERTY()\n    UAudioComponent* AudioComponent;\n\n    UFUNCTION()\n    void OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"SoundOverlapActor.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundOverlapActor::ASoundOverlapActor()\n{\n    // Set this actor to call Tick() every frame.\n    PrimaryActorTick.bCanEverTick = true;\n\n    SphereComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"SphereComponent\"));\n    RootComponent = SphereComponent;\n    SphereComponent->InitSphereRadius(100.0f);\n    SphereComponent->OnComponentBeginOverlap.AddDynamic(this, &ASoundOverlapActor::OnOverlapBegin);\n\n    AudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n    AudioComponent->SetupAttachment(RootComponent);\n    AudioComponent->bAutoActivate = false;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundOverlapActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ASoundOverlapActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ASoundOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n    if (OverlapSound && OtherActor != this) // Ensure the sound cue is valid and not overlapping itself\n    {\n        if (!AudioComponent->IsPlaying())\n        {\n            AudioComponent->SetSound(OverlapSound);\n            AudioComponent->Play();\n        }\n    }\n}\n```"}
{"requirement": "Set up a camera actor that follows a fixed path.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CameraPathActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACameraPathActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    ACameraPathActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, Category=\"Path\")\n    TArray<FVector> PathPoints;\n\n    UPROPERTY(EditAnywhere, Category=\"Path\")\n    float Speed;\n\nprivate:\n    int32 CurrentPathIndex;\n    FVector TargetLocation;\n};\n```", "cpp_code": "```cpp\n#include \"CameraPathActor.h\"\n\nACameraPathActor::ACameraPathActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    Speed = 100.0f;\n    CurrentPathIndex = 0;\n}\n\nvoid ACameraPathActor::BeginPlay()\n{\n    Super::BeginPlay();\n    if (PathPoints.Num() > 0)\n    {\n        TargetLocation = PathPoints[0];\n        SetActorLocation(TargetLocation);\n    }\n}\n\nvoid ACameraPathActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (PathPoints.Num() == 0)\n        return;\n\n    FVector CurrentLocation = GetActorLocation();\n    FVector Direction = (TargetLocation - CurrentLocation).GetSafeNormal();\n    FVector NewLocation = CurrentLocation + Direction * Speed * DeltaTime;\n\n    if (FVector::Dist(NewLocation, TargetLocation) <= KINDA_SMALL_NUMBER)\n    {\n        CurrentPathIndex = (CurrentPathIndex + 1) % PathPoints.Num();\n        TargetLocation = PathPoints[CurrentPathIndex];\n    }\n    else\n    {\n        SetActorLocation(NewLocation);\n    }\n}\n```"}
{"requirement": "Create an actor with a basic UFUNCTION callable from Blueprints.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyBlueprintCallableActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyBlueprintCallableActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AMyBlueprintCallableActor();\n\n    UFUNCTION(BlueprintCallable, Category=\"MyFunctions\")\n    void MyBlueprintCallableFunction();\n};\n```", "cpp_code": "```cpp\n#include \"MyBlueprintCallableActor.h\"\n\nAMyBlueprintCallableActor::AMyBlueprintCallableActor()\n{\n    PrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AMyBlueprintCallableActor::MyBlueprintCallableFunction()\n{\n    UE_LOG(LogTemp, Warning, TEXT(\"MyBlueprintCallableFunction called\"));\n}\n```"}
{"requirement": "Implement an actor that changes material on begin play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeMaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeMaterialActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:\n    AChangeMaterialActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    UPROPERTY(EditAnywhere, Category = \"Materials\")\n    UMaterialInterface* NewMaterial;\n\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nAChangeMaterialActor::AChangeMaterialActor()\n{\n    PrimaryActorTick.bCanEverTick = false;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n}\n\nvoid AChangeMaterialActor::BeginPlay()\n{\n    Super::BeginPlay();\n    \n    if (MeshComponent && NewMaterial)\n    {\n        MeshComponent->SetMaterial(0, NewMaterial);\n    }\n}\n```"}
{"requirement": "Create an actor that moves in a circle using tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CircularMovementActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACircularMovementActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ACircularMovementActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    FVector CenterPosition;\n    float Radius;\n    float AngularSpeed;\n    float CurrentAngle;\n};\n```", "cpp_code": "```cpp\n#include \"CircularMovementActor.h\"\n\nACircularMovementActor::ACircularMovementActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    Radius = 300.0f;\n    AngularSpeed = 90.0f; // degrees per second\n    CurrentAngle = 0.0f;\n}\n\nvoid ACircularMovementActor::BeginPlay()\n{\n    Super::BeginPlay();\n    CenterPosition = GetActorLocation();\n}\n\nvoid ACircularMovementActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    CurrentAngle += AngularSpeed * DeltaTime;\n    if (CurrentAngle >= 360.0f)\n    {\n        CurrentAngle -= 360.0f;\n    }\n    float Radians = FMath::DegreesToRadians(CurrentAngle);\n    FVector NewLocation = CenterPosition;\n    NewLocation.X += Radius * FMath::Cos(Radians);\n    NewLocation.Y += Radius * FMath::Sin(Radians);\n    SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Set up a pawn class with basic movement control.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"MyPawn.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyPawn : public APawn\n{\n    GENERATED_BODY()\n\npublic:\n    AMyPawn();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    void MoveForward(float Value);\n    void MoveRight(float Value);\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\", meta = (AllowPrivateAccess = \"true\"))\n    class UFloatingPawnMovement* MovementComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyPawn.h\"\n#include \"GameFramework/FloatingPawnMovement.h\"\n#include \"Components/InputComponent.h\"\n\nAMyPawn::AMyPawn()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    MovementComponent = CreateDefaultSubobject<UFloatingPawnMovement>(TEXT(\"MovementComponent\"));\n}\n\nvoid AMyPawn::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AMyPawn::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AMyPawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n    PlayerInputComponent->BindAxis(\"MoveForward\", this, &AMyPawn::MoveForward);\n    PlayerInputComponent->BindAxis(\"MoveRight\", this, &AMyPawn::MoveRight);\n}\n\nvoid AMyPawn::MoveForward(float Value)\n{\n    if (MovementComponent && (MovementComponent->UpdatedComponent == RootComponent))\n    {\n        MovementComponent->AddInputVector(GetActorForwardVector() * Value);\n    }\n}\n\nvoid AMyPawn::MoveRight(float Value)\n{\n    if (MovementComponent && (MovementComponent->UpdatedComponent == RootComponent))\n    {\n        MovementComponent->AddInputVector(GetActorRightVector() * Value);\n    }\n}\n```"}
{"requirement": "Implement a simple actor that changes its size when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeSizeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AChangeSizeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAChangeSizeActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to change size\n\tvoid ChangeSize();\n\nprivate:\n\t// Size change factor\n\tUPROPERTY(EditAnywhere)\n\tfloat SizeChangeFactor;\n\n\t// Input handling\n\tvoid SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeSizeActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAChangeSizeActor::AChangeSizeActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the size change factor\n\tSizeChangeFactor = 1.1f;\n}\n\n// Called when the game starts or when spawned\nvoid AChangeSizeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AChangeSizeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Change the size of the actor\nvoid AChangeSizeActor::ChangeSize()\n{\n\tFVector NewScale = GetActorScale3D() * SizeChangeFactor;\n\tSetActorScale3D(NewScale);\n}\n\n// Setup player input bindings\nvoid AChangeSizeActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"ChangeSize\", IE_Pressed, this, &AChangeSizeActor::ChangeSize);\n}\n```"}
{"requirement": "Create a component that logs a message when attached to an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LoggingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECTNAME_API ULoggingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this component's properties\n\tULoggingComponent();\n\nprotected:\n\t// Called when the game starts\n\tvirtual void BeginPlay() override;\n\n#if WITH_EDITOR\n\t// Called when the component is attached in the editor\n\tvirtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;\n#endif\n};\n```", "cpp_code": "```cpp\n#include \"LoggingComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values for this component's properties\nULoggingComponent::ULoggingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\n// Called when the game starts\nvoid ULoggingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"LoggingComponent attached to: %s\"), *Owner->GetName());\n\t}\n}\n\n#if WITH_EDITOR\nvoid ULoggingComponent::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)\n{\n\tSuper::PostEditChangeProperty(PropertyChangedEvent);\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"LoggingComponent attached to (Editor): %s\"), *Owner->GetName());\n\t}\n}\n#endif\n```"}
{"requirement": "Create an actor that increments a counter every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CounterActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACounterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACounterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFTimerHandle TimerHandle;\n\tint32 Counter;\n\n\tvoid IncrementCounter();\n};\n```", "cpp_code": "```cpp\n#include \"CounterActor.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nACounterActor::ACounterActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tCounter = 0;\n}\n\n// Called when the game starts or when spawned\nvoid ACounterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorldTimerManager().SetTimer(TimerHandle, this, &ACounterActor::IncrementCounter, 1.0f, true);\n}\n\n// Called every frame\nvoid ACounterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACounterActor::IncrementCounter()\n{\n\tCounter++;\n\tUE_LOG(LogTemp, Warning, TEXT(\"Counter: %d\"), Counter);\n}\n```"}
{"requirement": "Implement a basic projectile actor with movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ProjectileActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AProjectileActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AProjectileActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n    UStaticMeshComponent* ProjectileMesh;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Movement\")\n    FVector Velocity;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Movement\")\n    float Speed;\n};\n```", "cpp_code": "```cpp\n#include \"ProjectileActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nAProjectileActor::AProjectileActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    ProjectileMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"ProjectileMesh\"));\n    RootComponent = ProjectileMesh;\n\n    Speed = 1000.f;\n    Velocity = FVector::ForwardVector * Speed;\n}\n\nvoid AProjectileActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AProjectileActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    FVector NewLocation = GetActorLocation() + (Velocity * DeltaTime);\n    SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that changes location when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeLocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeLocationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAChangeLocationActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid MoveActor();\n};\n```", "cpp_code": "```cpp\n#include \"ChangeLocationActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAChangeLocationActor::AChangeLocationActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AChangeLocationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AChangeLocationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid AChangeLocationActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"MoveActor\", IE_Pressed, this, &AChangeLocationActor::MoveActor);\n}\n\nvoid AChangeLocationActor::MoveActor()\n{\n\tFVector NewLocation = GetActorLocation();\n\tNewLocation.X += 100.0f; // Move the actor by 100 units on the X axis\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that toggles a light on and off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleLightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleLightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to toggle the light\n\tUFUNCTION(BlueprintCallable, Category=\"Light\")\n\tvoid ToggleLight();\n\nprivate:\n\t// Point light component\n\tUPROPERTY(VisibleAnywhere)\n\tUPointLightComponent* PointLight;\n\n\t// Light status\n\tbool bIsLightOn;\n};\n```", "cpp_code": "```cpp\n#include \"ToggleLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nAToggleLightActor::AToggleLightActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the PointLight component\n\tPointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n\tRootComponent = PointLight;\n\n\t// Set initial light state\n\tbIsLightOn = true;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleLightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AToggleLightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AToggleLightActor::ToggleLight()\n{\n\tbIsLightOn = !bIsLightOn;\n\tPointLight->SetVisibility(bIsLightOn);\n}\n```"}
{"requirement": "Set up a trigger volume actor that prints a message on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TriggerVolumeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ATriggerVolumeActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    ATriggerVolumeActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UBoxComponent* TriggerVolume;\n\n    UFUNCTION()\n    void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"TriggerVolumeActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\nATriggerVolumeActor::ATriggerVolumeActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    TriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n    RootComponent = TriggerVolume;\n\n    TriggerVolume->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n    TriggerVolume->SetCollisionObjectType(ECollisionChannel::ECC_WorldStatic);\n    TriggerVolume->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);\n    TriggerVolume->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Overlap);\n\n    TriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &ATriggerVolumeActor::OnOverlapBegin);\n}\n\nvoid ATriggerVolumeActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ATriggerVolumeActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ATriggerVolumeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n    if (OtherActor && OtherActor != this)\n    {\n        GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Overlap Begin\"));\n    }\n}\n```"}
{"requirement": "Create an actor with a random color on spawn.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomColorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomColorActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  ARandomColorActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\nprivate:\n  UPROPERTY(VisibleAnywhere)\n  UStaticMeshComponent* MeshComponent;\n\n  void SetRandomColor();\n};\n```", "cpp_code": "```cpp\n#include \"RandomColorActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nARandomColorActor::ARandomColorActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = false;\n\n  MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n  RootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ARandomColorActor::BeginPlay()\n{\n  Super::BeginPlay();\n  SetRandomColor();\n}\n\nvoid ARandomColorActor::SetRandomColor()\n{\n  if (MeshComponent)\n  {\n    UMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n    if (DynamicMaterial)\n    {\n      FLinearColor RandomColor = FLinearColor::MakeRandomColor();\n      DynamicMaterial->SetVectorParameterValue(FName(\"BaseColor\"), RandomColor);\n    }\n  }\n}\n```"}
{"requirement": "Implement a simple actor with a UPROPERTY int variable.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MySimpleActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMySimpleActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:\n    AMySimpleActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Test\")\n    int32 MyIntVariable;\n};\n```", "cpp_code": "```cpp\n#include \"MySimpleActor.h\"\n\nAMySimpleActor::AMySimpleActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    MyIntVariable = 0;\n}\n\nvoid AMySimpleActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AMySimpleActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that moves left and right with arrow keys.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMovableActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyMovableActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:  \n  AMyMovableActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:  \n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  void MoveLeft(float Value);\n  void MoveRight(float Value);\n\n  UPROPERTY(EditAnywhere, Category=\"Movement\")\n  float MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MyMovableActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAMyMovableActor::AMyMovableActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n  MovementSpeed = 100.f;\n}\n\nvoid AMyMovableActor::BeginPlay()\n{\n  Super::BeginPlay();\n\n  if (APlayerController* PlayerController = Cast<APlayerController>(GetWorld()->GetFirstPlayerController()))\n  {\n    EnableInput(PlayerController);\n    InputComponent->BindAxis(\"MoveLeft\", this, &AMyMovableActor::MoveLeft);\n    InputComponent->BindAxis(\"MoveRight\", this, &AMyMovableActor::MoveRight);\n  }\n}\n\nvoid AMyMovableActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AMyMovableActor::MoveLeft(float Value)\n{\n  if (Value != 0.0f)\n  {\n    AddActorLocalOffset(FVector(-Value * MovementSpeed * GetWorld()->GetDeltaSeconds(), 0.f, 0.f), true);\n  }\n}\n\nvoid AMyMovableActor::MoveRight(float Value)\n{\n  if (Value != 0.0f)\n  {\n    AddActorLocalOffset(FVector(Value * MovementSpeed * GetWorld()->GetDeltaSeconds(), 0.f, 0.f), true);\n  }\n}\n```"}
{"requirement": "Set up an actor that spawns another actor on demand.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpawnActorOnDemand.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpawnActorOnDemand : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpawnActorOnDemand();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Spawning\")\n\tvoid SpawnActor();\n\n\tUPROPERTY(EditAnywhere, Category = \"Spawning\")\n\tTSubclassOf<AActor> ActorToSpawn;\n};\n```", "cpp_code": "```cpp\n#include \"SpawnActorOnDemand.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nASpawnActorOnDemand::ASpawnActorOnDemand()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASpawnActorOnDemand::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpawnActorOnDemand::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ASpawnActorOnDemand::SpawnActor()\n{\n\tif (ActorToSpawn)\n\t{\n\t\tUWorld* World = GetWorld();\n\t\tif (World)\n\t\t{\n\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\tSpawnParams.Owner = this;\n\t\t\tSpawnParams.Instigator = GetInstigator();\n\n\t\t\tFVector Location = GetActorLocation();\n\t\t\tFRotator Rotation = GetActorRotation();\n\n\t\t\tAActor* SpawnedActor = World->SpawnActor<AActor>(ActorToSpawn, Location, Rotation, SpawnParams);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that logs its position every tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PositionLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APositionLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPositionLoggerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"PositionLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAPositionLoggerActor::APositionLoggerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid APositionLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APositionLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector ActorLocation = GetActorLocation();\n\tUE_LOG(LogTemp, Log, TEXT(\"Actor Position: X=%f, Y=%f, Z=%f\"), ActorLocation.X, ActorLocation.Y, ActorLocation.Z);\n}\n```"}
{"requirement": "Implement an actor that rotates towards the player character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:\n    ARotatingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    AActor* PlayerCharacter;\n    FRotator GetLookAtRotation(FVector TargetLocation);\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nARotatingActor::ARotatingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n    Super::BeginPlay();\n    PlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    if (PlayerCharacter)\n    {\n        FVector PlayerLocation = PlayerCharacter->GetActorLocation();\n        FRotator TargetRotation = GetLookAtRotation(PlayerLocation);\n        SetActorRotation(TargetRotation);\n    }\n}\n\nFRotator ARotatingActor::GetLookAtRotation(FVector TargetLocation)\n{\n    FVector Direction = (TargetLocation - GetActorLocation()).GetSafeNormal();\n    return FRotationMatrix::MakeFromX(Direction).Rotator();\n}\n```"}
{"requirement": "Create a basic actor with a static mesh component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyStaticMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyStaticMeshActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    // Sets default values for this actor's properties\n    AMyStaticMeshActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* StaticMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyStaticMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAMyStaticMeshActor::AMyStaticMeshActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Create and attach StaticMeshComponent\n    StaticMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComponent\"));\n    RootComponent = StaticMeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AMyStaticMeshActor::BeginPlay()\n{\n    Super::BeginPlay();\n    \n}\n\n// Called every frame\nvoid AMyStaticMeshActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n}\n```"}
{"requirement": "Create an actor that scales over time when a key is held.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAScalingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ScaleActor(float DeltaTime);\n\n\tFVector InitialScale;\n\n\tUPROPERTY(EditAnywhere, Category = \"Scaling\")\n\tfloat ScalingSpeed;\n\n\tbool bIsScaling;\n\n\tvoid StartScaling();\n\tvoid StopScaling();\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n\nAScalingActor::AScalingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tScalingSpeed = 1.0f;\n\tbIsScaling = false;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tInitialScale = GetActorScale3D();\n\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tEnableInput(PlayerController);\n\t\tInputComponent->BindAction(\"Scale\", IE_Pressed, this, &AScalingActor::StartScaling);\n\t\tInputComponent->BindAction(\"Scale\", IE_Released, this, &AScalingActor::StopScaling);\n\t}\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsScaling)\n\t{\n\t\tScaleActor(DeltaTime);\n\t}\n}\n\nvoid AScalingActor::ScaleActor(float DeltaTime)\n{\n\tFVector NewScale = GetActorScale3D() + FVector(ScalingSpeed * DeltaTime);\n\tSetActorScale3D(NewScale);\n}\n\nvoid AScalingActor::StartScaling()\n{\n\tbIsScaling = true;\n}\n\nvoid AScalingActor::StopScaling()\n{\n\tbIsScaling = false;\n}\n```"}
{"requirement": "Set up a character that switches between walking and running.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    AMyCharacter();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic: \n    virtual void Tick(float DeltaTime) override;\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Movement\")\n    float WalkSpeed;\n\n    UPROPERTY(EditAnywhere, Category=\"Movement\")\n    float RunSpeed;\n\n    void MoveForward(float Value);\n    void MoveRight(float Value);\n    void StartRunning();\n    void StopRunning();\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/Controller.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n\nAMyCharacter::AMyCharacter()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    WalkSpeed = 200.0f;\n    RunSpeed = 600.0f;\n}\n\nvoid AMyCharacter::BeginPlay()\n{\n    Super::BeginPlay();\n    GetCharacterMovement()->MaxWalkSpeed = WalkSpeed;\n}\n\nvoid AMyCharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AMyCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    PlayerInputComponent->BindAxis(\"MoveForward\", this, &AMyCharacter::MoveForward);\n    PlayerInputComponent->BindAxis(\"MoveRight\", this, &AMyCharacter::MoveRight);\n    PlayerInputComponent->BindAction(\"Run\", IE_Pressed, this, &AMyCharacter::StartRunning);\n    PlayerInputComponent->BindAction(\"Run\", IE_Released, this, &AMyCharacter::StopRunning);\n}\n\nvoid AMyCharacter::MoveForward(float Value)\n{\n    if ((Controller != nullptr) && (Value != 0.0f))\n    {\n        const FRotator Rotation = Controller->GetControlRotation();\n        const FRotator YawRotation(0, Rotation.Yaw, 0);\n\n        const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n        AddMovementInput(Direction, Value);\n    }\n}\n\nvoid AMyCharacter::MoveRight(float Value)\n{\n    if ((Controller != nullptr) && (Value != 0.0f))\n    {\n        const FRotator Rotation = Controller->GetControlRotation();\n        const FRotator YawRotation(0, Rotation.Yaw, 0);\n\n        const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n        AddMovementInput(Direction, Value);\n    }\n}\n\nvoid AMyCharacter::StartRunning()\n{\n    GetCharacterMovement()->MaxWalkSpeed = RunSpeed;\n}\n\nvoid AMyCharacter::StopRunning()\n{\n    GetCharacterMovement()->MaxWalkSpeed = WalkSpeed;\n}\n```"}
{"requirement": "Create a light actor that changes intensity when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALightActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tALightActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to change the intensity of the light\n\tvoid ChangeLightIntensity();\n\n\t// Light component\n\tUPROPERTY(VisibleAnywhere)\n\tclass UPointLightComponent* LightComponent;\n\n\t// Light intensity values\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light\")\n\tfloat MinIntensity;\n\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Light\")\n\tfloat MaxIntensity;\n\nprivate:\n\t// Current intensity state\n\tbool bIsMaxIntensity;\n};\n```", "cpp_code": "```cpp\n#include \"LightActor.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nALightActor::ALightActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach the light component\n\tLightComponent = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLightComponent\"));\n\tRootComponent = LightComponent;\n\n\t// Set default intensity values\n\tMinIntensity = 1000.0f;\n\tMaxIntensity = 3000.0f;\n\tbIsMaxIntensity = true;\n\n\t// Set initial intensity\n\tLightComponent->Intensity = MaxIntensity;\n}\n\n// Called when the game starts or when spawned\nvoid ALightActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Get the player controller and bind the input\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tInputComponent = NewObject<UInputComponent>(this);\n\t\tInputComponent->RegisterComponent();\n\t\tInputComponent->BindAction(\"ToggleLightIntensity\", IE_Pressed, this, &ALightActor::ChangeLightIntensity);\n\t\tPlayerController->PushInputComponent(InputComponent);\n\t}\n}\n\n// Called every frame\nvoid ALightActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ALightActor::ChangeLightIntensity()\n{\n\tif (bIsMaxIntensity)\n\t{\n\t\tLightComponent->SetIntensity(MinIntensity);\n\t}\n\telse\n\t{\n\t\tLightComponent->SetIntensity(MaxIntensity);\n\t}\n\n\tbIsMaxIntensity = !bIsMaxIntensity;\n}\n```"}
{"requirement": "Implement an actor with a basic health system using UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AHealthActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    // Sets default values for this actor's properties\n    AHealthActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Health property\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n    float Health;\n\n    // Max Health property\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n    float MaxHealth;\n\n    // Function to apply damage\n    UFUNCTION(BlueprintCallable, Category=\"Health\")\n    void ApplyDamage(float DamageAmount);\n};\n```", "cpp_code": "```cpp\n#include \"HealthActor.h\"\n\n// Sets default values\nAHealthActor::AHealthActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Initialize default health values\n    Health = 100.0f;\n    MaxHealth = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AHealthActor::BeginPlay()\n{\n    Super::BeginPlay();\n    \n    // Ensure health is not more than max health at start\n    Health = FMath::Clamp(Health, 0.0f, MaxHealth);\n}\n\n// Called every frame\nvoid AHealthActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AHealthActor::ApplyDamage(float DamageAmount)\n{\n    Health -= DamageAmount;\n    Health = FMath::Clamp(Health, 0.0f, MaxHealth);\n    \n    // Print health to log for debugging\n    UE_LOG(LogTemp, Warning, TEXT(\"Health: %f\"), Health);\n}\n```"}
{"requirement": "Create a component that plays a sound when the game starts.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundPlayerComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API USoundPlayerComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic:\n\tUSoundPlayerComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"SoundPlayerComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUSoundPlayerComponent::USoundPlayerComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = false;\n}\n\nvoid USoundPlayerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::PlaySoundAtLocation(this, SoundToPlay, GetOwner()->GetActorLocation());\n\t}\n}\n```"}
{"requirement": "Create an actor that prints 'Tick' every frame.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TickActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATickActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATickActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"TickActor.h\"\n\n// Sets default values\nATickActor::ATickActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ATickActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ATickActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUE_LOG(LogTemp, Warning, TEXT(\"Tick\"));\n}\n```"}
{"requirement": "Set up a basic actor that moves up when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMovingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyMovingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AMyMovingActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Function to move the actor up\n    void MoveUp();\n\nprivate:\n    // The amount to move the actor each frame\n    UPROPERTY(EditAnywhere)\n    float MoveSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MyMovingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nAMyMovingActor::AMyMovingActor()\n{\n    // Set this actor to call Tick() every frame.\n    PrimaryActorTick.bCanEverTick = true;\n    MoveSpeed = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMyMovingActor::BeginPlay()\n{\n    Super::BeginPlay();\n    InputComponent = NewObject<UInputComponent>(this);\n    InputComponent->BindAction(\"MoveUp\", IE_Pressed, this, &AMyMovingActor::MoveUp);\n    EnableInput(GetWorld()->GetFirstPlayerController());\n}\n\n// Called every frame\nvoid AMyMovingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AMyMovingActor::MoveUp()\n{\n    FVector NewLocation = GetActorLocation();\n    NewLocation.Z += MoveSpeed * GetWorld()->GetDeltaSeconds();\n    SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that changes its material on overlap.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialChangerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialChangerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMaterialChangerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n\tUPROPERTY(VisibleAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NewMaterial;\n};\n```", "cpp_code": "```cpp\n#include \"MaterialChangerActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n#include \"Components/BoxComponent.h\"\n\n// Sets default values\nAMaterialChangerActor::AMaterialChangerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create Mesh Component\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\t// Setup Overlap\n\tMeshComponent->OnComponentBeginOverlap.AddDynamic(this, &AMaterialChangerActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid AMaterialChangerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMaterialChangerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMaterialChangerActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n\tif (NewMaterial && MeshComponent)\n\t{\n\t\tMeshComponent->SetMaterial(0, NewMaterial);\n\t}\n}\n```"}
{"requirement": "Implement a simple UFUNCTION that logs the player's location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PlayerLocationLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APlayerLocationLogger : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    APlayerLocationLogger();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category=\"Player\")\n    void LogPlayerLocation();\n};\n```", "cpp_code": "```cpp\n#include \"PlayerLocationLogger.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAPlayerLocationLogger::APlayerLocationLogger()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid APlayerLocationLogger::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid APlayerLocationLogger::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid APlayerLocationLogger::LogPlayerLocation()\n{\n    if (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n    {\n        if (APawn* PlayerPawn = PlayerController->GetPawn())\n        {\n            FVector PlayerLocation = PlayerPawn->GetActorLocation();\n            UE_LOG(LogTemp, Log, TEXT(\"Player Location: X=%f, Y=%f, Z=%f\"), PlayerLocation.X, PlayerLocation.Y, PlayerLocation.Z);\n        }\n    }\n}\n```"}
{"requirement": "Create an actor that spawns a sound at its location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundCue.h\"\n#include \"SoundSpawnActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundSpawnActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASoundSpawnActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Sound to spawn\n\tUPROPERTY(EditAnywhere, Category = \"Sound\")\n\tUSoundCue* SoundToPlay;\n};\n```", "cpp_code": "```cpp\n#include \"SoundSpawnActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nASoundSpawnActor::ASoundSpawnActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ASoundSpawnActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (SoundToPlay)\n\t{\n\t\tUGameplayStatics::SpawnSoundAtLocation(this, SoundToPlay, GetActorLocation());\n\t}\n}\n\n// Called every frame\nvoid ASoundSpawnActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Set up a basic actor with a visible text component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/TextRenderComponent.h\"\n#include \"MyTextActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyTextActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMyTextActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Text component\n\tUPROPERTY(VisibleAnywhere, Category=\"Components\")\n\tUTextRenderComponent* TextComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyTextActor.h\"\n\n// Sets default values\nAMyTextActor::AMyTextActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and attach TextRenderComponent\n\tTextComponent = CreateDefaultSubobject<UTextRenderComponent>(TEXT(\"TextComponent\"));\n\tTextComponent->SetupAttachment(RootComponent);\n\tTextComponent->SetText(FText::FromString(\"Hello, Unreal!\"));\n}\n\n// Called when the game starts or when spawned\nvoid AMyTextActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMyTextActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that moves randomly in a defined area.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomMover.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomMover : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tARandomMover();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid MoveRandomly();\n\n\tFVector MovementArea;\n\tFVector MinBounds;\n\tFVector MaxBounds;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MovementRange;\n\n\tUPROPERTY(EditAnywhere, Category=\"Movement\")\n\tfloat MovementDelay;\n\n\tFTimerHandle MovementTimer;\n};\n```", "cpp_code": "```cpp\n#include \"RandomMover.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n\nARandomMover::ARandomMover()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tMovementRange = 100.0f;\n\tMovementDelay = 1.0f;\n}\n\nvoid ARandomMover::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tMinBounds = GetActorLocation() - FVector(MovementRange);\n\tMaxBounds = GetActorLocation() + FVector(MovementRange);\n\n\tGetWorld()->GetTimerManager().SetTimer(MovementTimer, this, &ARandomMover::MoveRandomly, MovementDelay, true);\n}\n\nvoid ARandomMover::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARandomMover::MoveRandomly()\n{\n\tFVector NewLocation = FMath::RandPointInBox(FBox(MinBounds, MaxBounds));\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Implement a simple actor that changes texture when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TextureSwapper.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureSwapper : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ATextureSwapper();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    UPROPERTY(EditAnywhere)\n    UMaterialInterface* Material;\n\n    UPROPERTY(EditAnywhere)\n    UTexture* Texture1;\n\n    UPROPERTY(EditAnywhere)\n    UTexture* Texture2;\n\n    UFUNCTION()\n    void OnMeshClicked(UPrimitiveComponent* ClickedComp, FKey ButtonPressed);\n\nprivate:\n    bool bUsingTexture1;\n};\n```", "cpp_code": "```cpp\n#include \"TextureSwapper.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n#include \"Engine/Engine.h\"\n\nATextureSwapper::ATextureSwapper()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    MeshComponent->OnClicked.AddDynamic(this, &ATextureSwapper::OnMeshClicked);\n\n    bUsingTexture1 = true;\n}\n\nvoid ATextureSwapper::BeginPlay()\n{\n    Super::BeginPlay();\n\n    if (Material && Texture1)\n    {\n        UMaterialInstanceDynamic* DynamicMaterial = UMaterialInstanceDynamic::Create(Material, this);\n        DynamicMaterial->SetTextureParameterValue(TEXT(\"TextureParameter\"), Texture1);\n        MeshComponent->SetMaterial(0, DynamicMaterial);\n    }\n}\n\nvoid ATextureSwapper::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ATextureSwapper::OnMeshClicked(UPrimitiveComponent* ClickedComp, FKey ButtonPressed)\n{\n    if (Material)\n    {\n        UMaterialInstanceDynamic* DynamicMaterial = UMaterialInstanceDynamic::Create(Material, this);\n        if (bUsingTexture1 && Texture2)\n        {\n            DynamicMaterial->SetTextureParameterValue(TEXT(\"TextureParameter\"), Texture2);\n        }\n        else if (Texture1)\n        {\n            DynamicMaterial->SetTextureParameterValue(TEXT(\"TextureParameter\"), Texture1);\n        }\n        MeshComponent->SetMaterial(0, DynamicMaterial);\n        bUsingTexture1 = !bUsingTexture1;\n    }\n}\n```"}
{"requirement": "Create a basic rotating platform using actor ticking.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingPlatform.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingPlatform : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotatingPlatform();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\t// Rotation speed in degrees per second\n\tUPROPERTY(EditAnywhere, Category = \"Rotation\")\n\tfloat RotationSpeed = 45.0f; // Default rotation speed\n};\n```", "cpp_code": "```cpp\n#include \"RotatingPlatform.h\"\n\n// Sets default values\nARotatingPlatform::ARotatingPlatform()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingPlatform::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARotatingPlatform::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate rotation for this frame\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\n\t// Apply the new rotation\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Set up an actor with a public UPROPERTY string variable.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:\n    // Sets default values for this actor's properties\n    AMyActor();\n\n    // Public UPROPERTY string variable\n    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category=\"Custom\")\n    FString MyString;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Initialize the string variable with a default value if needed\n    MyString = TEXT(\"Default String\");\n}\n```"}
{"requirement": "Create an actor that changes its scale based on a public variable.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAScalingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Public variable to control scale\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Scaling\")\n\tFVector TargetScale;\n\nprivate:\n\t// Function to update the scale of the actor\n\tvoid UpdateScale();\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n\n// Sets default values\nAScalingActor::AScalingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default target scale\n\tTargetScale = FVector(1.0f, 1.0f, 1.0f);\n}\n\n// Called when the game starts or when spawned\nvoid AScalingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Initial scale update\n\tUpdateScale();\n}\n\n// Called every frame\nvoid AScalingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Update scale every frame (optional, if dynamic changes are needed)\n\tUpdateScale();\n}\n\nvoid AScalingActor::UpdateScale()\n{\n\tSetActorScale3D(TargetScale);\n}\n```"}
{"requirement": "Implement a simple actor that moves towards a target point.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AMovingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n    FVector TargetPoint;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n    float Speed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n\nAMovingActor::AMovingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    Speed = 100.0f; // Default speed\n}\n\nvoid AMovingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    FVector CurrentLocation = GetActorLocation();\n    FVector Direction = (TargetPoint - CurrentLocation).GetSafeNormal();\n    FVector NewLocation = CurrentLocation + (Direction * Speed * DeltaTime);\n\n    SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that respawns at a set location on command.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RespawnableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ARespawnableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARespawnableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Respawn the actor at a set location\n\tUFUNCTION(BlueprintCallable, Category=\"Respawn\")\n\tvoid Respawn();\n\nprivate:\n\t// The location to respawn the actor\n\tFVector RespawnLocation;\n};\n```", "cpp_code": "```cpp\n#include \"RespawnableActor.h\"\n\n// Sets default values\nARespawnableActor::ARespawnableActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize default respawn location\n\tRespawnLocation = FVector(0.0f, 0.0f, 0.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ARespawnableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARespawnableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARespawnableActor::Respawn()\n{\n\tSetActorLocation(RespawnLocation);\n}\n```"}
{"requirement": "Create a light that changes color every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingLight.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AColorChangingLight : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AColorChangingLight();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UPointLightComponent* PointLight;\n\n    FTimerHandle TimerHandle;\n\n    void ChangeLightColor();\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingLight.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n\nAColorChangingLight::AColorChangingLight()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    PointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n    RootComponent = PointLight;\n}\n\nvoid AColorChangingLight::BeginPlay()\n{\n    Super::BeginPlay();\n\n    GetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &AColorChangingLight::ChangeLightColor, 1.0f, true);\n}\n\nvoid AColorChangingLight::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AColorChangingLight::ChangeLightColor()\n{\n    FLinearColor NewColor = FLinearColor::MakeRandomColor();\n    PointLight->SetLightColor(NewColor);\n}\n```"}
{"requirement": "Set up a component that logs a message every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"LoggingComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API ULoggingComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tULoggingComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tfloat TimeAccumulator;\n\tfloat LogInterval;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nULoggingComponent::ULoggingComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\tTimeAccumulator = 0.0f;\n\tLogInterval = 1.0f; // Log every second\n}\n\nvoid ULoggingComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ULoggingComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tTimeAccumulator += DeltaTime;\n\n\tif (TimeAccumulator >= LogInterval)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Logging every second.\"));\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n```"}
{"requirement": "Create an actor that changes material when entering a trigger zone.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialChangeActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AMaterialChangeActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  UPROPERTY(VisibleAnywhere)\n  class UStaticMeshComponent* MeshComponent;\n\n  UPROPERTY(EditAnywhere)\n  class UMaterialInterface* NewMaterial;\n\n  UFUNCTION()\n  void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n};\n```", "cpp_code": "```cpp\n#include \"MaterialChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Materials/MaterialInterface.h\"\n\nAMaterialChangeActor::AMaterialChangeActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n\n  MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n  RootComponent = MeshComponent;\n\n  UBoxComponent* TriggerZone = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerZone\"));\n  TriggerZone->SetupAttachment(RootComponent);\n  TriggerZone->OnComponentBeginOverlap.AddDynamic(this, &AMaterialChangeActor::OnOverlapBegin);\n}\n\nvoid AMaterialChangeActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AMaterialChangeActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AMaterialChangeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n  if (NewMaterial && OtherActor && OtherActor != this)\n  {\n    MeshComponent->SetMaterial(0, NewMaterial);\n  }\n}\n```"}
{"requirement": "Implement a basic actor that scales down over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    AScalingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Scaling\")\n    float ScaleSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n\nAScalingActor::AScalingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    ScaleSpeed = 0.1f;\n}\n\nvoid AScalingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    FVector NewScale = GetActorScale3D();\n    NewScale -= FVector(ScaleSpeed * DeltaTime);\n    if (NewScale.X > 0 && NewScale.Y > 0 && NewScale.Z > 0)\n    {\n        SetActorScale3D(NewScale);\n    }\n}\n```"}
{"requirement": "Create a simple actor that follows the mouse cursor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseFollowerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMouseFollowerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMouseFollowerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid FollowMouseCursor();\n};\n```", "cpp_code": "```cpp\n#include \"MouseFollowerActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nAMouseFollowerActor::AMouseFollowerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMouseFollowerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AMouseFollowerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFollowMouseCursor();\n}\n\nvoid AMouseFollowerActor::FollowMouseCursor()\n{\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tFVector WorldLocation, WorldDirection;\n\t\tif (PlayerController->DeprojectMousePositionToWorld(WorldLocation, WorldDirection))\n\t\t{\n\t\t\tFVector NewLocation = WorldLocation + WorldDirection * 1000.0f; // Adjust the scalar to set the distance\n\t\t\tSetActorLocation(NewLocation);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create an actor that emits a particle effect when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ParticleEffectActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AParticleEffectActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAParticleEffectActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Particle System Component\n\tUPROPERTY(EditAnywhere, Category = \"Effects\")\n\tUParticleSystem* ParticleEffect;\n\n\t// Function to handle click\n\tUFUNCTION()\n\tvoid OnClick();\n\n\t// Function to setup input bindings\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n};\n```", "cpp_code": "```cpp\n#include \"ParticleEffectActor.h\"\n#include \"Components/InputComponent.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAParticleEffectActor::AParticleEffectActor()\n{\n \t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize particle effect\n\tParticleEffect = CreateDefaultSubobject<UParticleSystem>(TEXT(\"ParticleEffect\"));\n}\n\n// Called when the game starts or when spawned\nvoid AParticleEffectActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind input\n\tEnableInput(GetWorld()->GetFirstPlayerController());\n\tif (InputComponent)\n\t{\n\t\tInputComponent->BindAction(\"Click\", IE_Pressed, this, &AParticleEffectActor::OnClick);\n\t}\n}\n\n// Called every frame\nvoid AParticleEffectActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle click\nvoid AParticleEffectActor::OnClick()\n{\n\tif (ParticleEffect)\n\t{\n\t\tUGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ParticleEffect, GetActorLocation(), GetActorRotation());\n\t}\n}\n\n// Function to setup input bindings\nvoid AParticleEffectActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n```"}
{"requirement": "Set up a basic actor that changes its rotation with arrow keys.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    ARotatingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    void SetupInputComponent();\n    void RotateActor(float DeltaTime);\n\n    UPROPERTY(EditAnywhere)\n    float RotationSpeed;\n\n    FVector CurrentRotation;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nARotatingActor::ARotatingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    RotationSpeed = 100.0f;\n    CurrentRotation = FVector::ZeroVector;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n    Super::BeginPlay();\n    SetupInputComponent();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    RotateActor(DeltaTime);\n}\n\nvoid ARotatingActor::SetupInputComponent()\n{\n    APlayerController* PlayerController = Cast<APlayerController>(GetController());\n    if (PlayerController)\n    {\n        EnableInput(PlayerController);\n        InputComponent->BindAxis(\"MoveRight\", this, &ARotatingActor::RotateActor);\n    }\n}\n\nvoid ARotatingActor::RotateActor(float DeltaTime)\n{\n    float RightValue = InputComponent ? InputComponent->GetAxisValue(\"MoveRight\") : 0.0f;\n    if (RightValue != 0.0f)\n    {\n        CurrentRotation.Yaw += RightValue * RotationSpeed * DeltaTime;\n        SetActorRotation(FQuat::MakeFromEuler(CurrentRotation));\n    }\n}\n```"}
{"requirement": "Create a trigger volume that changes the player's speed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeSpeedTrigger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeSpeedTrigger : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AChangeSpeedTrigger();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(VisibleAnywhere, Category = \"Trigger\")\n    class UBoxComponent* TriggerVolume;\n\n    UPROPERTY(EditAnywhere, Category = \"Speed\")\n    float NewSpeed;\n\n    UFUNCTION()\n    void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n    UFUNCTION()\n    void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n};\n```", "cpp_code": "```cpp\n#include \"ChangeSpeedTrigger.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n\nAChangeSpeedTrigger::AChangeSpeedTrigger()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    TriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n    RootComponent = TriggerVolume;\n\n    TriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &AChangeSpeedTrigger::OnOverlapBegin);\n    TriggerVolume->OnComponentEndOverlap.AddDynamic(this, &AChangeSpeedTrigger::OnOverlapEnd);\n\n    NewSpeed = 600.0f; // Default speed\n}\n\nvoid AChangeSpeedTrigger::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AChangeSpeedTrigger::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AChangeSpeedTrigger::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n    if (OtherActor && (OtherActor != this))\n    {\n        ACharacter* Character = Cast<ACharacter>(OtherActor);\n        if (Character)\n        {\n            Character->GetCharacterMovement()->MaxWalkSpeed = NewSpeed;\n        }\n    }\n}\n\nvoid AChangeSpeedTrigger::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n    if (OtherActor && (OtherActor != this))\n    {\n        ACharacter* Character = Cast<ACharacter>(OtherActor);\n        if (Character)\n        {\n            // Reset to default speed or handle accordingly\n            Character->GetCharacterMovement()->MaxWalkSpeed = Character->GetCharacterMovement()->GetMaxSpeed();\n        }\n    }\n}\n```"}
{"requirement": "Implement a simple actor that changes size when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ClickableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AClickableActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AClickableActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION()\n    void OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n\nprivate:\n    FVector OriginalScale;\n    FVector TargetScale;\n};\n```", "cpp_code": "```cpp\n#include \"ClickableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n\nAClickableActor::AClickableActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    OnClicked.AddDynamic(this, &AClickableActor::OnClicked);\n\n    OriginalScale = FVector(1.0f, 1.0f, 1.0f);\n    TargetScale = FVector(2.0f, 2.0f, 2.0f);\n}\n\nvoid AClickableActor::BeginPlay()\n{\n    Super::BeginPlay();\n    SetActorScale3D(OriginalScale);\n}\n\nvoid AClickableActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AClickableActor::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n    FVector CurrentScale = GetActorScale3D();\n    if (CurrentScale.Equals(OriginalScale))\n    {\n        SetActorScale3D(TargetScale);\n    }\n    else\n    {\n        SetActorScale3D(OriginalScale);\n    }\n}\n```"}
{"requirement": "Create an actor that logs when it enters a trigger volume.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LoggingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALoggingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ALoggingActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION()\n    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    class UBoxComponent* TriggerVolume;\n};\n```", "cpp_code": "```cpp\n#include \"LoggingActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nALoggingActor::ALoggingActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Create and initialize trigger volume\n    TriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n    TriggerVolume->SetupAttachment(RootComponent);\n    TriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &ALoggingActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ALoggingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ALoggingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ALoggingActor::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)\n{\n    if (OtherActor && (OtherActor != this))\n    {\n        UE_LOG(LogTemp, Warning, TEXT(\"%s has entered the trigger volume of %s\"), *OtherActor->GetName(), *GetName());\n    }\n}\n```"}
{"requirement": "Create a basic actor that moves with WASD keys.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyMovingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyMovingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AMyMovingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    void MoveForward(float Value);\n    void MoveRight(float Value);\n\nprivate:\n    FVector CurrentVelocity;\n    UPROPERTY(EditAnywhere)\n    float MoveSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MyMovingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nAMyMovingActor::AMyMovingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    MoveSpeed = 100.0f;\n}\n\nvoid AMyMovingActor::BeginPlay()\n{\n    Super::BeginPlay();\n\n    if (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n    {\n        EnableInput(PlayerController);\n        InputComponent->BindAxis(\"MoveForward\", this, &AMyMovingActor::MoveForward);\n        InputComponent->BindAxis(\"MoveRight\", this, &AMyMovingActor::MoveRight);\n    }\n}\n\nvoid AMyMovingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    if (!CurrentVelocity.IsZero())\n    {\n        FVector NewLocation = GetActorLocation() + (CurrentVelocity * DeltaTime);\n        SetActorLocation(NewLocation);\n    }\n}\n\nvoid AMyMovingActor::MoveForward(float Value)\n{\n    CurrentVelocity.X = Value * MoveSpeed;\n}\n\nvoid AMyMovingActor::MoveRight(float Value)\n{\n    CurrentVelocity.Y = Value * MoveSpeed;\n}\n```"}
{"requirement": "Set up an actor that plays a sound when destroyed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"MyDestructibleActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMyDestructibleActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AMyDestructibleActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, Category = \"Sound\")\n    USoundBase* DestructionSound;\n\n    virtual void Destroyed() override;\n};\n```", "cpp_code": "```cpp\n#include \"MyDestructibleActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAMyDestructibleActor::AMyDestructibleActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyDestructibleActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AMyDestructibleActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AMyDestructibleActor::Destroyed()\n{\n    Super::Destroyed();\n\n    if (DestructionSound)\n    {\n        UGameplayStatics::PlaySoundAtLocation(this, DestructionSound, GetActorLocation());\n    }\n}\n```"}
{"requirement": "Create a simple actor with a dynamic material instance.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicMaterialActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ADynamicMaterialActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ADynamicMaterialActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    UPROPERTY(EditAnywhere)\n    UMaterialInterface* Material;\n\n    UMaterialInstanceDynamic* DynamicMaterialInstance;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicMaterialActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nADynamicMaterialActor::ADynamicMaterialActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid ADynamicMaterialActor::BeginPlay()\n{\n    Super::BeginPlay();\n\n    if (Material)\n    {\n        DynamicMaterialInstance = UMaterialInstanceDynamic::Create(Material, this);\n        if (DynamicMaterialInstance)\n        {\n            MeshComponent->SetMaterial(0, DynamicMaterialInstance);\n        }\n    }\n}\n\n// Called every frame\nvoid ADynamicMaterialActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    // Example of updating a parameter on the dynamic material instance\n    if (DynamicMaterialInstance)\n    {\n        float Time = GetWorld()->GetTimeSeconds();\n        DynamicMaterialInstance->SetScalarParameterValue(TEXT(\"ParamName\"), FMath::Sin(Time));\n    }\n}\n```"}
{"requirement": "Implement a basic actor that moves away when the player is near.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    AMovingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, Category=\"Movement\")\n    float MovementSpeed;\n\n    UPROPERTY(EditAnywhere, Category=\"Detection\")\n    float DetectionRadius;\n\nprivate:\n    void MoveAwayFromPlayer();\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAMovingActor::AMovingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    MovementSpeed = 100.0f;\n    DetectionRadius = 500.0f;\n}\n\nvoid AMovingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    MoveAwayFromPlayer();\n}\n\nvoid AMovingActor::MoveAwayFromPlayer()\n{\n    ACharacter* PlayerCharacter = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);\n    if (PlayerCharacter)\n    {\n        FVector PlayerLocation = PlayerCharacter->GetActorLocation();\n        FVector ActorLocation = GetActorLocation();\n        float DistanceToPlayer = FVector::Dist(PlayerLocation, ActorLocation);\n\n        if (DistanceToPlayer < DetectionRadius)\n        {\n            FVector Direction = (ActorLocation - PlayerLocation).GetSafeNormal();\n            FVector NewLocation = ActorLocation + Direction * MovementSpeed * GetWorld()->DeltaTimeSeconds;\n            SetActorLocation(NewLocation);\n        }\n    }\n}\n```"}
{"requirement": "Create an actor that prints the game's current time every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimePrinterActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATimePrinterActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tATimePrinterActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFTimerHandle TimerHandle;\n\n\tvoid PrintCurrentTime();\n};\n```", "cpp_code": "```cpp\n#include \"TimePrinterActor.h\"\n#include \"Engine/World.h\"\n#include \"TimerManager.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nATimePrinterActor::ATimePrinterActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ATimePrinterActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Set timer to call PrintCurrentTime every second\n\tGetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &ATimePrinterActor::PrintCurrentTime, 1.0f, true);\n}\n\n// Called every frame\nvoid ATimePrinterActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ATimePrinterActor::PrintCurrentTime()\n{\n\tFDateTime CurrentTime = FDateTime::Now();\n\tUE_LOG(LogTemp, Log, TEXT(\"Current Game Time: %s\"), *CurrentTime.ToString());\n}\n```"}
{"requirement": "Create a simple moving platform using key inputs.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingPlatform.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingPlatform : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AMovingPlatform();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere)\n    float MoveSpeed;\n\nprivate:\n    void MovePlatform(float DeltaTime);\n    void SetupInputComponent();\n\n    FVector CurrentVelocity;\n\n    UPROPERTY()\n    UInputComponent* InputComponent;\n\n    void MoveForward();\n    void MoveBackward();\n};\n```", "cpp_code": "```cpp\n#include \"MovingPlatform.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAMovingPlatform::AMovingPlatform()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    MoveSpeed = 200.0f;\n    CurrentVelocity = FVector::ZeroVector;\n}\n\nvoid AMovingPlatform::BeginPlay()\n{\n    Super::BeginPlay();\n    SetupInputComponent();\n}\n\nvoid AMovingPlatform::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    MovePlatform(DeltaTime);\n}\n\nvoid AMovingPlatform::SetupInputComponent()\n{\n    InputComponent = FindComponentByClass<UInputComponent>();\n    if (InputComponent)\n    {\n        InputComponent->BindAction(\"MoveForward\", IE_Pressed, this, &AMovingPlatform::MoveForward);\n        InputComponent->BindAction(\"MoveBackward\", IE_Pressed, this, &AMovingPlatform::MoveBackward);\n    }\n}\n\nvoid AMovingPlatform::MovePlatform(float DeltaTime)\n{\n    FVector NewLocation = GetActorLocation() + (CurrentVelocity * DeltaTime);\n    SetActorLocation(NewLocation);\n}\n\nvoid AMovingPlatform::MoveForward()\n{\n    CurrentVelocity = FVector(MoveSpeed, 0, 0);\n}\n\nvoid AMovingPlatform::MoveBackward()\n{\n    CurrentVelocity = FVector(-MoveSpeed, 0, 0);\n}\n```"}
{"requirement": "Set up a basic actor with a UPROPERTY bool variable.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this actor's properties\n  AMyActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:\n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MyCategory\")\n  bool bMyBool;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n  // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Initialize the bool variable\n  bMyBool = false;\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n  Super::BeginPlay();\n  \n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n  \n}\n```"}
{"requirement": "Create an actor that changes its mesh on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MeshChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMeshChangeActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AMeshChangeActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, Category = \"Mesh\")\n    UStaticMeshComponent* MeshComponent;\n\n    UPROPERTY(EditAnywhere, Category = \"Mesh\")\n    UStaticMesh* Mesh1;\n\n    UPROPERTY(EditAnywhere, Category = \"Mesh\")\n    UStaticMesh* Mesh2;\n\nprivate:\n    void ChangeMesh();\n};\n```", "cpp_code": "```cpp\n#include \"MeshChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAMeshChangeActor::AMeshChangeActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n}\n\nvoid AMeshChangeActor::BeginPlay()\n{\n    Super::BeginPlay();\n\n    if (Mesh1)\n    {\n        MeshComponent->SetStaticMesh(Mesh1);\n    }\n}\n\nvoid AMeshChangeActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    APlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n    if (PlayerController)\n    {\n        if (PlayerController->WasInputKeyJustPressed(EKeys::M))\n        {\n            ChangeMesh();\n        }\n    }\n}\n\nvoid AMeshChangeActor::ChangeMesh()\n{\n    if (MeshComponent && Mesh2)\n    {\n        UStaticMesh* CurrentMesh = MeshComponent->GetStaticMesh();\n        MeshComponent->SetStaticMesh(CurrentMesh == Mesh1 ? Mesh2 : Mesh1);\n    }\n}\n```"}
{"requirement": "Implement a simple actor that disappears after a few seconds.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DisappearingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADisappearingActor : public AActor\n{\n  GENERATED_BODY()\n  \npublic:  \n  ADisappearingActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\nprivate:\n  UPROPERTY(EditAnywhere, Category=\"Disappear\")\n  float DisappearTime;\n\n  FTimerHandle TimerHandle;\n\n  void Disappear();\n};\n```", "cpp_code": "```cpp\n#include \"DisappearingActor.h\"\n#include \"TimerManager.h\"\n\nADisappearingActor::ADisappearingActor()\n{\n  PrimaryActorTick.bCanEverTick = false;\n  DisappearTime = 5.0f; // Default time to disappear\n}\n\nvoid ADisappearingActor::BeginPlay()\n{\n  Super::BeginPlay();\n  \n  GetWorldTimerManager().SetTimer(TimerHandle, this, &ADisappearingActor::Disappear, DisappearTime, false);\n}\n\nvoid ADisappearingActor::Disappear()\n{\n  Destroy();\n}\n```"}
{"requirement": "Create an actor that logs a message when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"KeyPressLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AKeyPressLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tAKeyPressLogger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to bind input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\t// Function to log message\n\tvoid LogMessage();\n};\n```", "cpp_code": "```cpp\n#include \"KeyPressLogger.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAKeyPressLogger::AKeyPressLogger()\n{\n\t// Set this actor to call Tick() every frame. \n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AKeyPressLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AKeyPressLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid AKeyPressLogger::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"LogMessage\", IE_Pressed, this, &AKeyPressLogger::LogMessage);\n}\n\n// Function to log message\nvoid AKeyPressLogger::LogMessage()\n{\n\tUE_LOG(LogTemp, Warning, TEXT(\"Key Pressed!\"));\n}\n```"}
{"requirement": "Create a basic pawn that can be controlled with a mouse.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"MouseControlledPawn.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AMouseControlledPawn : public APawn\n{\n    GENERATED_BODY()\n\npublic:\n    AMouseControlledPawn();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic: \n    virtual void Tick(float DeltaTime) override;\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n    void MoveForward(float Value);\n    void MoveRight(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"MouseControlledPawn.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/FloatingPawnMovement.h\"\n#include \"Components/InputComponent.h\"\n\nAMouseControlledPawn::AMouseControlledPawn()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    USpringArmComponent* SpringArm = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"SpringArm\"));\n    SpringArm->SetupAttachment(RootComponent);\n    SpringArm->TargetArmLength = 400.0f;\n    SpringArm->bUsePawnControlRotation = true;\n\n    UCameraComponent* Camera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"Camera\"));\n    Camera->SetupAttachment(SpringArm, USpringArmComponent::SocketName);\n    Camera->bUsePawnControlRotation = false;\n\n    UFloatingPawnMovement* Movement = CreateDefaultSubobject<UFloatingPawnMovement>(TEXT(\"PawnMovement\"));\n}\n\nvoid AMouseControlledPawn::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AMouseControlledPawn::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AMouseControlledPawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    PlayerInputComponent->BindAxis(\"MoveForward\", this, &AMouseControlledPawn::MoveForward);\n    PlayerInputComponent->BindAxis(\"MoveRight\", this, &AMouseControlledPawn::MoveRight);\n}\n\nvoid AMouseControlledPawn::MoveForward(float Value)\n{\n    AddMovementInput(GetActorForwardVector() * Value);\n}\n\nvoid AMouseControlledPawn::MoveRight(float Value)\n{\n    AddMovementInput(GetActorRightVector() * Value);\n}\n```"}
{"requirement": "Set up an actor that spawns a particle effect on begin play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ParticleSpawnActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AParticleSpawnActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AParticleSpawnActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Particle system to spawn\n    UPROPERTY(EditAnywhere, Category=\"Effects\")\n    UParticleSystem* ParticleEffect;\n};\n```", "cpp_code": "```cpp\n#include \"ParticleSpawnActor.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n// Sets default values\nAParticleSpawnActor::AParticleSpawnActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid AParticleSpawnActor::BeginPlay()\n{\n    Super::BeginPlay();\n\n    if (ParticleEffect)\n    {\n        UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ParticleEffect, GetActorLocation(), GetActorRotation());\n    }\n}\n```"}
{"requirement": "Create an actor that drops to the ground when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DroppableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADroppableActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tADroppableActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called when the actor is clicked\n\tUFUNCTION()\n\tvoid OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n\nprivate:\n\tbool bShouldDrop;\n};\n```", "cpp_code": "```cpp\n#include \"DroppableActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nADroppableActor::ADroppableActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tbShouldDrop = false;\n\n\t// Enable the actor to be clicked\n\tthis->OnClicked.AddDynamic(this, &ADroppableActor::OnClicked);\n}\n\n// Called when the game starts or when spawned\nvoid ADroppableActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADroppableActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bShouldDrop)\n\t{\n\t\tFVector NewLocation = GetActorLocation();\n\t\tNewLocation.Z -= 100 * DeltaTime; // Dropping speed\n\t\tSetActorLocation(NewLocation);\n\t}\n}\n\nvoid ADroppableActor::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n\tbShouldDrop = true;\n}\n```"}
{"requirement": "Implement a simple actor that changes location when hitting a wall.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeLocationOnHit.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeLocationOnHit : public AActor\n{\n  GENERATED_BODY()\n\npublic:  \n  // Sets default values for this actor's properties\n  AChangeLocationOnHit();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic:  \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n  UFUNCTION()\n  void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n  UPROPERTY(EditAnywhere)\n  FVector NewLocation;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeLocationOnHit.h\"\n#include \"Components/PrimitiveComponent.h\"\n\n// Sets default values\nAChangeLocationOnHit::AChangeLocationOnHit()\n{\n  // Set this actor to call Tick() every frame.\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Create a root component and attach the on hit event\n  UPrimitiveComponent* RootComp = CreateDefaultSubobject<UPrimitiveComponent>(TEXT(\"RootComponent\"));\n  RootComponent = RootComp;\n  RootComp->OnComponentHit.AddDynamic(this, &AChangeLocationOnHit::OnHit);\n}\n\n// Called when the game starts or when spawned\nvoid AChangeLocationOnHit::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\n// Called every frame\nvoid AChangeLocationOnHit::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AChangeLocationOnHit::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n  if (OtherActor != this)\n  {\n    // Change the actor's location to NewLocation when hitting a wall\n    SetActorLocation(NewLocation);\n  }\n}\n```"}
{"requirement": "Create a basic actor that flies upward when a key is pressed.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FlyingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFlyingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AFlyingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    void FlyUpward();\n\nprivate:\n    UPROPERTY(EditAnywhere)\n    float FlySpeed;\n};\n```", "cpp_code": "```cpp\n#include \"FlyingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"Components/InputComponent.h\"\n\nAFlyingActor::AFlyingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    FlySpeed = 200.0f;\n}\n\nvoid AFlyingActor::BeginPlay()\n{\n    Super::BeginPlay();\n    if (InputComponent)\n    {\n        InputComponent->BindAction(\"FlyUpward\", IE_Pressed, this, &AFlyingActor::FlyUpward);\n    }\n}\n\nvoid AFlyingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AFlyingActor::FlyUpward()\n{\n    FVector NewLocation = GetActorLocation();\n    NewLocation.Z += FlySpeed * GetWorld()->GetDeltaSeconds();\n    SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that logs its speed every frame.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpeedLoggerActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpeedLoggerActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tASpeedLoggerActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector PreviousLocation;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedLoggerActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\n// Sets default values\nASpeedLoggerActor::ASpeedLoggerActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tPreviousLocation = FVector::ZeroVector;\n}\n\n// Called when the game starts or when spawned\nvoid ASpeedLoggerActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPreviousLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid ASpeedLoggerActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t// Calculate speed\n\tFVector CurrentLocation = GetActorLocation();\n\tfloat Speed = FVector::Dist(CurrentLocation, PreviousLocation) / DeltaTime;\n\n\t// Log speed\n\tUE_LOG(LogTemp, Log, TEXT(\"Speed: %f\"), Speed);\n\n\t// Update previous location\n\tPreviousLocation = CurrentLocation;\n}\n```"}
{"requirement": "Set up an actor that rotates on a timer.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFTimerHandle RotationTimerHandle;\n\tvoid RotateActor();\n\n\tUPROPERTY(EditAnywhere, Category = \"Rotation\")\n\tFRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tRotationRate = FRotator(0.f, 45.f, 0.f); // Default rotation rate of 45 degrees per second on the Yaw\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tGetWorldTimerManager().SetTimer(RotationTimerHandle, this, &ARotatingActor::RotateActor, 1.0f, true);\n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARotatingActor::RotateActor()\n{\n\tAddActorLocalRotation(RotationRate * GetWorld()->GetDeltaSeconds());\n}\n```"}
{"requirement": "Create a light that turns on and off with a switch.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightSwitch.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALightSwitch : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ALightSwitch();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(VisibleAnywhere)\n    class UPointLightComponent* PointLight;\n\n    UPROPERTY(EditAnywhere)\n    float LightIntensity;\n\n    UFUNCTION()\n    void ToggleLight();\n\n    UPROPERTY(VisibleAnywhere)\n    class UBoxComponent* TriggerBox;\n\n    UFUNCTION()\n    void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n    UFUNCTION()\n    void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n};\n```", "cpp_code": "```cpp\n#include \"LightSwitch.h\"\n#include \"Components/PointLightComponent.h\"\n#include \"Components/BoxComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nALightSwitch::ALightSwitch()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    PointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n    PointLight->Intensity = 3000.0f;\n    PointLight->bVisible = false;\n    RootComponent = PointLight;\n\n    TriggerBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerBox\"));\n    TriggerBox->SetupAttachment(RootComponent);\n    TriggerBox->SetBoxExtent(FVector(200.0f));\n    TriggerBox->OnComponentBeginOverlap.AddDynamic(this, &ALightSwitch::OnOverlapBegin);\n    TriggerBox->OnComponentEndOverlap.AddDynamic(this, &ALightSwitch::OnOverlapEnd);\n\n    LightIntensity = 3000.0f;\n}\n\nvoid ALightSwitch::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ALightSwitch::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ALightSwitch::ToggleLight()\n{\n    PointLight->ToggleVisibility();\n}\n\nvoid ALightSwitch::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n    ToggleLight();\n}\n\nvoid ALightSwitch::OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n    ToggleLight();\n}\n```"}
{"requirement": "Implement a simple actor that oscillates up and down.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OscillatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOscillatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAOscillatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tFVector StartLocation;\n\tUPROPERTY(EditAnywhere)\n\tfloat Amplitude;\n\tUPROPERTY(EditAnywhere)\n\tfloat Frequency;\n};\n```", "cpp_code": "```cpp\n#include \"OscillatingActor.h\"\n\n// Sets default values\nAOscillatingActor::AOscillatingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tAmplitude = 100.0f;\n\tFrequency = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AOscillatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tStartLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid AOscillatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tFVector NewLocation = StartLocation;\n\tfloat DeltaHeight = Amplitude * FMath::Sin(Frequency * GetWorld()->GetTimeSeconds());\n\tNewLocation.Z += DeltaHeight;\n\tSetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create an actor that turns towards the camera on spawn.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LookAtCameraActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALookAtCameraActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:\n    // Sets default values for this actor's properties\n    ALookAtCameraActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n};\n```", "cpp_code": "```cpp\n#include \"LookAtCameraActor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Camera/PlayerCameraManager.h\"\n\n// Sets default values\nALookAtCameraActor::ALookAtCameraActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid ALookAtCameraActor::BeginPlay()\n{\n    Super::BeginPlay();\n    \n    APlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n    if (PlayerController)\n    {\n        APlayerCameraManager* CameraManager = PlayerController->PlayerCameraManager;\n        if (CameraManager)\n        {\n            FVector CameraLocation = CameraManager->GetCameraLocation();\n            FRotator LookAtRotation = (CameraLocation - GetActorLocation()).Rotation();\n            SetActorRotation(LookAtRotation);\n        }\n    }\n}\n```"}
{"requirement": "Create an actor with a timer that changes its material.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MaterialActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMaterialActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    AMaterialActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(EditAnywhere)\n    TArray<UMaterialInterface*> Materials;\n\n    UPROPERTY(EditAnywhere)\n    float ChangeInterval;\n\n    FTimerHandle MaterialChangeTimerHandle;\n\n    void ChangeMaterial();\n};\n```", "cpp_code": "```cpp\n#include \"MaterialActor.h\"\n#include \"TimerManager.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nAMaterialActor::AMaterialActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMaterialActor::BeginPlay()\n{\n    Super::BeginPlay();\n    if (Materials.Num() > 0 && ChangeInterval > 0.0f)\n    {\n        GetWorldTimerManager().SetTimer(MaterialChangeTimerHandle, this, &AMaterialActor::ChangeMaterial, ChangeInterval, true);\n    }\n}\n\nvoid AMaterialActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AMaterialActor::ChangeMaterial()\n{\n    UStaticMeshComponent* MeshComponent = FindComponentByClass<UStaticMeshComponent>();\n    if (MeshComponent && Materials.Num() > 0)\n    {\n        int32 RandomIndex = FMath::RandRange(0, Materials.Num() - 1);\n        MeshComponent->SetMaterial(0, Materials[RandomIndex]);\n    }\n}\n```"}
{"requirement": "Set up a basic actor with UPROPERTY for color change.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangeActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    // Sets default values for this actor's properties\n    AColorChangeActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Color\")\n    FLinearColor ActorColor;\n\n    void ChangeColor(const FLinearColor& NewColor);\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeActor.h\"\n\n// Sets default values\nAColorChangeActor::AColorChangeActor()\n{\n     // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Initialize default color\n    ActorColor = FLinearColor::White;\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangeActor::BeginPlay()\n{\n    Super::BeginPlay();\n    \n}\n\n// Called every frame\nvoid AColorChangeActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n}\n\nvoid AColorChangeActor::ChangeColor(const FLinearColor& NewColor)\n{\n    ActorColor = NewColor;\n    // Additional logic can be added here to update material, etc.\n}\n```"}
{"requirement": "Create an actor that scales up when overlapping another actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScalingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScalingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic: \n  AScalingActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic: \n  virtual void Tick(float DeltaTime) override;\n\n  UFUNCTION()\n  void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n  UPROPERTY(EditAnywhere)\n  FVector ScaleFactor;\n\n  UPROPERTY(VisibleAnywhere)\n  class UBoxComponent* CollisionComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ScalingActor.h\"\n#include \"Components/BoxComponent.h\"\n\nAScalingActor::AScalingActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n  \n  CollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n  RootComponent = CollisionComponent;\n  \n  CollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AScalingActor::OnOverlapBegin);\n  \n  ScaleFactor = FVector(2.0f, 2.0f, 2.0f);\n}\n\nvoid AScalingActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AScalingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AScalingActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n  if (OtherActor && (OtherActor != this) && OtherComp)\n  {\n    FVector NewScale = GetActorScale3D() * ScaleFactor;\n    SetActorScale3D(NewScale);\n  }\n}\n```"}
{"requirement": "Implement an actor that moves to a random location on a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomMoveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomMoveActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ARandomMoveActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n    float MoveRadius;\n\n    UFUNCTION()\n    void MoveToRandomLocation();\n\nprivate:\n    void SetupInputComponent();\n\n    UPROPERTY()\n    UInputComponent* InputComponent;\n};\n```", "cpp_code": "```cpp\n#include \"RandomMoveActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n\nARandomMoveActor::ARandomMoveActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    MoveRadius = 1000.0f;\n}\n\nvoid ARandomMoveActor::BeginPlay()\n{\n    Super::BeginPlay();\n    SetupInputComponent();\n}\n\nvoid ARandomMoveActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ARandomMoveActor::SetupInputComponent()\n{\n    InputComponent = NewObject<UInputComponent>(this);\n    InputComponent->RegisterComponent();\n\n    if (InputComponent)\n    {\n        InputComponent->BindAction(\"MoveRandom\", IE_Pressed, this, &ARandomMoveActor::MoveToRandomLocation);\n        EnableInput(GetWorld()->GetFirstPlayerController());\n    }\n}\n\nvoid ARandomMoveActor::MoveToRandomLocation()\n{\n    FVector NewLocation = UKismetMathLibrary::RandomUnitVector() * MoveRadius;\n    NewLocation.Z = 0; // Keep the movement on the same plane\n    SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Create a simple actor that spins when a key is held down.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpinningActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpinningActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    ASpinningActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    void Spin(float DeltaTime);\n\n    bool bIsSpinning;\n};\n```", "cpp_code": "```cpp\n#include \"SpinningActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nASpinningActor::ASpinningActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    bIsSpinning = false;\n}\n\nvoid ASpinningActor::BeginPlay()\n{\n    Super::BeginPlay();\n\n    if (APlayerController* PC = GetWorld()->GetFirstPlayerController())\n    {\n        PC->InputComponent->BindAction(\"Spin\", IE_Pressed, this, [&]() { bIsSpinning = true; });\n        PC->InputComponent->BindAction(\"Spin\", IE_Released, this, [&]() { bIsSpinning = false; });\n    }\n}\n\nvoid ASpinningActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (bIsSpinning)\n    {\n        Spin(DeltaTime);\n    }\n}\n\nvoid ASpinningActor::Spin(float DeltaTime)\n{\n    FRotator NewRotation = GetActorRotation();\n    NewRotation.Yaw += 180.0f * DeltaTime; // Adjust the speed as needed\n    SetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an actor that switches between two states using a key.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"StateSwitchingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AStateSwitchingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAStateSwitchingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tbool bIsStateOne;\n\n\tvoid SwitchState();\n\n\tvoid SetupInputBindings();\n};\n```", "cpp_code": "```cpp\n#include \"StateSwitchingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/InputSettings.h\"\n\n// Sets default values\nAStateSwitchingActor::AStateSwitchingActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tbIsStateOne = true;\n}\n\n// Called when the game starts or when spawned\nvoid AStateSwitchingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tSetupInputBindings();\n}\n\n// Called every frame\nvoid AStateSwitchingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AStateSwitchingActor::SwitchState()\n{\n\tbIsStateOne = !bIsStateOne;\n\tif (bIsStateOne)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Switched to State One\"));\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Switched to State Two\"));\n\t}\n}\n\nvoid AStateSwitchingActor::SetupInputBindings()\n{\n\tif (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n\t{\n\t\tInputComponent = NewObject<UInputComponent>(this);\n\t\tInputComponent->RegisterComponent();\n\t\tInputComponent->BindAction(\"SwitchState\", IE_Pressed, this, &AStateSwitchingActor::SwitchState);\n\n\t\tPlayerController->PushInputComponent(InputComponent);\n\t}\n}\n```"}
{"requirement": "Set up a basic actor with a visible light component.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALightActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:\n    // Sets default values for this actor's properties\n    ALightActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    class UPointLightComponent* PointLight;\n};\n```", "cpp_code": "```cpp\n#include \"LightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nALightActor::ALightActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Create and attach a PointLightComponent\n    PointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n    RootComponent = PointLight;\n}\n\n// Called when the game starts or when spawned\nvoid ALightActor::BeginPlay()\n{\n    Super::BeginPlay();\n    \n}\n\n// Called every frame\nvoid ALightActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor that teleports to a location on command.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TeleportActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATeleportActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    ATeleportActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category=\"Teleport\")\n    void TeleportToLocation(FVector NewLocation);\n};\n```", "cpp_code": "```cpp\n#include \"TeleportActor.h\"\n\nATeleportActor::ATeleportActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ATeleportActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ATeleportActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ATeleportActor::TeleportToLocation(FVector NewLocation)\n{\n    SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Implement a simple actor that changes rotation speed over time.", "header_code": "```cpp\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  ARotatingActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  UPROPERTY(EditAnywhere, Category=\"Rotation\")\n  float RotationSpeed;\n\n  UPROPERTY(EditAnywhere, Category=\"Rotation\")\n  float RotationSpeedIncrement;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/Actor.h\"\n\nARotatingActor::ARotatingActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n  RotationSpeed = 10.0f;\n  RotationSpeedIncrement = 1.0f;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  FRotator NewRotation = GetActorRotation();\n  NewRotation.Yaw += RotationSpeed * DeltaTime;\n  SetActorRotation(NewRotation);\n\n  RotationSpeed += RotationSpeedIncrement * DeltaTime;\n}\n```"}
{"requirement": "Create an actor that follows a spline path using tick.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/SplineComponent.h\"\n#include \"SplineFollower.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASplineFollower : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    ASplineFollower();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Spline\")\n    USplineComponent* SplineComponent;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Movement\")\n    float Speed;\n\nprivate:\n    float DistanceTraveled;\n};\n```", "cpp_code": "```cpp\n#include \"SplineFollower.h\"\n#include \"Components/SplineComponent.h\"\n\nASplineFollower::ASplineFollower()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    SplineComponent = CreateDefaultSubobject<USplineComponent>(TEXT(\"SplineComponent\"));\n    RootComponent = SplineComponent;\n\n    Speed = 100.0f;\n    DistanceTraveled = 0.0f;\n}\n\nvoid ASplineFollower::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ASplineFollower::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (!SplineComponent) return;\n\n    DistanceTraveled += Speed * DeltaTime;\n    float SplineLength = SplineComponent->GetSplineLength();\n    if (DistanceTraveled > SplineLength)\n    {\n        DistanceTraveled -= SplineLength;\n    }\n\n    FVector NewLocation = SplineComponent->GetLocationAtDistanceAlongSpline(DistanceTraveled, ESplineCoordinateSpace::World);\n    FRotator NewRotation = SplineComponent->GetRotationAtDistanceAlongSpline(DistanceTraveled, ESplineCoordinateSpace::World);\n\n    SetActorLocation(NewLocation);\n    SetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Set up an actor that changes texture based on time of day.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TextureChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATextureChangeActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\tATextureChangeActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid UpdateTexture();\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* DayMaterial;\n\n\tUPROPERTY(EditAnywhere)\n\tUMaterialInterface* NightMaterial;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat DayStartTime;\n\n\tUPROPERTY(EditAnywhere)\n\tfloat NightStartTime;\n};\n```", "cpp_code": "```cpp\n#include \"TextureChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"Materials/MaterialInterface.h\"\n\nATextureChangeActor::ATextureChangeActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tDayStartTime = 6.0f; // 6 AM\n\tNightStartTime = 18.0f; // 6 PM\n}\n\nvoid ATextureChangeActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUpdateTexture();\n}\n\nvoid ATextureChangeActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tUpdateTexture();\n}\n\nvoid ATextureChangeActor::UpdateTexture()\n{\n\tfloat CurrentHour = GetWorld()->GetTimeSeconds() / 3600.0f;\n\n\tif (CurrentHour >= DayStartTime && CurrentHour < NightStartTime)\n\t{\n\t\tif (DayMaterial)\n\t\t{\n\t\t\tMeshComponent->SetMaterial(0, DayMaterial);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (NightMaterial)\n\t\t{\n\t\t\tMeshComponent->SetMaterial(0, NightMaterial);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Create a basic actor that rotates with the mouse movement.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MouseRotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMouseRotatingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAMouseRotatingActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle mouse input\n\tvoid RotateWithMouse();\n\nprivate:\n\t// Input component\n\tUInputComponent* InputComponent;\n\n\t// Rotation speed factor\n\tUPROPERTY(EditAnywhere, Category = \"Rotation\")\n\tfloat RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MouseRotatingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAMouseRotatingActor::AMouseRotatingActor()\n{\n\t// Set this actor to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize rotation speed\n\tRotationSpeed = 10.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AMouseRotatingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Bind the mouse input\n\tInputComponent = GetWorld()->GetFirstPlayerController()->InputComponent;\n\tif (InputComponent)\n\t{\n\t\tInputComponent->BindAxis(\"Turn\", this, &AMouseRotatingActor::RotateWithMouse);\n\t}\n}\n\n// Called every frame\nvoid AMouseRotatingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Function to handle mouse rotation\nvoid AMouseRotatingActor::RotateWithMouse()\n{\n\tfloat MouseX = InputComponent->GetAxisValue(\"Turn\");\n\tFRotator NewRotation = GetActorRotation();\n\tNewRotation.Yaw += MouseX * RotationSpeed;\n\tSetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Create an actor that toggles between two meshes on input.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AToggleMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAToggleMeshActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to toggle between meshes\n\tvoid ToggleMesh();\n\n\t// Mesh components\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* Mesh1;\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* Mesh2;\n\nprivate:\n\t// Currently active mesh\n\tbool bIsMesh1Active;\n\n\t// Input binding\n\tvoid SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent);\n};\n```", "cpp_code": "```cpp\n#include \"ToggleMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/InputSettings.h\"\n\n// Sets default values\nAToggleMeshActor::AToggleMeshActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize the mesh components\n\tMesh1 = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh1\"));\n\tMesh2 = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh2\"));\n\n\t// Attach the mesh components\n\tRootComponent = Mesh1;\n\tMesh2->SetupAttachment(RootComponent);\n\n\t// Set initial active mesh\n\tbIsMesh1Active = true;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Ensure only one mesh is visible at a time\n\tMesh1->SetVisibility(bIsMesh1Active);\n\tMesh2->SetVisibility(!bIsMesh1Active);\n\n\t// Setup input binding\n\tAPlayerController* PlayerController = GetWorld()->GetFirstPlayerController();\n\tif (PlayerController)\n\t{\n\t\tEnableInput(PlayerController);\n\t\tInputComponent->BindAction(\"ToggleMesh\", IE_Pressed, this, &AToggleMeshActor::ToggleMesh);\n\t}\n}\n\n// Called every frame\nvoid AToggleMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Toggle between the two meshes\nvoid AToggleMeshActor::ToggleMesh()\n{\n\tbIsMesh1Active = !bIsMesh1Active;\n\tMesh1->SetVisibility(bIsMesh1Active);\n\tMesh2->SetVisibility(!bIsMesh1Active);\n}\n\nvoid AToggleMeshActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind the toggle function to input\n\tPlayerInputComponent->BindAction(\"ToggleMesh\", IE_Pressed, this, &AToggleMeshActor::ToggleMesh);\n}\n```"}
{"requirement": "Implement a simple actor that moves towards a light source.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MovingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AMovingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:  \n  AMovingActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:  \n  virtual void Tick(float DeltaTime) override;\n\nprivate:\n  FVector FindClosestLightSource();\n\n  UPROPERTY(EditAnywhere)\n  float MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"MovingActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Components/PointLightComponent.h\"\n\nAMovingActor::AMovingActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n  MovementSpeed = 100.0f;\n}\n\nvoid AMovingActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AMovingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  FVector LightLocation = FindClosestLightSource();\n  FVector Direction = (LightLocation - GetActorLocation()).GetSafeNormal();\n  FVector NewLocation = GetActorLocation() + (Direction * MovementSpeed * DeltaTime);\n\n  SetActorLocation(NewLocation);\n}\n\nFVector AMovingActor::FindClosestLightSource()\n{\n  FVector ClosestLightLocation = FVector::ZeroVector;\n  float MinDistance = FLT_MAX;\n\n  TArray<AActor*> LightSources;\n  UGameplayStatics::GetAllActorsWithComponent(GetWorld(), UPointLightComponent::StaticClass(), LightSources);\n\n  for (AActor* Light : LightSources)\n  {\n    float Distance = FVector::Dist(Light->GetActorLocation(), GetActorLocation());\n    if (Distance < MinDistance)\n    {\n      MinDistance = Distance;\n      ClosestLightLocation = Light->GetActorLocation();\n    }\n  }\n\n  return ClosestLightLocation;\n}\n```"}
{"requirement": "Create an actor that blinks in and out of visibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BlinkingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ABlinkingActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tABlinkingActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ToggleVisibility();\n\n\tFTimerHandle BlinkTimerHandle;\n\n\tUPROPERTY(EditAnywhere, Category = \"Blink\")\n\tfloat BlinkInterval;\n};\n```", "cpp_code": "```cpp\n#include \"BlinkingActor.h\"\n#include \"TimerManager.h\"\n\nABlinkingActor::ABlinkingActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tBlinkInterval = 1.0f; // Default interval of 1 second\n}\n\nvoid ABlinkingActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGetWorldTimerManager().SetTimer(BlinkTimerHandle, this, &ABlinkingActor::ToggleVisibility, BlinkInterval, true);\n}\n\nvoid ABlinkingActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ABlinkingActor::ToggleVisibility()\n{\n\tSetActorHiddenInGame(!IsHidden());\n}\n```"}
{"requirement": "Set up a basic actor that spawns a light at its location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ALightActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ALightActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(EditAnywhere)\n    class UPointLightComponent* PointLight;\n};\n```", "cpp_code": "```cpp\n#include \"LightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nALightActor::ALightActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Create and attach a PointLightComponent\n    PointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n    RootComponent = PointLight;\n}\n\n// Called when the game starts or when spawned\nvoid ALightActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ALightActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n```"}
{"requirement": "Create an actor with a UFUNCTION to reset its position.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ResetPositionActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AResetPositionActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    AResetPositionActor();\n\n    UFUNCTION(BlueprintCallable, Category=\"Position\")\n    void ResetPosition();\n\nprotected:\n    virtual void BeginPlay() override;\n\nprivate:\n    FVector InitialPosition;\n};\n```", "cpp_code": "```cpp\n#include \"ResetPositionActor.h\"\n\nAResetPositionActor::AResetPositionActor()\n{\n    PrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AResetPositionActor::BeginPlay()\n{\n    Super::BeginPlay();\n    InitialPosition = GetActorLocation();\n}\n\nvoid AResetPositionActor::ResetPosition()\n{\n    SetActorLocation(InitialPosition);\n}\n```"}
{"requirement": "Implement a simple actor that changes its name on key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ChangeNameActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AChangeNameActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AChangeNameActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n    \nprivate:\n    void ChangeName();\n\nprotected:\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n};\n```", "cpp_code": "```cpp\n#include \"ChangeNameActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAChangeNameActor::AChangeNameActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AChangeNameActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AChangeNameActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AChangeNameActor::ChangeName()\n{\n    FName NewName = FName(*FString::Printf(TEXT(\"NewActorName_%d\"), FMath::Rand()));\n    this->Rename(*NewName.ToString());\n    UE_LOG(LogTemp, Warning, TEXT(\"Actor's new name: %s\"), *NewName.ToString());\n}\n\nvoid AChangeNameActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n    \n    PlayerInputComponent->BindAction(\"ChangeName\", IE_Pressed, this, &AChangeNameActor::ChangeName);\n}\n```"}
{"requirement": "Create an actor that rotates towards a given point.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    ARotatingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Rotation\")\n    FVector TargetPoint;\n\n    UPROPERTY(EditAnywhere, Category=\"Rotation\")\n    float RotationSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\nARotatingActor::ARotatingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    RotationSpeed = 10.0f;\n}\n\nvoid ARotatingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (TargetPoint != FVector::ZeroVector)\n    {\n        FRotator CurrentRotation = GetActorRotation();\n        FRotator TargetRotation = UKismetMathLibrary::FindLookAtRotation(GetActorLocation(), TargetPoint);\n        FRotator NewRotation = FMath::RInterpTo(CurrentRotation, TargetRotation, DeltaTime, RotationSpeed);\n        SetActorRotation(NewRotation);\n    }\n}\n```"}
{"requirement": "Set up an actor with a countdown timer to destroy itself.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SelfDestructActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASelfDestructActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    ASelfDestructActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Destruction\")\n    float CountdownTime;\n\n    FTimerHandle CountdownTimerHandle;\n\n    void DestroySelf();\n};\n```", "cpp_code": "```cpp\n#include \"SelfDestructActor.h\"\n#include \"TimerManager.h\"\n\nASelfDestructActor::ASelfDestructActor()\n{\n    PrimaryActorTick.bCanEverTick = false;\n    CountdownTime = 5.0f; // Default countdown time in seconds\n}\n\nvoid ASelfDestructActor::BeginPlay()\n{\n    Super::BeginPlay();\n    GetWorldTimerManager().SetTimer(CountdownTimerHandle, this, &ASelfDestructActor::DestroySelf, CountdownTime, false);\n}\n\nvoid ASelfDestructActor::DestroySelf()\n{\n    Destroy();\n}\n```"}
