{"requirement": "Create an actor with a visible mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyVisibleMeshActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyVisibleMeshActor : public AActor\n{\n    GENERATED_BODY()\n\npublic: \n    // Sets default values for this actor's properties\n    AMyVisibleMeshActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyVisibleMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAMyVisibleMeshActor::AMyVisibleMeshActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Create mesh component and set as root\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AMyVisibleMeshActor::BeginPlay()\n{\n    Super::BeginPlay();\n    \n}\n\n// Called every frame\nvoid AMyVisibleMeshActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n```"}
{"requirement": "Add a jump function to a character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    AMyCharacter();\n\nprotected:\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\npublic:\n    void Jump();\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n\nAMyCharacter::AMyCharacter()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    PlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, &AMyCharacter::Jump);\n}\n\nvoid AMyCharacter::Jump()\n{\n    if (CanJump())\n    {\n        ACharacter::Jump();\n    }\n}\n```"}
{"requirement": "Create a rotating actor using a tick function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatingActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    // Sets default values for this actor's properties\n    ARotatingActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Rotation\")\n    FRotator RotationRate;\n};\n```", "cpp_code": "```cpp\n#include \"RotatingActor.h\"\n\n// Sets default values\nARotatingActor::ARotatingActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Initialize the rotation rate\n    RotationRate = FRotator(0.f, 180.f, 0.f);\n}\n\n// Called when the game starts or when spawned\nvoid ARotatingActor::BeginPlay()\n{\n    Super::BeginPlay();\n    \n}\n\n// Called every frame\nvoid ARotatingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    // Rotate the actor\n    AddActorLocalRotation(RotationRate * DeltaTime);\n}\n```"}
{"requirement": "Implement a trigger volume that prints a message when an actor enters.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TriggerVolumeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATriggerVolumeActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    // Sets default values for this actor's properties\n    ATriggerVolumeActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(VisibleAnywhere)\n    class UBoxComponent* TriggerVolume;\n\n    UFUNCTION()\n    void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n};\n```", "cpp_code": "```cpp\n#include \"TriggerVolumeActor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nATriggerVolumeActor::ATriggerVolumeActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    TriggerVolume = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerVolume\"));\n    RootComponent = TriggerVolume;\n\n    TriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &ATriggerVolumeActor::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ATriggerVolumeActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ATriggerVolumeActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ATriggerVolumeActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n    if (OtherActor && (OtherActor != this) && OtherComp)\n    {\n        GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"Actor has entered the trigger volume\"));\n    }\n}\n```"}
{"requirement": "Add a health variable to a character using UPROPERTY.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"YourCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AYourCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this character's properties\n    AYourCharacter();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Called to bind functionality to input\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n    float Health;\n};\n```", "cpp_code": "```cpp\n#include \"YourCharacter.h\"\n\n// Sets default values\nAYourCharacter::AYourCharacter()\n{\n    // Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    Health = 100.0f; // Default health value\n}\n\n// Called when the game starts or when spawned\nvoid AYourCharacter::BeginPlay()\n{\n    Super::BeginPlay();\n    \n}\n\n// Called every frame\nvoid AYourCharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n}\n\n// Called to bind functionality to input\nvoid AYourCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n}\n```"}
{"requirement": "Create a simple pickup item that destroys itself when collected.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PickupItem.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API APickupItem : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    APickupItem();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION()\n    void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    class USphereComponent* CollisionComponent;\n};\n```", "cpp_code": "```cpp\n#include \"PickupItem.h\"\n#include \"Components/SphereComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nAPickupItem::APickupItem()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    CollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"CollisionComponent\"));\n    RootComponent = CollisionComponent;\n\n    CollisionComponent->SetSphereRadius(50.0f);\n    CollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &APickupItem::OnOverlapBegin);\n}\n\nvoid APickupItem::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid APickupItem::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid APickupItem::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n    if (OtherActor && OtherActor != this && OtherComp)\n    {\n        Destroy();\n    }\n}\n```"}
{"requirement": "Implement a floating movement component for an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FloatingMovementComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURPROJECT_API UFloatingMovementComponent : public UActorComponent\n{\n\tGENERATED_BODY()\n\npublic: \n\tUFloatingMovementComponent();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\nprivate:\n\tUPROPERTY(EditAnywhere, Category=\"Floating\")\n\tfloat FloatSpeed = 20.0f;\n\n\tUPROPERTY(EditAnywhere, Category=\"Floating\")\n\tfloat Amplitude = 50.0f;\n\n\tFVector InitialLocation;\n};\n```", "cpp_code": "```cpp\n#include \"FloatingMovementComponent.h\"\n#include \"GameFramework/Actor.h\"\n\nUFloatingMovementComponent::UFloatingMovementComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UFloatingMovementComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Save the initial location of the actor\n\tInitialLocation = GetOwner()->GetActorLocation();\n}\n\nvoid UFloatingMovementComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (!GetOwner()) return;\n\n\t// Calculate new location\n\tFVector NewLocation = InitialLocation;\n\tNewLocation.Z += Amplitude * FMath::Sin(FloatSpeed * GetWorld()->GetTimeSeconds());\n\n\t// Update Actor's location\n\tGetOwner()->SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Add a function to change the material of a mesh.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AYourActor();\n\n  UFUNCTION(BlueprintCallable, Category = \"Mesh\")\n  void ChangeMeshMaterial(UMeshComponent* MeshComponent, UMaterialInterface* NewMaterial);\n};\n```", "cpp_code": "```cpp\n#include \"YourActor.h\"\n\nAYourActor::AYourActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AYourActor::ChangeMeshMaterial(UMeshComponent* MeshComponent, UMaterialInterface* NewMaterial)\n{\n  if (MeshComponent && NewMaterial)\n  {\n    MeshComponent->SetMaterial(0, NewMaterial);\n  }\n}\n```"}
{"requirement": "Bind a key to print a message in the log.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"KeyBindingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AKeyBindingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AKeyBindingActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n  void PrintMessage();\n};\n```", "cpp_code": "```cpp\n#include \"KeyBindingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/Engine.h\"\n\nAKeyBindingActor::AKeyBindingActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AKeyBindingActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AKeyBindingActor::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n  Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n  PlayerInputComponent->BindAction(\"PrintMessage\", IE_Pressed, this, &AKeyBindingActor::PrintMessage);\n}\n\nvoid AKeyBindingActor::PrintMessage()\n{\n  if (GEngine)\n  {\n    GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"Key Pressed: Print Message\"));\n    UE_LOG(LogTemp, Warning, TEXT(\"Key Pressed: Print Message\"));\n  }\n}\n```"}
{"requirement": "Create a door actor that opens and closes with a toggle function.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DoorActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADoorActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tADoorActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Door\")\n\tvoid ToggleDoor();\n\nprivate:\n\tbool bIsOpen;\n\n\tUPROPERTY(EditAnywhere)\n\tFRotator OpenRotation;\n\n\tUPROPERTY(EditAnywhere)\n\tFRotator ClosedRotation;\n\n\tvoid OpenDoor();\n\tvoid CloseDoor();\n};\n```", "cpp_code": "```cpp\n#include \"DoorActor.h\"\n\n// Sets default values\nADoorActor::ADoorActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tbIsOpen = false;\n\n\t// Define default rotations\n\tOpenRotation = FRotator(0.f, 90.f, 0.f);\n\tClosedRotation = FRotator(0.f, 0.f, 0.f);\n}\n\n// Called when the game starts or when spawned\nvoid ADoorActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ADoorActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ADoorActor::ToggleDoor()\n{\n\tif (bIsOpen)\n\t{\n\t\tCloseDoor();\n\t}\n\telse\n\t{\n\t\tOpenDoor();\n\t}\n}\n\nvoid ADoorActor::OpenDoor()\n{\n\tSetActorRotation(OpenRotation);\n\tbIsOpen = true;\n}\n\nvoid ADoorActor::CloseDoor()\n{\n\tSetActorRotation(ClosedRotation);\n\tbIsOpen = false;\n}\n```"}
{"requirement": "Implement a timer that prints a message every second.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerExample.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ATimerExample : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    ATimerExample();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    FTimerHandle TimerHandle;\n    void PrintMessage();\n};\n```", "cpp_code": "```cpp\n#include \"TimerExample.h\"\n#include \"Engine/Engine.h\"\n\nATimerExample::ATimerExample()\n{\n     PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ATimerExample::BeginPlay()\n{\n    Super::BeginPlay();\n    \n    GetWorldTimerManager().SetTimer(TimerHandle, this, &ATimerExample::PrintMessage, 1.0f, true);\n}\n\nvoid ATimerExample::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ATimerExample::PrintMessage()\n{\n    if (GEngine)\n    {\n        GEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Green, TEXT(\"Message printed every second\"));\n    }\n}\n```"}
{"requirement": "Create a light actor that changes color over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangingLight.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AColorChangingLight : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    AColorChangingLight();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    class UPointLightComponent* PointLight;\n\n    FLinearColor CurrentColor;\n    float TimeAccumulator;\n    float ColorChangeRate;\n\n    void UpdateLightColor(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangingLight.h\"\n#include \"Components/PointLightComponent.h\"\n\nAColorChangingLight::AColorChangingLight()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    PointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n    RootComponent = PointLight;\n\n    CurrentColor = FLinearColor::Red;\n    TimeAccumulator = 0.0f;\n    ColorChangeRate = 1.0f; // Change color every second\n}\n\nvoid AColorChangingLight::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AColorChangingLight::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    UpdateLightColor(DeltaTime);\n}\n\nvoid AColorChangingLight::UpdateLightColor(float DeltaTime)\n{\n    TimeAccumulator += DeltaTime;\n\n    if (TimeAccumulator >= ColorChangeRate)\n    {\n        TimeAccumulator = 0.0f;\n\n        // Cycle through colors: Red -> Green -> Blue -> Red\n        if (CurrentColor == FLinearColor::Red)\n        {\n            CurrentColor = FLinearColor::Green;\n        }\n        else if (CurrentColor == FLinearColor::Green)\n        {\n            CurrentColor = FLinearColor::Blue;\n        }\n        else if (CurrentColor == FLinearColor::Blue)\n        {\n            CurrentColor = FLinearColor::Red;\n        }\n    }\n\n    PointLight->SetLightColor(CurrentColor);\n}\n```"}
{"requirement": "Add a function to increase a character's speed temporarily.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SpeedBoostCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API ASpeedBoostCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    ASpeedBoostCharacter();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic: \n    virtual void Tick(float DeltaTime) override;\n\n    void IncreaseSpeedTemporarily(float SpeedMultiplier, float Duration);\n\nprivate:\n    void ResetSpeed();\n\n    FTimerHandle SpeedBoostTimerHandle;\n    float OriginalSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"SpeedBoostCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"TimerManager.h\"\n\nASpeedBoostCharacter::ASpeedBoostCharacter()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ASpeedBoostCharacter::BeginPlay()\n{\n    Super::BeginPlay();\n    OriginalSpeed = GetCharacterMovement()->MaxWalkSpeed;\n}\n\nvoid ASpeedBoostCharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ASpeedBoostCharacter::IncreaseSpeedTemporarily(float SpeedMultiplier, float Duration)\n{\n    GetCharacterMovement()->MaxWalkSpeed *= SpeedMultiplier;\n    GetWorldTimerManager().SetTimer(SpeedBoostTimerHandle, this, &ASpeedBoostCharacter::ResetSpeed, Duration, false);\n}\n\nvoid ASpeedBoostCharacter::ResetSpeed()\n{\n    GetCharacterMovement()->MaxWalkSpeed = OriginalSpeed;\n    GetWorldTimerManager().ClearTimer(SpeedBoostTimerHandle);\n}\n```"}
{"requirement": "Create a simple camera shake effect.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Camera/CameraShakeBase.h\"\n#include \"SimpleCameraShake.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API USimpleCameraShake : public UCameraShakeBase\n{\n    GENERATED_BODY()\n\npublic:\n    USimpleCameraShake();\n};\n```", "cpp_code": "```cpp\n#include \"SimpleCameraShake.h\"\n\nUSimpleCameraShake::USimpleCameraShake()\n{\n    OscillationDuration = 0.25f;\n    OscillationBlendInTime = 0.05f;\n    OscillationBlendOutTime = 0.05f;\n\n    RotOscillation.Pitch.Amplitude = 10.0f;\n    RotOscillation.Pitch.Frequency = 5.0f;\n\n    RotOscillation.Yaw.Amplitude = 10.0f;\n    RotOscillation.Yaw.Frequency = 5.0f;\n\n    RotOscillation.Roll.Amplitude = 0.0f;\n    RotOscillation.Roll.Frequency = 0.0f;\n}\n```"}
{"requirement": "Implement a HUD element that displays player health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/HUD.h\"\n#include \"PlayerHealthHUD.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APlayerHealthHUD : public AHUD\n{\n\tGENERATED_BODY()\n\npublic:\n\tAPlayerHealthHUD();\n\nprotected:\n\tvirtual void DrawHUD() override;\n\nprivate:\n\tvoid DrawHealthBar();\n\n\t// Example health value, replace with actual player health retrieval\n\tfloat PlayerHealth;\n\tfloat MaxPlayerHealth;\n\n\t// Health bar properties\n\tFVector2D HealthBarPosition;\n\tFVector2D HealthBarSize;\n\tFLinearColor HealthBarColor;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerHealthHUD.h\"\n#include \"Engine/Canvas.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAPlayerHealthHUD::APlayerHealthHUD()\n{\n\t// Initialize default values\n\tPlayerHealth = 100.0f;\n\tMaxPlayerHealth = 100.0f;\n\tHealthBarPosition = FVector2D(50, 50);\n\tHealthBarSize = FVector2D(200, 25);\n\tHealthBarColor = FLinearColor::Green;\n}\n\nvoid APlayerHealthHUD::DrawHUD()\n{\n\tSuper::DrawHUD();\n\n\t// Update PlayerHealth here with actual data\n\n\tDrawHealthBar();\n}\n\nvoid APlayerHealthHUD::DrawHealthBar()\n{\n\t// Calculate the width of the health bar based on current health\n\tfloat HealthPercentage = PlayerHealth / MaxPlayerHealth;\n\tfloat HealthBarWidth = HealthBarSize.X * HealthPercentage;\n\n\t// Draw the health bar background\n\tFCanvasTileItem BackgroundTile(HealthBarPosition, HealthBarSize, FLinearColor::Black);\n\tBackgroundTile.BlendMode = SE_BLEND_Translucent;\n\tCanvas->DrawItem(BackgroundTile);\n\n\t// Draw the health bar\n\tFCanvasTileItem HealthTile(HealthBarPosition, FVector2D(HealthBarWidth, HealthBarSize.Y), HealthBarColor);\n\tHealthTile.BlendMode = SE_BLEND_Translucent;\n\tCanvas->DrawItem(HealthTile);\n}\n```"}
{"requirement": "Create a basic inventory system with an array of items.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InventorySystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FInventoryItem\n{\n    GENERATED_BODY()\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Inventory\")\n    FString ItemName;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Inventory\")\n    int32 Quantity;\n\n    FInventoryItem() : ItemName(\"\"), Quantity(0) {}\n};\n\nUCLASS()\nclass AInventorySystem : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AInventorySystem();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Inventory\")\n    TArray<FInventoryItem> Items;\n\n    UFUNCTION(BlueprintCallable, Category=\"Inventory\")\n    void AddItem(const FString& ItemName, int32 Quantity);\n};\n```", "cpp_code": "```cpp\n#include \"InventorySystem.h\"\n\nAInventorySystem::AInventorySystem()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AInventorySystem::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AInventorySystem::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AInventorySystem::AddItem(const FString& ItemName, int32 Quantity)\n{\n    for (FInventoryItem& Item : Items)\n    {\n        if (Item.ItemName == ItemName)\n        {\n            Item.Quantity += Quantity;\n            return;\n        }\n    }\n    FInventoryItem NewItem;\n    NewItem.ItemName = ItemName;\n    NewItem.Quantity = Quantity;\n    Items.Add(NewItem);\n}\n```"}
{"requirement": "Add a sound effect that plays when an actor is clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Sound/SoundBase.h\"\n#include \"ClickableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AClickableActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AClickableActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sound\")\n    USoundBase* ClickSound;\n\n    UFUNCTION()\n    void OnClicked(AActor* TouchedActor, FKey ButtonPressed);\n};\n```", "cpp_code": "```cpp\n#include \"ClickableActor.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\nAClickableActor::AClickableActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    OnClicked.AddDynamic(this, &AClickableActor::OnClicked);\n}\n\nvoid AClickableActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AClickableActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AClickableActor::OnClicked(AActor* TouchedActor, FKey ButtonPressed)\n{\n    if (ClickSound)\n    {\n        UGameplayStatics::PlaySoundAtLocation(this, ClickSound, GetActorLocation());\n    }\n}\n```"}
{"requirement": "Implement a simple save and load system for player score.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/SaveGame.h\"\n#include \"PlayerScoreSaveGame.generated.h\"\n\nUCLASS()\nclass YOURGAME_API UPlayerScoreSaveGame : public USaveGame\n{\n    GENERATED_BODY()\n\npublic:\n    UPlayerScoreSaveGame();\n\n    UPROPERTY(VisibleAnywhere, Category = Basic)\n    int32 PlayerScore;\n};\n\nUCLASS()\nclass YOURGAME_API AYourGameGameModeBase : public AGameModeBase\n{\n    GENERATED_BODY()\n\npublic:\n    void SavePlayerScore(int32 Score);\n    int32 LoadPlayerScore();\n};\n```", "cpp_code": "```cpp\n#include \"PlayerScoreSaveGame.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nUPlayerScoreSaveGame::UPlayerScoreSaveGame()\n{\n    PlayerScore = 0;\n}\n\nvoid AYourGameGameModeBase::SavePlayerScore(int32 Score)\n{\n    UPlayerScoreSaveGame* SaveGameInstance = Cast<UPlayerScoreSaveGame>(UGameplayStatics::CreateSaveGameObject(UPlayerScoreSaveGame::StaticClass()));\n    if (SaveGameInstance)\n    {\n        SaveGameInstance->PlayerScore = Score;\n        UGameplayStatics::SaveGameToSlot(SaveGameInstance, TEXT(\"PlayerScoreSlot\"), 0);\n    }\n}\n\nint32 AYourGameGameModeBase::LoadPlayerScore()\n{\n    UPlayerScoreSaveGame* LoadGameInstance = Cast<UPlayerScoreSaveGame>(UGameplayStatics::LoadGameFromSlot(TEXT(\"PlayerScoreSlot\"), 0));\n    if (LoadGameInstance)\n    {\n        return LoadGameInstance->PlayerScore;\n    }\n    return 0;\n}\n```"}
{"requirement": "Create a projectile that moves forward when spawned.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Projectile.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AProjectile : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AProjectile();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaTime) override;\n\n  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n  UStaticMeshComponent* ProjectileMesh;\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Movement\")\n  float MovementSpeed;\n};\n```", "cpp_code": "```cpp\n#include \"Projectile.h\"\n#include \"GameFramework/ProjectileMovementComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nAProjectile::AProjectile()\n{\n  PrimaryActorTick.bCanEverTick = true;\n\n  ProjectileMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"ProjectileMesh\"));\n  RootComponent = ProjectileMesh;\n\n  MovementSpeed = 1000.0f;\n}\n\nvoid AProjectile::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AProjectile::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n  FVector NewLocation = GetActorLocation() + GetActorForwardVector() * MovementSpeed * DeltaTime;\n  SetActorLocation(NewLocation);\n}\n```"}
{"requirement": "Add a function to check if a character is in the air.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    // Function to check if the character is in the air\n    UFUNCTION(BlueprintCallable, Category=\"Character\")\n    bool IsInAir() const;\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n\nbool AMyCharacter::IsInAir() const\n{\n    return GetCharacterMovement()->IsFalling();\n}\n```"}
{"requirement": "Implement a basic countdown timer on the HUD.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/HUD.h\"\n#include \"CountdownTimerHUD.generated.h\"\n\nUCLASS()\nclass MYGAME_API ACountdownTimerHUD : public AHUD\n{\n    GENERATED_BODY()\n\npublic:\n    ACountdownTimerHUD();\n\n    virtual void DrawHUD() override;\n\nprotected:\n    virtual void BeginPlay() override;\n\nprivate:\n    float CountdownTime;\n    FText CountdownText;\n    FTimerHandle CountdownTimerHandle;\n\n    void UpdateCountdownDisplay();\n    void CountdownHasFinished();\n};\n```", "cpp_code": "```cpp\n#include \"CountdownTimerHUD.h\"\n#include \"Engine/Canvas.h\"\n#include \"Engine/Font.h\"\n#include \"TimerManager.h\"\n\nACountdownTimerHUD::ACountdownTimerHUD()\n{\n    CountdownTime = 60.0f; // Set initial countdown time in seconds\n}\n\nvoid ACountdownTimerHUD::BeginPlay()\n{\n    Super::BeginPlay();\n\n    // Start the countdown timer\n    GetWorldTimerManager().SetTimer(CountdownTimerHandle, this, &ACountdownTimerHUD::UpdateCountdownDisplay, 1.0f, true);\n}\n\nvoid ACountdownTimerHUD::DrawHUD()\n{\n    Super::DrawHUD();\n\n    // Draw the countdown timer text on the screen\n    if (GEngine && GEngine->GetMediumFont())\n    {\n        FVector2D ScreenDimensions = FVector2D(Canvas->SizeX, Canvas->SizeY);\n        FVector2D TextSize;\n        GetTextSize(CountdownText.ToString(), TextSize.X, TextSize.Y, GEngine->GetMediumFont());\n        FVector2D TextPosition = FVector2D(ScreenDimensions.X / 2.0f - TextSize.X / 2.0f, 50.0f);\n        FCanvasTextItem TextItem(TextPosition, CountdownText, GEngine->GetMediumFont(), FLinearColor::White);\n        Canvas->DrawItem(TextItem);\n    }\n}\n\nvoid ACountdownTimerHUD::UpdateCountdownDisplay()\n{\n    if (CountdownTime > 0)\n    {\n        CountdownTime--;\n        CountdownText = FText::FromString(FString::Printf(TEXT(\"Time Remaining: %d\"), FMath::CeilToInt(CountdownTime)));\n    }\n    else\n    {\n        CountdownHasFinished();\n    }\n}\n\nvoid ACountdownTimerHUD::CountdownHasFinished()\n{\n    GetWorldTimerManager().ClearTimer(CountdownTimerHandle);\n    CountdownText = FText::FromString(TEXT(\"Time's Up!\"));\n}\n```"}
{"requirement": "Create a character that can crouch with a key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"CrouchingCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ACrouchingCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tACrouchingCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \t\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid StartCrouch();\n\tvoid StopCrouch();\n};\n```", "cpp_code": "```cpp\n#include \"CrouchingCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nACrouchingCharacter::ACrouchingCharacter()\n{\n\t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ACrouchingCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACrouchingCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid ACrouchingCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"Crouch\", IE_Pressed, this, &ACrouchingCharacter::StartCrouch);\n\tPlayerInputComponent->BindAction(\"Crouch\", IE_Released, this, &ACrouchingCharacter::StopCrouch);\n}\n\nvoid ACrouchingCharacter::StartCrouch()\n{\n\tCrouch();\n}\n\nvoid ACrouchingCharacter::StopCrouch()\n{\n\tUnCrouch();\n}\n```"}
{"requirement": "Add a function to respawn a character at a specific location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyCharacter : public ACharacter\n{\n  GENERATED_BODY()\n\npublic:\n  // Sets default values for this character's properties\n  AMyCharacter();\n\n  // Function to respawn the character at a specific location\n  UFUNCTION(BlueprintCallable, Category = \"Respawn\")\n  void RespawnAtLocation(const FVector& NewLocation);\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n\n// Sets default values\nAMyCharacter::AMyCharacter()\n{\n  // Set this character to call Tick() every frame.\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyCharacter::RespawnAtLocation(const FVector& NewLocation)\n{\n  // Set the new location for the character\n  SetActorLocation(NewLocation);\n\n  // Additional logic for respawning can be added here\n}\n```"}
{"requirement": "Implement a simple fade-in effect on level start.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FadeInEffect.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AFadeInEffect : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AFadeInEffect();\n\nprotected:\n    virtual void BeginPlay() override;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Fade\")\n    float FadeDuration;\n\n    UFUNCTION()\n    void StartFadeIn();\n};\n```", "cpp_code": "```cpp\n#include \"FadeInEffect.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Engine/World.h\"\n\nAFadeInEffect::AFadeInEffect()\n{\n    PrimaryActorTick.bCanEverTick = false;\n    FadeDuration = 2.0f; // Default fade duration\n}\n\nvoid AFadeInEffect::BeginPlay()\n{\n    Super::BeginPlay();\n    StartFadeIn();\n}\n\nvoid AFadeInEffect::StartFadeIn()\n{\n    APlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n    if (PlayerController)\n    {\n        PlayerController->PlayerCameraManager->StartCameraFade(1.0f, 0.0f, FadeDuration, FLinearColor::Black);\n    }\n}\n```"}
{"requirement": "Create a basic day-night cycle with a directional light.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DayNightCycle.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADayNightCycle : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ADayNightCycle();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category = \"DayNight\")\n    float DayLengthInSeconds;\n\n    UPROPERTY(EditAnywhere, Category = \"DayNight\")\n    ADirectionalLight* DirectionalLight;\n\n    float CurrentTimeOfDay;\n};\n```", "cpp_code": "```cpp\n#include \"DayNightCycle.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/DirectionalLight.h\"\n\nADayNightCycle::ADayNightCycle()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    DayLengthInSeconds = 120.0f; // 2 minutes for a full cycle\n    CurrentTimeOfDay = 0.0f;\n}\n\nvoid ADayNightCycle::BeginPlay()\n{\n    Super::BeginPlay();\n    if (DirectionalLight == nullptr)\n    {\n        UE_LOG(LogTemp, Warning, TEXT(\"DirectionalLight not set on DayNightCycle.\"));\n    }\n}\n\nvoid ADayNightCycle::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (DirectionalLight)\n    {\n        CurrentTimeOfDay += DeltaTime;\n        if (CurrentTimeOfDay >= DayLengthInSeconds)\n        {\n            CurrentTimeOfDay = 0.0f;\n        }\n\n        float SunAngle = (CurrentTimeOfDay / DayLengthInSeconds) * 360.0f;\n        FRotator NewRotation = FRotator(SunAngle, 0.0f, 0.0f);\n        DirectionalLight->SetActorRotation(NewRotation);\n    }\n}\n```"}
{"requirement": "Add a function to pause and resume the game.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"PauseGameMode.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APauseGameMode : public AGameModeBase\n{\n    GENERATED_BODY()\n\npublic:\n    APauseGameMode();\n\n    UFUNCTION(BlueprintCallable, Category = \"Game\")\n    void PauseGame();\n\n    UFUNCTION(BlueprintCallable, Category = \"Game\")\n    void ResumeGame();\n\nprivate:\n    bool bIsGamePaused;\n};\n```", "cpp_code": "```cpp\n#include \"PauseGameMode.h\"\n\nAPauseGameMode::APauseGameMode()\n{\n    bIsGamePaused = false;\n}\n\nvoid APauseGameMode::PauseGame()\n{\n    if (!bIsGamePaused)\n    {\n        UGameplayStatics::SetGamePaused(GetWorld(), true);\n        bIsGamePaused = true;\n    }\n}\n\nvoid APauseGameMode::ResumeGame()\n{\n    if (bIsGamePaused)\n    {\n        UGameplayStatics::SetGamePaused(GetWorld(), false);\n        bIsGamePaused = false;\n    }\n}\n```"}
{"requirement": "Implement a basic score system using integers.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AScoreSystem : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AScoreSystem();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category = \"Score\")\n    void AddScore(int32 Points);\n\n    UFUNCTION(BlueprintCallable, Category = \"Score\")\n    int32 GetScore() const;\n\nprivate:\n    int32 Score;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreSystem.h\"\n\nAScoreSystem::AScoreSystem()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    Score = 0;\n}\n\nvoid AScoreSystem::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AScoreSystem::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AScoreSystem::AddScore(int32 Points)\n{\n    Score += Points;\n}\n\nint32 AScoreSystem::GetScore() const\n{\n    return Score;\n}\n```"}
{"requirement": "Create a flashlight effect that toggles on and off.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Flashlight.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFlashlight : public AActor\n{\n    GENERATED_BODY()\n    \npublic:\n    // Sets default values for this actor's properties\n    AFlashlight();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Function to toggle the flashlight\n    UFUNCTION(BlueprintCallable, Category=\"Flashlight\")\n    void ToggleFlashlight();\n\nprivate:\n    // Point light component for the flashlight\n    UPROPERTY(VisibleAnywhere, Category=\"Components\")\n    class UPointLightComponent* FlashlightLight;\n\n    // Whether the flashlight is currently on\n    bool bIsFlashlightOn;\n};\n```", "cpp_code": "```cpp\n#include \"Flashlight.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nAFlashlight::AFlashlight()\n{\n    // Set this actor to call Tick() every frame\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Create Point Light Component\n    FlashlightLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"FlashlightLight\"));\n    RootComponent = FlashlightLight;\n\n    // Initialize the flashlight to be off\n    bIsFlashlightOn = false;\n    FlashlightLight->SetVisibility(bIsFlashlightOn);\n}\n\n// Called when the game starts or when spawned\nvoid AFlashlight::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid AFlashlight::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\n// Toggle the flashlight on and off\nvoid AFlashlight::ToggleFlashlight()\n{\n    bIsFlashlightOn = !bIsFlashlightOn;\n    FlashlightLight->SetVisibility(bIsFlashlightOn);\n}\n```"}
{"requirement": "Add a collision event that changes an actor's color.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollisionColorChangeActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACollisionColorChangeActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ACollisionColorChangeActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n\n    UFUNCTION()\n    void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n};\n```", "cpp_code": "```cpp\n#include \"CollisionColorChangeActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Materials/MaterialInstanceDynamic.h\"\n\n// Sets default values\nACollisionColorChangeActor::ACollisionColorChangeActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    MeshComponent->SetNotifyRigidBodyCollision(true);\n    MeshComponent->OnComponentHit.AddDynamic(this, &ACollisionColorChangeActor::OnHit);\n}\n\n// Called when the game starts or when spawned\nvoid ACollisionColorChangeActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ACollisionColorChangeActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ACollisionColorChangeActor::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n    if (MeshComponent)\n    {\n        UMaterialInstanceDynamic* DynamicMaterial = MeshComponent->CreateAndSetMaterialInstanceDynamic(0);\n        if (DynamicMaterial)\n        {\n            FLinearColor NewColor = FLinearColor::MakeRandomColor();\n            DynamicMaterial->SetVectorParameterValue(\"BaseColor\", NewColor);\n        }\n    }\n}\n```"}
{"requirement": "Implement a basic sprint mechanic for a character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SprintCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASprintCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this character's properties\n\tASprintCharacter();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Called to bind functionality to input\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\t// Sprint speed multiplier\n\tUPROPERTY(EditAnywhere, Category=\"Sprint\")\n\tfloat SprintMultiplier;\n\n\t// Default movement speed\n\tfloat DefaultWalkSpeed;\n\n\t// Function to start sprinting\n\tvoid StartSprinting();\n\n\t// Function to stop sprinting\n\tvoid StopSprinting();\n};\n```", "cpp_code": "```cpp\n#include \"SprintCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/InputComponent.h\"\n\n// Sets default values\nASprintCharacter::ASprintCharacter()\n{\n\t// Set this character to call Tick() every frame\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Initialize sprint multiplier\n\tSprintMultiplier = 2.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASprintCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Save the default walk speed\n\tDefaultWalkSpeed = GetCharacterMovement()->MaxWalkSpeed;\n}\n\n// Called every frame\nvoid ASprintCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid ASprintCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Bind sprint actions\n\tPlayerInputComponent->BindAction(\"Sprint\", IE_Pressed, this, &ASprintCharacter::StartSprinting);\n\tPlayerInputComponent->BindAction(\"Sprint\", IE_Released, this, &ASprintCharacter::StopSprinting);\n}\n\nvoid ASprintCharacter::StartSprinting()\n{\n\t// Increase the character's speed\n\tGetCharacterMovement()->MaxWalkSpeed = DefaultWalkSpeed * SprintMultiplier;\n}\n\nvoid ASprintCharacter::StopSprinting()\n{\n\t// Reset the character's speed to default\n\tGetCharacterMovement()->MaxWalkSpeed = DefaultWalkSpeed;\n}\n```"}
{"requirement": "Create a simple health pickup that restores health.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthPickup.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHealthPickup : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    AHealthPickup();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\")\n    float HealthAmount;\n\n    UFUNCTION()\n    void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    class UBoxComponent* CollisionComponent;\n\n    UPROPERTY(VisibleAnywhere)\n    class UStaticMeshComponent* PickupMesh;\n};\n```", "cpp_code": "```cpp\n#include \"HealthPickup.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourGameCharacter.h\"  // Replace with your character class\n\nAHealthPickup::AHealthPickup()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    CollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"CollisionComponent\"));\n    RootComponent = CollisionComponent;\n    CollisionComponent->SetCollisionProfileName(TEXT(\"OverlapAll\"));\n    CollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AHealthPickup::OnOverlapBegin);\n\n    PickupMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"PickupMesh\"));\n    PickupMesh->SetupAttachment(RootComponent);\n\n    HealthAmount = 50.0f;  // Default health amount\n}\n\nvoid AHealthPickup::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AHealthPickup::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AHealthPickup::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n    if (OtherActor && OtherActor != this)\n    {\n        AYourGameCharacter* Character = Cast<AYourGameCharacter>(OtherActor);  // Replace with your character class\n        if (Character)\n        {\n            Character->ChangeHealth(HealthAmount);  // Assumes your character has a ChangeHealth function\n            Destroy();  // Destroy the pickup after use\n        }\n    }\n}\n```"}
{"requirement": "Add a function to play an animation on an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AMyActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category=\"Animation\")\n    void PlayAnimation(UAnimSequence* AnimationToPlay);\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Animation\")\n    USkeletalMeshComponent* SkeletalMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyActor.h\"\n#include \"Animation/AnimSequence.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n\nAMyActor::AMyActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    SkeletalMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"SkeletalMeshComponent\"));\n    RootComponent = SkeletalMeshComponent;\n}\n\nvoid AMyActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AMyActor::PlayAnimation(UAnimSequence* AnimationToPlay)\n{\n    if (SkeletalMeshComponent && AnimationToPlay)\n    {\n        SkeletalMeshComponent->PlayAnimation(AnimationToPlay, false);\n    }\n}\n```"}
{"requirement": "Implement a basic zoom feature for the player camera.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ZoomCameraComponent.generated.h\"\n\nUCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\nclass YOURGAME_API UZoomCameraComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic:    \n    UZoomCameraComponent();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Zoom\")\n    float ZoomedFOV;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Zoom\")\n    float ZoomInterpSpeed;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Zoom\")\n    float DefaultFOV;\n\n    void ZoomIn();\n    void ZoomOut();\n\nprivate:\n    bool bIsZoomedIn;\n    class UCameraComponent* CameraComponent;\n};\n```", "cpp_code": "```cpp\n#include \"ZoomCameraComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Camera/CameraComponent.h\"\n\nUZoomCameraComponent::UZoomCameraComponent()\n{\n    PrimaryComponentTick.bCanEverTick = true;\n\n    ZoomedFOV = 65.0f;\n    ZoomInterpSpeed = 20.0f;\n    DefaultFOV = 90.0f;\n    bIsZoomedIn = false;\n}\n\nvoid UZoomCameraComponent::BeginPlay()\n{\n    Super::BeginPlay();\n\n    CameraComponent = GetOwner()->FindComponentByClass<UCameraComponent>();\n    if (CameraComponent)\n    {\n        DefaultFOV = CameraComponent->FieldOfView;\n    }\n}\n\nvoid UZoomCameraComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n    if (CameraComponent)\n    {\n        float TargetFOV = bIsZoomedIn ? ZoomedFOV : DefaultFOV;\n        float CurrentFOV = CameraComponent->FieldOfView;\n        CameraComponent->SetFieldOfView(FMath::FInterpTo(CurrentFOV, TargetFOV, DeltaTime, ZoomInterpSpeed));\n    }\n}\n\nvoid UZoomCameraComponent::ZoomIn()\n{\n    bIsZoomedIn = true;\n}\n\nvoid UZoomCameraComponent::ZoomOut()\n{\n    bIsZoomedIn = false;\n}\n```"}
{"requirement": "Create a bounce effect when an actor hits the ground.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BouncingActor.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ABouncingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    ABouncingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Bounce\")\n    float BounceFactor;\n\n    UFUNCTION()\n    void OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UStaticMeshComponent* MeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"BouncingActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nABouncingActor::ABouncingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n    MeshComponent->SetSimulatePhysics(true);\n    MeshComponent->SetNotifyRigidBodyCollision(true);\n\n    BounceFactor = 1.0f;\n\n    MeshComponent->OnComponentHit.AddDynamic(this, &ABouncingActor::OnHit);\n}\n\nvoid ABouncingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ABouncingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ABouncingActor::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n    if (OtherActor && (OtherActor != this) && OtherComp)\n    {\n        FVector BounceVelocity = -NormalImpulse * BounceFactor;\n        MeshComponent->AddImpulse(BounceVelocity, NAME_None, true);\n    }\n}\n```"}
{"requirement": "Add a function to randomly change an actor's location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RandomLocationActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARandomLocationActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tARandomLocationActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"RandomLocation\")\n\tvoid ChangeLocationRandomly();\n\nprivate:\n\tFVector GetRandomLocationWithinBounds(const FVector& MinBounds, const FVector& MaxBounds) const;\n\n\tUPROPERTY(EditAnywhere, Category=\"RandomLocation\")\n\tFVector MinBounds;\n\n\tUPROPERTY(EditAnywhere, Category=\"RandomLocation\")\n\tFVector MaxBounds;\n};\n```", "cpp_code": "```cpp\n#include \"RandomLocationActor.h\"\n#include \"Engine/World.h\"\n#include \"Math/UnrealMathUtility.h\"\n\n// Sets default values\nARandomLocationActor::ARandomLocationActor()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Set default bounds\n\tMinBounds = FVector(-1000.0f, -1000.0f, 0.0f);\n\tMaxBounds = FVector(1000.0f, 1000.0f, 500.0f);\n}\n\n// Called when the game starts or when spawned\nvoid ARandomLocationActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ARandomLocationActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ARandomLocationActor::ChangeLocationRandomly()\n{\n\tFVector NewLocation = GetRandomLocationWithinBounds(MinBounds, MaxBounds);\n\tSetActorLocation(NewLocation);\n}\n\nFVector ARandomLocationActor::GetRandomLocationWithinBounds(const FVector& MinBounds, const FVector& MaxBounds) const\n{\n\tfloat RandomX = FMath::FRandRange(MinBounds.X, MaxBounds.X);\n\tfloat RandomY = FMath::FRandRange(MinBounds.Y, MaxBounds.Y);\n\tfloat RandomZ = FMath::FRandRange(MinBounds.Z, MaxBounds.Z);\n\treturn FVector(RandomX, RandomY, RandomZ);\n}\n```"}
{"requirement": "Implement a simple fire rate control for a weapon.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Weapon.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AWeapon : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AWeapon();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Function to fire the weapon\n    void Fire();\n\nprivate:\n    // Fire rate in rounds per second\n    UPROPERTY(EditAnywhere, Category = \"Weapon\")\n    float FireRate;\n\n    // Time since last fire\n    float TimeSinceLastFire;\n};\n```", "cpp_code": "```cpp\n#include \"Weapon.h\"\n#include \"TimerManager.h\"\n\n// Sets default values\nAWeapon::AWeapon()\n{\n    // Set this actor to call Tick() every frame\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Initialize fire rate and timer\n    FireRate = 1.0f; // 1 round per second\n    TimeSinceLastFire = 0.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AWeapon::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid AWeapon::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    // Update time since last fire\n    TimeSinceLastFire += DeltaTime;\n}\n\nvoid AWeapon::Fire()\n{\n    if (TimeSinceLastFire >= 1.0f / FireRate)\n    {\n        // Fire the weapon\n        UE_LOG(LogTemp, Warning, TEXT(\"Weapon Fired!\"));\n\n        // Reset the timer\n        TimeSinceLastFire = 0.0f;\n    }\n    else\n    {\n        UE_LOG(LogTemp, Warning, TEXT(\"Weapon can't fire yet!\"));\n    }\n}\n```"}
{"requirement": "Create a character that can swim when in water.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SwimmableCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASwimmableCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    ASwimmableCharacter();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic: \n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION()\n    void StartSwimming();\n\n    UFUNCTION()\n    void StopSwimming();\n\nprivate:\n    bool bIsInWater;\n    void CheckIfInWater();\n};\n```", "cpp_code": "```cpp\n#include \"SwimmableCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nASwimmableCharacter::ASwimmableCharacter()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    bIsInWater = false;\n}\n\nvoid ASwimmableCharacter::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ASwimmableCharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    CheckIfInWater();\n}\n\nvoid ASwimmableCharacter::StartSwimming()\n{\n    // Logic to start swimming\n    // E.g., change movement mode\n    GetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_Swimming);\n}\n\nvoid ASwimmableCharacter::StopSwimming()\n{\n    // Logic to stop swimming\n    // E.g., revert movement mode\n    GetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_Walking);\n}\n\nvoid ASwimmableCharacter::CheckIfInWater()\n{\n    // Simple example of checking if character is in water\n    if (GetActorLocation().Z < WaterLevel && !bIsInWater)\n    {\n        bIsInWater = true;\n        StartSwimming();\n    }\n    else if (GetActorLocation().Z >= WaterLevel && bIsInWater)\n    {\n        bIsInWater = false;\n        StopSwimming();\n    }\n}\n```"}
{"requirement": "Add a function to log the player's current position.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PlayerPositionLogger.generated.h\"\n\nUCLASS()\nclass YOURGAME_API APlayerPositionLogger : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAPlayerPositionLogger();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Logs the player's current position\n\tUFUNCTION(BlueprintCallable, Category=\"Player\")\n\tvoid LogPlayerPosition();\n};\n```", "cpp_code": "```cpp\n#include \"PlayerPositionLogger.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAPlayerPositionLogger::APlayerPositionLogger()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid APlayerPositionLogger::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid APlayerPositionLogger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid APlayerPositionLogger::LogPlayerPosition()\n{\n\tAPlayerController* PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PlayerController)\n\t{\n\t\tAPawn* PlayerPawn = PlayerController->GetPawn();\n\t\tif (PlayerPawn)\n\t\t{\n\t\t\tFVector PlayerLocation = PlayerPawn->GetActorLocation();\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"Player Location: X=%f, Y=%f, Z=%f\"), PlayerLocation.X, PlayerLocation.Y, PlayerLocation.Z);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Implement a simple gravity switch for an actor.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GravitySwitchActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AGravitySwitchActor : public AActor\n{\n  GENERATED_BODY()\n\npublic: \n  AGravitySwitchActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic: \n  virtual void Tick(float DeltaTime) override;\n\n  UFUNCTION(BlueprintCallable, Category=\"Gravity\")\n  void ToggleGravity();\n\nprivate:\n  UPROPERTY(EditAnywhere, Category=\"Gravity\")\n  bool bIsGravityEnabled;\n};\n```", "cpp_code": "```cpp\n#include \"GravitySwitchActor.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nAGravitySwitchActor::AGravitySwitchActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n  bIsGravityEnabled = true;\n}\n\nvoid AGravitySwitchActor::BeginPlay()\n{\n  Super::BeginPlay();\n}\n\nvoid AGravitySwitchActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AGravitySwitchActor::ToggleGravity()\n{\n  bIsGravityEnabled = !bIsGravityEnabled;\n  TArray<UActorComponent*> Components = GetComponentsByClass(UPrimitiveComponent::StaticClass());\n  for (UActorComponent* Component : Components)\n  {\n    if (UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(Component))\n    {\n      PrimitiveComponent->SetEnableGravity(bIsGravityEnabled);\n    }\n  }\n}\n```"}
{"requirement": "Create a console command that prints a custom message.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PrintMessageConsoleCommand.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APrintMessageConsoleCommand : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    APrintMessageConsoleCommand();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    void PrintCustomMessage();\n};\n```", "cpp_code": "```cpp\n#include \"PrintMessageConsoleCommand.h\"\n#include \"Engine/Engine.h\"\n\nAPrintMessageConsoleCommand::APrintMessageConsoleCommand()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid APrintMessageConsoleCommand::BeginPlay()\n{\n    Super::BeginPlay();\n\n    if (GEngine)\n    {\n        GEngine->Exec(GetWorld(), TEXT(\"ce PrintCustomMessage\"));\n    }\n}\n\nvoid APrintMessageConsoleCommand::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid APrintMessageConsoleCommand::PrintCustomMessage()\n{\n    if (GEngine)\n    {\n        GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"This is a custom message from the console command!\"));\n    }\n}\n\nstatic FAutoConsoleCommand PrintCustomMessageCommand = FAutoConsoleCommand(\n    TEXT(\"PrintCustomMessage\"),\n    TEXT(\"Executes the PrintCustomMessage function.\"),\n    FConsoleCommandDelegate::CreateStatic(&APrintMessageConsoleCommand::PrintCustomMessage)\n);\n```"}
{"requirement": "Add a function to toggle an actor's visibility.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ToggleVisibilityActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AToggleVisibilityActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AToggleVisibilityActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category=\"Visibility\")\n    void ToggleVisibility();\n};\n```", "cpp_code": "```cpp\n#include \"ToggleVisibilityActor.h\"\n\n// Sets default values\nAToggleVisibilityActor::AToggleVisibilityActor()\n{\n     // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AToggleVisibilityActor::BeginPlay()\n{\n    Super::BeginPlay();\n    \n}\n\n// Called every frame\nvoid AToggleVisibilityActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AToggleVisibilityActor::ToggleVisibility()\n{\n    SetActorHiddenInGame(!bHidden);\n    SetActorEnableCollision(!bHidden);\n    SetActorTickEnabled(!bHidden);\n}\n```"}
{"requirement": "Implement a basic health regeneration system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthRegenSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHealthRegenSystem : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AHealthRegenSystem();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Health\")\n    float MaxHealth;\n\n    UPROPERTY(EditAnywhere, Category=\"Health\")\n    float CurrentHealth;\n\n    UPROPERTY(EditAnywhere, Category=\"Health\")\n    float RegenRate;\n\n    void RegenerateHealth(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"HealthRegenSystem.h\"\n\nAHealthRegenSystem::AHealthRegenSystem()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    MaxHealth = 100.0f;\n    CurrentHealth = 50.0f;\n    RegenRate = 5.0f; // Health per second\n}\n\nvoid AHealthRegenSystem::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AHealthRegenSystem::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    RegenerateHealth(DeltaTime);\n}\n\nvoid AHealthRegenSystem::RegenerateHealth(float DeltaTime)\n{\n    if (CurrentHealth < MaxHealth)\n    {\n        CurrentHealth += RegenRate * DeltaTime;\n        if (CurrentHealth > MaxHealth)\n        {\n            CurrentHealth = MaxHealth;\n        }\n    }\n}\n```"}
{"requirement": "Create a simple checkpoint system for a player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CheckpointSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ACheckpointSystem : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ACheckpointSystem();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Function to set a checkpoint\n    UFUNCTION(BlueprintCallable, Category = \"Checkpoint\")\n    void SetCheckpoint(FVector NewCheckpointLocation);\n\n    // Function to get the last checkpoint location\n    UFUNCTION(BlueprintCallable, Category = \"Checkpoint\")\n    FVector GetCheckpoint() const;\n\nprivate:\n    // Variable to store the last checkpoint location\n    FVector CheckpointLocation;\n};\n```", "cpp_code": "```cpp\n#include \"CheckpointSystem.h\"\n\n// Sets default values\nACheckpointSystem::ACheckpointSystem()\n{\n    // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ACheckpointSystem::BeginPlay()\n{\n    Super::BeginPlay();\n    \n    // Initialize the checkpoint location to a default value, e.g., the actor's starting location\n    CheckpointLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid ACheckpointSystem::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ACheckpointSystem::SetCheckpoint(FVector NewCheckpointLocation)\n{\n    CheckpointLocation = NewCheckpointLocation;\n}\n\nFVector ACheckpointSystem::GetCheckpoint() const\n{\n    return CheckpointLocation;\n}\n```"}
{"requirement": "Add a function to rotate an actor towards a point.", "header_code": "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RotatableActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARotatableActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ARotatableActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category = \"Rotation\")\n    void RotateTowardsPoint(const FVector& TargetPoint);\n};\n```", "cpp_code": "```cpp\n#include \"RotatableActor.h\"\n#include \"GameFramework/Actor.h\"\n\nARotatableActor::ARotatableActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ARotatableActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ARotatableActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ARotatableActor::RotateTowardsPoint(const FVector& TargetPoint)\n{\n    FVector Direction = TargetPoint - GetActorLocation();\n    Direction.Z = 0.0f; // Assuming you want to rotate only on the Z axis\n    FRotator NewRotation = Direction.Rotation();\n    SetActorRotation(NewRotation);\n}\n```"}
{"requirement": "Implement a basic wall jump mechanic for a character.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"WallJumpCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AWallJumpCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWallJumpCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tbool bIsWallJumping;\n\tFVector WallNormal;\n\n\tUFUNCTION()\n\tvoid OnWallJump();\n\n\tvoid CheckForWall();\n};\n```", "cpp_code": "```cpp\n#include \"WallJumpCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/InputComponent.h\"\n\nAWallJumpCharacter::AWallJumpCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsWallJumping = false;\n}\n\nvoid AWallJumpCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AWallJumpCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tCheckForWall();\n}\n\nvoid AWallJumpCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tPlayerInputComponent->BindAction(\"WallJump\", IE_Pressed, this, &AWallJumpCharacter::OnWallJump);\n}\n\nvoid AWallJumpCharacter::OnWallJump()\n{\n\tif (bIsWallJumping)\n\t{\n\t\tFVector JumpDirection = FVector::UpVector + WallNormal * 0.5f;\n\t\tLaunchCharacter(JumpDirection * 600.0f, true, true);\n\t\tbIsWallJumping = false;\n\t}\n}\n\nvoid AWallJumpCharacter::CheckForWall()\n{\n\tFVector Start = GetActorLocation();\n\tFVector ForwardVector = GetActorForwardVector();\n\tFVector End = ((ForwardVector * 100.0f) + Start);\n\tFHitResult HitResult;\n\tFCollisionQueryParams CollisionParams;\n\n\tif (GetWorld()->LineTraceSingleByChannel(HitResult, Start, End, ECC_Visibility, CollisionParams))\n\t{\n\t\tif (HitResult.bBlockingHit)\n\t\t{\n\t\t\tWallNormal = HitResult.Normal;\n\t\t\tbIsWallJumping = true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tbIsWallJumping = false;\n\t}\n}\n```"}
{"requirement": "Create an actor that changes size over time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SizeChangingActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASizeChangingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ASizeChangingActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    FVector InitialScale;\n    UPROPERTY(EditAnywhere, Category = \"Size\")\n    float ScaleFactor;\n    UPROPERTY(EditAnywhere, Category = \"Size\")\n    float Speed;\n};\n```", "cpp_code": "```cpp\n#include \"SizeChangingActor.h\"\n\n// Sets default values\nASizeChangingActor::ASizeChangingActor()\n{\n    // Set this actor to call Tick() every frame\n    PrimaryActorTick.bCanEverTick = true;\n\n    InitialScale = FVector(1.0f);\n    ScaleFactor = 1.0f;\n    Speed = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid ASizeChangingActor::BeginPlay()\n{\n    Super::BeginPlay();\n\n    InitialScale = GetActorScale3D();\n}\n\n// Called every frame\nvoid ASizeChangingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    float NewScaleFactor = ScaleFactor + FMath::Sin(GetWorld()->TimeSeconds * Speed) * 0.5f;\n    SetActorScale3D(InitialScale * NewScaleFactor);\n}\n```"}
{"requirement": "Add a function to check if an actor is in a trigger box.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyTriggerBox.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AMyTriggerBox : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AMyTriggerBox();\n\n    UFUNCTION(BlueprintCallable, Category=\"Trigger\")\n    bool IsActorInTriggerBox(AActor* ActorToCheck) const;\n\nprotected:\n    virtual void BeginPlay() override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    class UBoxComponent* TriggerBoxComponent;\n};\n```", "cpp_code": "```cpp\n#include \"MyTriggerBox.h\"\n#include \"Components/BoxComponent.h\"\n\nAMyTriggerBox::AMyTriggerBox()\n{\n    PrimaryActorTick.bCanEverTick = false;\n\n    TriggerBoxComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerBoxComponent\"));\n    RootComponent = TriggerBoxComponent;\n}\n\nvoid AMyTriggerBox::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nbool AMyTriggerBox::IsActorInTriggerBox(AActor* ActorToCheck) const\n{\n    if (!ActorToCheck || !TriggerBoxComponent)\n    {\n        return false;\n    }\n\n    return TriggerBoxComponent->IsOverlappingActor(ActorToCheck);\n}\n```"}
{"requirement": "Implement a basic energy system with a depletion rate.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"EnergySystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AEnergySystem : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AEnergySystem();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    // Energy value\n    UPROPERTY(EditAnywhere, Category = \"Energy\")\n    float Energy;\n\n    // Energy depletion rate per second\n    UPROPERTY(EditAnywhere, Category = \"Energy\")\n    float DepletionRate;\n\n    // Function to deplete energy\n    void DepleteEnergy(float DeltaTime);\n\n    // Function to handle energy reaching zero\n    void OnEnergyDepleted();\n};\n```", "cpp_code": "```cpp\n#include \"EnergySystem.h\"\n\n// Sets default values\nAEnergySystem::AEnergySystem()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Initialize energy and depletion rate\n    Energy = 100.0f;\n    DepletionRate = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid AEnergySystem::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid AEnergySystem::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    // Deplete energy based on the delta time\n    DepleteEnergy(DeltaTime);\n}\n\nvoid AEnergySystem::DepleteEnergy(float DeltaTime)\n{\n    Energy -= DepletionRate * DeltaTime;\n\n    // Clamp the energy to zero to prevent negative values\n    if (Energy <= 0.0f)\n    {\n        Energy = 0.0f;\n        OnEnergyDepleted();\n    }\n}\n\nvoid AEnergySystem::OnEnergyDepleted()\n{\n    // Handle what happens when energy is depleted\n    UE_LOG(LogTemp, Warning, TEXT(\"Energy Depleted!\"));\n    // Additional logic for energy depletion can be added here\n}\n```"}
{"requirement": "Create a rain effect with a particle system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"RainParticleSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ARainParticleSystem : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ARainParticleSystem();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    // The particle system component for rain\n    UPROPERTY(VisibleAnywhere)\n    class UParticleSystemComponent* RainParticleSystemComponent;\n\n    // Function to initialize the particle system\n    void InitializeRainParticleSystem();\n};\n```", "cpp_code": "```cpp\n#include \"RainParticleSystem.h\"\n#include \"Particles/ParticleSystem.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nARainParticleSystem::ARainParticleSystem()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Create the particle system component and attach it to the root\n    RainParticleSystemComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"RainParticleSystem\"));\n    RootComponent = RainParticleSystemComponent;\n\n    // Load the rain particle system asset\n    static ConstructorHelpers::FObjectFinder<UParticleSystem> ParticleSystemAsset(TEXT(\"/Game/PathToYourParticleSystem/PS_Rain\"));\n    if (ParticleSystemAsset.Succeeded())\n    {\n        RainParticleSystemComponent->SetTemplate(ParticleSystemAsset.Object);\n    }\n}\n\n// Called when the game starts or when spawned\nvoid ARainParticleSystem::BeginPlay()\n{\n    Super::BeginPlay();\n    \n    InitializeRainParticleSystem();\n}\n\n// Called every frame\nvoid ARainParticleSystem::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ARainParticleSystem::InitializeRainParticleSystem()\n{\n    // Additional setup for the particle system can be done here\n    RainParticleSystemComponent->ActivateSystem();\n}\n```"}
{"requirement": "Add a function to explode an actor on key press.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ExplodingActor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AExplodingActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AExplodingActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:  \n  virtual void Tick(float DeltaTime) override;\n\n  UFUNCTION()\n  void Explode();\n\nprivate:\n  void SetupInputComponent();\n\n  UPROPERTY(EditAnywhere)\n  float ExplosionRadius;\n\n  UPROPERTY(EditAnywhere)\n  float ExplosionStrength;\n};\n```", "cpp_code": "```cpp\n#include \"ExplodingActor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nAExplodingActor::AExplodingActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AExplodingActor::BeginPlay()\n{\n  Super::BeginPlay();\n  SetupInputComponent();\n}\n\nvoid AExplodingActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n}\n\nvoid AExplodingActor::Explode()\n{\n  UGameplayStatics::ApplyRadialDamage(\n    this,\n    ExplosionStrength,\n    GetActorLocation(),\n    ExplosionRadius,\n    nullptr,\n    TArray<AActor*>(),\n    this,\n    GetInstigatorController(),\n    true\n  );\n  Destroy();\n}\n\nvoid AExplodingActor::SetupInputComponent()\n{\n  if (APlayerController* PlayerController = GetWorld()->GetFirstPlayerController())\n  {\n    if (InputComponent == nullptr)\n    {\n      InputComponent = NewObject<UInputComponent>(this);\n      InputComponent->RegisterComponent();\n    }\n    InputComponent->BindAction(\"Explode\", IE_Pressed, this, &AExplodingActor::Explode);\n    PlayerController->PushInputComponent(InputComponent);\n  }\n}\n```"}
{"requirement": "Implement a simple flashlight with battery life.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Flashlight.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AFlashlight : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AFlashlight();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Flashlight\")\n    bool bIsOn;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Flashlight\")\n    float BatteryLife;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Flashlight\")\n    float BatteryDrainRate;\n\n    UFUNCTION(BlueprintCallable, Category=\"Flashlight\")\n    void ToggleFlashlight();\n\nprivate:\n    void DrainBattery(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"Flashlight.h\"\n\nAFlashlight::AFlashlight()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    bIsOn = false;\n    BatteryLife = 100.0f;\n    BatteryDrainRate = 1.0f;\n}\n\nvoid AFlashlight::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AFlashlight::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (bIsOn)\n    {\n        DrainBattery(DeltaTime);\n    }\n}\n\nvoid AFlashlight::ToggleFlashlight()\n{\n    if (BatteryLife > 0.0f)\n    {\n        bIsOn = !bIsOn;\n    }\n    else\n    {\n        bIsOn = false;\n    }\n}\n\nvoid AFlashlight::DrainBattery(float DeltaTime)\n{\n    if (BatteryLife > 0.0f)\n    {\n        BatteryLife -= BatteryDrainRate * DeltaTime;\n        if (BatteryLife <= 0.0f)\n        {\n            BatteryLife = 0.0f;\n            bIsOn = false;\n        }\n    }\n}\n```"}
{"requirement": "Create a character that can slide under obstacles.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"SlidingCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASlidingCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    ASlidingCharacter();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic: \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sliding\")\n    float SlideSpeed;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Sliding\")\n    float SlideDuration;\n\n    UFUNCTION(BlueprintCallable, Category=\"Sliding\")\n    void StartSlide();\n\n    UFUNCTION(BlueprintCallable, Category=\"Sliding\")\n    void StopSlide();\n\nprivate:\n    FTimerHandle SlideTimerHandle;\n    bool bIsSliding;\n};\n```", "cpp_code": "```cpp\n#include \"SlidingCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"TimerManager.h\"\n\nASlidingCharacter::ASlidingCharacter()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    SlideSpeed = 600.0f;\n    SlideDuration = 1.0f;\n    bIsSliding = false;\n}\n\nvoid ASlidingCharacter::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ASlidingCharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    if (bIsSliding)\n    {\n        FVector SlideDirection = GetActorForwardVector();\n        AddMovementInput(SlideDirection, SlideSpeed * DeltaTime);\n    }\n}\n\nvoid ASlidingCharacter::StartSlide()\n{\n    if (!bIsSliding)\n    {\n        bIsSliding = true;\n        GetCharacterMovement()->MaxWalkSpeed = SlideSpeed;\n        GetWorldTimerManager().SetTimer(SlideTimerHandle, this, &ASlidingCharacter::StopSlide, SlideDuration, false);\n    }\n}\n\nvoid ASlidingCharacter::StopSlide()\n{\n    bIsSliding = false;\n    GetCharacterMovement()->MaxWalkSpeed = 600.0f; // Reset to default walk speed\n    GetWorldTimerManager().ClearTimer(SlideTimerHandle);\n}\n```"}
{"requirement": "Add a function to log the current level name.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LevelLogger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALevelLogger : public AActor\n{\n  GENERATED_BODY()\n\npublic:  \n  ALevelLogger();\n\n  UFUNCTION(BlueprintCallable, Category=\"Logging\")\n  void LogCurrentLevelName();\n};\n```", "cpp_code": "```cpp\n#include \"LevelLogger.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nALevelLogger::ALevelLogger()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ALevelLogger::LogCurrentLevelName()\n{\n  if (UWorld* World = GetWorld())\n  {\n    FString LevelName = UGameplayStatics::GetCurrentLevelName(World);\n    UE_LOG(LogTemp, Log, TEXT(\"Current Level Name: %s\"), *LevelName);\n  }\n}\n```"}
{"requirement": "Implement a basic health bar with UMG.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"HealthBarWidget.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API UHealthBarWidget : public UUserWidget\n{\n\tGENERATED_BODY()\n\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"Health\")\n\tvoid SetHealthPercentage(float HealthPercentage);\n\nprotected:\n\tUPROPERTY(meta = (BindWidget))\n\tclass UProgressBar* HealthProgressBar;\n};\n```", "cpp_code": "```cpp\n#include \"HealthBarWidget.h\"\n#include \"Components/ProgressBar.h\"\n\nvoid UHealthBarWidget::SetHealthPercentage(float HealthPercentage)\n{\n\tif (HealthProgressBar)\n\t{\n\t\tHealthProgressBar->SetPercent(HealthPercentage);\n\t}\n}\n```"}
{"requirement": "Create a simple wind effect that moves actors.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WindEffectActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWindEffectActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AWindEffectActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category = \"Wind\")\n    FVector WindDirection;\n\n    UPROPERTY(EditAnywhere, Category = \"Wind\")\n    float WindStrength;\n};\n```", "cpp_code": "```cpp\n#include \"WindEffectActor.h\"\n#include \"GameFramework/Actor.h\"\n\nAWindEffectActor::AWindEffectActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    WindDirection = FVector(1.0f, 0.0f, 0.0f);\n    WindStrength = 100.0f;\n}\n\nvoid AWindEffectActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AWindEffectActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    FVector Movement = WindDirection * WindStrength * DeltaTime;\n    for (TActorIterator<AActor> It(GetWorld()); It; ++It)\n    {\n        AActor* Actor = *It;\n        if (Actor != this)\n        {\n            Actor->AddActorWorldOffset(Movement);\n        }\n    }\n}\n```"}
{"requirement": "Add a function to check the player's speed.", "header_code": "```cpp\nUCLASS()\nclass YOURGAME_API APlayerCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    // Function to get the player's current speed\n    UFUNCTION(BlueprintCallable, Category=\"Player\")\n    float GetPlayerSpeed() const;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerCharacter.h\"\n\nfloat APlayerCharacter::GetPlayerSpeed() const\n{\n    return GetVelocity().Size();\n}\n```"}
{"requirement": "Implement a basic wall running mechanic.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"WallRunningCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AWallRunningCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWallRunningCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tUFUNCTION()\n\tvoid StartWallRun();\n\n\tUFUNCTION()\n\tvoid StopWallRun();\n\n\tUFUNCTION()\n\tbool CanWallRun() const;\n\n\tUFUNCTION()\n\tvoid PerformWallRun(float DeltaTime);\n\nprivate:\n\tbool bIsWallRunning;\n\tFVector WallRunDirection;\n\n\tUPROPERTY(EditAnywhere, Category=\"WallRun\")\n\tfloat WallRunSpeed;\n\n\tUPROPERTY(EditAnywhere, Category=\"WallRun\")\n\tfloat WallRunDuration;\n\n\tUPROPERTY(EditAnywhere, Category=\"WallRun\")\n\tfloat WallRunGravityScale;\n};\n```", "cpp_code": "```cpp\n#include \"WallRunningCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/InputComponent.h\"\n\nAWallRunningCharacter::AWallRunningCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsWallRunning = false;\n\tWallRunSpeed = 600.0f;\n\tWallRunDuration = 1.0f;\n\tWallRunGravityScale = 0.3f;\n}\n\nvoid AWallRunningCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AWallRunningCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsWallRunning)\n\t{\n\t\tPerformWallRun(DeltaTime);\n\t}\n}\n\nvoid AWallRunningCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAction(\"WallRun\", IE_Pressed, this, &AWallRunningCharacter::StartWallRun);\n\tPlayerInputComponent->BindAction(\"WallRun\", IE_Released, this, &AWallRunningCharacter::StopWallRun);\n}\n\nvoid AWallRunningCharacter::StartWallRun()\n{\n\tif (CanWallRun())\n\t{\n\t\tbIsWallRunning = true;\n\t\tGetCharacterMovement()->GravityScale = WallRunGravityScale;\n\t\tWallRunDirection = GetActorRightVector(); // Assume wall on the right for simplicity\n\t}\n}\n\nvoid AWallRunningCharacter::StopWallRun()\n{\n\tbIsWallRunning = false;\n\tGetCharacterMovement()->GravityScale = 1.0f;\n}\n\nbool AWallRunningCharacter::CanWallRun() const\n{\n\t// Add logic to check if wall run is possible (e.g., raycasting to check for nearby walls)\n\treturn true;\n}\n\nvoid AWallRunningCharacter::PerformWallRun(float DeltaTime)\n{\n\tif (!bIsWallRunning) return;\n\n\tFVector NewLocation = GetActorLocation() + WallRunDirection * WallRunSpeed * DeltaTime;\n\tSetActorLocation(NewLocation);\n\n\tWallRunDuration -= DeltaTime;\n\tif (WallRunDuration <= 0.0f)\n\t{\n\t\tStopWallRun();\n\t}\n}\n```"}
{"requirement": "Create a simple collectable coin system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Coin.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ACoin : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tACoin();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle the collection of the coin\n\tUFUNCTION()\n\tvoid OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprivate:\n\t// Sphere component to detect overlaps\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tclass USphereComponent* CollisionComponent;\n\n\t// Static mesh for the coin\n\tUPROPERTY(VisibleAnywhere, Category = \"Components\")\n\tclass UStaticMeshComponent* CoinMesh;\n\n\t// Coin value\n\tUPROPERTY(EditAnywhere, Category = \"Coin\")\n\tint32 CoinValue;\n};\n```", "cpp_code": "```cpp\n#include \"Coin.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nACoin::ACoin()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create and set up the sphere component\n\tCollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"CollisionComponent\"));\n\tRootComponent = CollisionComponent;\n\tCollisionComponent->InitSphereRadius(50.0f);\n\tCollisionComponent->SetCollisionProfileName(TEXT(\"OverlapAllDynamic\"));\n\n\t// Create and set up the static mesh component\n\tCoinMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"CoinMesh\"));\n\tCoinMesh->SetupAttachment(RootComponent);\n\n\t// Set default coin value\n\tCoinValue = 10;\n\n\t// Register the overlap event\n\tCollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACoin::OnOverlapBegin);\n}\n\n// Called when the game starts or when spawned\nvoid ACoin::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ACoin::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ACoin::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor != nullptr && OtherActor != this && OtherComp != nullptr)\n\t{\n\t\t// Implement logic to add the coin value to the player's total\n\t\t// For example, cast to the player's character and increase the score\n\t\tDestroy(); // Destroy the coin after collection\n\t}\n}\n```"}
{"requirement": "Add a function to change the skybox during play.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SkyboxChanger.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASkyboxChanger : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    ASkyboxChanger();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category=\"Skybox\")\n    void ChangeSkybox(UStaticMesh* NewSkybox);\n\nprivate:\n    UPROPERTY(EditAnywhere)\n    UStaticMeshComponent* SkyboxMeshComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SkyboxChanger.h\"\n#include \"Components/StaticMeshComponent.h\"\n\nASkyboxChanger::ASkyboxChanger()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    SkyboxMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"SkyboxMeshComponent\"));\n    RootComponent = SkyboxMeshComponent;\n}\n\nvoid ASkyboxChanger::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ASkyboxChanger::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ASkyboxChanger::ChangeSkybox(UStaticMesh* NewSkybox)\n{\n    if (SkyboxMeshComponent && NewSkybox)\n    {\n        SkyboxMeshComponent->SetStaticMesh(NewSkybox);\n    }\n}\n```"}
{"requirement": "Implement a basic dual-wield weapon system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DualWieldWeaponSystem.generated.h\"\n\nUCLASS()\nclass MYGAME_API ADualWieldWeaponSystem : public AActor\n{\n    GENERATED_BODY()\n    \npublic:\n    // Sets default values for this actor's properties\n    ADualWieldWeaponSystem();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:    \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Function to equip weapons\n    UFUNCTION(BlueprintCallable, Category=\"Weapon\")\n    void EquipWeapons(AActor* LeftWeapon, AActor* RightWeapon);\n\n    // Function to fire left weapon\n    UFUNCTION(BlueprintCallable, Category=\"Weapon\")\n    void FireLeftWeapon();\n\n    // Function to fire right weapon\n    UFUNCTION(BlueprintCallable, Category=\"Weapon\")\n    void FireRightWeapon();\n\nprivate:\n    // Pointers to the weapons\n    UPROPERTY()\n    AActor* LeftWeapon;\n\n    UPROPERTY()\n    AActor* RightWeapon;\n};\n```", "cpp_code": "```cpp\n#include \"DualWieldWeaponSystem.h\"\n\n// Sets default values\nADualWieldWeaponSystem::ADualWieldWeaponSystem()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    LeftWeapon = nullptr;\n    RightWeapon = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid ADualWieldWeaponSystem::BeginPlay()\n{\n    Super::BeginPlay();\n    \n}\n\n// Called every frame\nvoid ADualWieldWeaponSystem::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n}\n\nvoid ADualWieldWeaponSystem::EquipWeapons(AActor* NewLeftWeapon, AActor* NewRightWeapon)\n{\n    if (NewLeftWeapon)\n    {\n        LeftWeapon = NewLeftWeapon;\n        // Additional logic for equipping left weapon can be added here\n    }\n    if (NewRightWeapon)\n    {\n        RightWeapon = NewRightWeapon;\n        // Additional logic for equipping right weapon can be added here\n    }\n}\n\nvoid ADualWieldWeaponSystem::FireLeftWeapon()\n{\n    if (LeftWeapon)\n    {\n        // Logic to fire the left weapon\n        UE_LOG(LogTemp, Warning, TEXT(\"Firing Left Weapon!\"));\n    }\n}\n\nvoid ADualWieldWeaponSystem::FireRightWeapon()\n{\n    if (RightWeapon)\n    {\n        // Logic to fire the right weapon\n        UE_LOG(LogTemp, Warning, TEXT(\"Firing Right Weapon!\"));\n    }\n}\n```"}
{"requirement": "Create an actor that spins when clicked.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SpinActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASpinActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic: \n\t// Sets default values for this actor's properties\n\tASpinActor();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic: \n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\n\t// Function to handle click event\n\tUFUNCTION()\n\tvoid OnClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed);\n\nprivate:\n\t// Rotation speed\n\tUPROPERTY(EditAnywhere)\n\tfloat RotationSpeed;\n\n\t// Flag to check if spinning\n\tbool bIsSpinning;\n\n\t// Root component\n\tUSceneComponent* RootComp;\n\n\t// Static Mesh\n\tUStaticMeshComponent* MeshComp;\n};\n```", "cpp_code": "```cpp\n#include \"SpinActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"Engine/Engine.h\"\n\n// Sets default values\nASpinActor::ASpinActor()\n{\n\t// Set this actor to call Tick() every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// Create root component\n\tRootComp = CreateDefaultSubobject<USceneComponent>(TEXT(\"RootComponent\"));\n\tRootComponent = RootComp;\n\n\t// Create static mesh component\n\tMeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tMeshComp->SetupAttachment(RootComp);\n\n\t// Enable click events\n\tMeshComp->SetMobility(EComponentMobility::Movable);\n\tMeshComp->OnClicked.AddDynamic(this, &ASpinActor::OnClicked);\n\n\t// Initialize variables\n\tRotationSpeed = 180.0f;\n\tbIsSpinning = false;\n}\n\n// Called when the game starts or when spawned\nvoid ASpinActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid ASpinActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsSpinning)\n\t{\n\t\tFRotator NewRotation = GetActorRotation();\n\t\tNewRotation.Yaw += RotationSpeed * DeltaTime;\n\t\tSetActorRotation(NewRotation);\n\t}\n}\n\nvoid ASpinActor::OnClicked(UPrimitiveComponent* TouchedComponent, FKey ButtonPressed)\n{\n\tbIsSpinning = !bIsSpinning;\n}\n```"}
{"requirement": "Add a function to toggle slow motion.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SlowMotionToggle.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASlowMotionToggle : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ASlowMotionToggle();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category=\"TimeControl\")\n    void ToggleSlowMotion();\n\nprivate:\n    bool bIsSlowMotionActive;\n};\n```", "cpp_code": "```cpp\n#include \"SlowMotionToggle.h\"\n#include \"GameFramework/WorldSettings.h\"\n\nASlowMotionToggle::ASlowMotionToggle()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    bIsSlowMotionActive = false;\n}\n\nvoid ASlowMotionToggle::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ASlowMotionToggle::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ASlowMotionToggle::ToggleSlowMotion()\n{\n    if (GetWorld())\n    {\n        UWorld* World = GetWorld();\n        AWorldSettings* WorldSettings = World->GetWorldSettings();\n        if (bIsSlowMotionActive)\n        {\n            WorldSettings->SetTimeDilation(1.0f);\n        }\n        else\n        {\n            WorldSettings->SetTimeDilation(0.5f); // Adjust this value for desired slow motion effect\n        }\n        bIsSlowMotionActive = !bIsSlowMotionActive;\n    }\n}\n```"}
{"requirement": "Implement a basic healing zone for the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealingZone.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHealingZone : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AHealingZone();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Healing\")\n    float HealingRate;\n\n    UFUNCTION()\n    void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult);\n\n    UFUNCTION()\n    void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    class USphereComponent* CollisionComponent;\n\n    UPROPERTY()\n    TSet<AActor*> OverlappingPlayers;\n};\n```", "cpp_code": "```cpp\n#include \"HealingZone.h\"\n#include \"Components/SphereComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/Character.h\"\n#include \"TimerManager.h\"\n\nAHealingZone::AHealingZone()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    CollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"SphereComponent\"));\n    CollisionComponent->InitSphereRadius(200.0f);\n    CollisionComponent->SetCollisionProfileName(TEXT(\"Trigger\"));\n    RootComponent = CollisionComponent;\n\n    CollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AHealingZone::OnOverlapBegin);\n    CollisionComponent->OnComponentEndOverlap.AddDynamic(this, &AHealingZone::OnOverlapEnd);\n\n    HealingRate = 5.0f;\n}\n\nvoid AHealingZone::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AHealingZone::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    for (AActor* Player : OverlappingPlayers)\n    {\n        if (ACharacter* Character = Cast<ACharacter>(Player))\n        {\n            // Assuming the character has a function to modify health\n            // Character->ModifyHealth(HealingRate * DeltaTime);\n        }\n    }\n}\n\nvoid AHealingZone::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n    if (OtherActor && OtherActor != this)\n    {\n        OverlappingPlayers.Add(OtherActor);\n    }\n}\n\nvoid AHealingZone::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n    if (OtherActor && OtherActor != this)\n    {\n        OverlappingPlayers.Remove(OtherActor);\n    }\n}\n```"}
{"requirement": "Create a simple NPC that follows the player.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"NPCFollower.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ANPCFollower : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tANPCFollower();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tAPawn* PlayerPawn;\n\n\tUPROPERTY(EditAnywhere, Category = \"AI\")\n\tfloat AcceptanceRadius = 200.0f;\n};\n```", "cpp_code": "```cpp\n#include \"NPCFollower.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"AIController.h\"\n\nANPCFollower::ANPCFollower()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ANPCFollower::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tPlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);\n}\n\nvoid ANPCFollower::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (PlayerPawn)\n\t{\n\t\tAAIController* AIController = Cast<AAIController>(GetController());\n\t\tif (AIController)\n\t\t{\n\t\t\tAIController->MoveToActor(PlayerPawn, AcceptanceRadius);\n\t\t}\n\t}\n}\n```"}
{"requirement": "Add a function to spawn an actor at a random location.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"YourActorSpawner.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AYourActorSpawner : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AYourActorSpawner();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category = \"Spawning\")\n    void SpawnActorAtRandomLocation();\n\n    UPROPERTY(EditAnywhere, Category = \"Spawning\")\n    TSubclassOf<AActor> ActorToSpawn;\n\n    UPROPERTY(EditAnywhere, Category = \"Spawning\")\n    FVector SpawnAreaMin;\n\n    UPROPERTY(EditAnywhere, Category = \"Spawning\")\n    FVector SpawnAreaMax;\n};\n```", "cpp_code": "```cpp\n#include \"YourActorSpawner.h\"\n#include \"Engine/World.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\n// Sets default values\nAYourActorSpawner::AYourActorSpawner()\n{\n    // Set this actor to call Tick() every frame\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AYourActorSpawner::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid AYourActorSpawner::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AYourActorSpawner::SpawnActorAtRandomLocation()\n{\n    if (ActorToSpawn)\n    {\n        FVector RandomLocation = UKismetMathLibrary::RandomPointInBoundingBox(SpawnAreaMin, SpawnAreaMax - SpawnAreaMin);\n        FActorSpawnParameters SpawnParams;\n        GetWorld()->SpawnActor<AActor>(ActorToSpawn, RandomLocation, FRotator::ZeroRotator, SpawnParams);\n    }\n}\n```"}
{"requirement": "Implement a simple music system with volume control.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SimpleMusicSystem.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API ASimpleMusicSystem : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ASimpleMusicSystem();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic: \n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category=\"Music\")\n    void PlayMusic();\n\n    UFUNCTION(BlueprintCallable, Category=\"Music\")\n    void StopMusic();\n\n    UFUNCTION(BlueprintCallable, Category=\"Music\")\n    void SetVolume(float Volume);\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Music\")\n    USoundCue* MusicCue;\n\n    UPROPERTY(EditAnywhere, Category=\"Music\")\n    float Volume;\n\n    UAudioComponent* AudioComponent;\n};\n```", "cpp_code": "```cpp\n#include \"SimpleMusicSystem.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Sound/SoundCue.h\"\n\nASimpleMusicSystem::ASimpleMusicSystem()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    AudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"AudioComponent\"));\n    AudioComponent->bAutoActivate = false;\n    Volume = 1.0f;\n}\n\nvoid ASimpleMusicSystem::BeginPlay()\n{\n    Super::BeginPlay();\n    if (MusicCue)\n    {\n        AudioComponent->SetSound(MusicCue);\n    }\n}\n\nvoid ASimpleMusicSystem::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ASimpleMusicSystem::PlayMusic()\n{\n    if (AudioComponent && MusicCue)\n    {\n        AudioComponent->Play();\n    }\n}\n\nvoid ASimpleMusicSystem::StopMusic()\n{\n    if (AudioComponent)\n    {\n        AudioComponent->Stop();\n    }\n}\n\nvoid ASimpleMusicSystem::SetVolume(float NewVolume)\n{\n    Volume = FMath::Clamp(NewVolume, 0.0f, 1.0f);\n    if (AudioComponent)\n    {\n        AudioComponent->SetVolumeMultiplier(Volume);\n    }\n}\n```"}
{"requirement": "Create a character that clings to surfaces.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"ClingingCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AClingingCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    AClingingCharacter();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Cling\")\n    bool bIsClinging;\n\n    UFUNCTION(BlueprintCallable, Category = \"Cling\")\n    void StartClinging();\n\n    UFUNCTION(BlueprintCallable, Category = \"Cling\")\n    void StopClinging();\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Cling\")\n    float ClingSpeed;\n\nprivate:\n    void ClingToSurface(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"ClingingCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/InputComponent.h\"\n\nAClingingCharacter::AClingingCharacter()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    bIsClinging = false;\n    ClingSpeed = 200.0f;\n}\n\nvoid AClingingCharacter::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AClingingCharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (bIsClinging)\n    {\n        ClingToSurface(DeltaTime);\n    }\n}\n\nvoid AClingingCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    PlayerInputComponent->BindAction(\"Cling\", IE_Pressed, this, &AClingingCharacter::StartClinging);\n    PlayerInputComponent->BindAction(\"Cling\", IE_Released, this, &AClingingCharacter::StopClinging);\n}\n\nvoid AClingingCharacter::StartClinging()\n{\n    bIsClinging = true;\n    GetCharacterMovement()->GravityScale = 0.0f;\n}\n\nvoid AClingingCharacter::StopClinging()\n{\n    bIsClinging = false;\n    GetCharacterMovement()->GravityScale = 1.0f;\n}\n\nvoid AClingingCharacter::ClingToSurface(float DeltaTime)\n{\n    if (Controller)\n    {\n        FVector ForwardVector = Controller->GetControlRotation().Vector();\n        AddMovementInput(ForwardVector, ClingSpeed * DeltaTime);\n    }\n}\n```"}
{"requirement": "Add a function to print out available console commands.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ConsoleCommandPrinter.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API AConsoleCommandPrinter : public AActor\n{\n    GENERATED_BODY()\n    \npublic: \n    // Sets default values for this actor's properties\n    AConsoleCommandPrinter();\n\n    // Function to print available console commands\n    UFUNCTION(BlueprintCallable, Category=\"Console Commands\")\n    void PrintAvailableConsoleCommands();\n};\n```", "cpp_code": "```cpp\n#include \"ConsoleCommandPrinter.h\"\n#include \"Engine/Engine.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Actor.h\"\n\nAConsoleCommandPrinter::AConsoleCommandPrinter()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = false;\n}\n\nvoid AConsoleCommandPrinter::PrintAvailableConsoleCommands()\n{\n    if (GEngine)\n    {\n        FString Output;\n        for (TObjectIterator<UConsole> It; It; ++It)\n        {\n            UConsole* Console = *It;\n            if (Console)\n            {\n                Output = Console->ConsoleCommandHistory;\n                for (const FString& Command : Console->AutoCompleteList)\n                {\n                    Output += Command + TEXT(\"\\n\");\n                }\n                GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, Output);\n            }\n        }\n    }\n}\n```"}
{"requirement": "Implement a basic color change on damage.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ColorChangeOnDamage.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AColorChangeOnDamage : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AColorChangeOnDamage();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\n    UStaticMeshComponent* MeshComponent;\n\n    UFUNCTION()\n    void OnTakeDamage();\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Damage\")\n    FLinearColor DamageColor;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Damage\")\n    FLinearColor DefaultColor;\n};\n```", "cpp_code": "```cpp\n#include \"ColorChangeOnDamage.h\"\n#include \"Components/StaticMeshComponent.h\"\n\n// Sets default values\nAColorChangeOnDamage::AColorChangeOnDamage()\n{\n    // Set this actor to call Tick() every frame.\n    PrimaryActorTick.bCanEverTick = true;\n\n    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n    RootComponent = MeshComponent;\n\n    DefaultColor = FLinearColor::White;\n    DamageColor = FLinearColor::Red;\n}\n\n// Called when the game starts or when spawned\nvoid AColorChangeOnDamage::BeginPlay()\n{\n    Super::BeginPlay();\n    MeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"Color\"), DefaultColor);\n}\n\n// Called every frame\nvoid AColorChangeOnDamage::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AColorChangeOnDamage::OnTakeDamage()\n{\n    MeshComponent->SetVectorParameterValueOnMaterials(TEXT(\"Color\"), DamageColor);\n}\n```"}
{"requirement": "Create a simple teleportation system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TeleportationSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ATeleportationSystem : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    ATeleportationSystem();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category=\"Teleportation\")\n    void TeleportActor(AActor* ActorToTeleport, const FVector& TargetLocation);\n};\n```", "cpp_code": "```cpp\n#include \"TeleportationSystem.h\"\n\nATeleportationSystem::ATeleportationSystem()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid ATeleportationSystem::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ATeleportationSystem::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ATeleportationSystem::TeleportActor(AActor* ActorToTeleport, const FVector& TargetLocation)\n{\n    if (ActorToTeleport)\n    {\n        ActorToTeleport->SetActorLocation(TargetLocation);\n    }\n}\n```"}
{"requirement": "Add a function to toggle character invisibility.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"MyCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAMyCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic: \t\n\tvirtual void Tick(float DeltaTime) override;\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n\tUFUNCTION(BlueprintCallable, Category=\"Visibility\")\n\tvoid ToggleInvisibility();\n\nprivate:\n\tbool bIsInvisible;\n};\n```", "cpp_code": "```cpp\n#include \"MyCharacter.h\"\n\nAMyCharacter::AMyCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsInvisible = false;\n}\n\nvoid AMyCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AMyCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AMyCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\nvoid AMyCharacter::ToggleInvisibility()\n{\n\tbIsInvisible = !bIsInvisible;\n\tSetActorHiddenInGame(bIsInvisible);\n\tSetActorEnableCollision(!bIsInvisible);\n}\n```"}
{"requirement": "Implement a basic sliding door mechanic.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SlidingDoor.generated.h\"\n\nUCLASS()\nclass YOURGAME_API ASlidingDoor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    ASlidingDoor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere)\n    FVector OpenPosition;\n\n    UPROPERTY(EditAnywhere)\n    FVector ClosedPosition;\n\n    UPROPERTY(EditAnywhere)\n    float DoorSpeed;\n\n    UFUNCTION(BlueprintCallable)\n    void OpenDoor();\n\n    UFUNCTION(BlueprintCallable)\n    void CloseDoor();\n\nprivate:\n    bool bIsOpening;\n    bool bIsClosing;\n};\n```", "cpp_code": "```cpp\n#include \"SlidingDoor.h\"\n\nASlidingDoor::ASlidingDoor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    \n    ClosedPosition = GetActorLocation();\n    OpenPosition = ClosedPosition + FVector(0, 200, 0); // Example offset for open position\n    DoorSpeed = 100.0f;\n    bIsOpening = false;\n    bIsClosing = false;\n}\n\nvoid ASlidingDoor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ASlidingDoor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (bIsOpening)\n    {\n        FVector CurrentPosition = GetActorLocation();\n        FVector NewPosition = FMath::VInterpConstantTo(CurrentPosition, OpenPosition, DeltaTime, DoorSpeed);\n        SetActorLocation(NewPosition);\n\n        if (CurrentPosition.Equals(OpenPosition, 1.0f))\n        {\n            bIsOpening = false;\n        }\n    }\n    else if (bIsClosing)\n    {\n        FVector CurrentPosition = GetActorLocation();\n        FVector NewPosition = FMath::VInterpConstantTo(CurrentPosition, ClosedPosition, DeltaTime, DoorSpeed);\n        SetActorLocation(NewPosition);\n\n        if (CurrentPosition.Equals(ClosedPosition, 1.0f))\n        {\n            bIsClosing = false;\n        }\n    }\n}\n\nvoid ASlidingDoor::OpenDoor()\n{\n    bIsOpening = true;\n    bIsClosing = false;\n}\n\nvoid ASlidingDoor::CloseDoor()\n{\n    bIsClosing = true;\n    bIsOpening = false;\n}\n```"}
{"requirement": "Create an actor that changes its mesh based on time.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DynamicMeshActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECTNAME_API ADynamicMeshActor : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tADynamicMeshActor();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid ChangeMesh();\n\n\tUPROPERTY(EditAnywhere)\n\tUStaticMeshComponent* MeshComponent;\n\n\tUPROPERTY(EditAnywhere, Category=\"Meshes\")\n\tTArray<UStaticMesh*> Meshes;\n\n\tfloat TimeAccumulator;\n\n\tUPROPERTY(EditAnywhere, Category=\"Time\")\n\tfloat ChangeInterval;\n};\n```", "cpp_code": "```cpp\n#include \"DynamicMeshActor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/StaticMesh.h\"\n\nADynamicMeshActor::ADynamicMeshActor()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"MeshComponent\"));\n\tRootComponent = MeshComponent;\n\n\tTimeAccumulator = 0.0f;\n\tChangeInterval = 5.0f; // Change mesh every 5 seconds by default\n}\n\nvoid ADynamicMeshActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid ADynamicMeshActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tTimeAccumulator += DeltaTime;\n\tif (TimeAccumulator >= ChangeInterval)\n\t{\n\t\tChangeMesh();\n\t\tTimeAccumulator = 0.0f;\n\t}\n}\n\nvoid ADynamicMeshActor::ChangeMesh()\n{\n\tif (Meshes.Num() > 0)\n\t{\n\t\tint32 MeshIndex = FMath::RandRange(0, Meshes.Num() - 1);\n\t\tMeshComponent->SetStaticMesh(Meshes[MeshIndex]);\n\t}\n}\n```"}
{"requirement": "Add a function to detect when the player is falling.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"FallingCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API AFallingCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    AFallingCharacter();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category = \"Movement\")\n    bool IsFalling() const;\n};\n```", "cpp_code": "```cpp\n#include \"FallingCharacter.h\"\n\nAFallingCharacter::AFallingCharacter()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AFallingCharacter::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AFallingCharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nbool AFallingCharacter::IsFalling() const\n{\n    return GetCharacterMovement()->IsFalling();\n}\n```"}
{"requirement": "Implement a basic dynamic weather system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"WeatherSystem.generated.h\"\n\nUCLASS()\nclass MYPROJECT_API AWeatherSystem : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AWeatherSystem();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Weather\")\n    float WeatherChangeInterval;\n\n    UFUNCTION(BlueprintCallable, Category = \"Weather\")\n    void ChangeWeather();\n\nprivate:\n    void UpdateWeather();\n\n    FTimerHandle WeatherChangeTimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"WeatherSystem.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n\n// Sets default values\nAWeatherSystem::AWeatherSystem()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    WeatherChangeInterval = 60.0f; // Default to change weather every 60 seconds\n}\n\n// Called when the game starts or when spawned\nvoid AWeatherSystem::BeginPlay()\n{\n    Super::BeginPlay();\n    \n    GetWorldTimerManager().SetTimer(WeatherChangeTimerHandle, this, &AWeatherSystem::ChangeWeather, WeatherChangeInterval, true);\n}\n\n// Called every frame\nvoid AWeatherSystem::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AWeatherSystem::ChangeWeather()\n{\n    UpdateWeather();\n}\n\nvoid AWeatherSystem::UpdateWeather()\n{\n    // Simple weather change logic\n    int WeatherType = FMath::RandRange(0, 2);\n    switch (WeatherType)\n    {\n    case 0:\n        UE_LOG(LogTemp, Warning, TEXT(\"Weather changed to Sunny\"));\n        break;\n    case 1:\n        UE_LOG(LogTemp, Warning, TEXT(\"Weather changed to Rainy\"));\n        break;\n    case 2:\n        UE_LOG(LogTemp, Warning, TEXT(\"Weather changed to Cloudy\"));\n        break;\n    default:\n        break;\n    }\n}\n```"}
{"requirement": "Create a destructible object that breaks on impact.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"DestructibleComponent.h\"\n#include \"DestructibleObject.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ADestructibleObject : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ADestructibleObject();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Destructible\")\n    UDestructibleComponent* DestructibleComponent;\n\n    UFUNCTION()\n    void OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"DestructibleObject.h\"\n#include \"Components/PrimitiveComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Engine/World.h\"\n\nADestructibleObject::ADestructibleObject()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    DestructibleComponent = CreateDefaultSubobject<UDestructibleComponent>(TEXT(\"DestructibleComponent\"));\n    RootComponent = DestructibleComponent;\n\n    DestructibleComponent->OnComponentHit.AddDynamic(this, &ADestructibleObject::OnHit);\n}\n\nvoid ADestructibleObject::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ADestructibleObject::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ADestructibleObject::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n    if (DestructibleComponent)\n    {\n        DestructibleComponent->ApplyDamage(10.0f, Hit.ImpactPoint, NormalImpulse, 1000.0f);\n    }\n}\n```"}
{"requirement": "Add a function to control actor brightness.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"BrightnessControlActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ABrightnessControlActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ABrightnessControlActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category=\"Brightness\")\n    void SetBrightness(float NewBrightness);\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Brightness\")\n    float Brightness;\n};\n```", "cpp_code": "```cpp\n#include \"BrightnessControlActor.h\"\n#include \"Components/PrimitiveComponent.h\"\n\nABrightnessControlActor::ABrightnessControlActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    Brightness = 1.0f;\n}\n\nvoid ABrightnessControlActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ABrightnessControlActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid ABrightnessControlActor::SetBrightness(float NewBrightness)\n{\n    Brightness = FMath::Clamp(NewBrightness, 0.0f, 1.0f);\n\n    TArray<UPrimitiveComponent*> Components;\n    GetComponents(Components);\n\n    for (UPrimitiveComponent* Component : Components)\n    {\n        if (Component)\n        {\n            Component->SetScalarParameterValueOnMaterials(TEXT(\"Brightness\"), Brightness);\n        }\n    }\n}\n```"}
{"requirement": "Implement a basic inventory limit system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"InventorySystem.generated.h\"\n\nUCLASS(Blueprintable)\nclass YOURGAME_API UInventorySystem : public UObject\n{\n    GENERATED_BODY()\n\npublic:\n    UInventorySystem();\n\n    UFUNCTION(BlueprintCallable, Category=\"Inventory\")\n    bool AddItem(FString ItemName);\n\n    UFUNCTION(BlueprintCallable, Category=\"Inventory\")\n    bool RemoveItem(FString ItemName);\n\n    UFUNCTION(BlueprintCallable, Category=\"Inventory\")\n    TArray<FString> GetInventoryItems() const;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Inventory\")\n    int32 InventoryLimit;\n\n    UPROPERTY()\n    TArray<FString> Items;\n};\n```", "cpp_code": "```cpp\n#include \"InventorySystem.h\"\n\nUInventorySystem::UInventorySystem()\n{\n    InventoryLimit = 10; // Default inventory limit\n}\n\nbool UInventorySystem::AddItem(FString ItemName)\n{\n    if (Items.Num() < InventoryLimit)\n    {\n        Items.Add(ItemName);\n        return true;\n    }\n    return false; // Inventory is full\n}\n\nbool UInventorySystem::RemoveItem(FString ItemName)\n{\n    return Items.Remove(ItemName) > 0;\n}\n\nTArray<FString> UInventorySystem::GetInventoryItems() const\n{\n    return Items;\n}\n```"}
{"requirement": "Create a simple starfield background.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"StarfieldBackground.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AStarfieldBackground : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\t// Sets default values for this actor's properties\n\tAStarfieldBackground();\n\nprotected:\n\t// Called when the game starts or when spawned\n\tvirtual void BeginPlay() override;\n\npublic:\n\t// Called every frame\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tvoid GenerateStarfield();\n\n\tUPROPERTY(EditAnywhere, Category = \"Starfield\")\n\tint32 NumberOfStars;\n\n\tUPROPERTY(EditAnywhere, Category = \"Starfield\")\n\tfloat StarfieldRadius;\n\n\tUPROPERTY(EditDefaultsOnly, Category = \"Starfield\")\n\tUMaterial* StarMaterial;\n\n\tUPROPERTY()\n\tTArray<UStaticMeshComponent*> Stars;\n};\n```", "cpp_code": "```cpp\n#include \"StarfieldBackground.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"Engine/World.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\n// Sets default values\nAStarfieldBackground::AStarfieldBackground()\n{\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tNumberOfStars = 100;\n\tStarfieldRadius = 1000.0f;\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> StarMesh(TEXT(\"/Engine/BasicShapes/Sphere.Sphere\"));\n\tstatic ConstructorHelpers::FObjectFinder<UMaterial> StarMat(TEXT(\"/Game/StarMaterial.StarMaterial\"));\n\n\tif (StarMesh.Succeeded() && StarMat.Succeeded())\n\t{\n\t\tStarMaterial = StarMat.Object;\n\t}\n}\n\n// Called when the game starts or when spawned\nvoid AStarfieldBackground::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tGenerateStarfield();\n}\n\n// Called every frame\nvoid AStarfieldBackground::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AStarfieldBackground::GenerateStarfield()\n{\n\tfor (int32 i = 0; i < NumberOfStars; ++i)\n\t{\n\t\tUStaticMeshComponent* Star = NewObject<UStaticMeshComponent>(this);\n\t\tStar->SetStaticMesh(ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"/Engine/BasicShapes/Sphere.Sphere\")).Object);\n\t\tStar->SetMaterial(0, StarMaterial);\n\n\t\tFVector RandomLocation = FMath::VRand() * FMath::RandRange(0.0f, StarfieldRadius);\n\t\tStar->SetWorldLocation(RandomLocation);\n\t\tStar->SetWorldScale3D(FVector(0.1f));\n\t\tStar->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepWorldTransform);\n\t\tStar->RegisterComponent();\n\t\tStars.Add(Star);\n\t}\n}\n```"}
{"requirement": "Add a function to pause sound effects.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/AudioComponent.h\"\n#include \"GameFramework/Actor.h\"\n#include \"SoundEffectManager.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ASoundEffectManager : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ASoundEffectManager();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    UFUNCTION(BlueprintCallable, Category = \"Audio\")\n    void PauseSoundEffects();\n\nprivate:\n    UPROPERTY()\n    TArray<UAudioComponent*> AudioComponents;\n};\n```", "cpp_code": "```cpp\n#include \"SoundEffectManager.h\"\n#include \"Components/AudioComponent.h\"\n\nASoundEffectManager::ASoundEffectManager()\n{\n    PrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ASoundEffectManager::BeginPlay()\n{\n    Super::BeginPlay();\n\n    // Find all audio components in the scene\n    TArray<UActorComponent*> Components;\n    GetComponents(UAudioComponent::StaticClass(), Components);\n\n    for (UActorComponent* Component : Components)\n    {\n        UAudioComponent* AudioComponent = Cast<UAudioComponent>(Component);\n        if (AudioComponent && AudioComponent->IsPlaying())\n        {\n            AudioComponents.Add(AudioComponent);\n        }\n    }\n}\n\nvoid ASoundEffectManager::PauseSoundEffects()\n{\n    for (UAudioComponent* AudioComponent : AudioComponents)\n    {\n        if (AudioComponent && AudioComponent->IsPlaying())\n        {\n            AudioComponent->SetPaused(true);\n        }\n    }\n}\n```"}
{"requirement": "Implement a basic on-screen key prompt.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"KeyPromptActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AKeyPromptActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    AKeyPromptActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Prompt\")\n    FString PromptMessage;\n\n    UPROPERTY(EditAnywhere, Category=\"Prompt\")\n    FKey PromptKey;\n\n    void ShowPrompt();\n\n    void HidePrompt();\n\n    bool bIsPromptVisible;\n};\n```", "cpp_code": "```cpp\n#include \"KeyPromptActor.h\"\n#include \"Engine/Engine.h\"\n\nAKeyPromptActor::AKeyPromptActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    bIsPromptVisible = false;\n}\n\nvoid AKeyPromptActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AKeyPromptActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (!bIsPromptVisible && FInputKeyEventArgs::IsPressed(PromptKey))\n    {\n        ShowPrompt();\n        bIsPromptVisible = true;\n    }\n    else if (bIsPromptVisible && !FInputKeyEventArgs::IsPressed(PromptKey))\n    {\n        HidePrompt();\n        bIsPromptVisible = false;\n    }\n}\n\nvoid AKeyPromptActor::ShowPrompt()\n{\n    if (GEngine)\n    {\n        GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, PromptMessage);\n    }\n}\n\nvoid AKeyPromptActor::HidePrompt()\n{\n    if (GEngine)\n    {\n        GEngine->ClearOnScreenDebugMessages();\n    }\n}\n```"}
{"requirement": "Create a simple score multiplier system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ScoreMultiplierSystem.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AScoreMultiplierSystem : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    AScoreMultiplierSystem();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category=\"Score\")\n    void AddScore(int32 BasePoints);\n\n    UFUNCTION(BlueprintCallable, Category=\"Score\")\n    void SetMultiplier(float NewMultiplier);\n\n    UFUNCTION(BlueprintCallable, Category=\"Score\")\n    int32 GetTotalScore() const;\n\nprivate:\n    int32 TotalScore;\n    float Multiplier;\n};\n```", "cpp_code": "```cpp\n#include \"ScoreMultiplierSystem.h\"\n\nAScoreMultiplierSystem::AScoreMultiplierSystem()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    TotalScore = 0;\n    Multiplier = 1.0f;\n}\n\nvoid AScoreMultiplierSystem::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AScoreMultiplierSystem::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AScoreMultiplierSystem::AddScore(int32 BasePoints)\n{\n    TotalScore += FMath::RoundToInt(BasePoints * Multiplier);\n}\n\nvoid AScoreMultiplierSystem::SetMultiplier(float NewMultiplier)\n{\n    Multiplier = NewMultiplier;\n}\n\nint32 AScoreMultiplierSystem::GetTotalScore() const\n{\n    return TotalScore;\n}\n```"}
{"requirement": "Add a function to print the number of actors in a level.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CountActors.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ACountActors : public AActor\n{\n    GENERATED_BODY()\n\npublic:    \n    ACountActors();\n\n    UFUNCTION(BlueprintCallable, Category=\"Level\")\n    void PrintNumberOfActorsInLevel();\n};\n```", "cpp_code": "```cpp\n#include \"CountActors.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nACountActors::ACountActors()\n{\n    PrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ACountActors::PrintNumberOfActorsInLevel()\n{\n    if (GetWorld())\n    {\n        int32 ActorCount = GetWorld()->GetActorCount();\n        UE_LOG(LogTemp, Log, TEXT(\"Number of actors in the level: %d\"), ActorCount);\n    }\n}\n```"}
{"requirement": "Implement a simple health display using text.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"HealthDisplay.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AHealthDisplay : public AActor\n{\n\tGENERATED_BODY()\n\npublic:\n\tAHealthDisplay();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\nprivate:\n\tint32 Health;\n\n\tUFUNCTION()\n\tvoid DisplayHealth();\n};\n```", "cpp_code": "```cpp\n#include \"HealthDisplay.h\"\n#include \"Engine/Engine.h\"\n\nAHealthDisplay::AHealthDisplay()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tHealth = 100; // Initialize health\n}\n\nvoid AHealthDisplay::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tDisplayHealth();\n}\n\nvoid AHealthDisplay::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid AHealthDisplay::DisplayHealth()\n{\n\tif (GEngine)\n\t{\n\t\tFString HealthString = FString::Printf(TEXT(\"Current Health: %d\"), Health);\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, HealthString);\n\t}\n}\n```"}
{"requirement": "Create a character that can wall slide.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"WallSlideCharacter.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AWallSlideCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAWallSlideCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n\tvoid WallSlide();\n\n\tbool bIsSliding;\n\n\tUFUNCTION()\n\tvoid OnWallHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);\n};\n```", "cpp_code": "```cpp\n#include \"WallSlideCharacter.h\"\n#include \"GameFramework/Actor.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"Components/CapsuleComponent.h\"\n\nAWallSlideCharacter::AWallSlideCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tGetCapsuleComponent()->OnComponentHit.AddDynamic(this, &AWallSlideCharacter::OnWallHit);\n\n\tbIsSliding = false;\n}\n\nvoid AWallSlideCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AWallSlideCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsSliding)\n\t{\n\t\tWallSlide();\n\t}\n}\n\nvoid AWallSlideCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\nvoid AWallSlideCharacter::WallSlide()\n{\n\t// Simple gravity reduction for wall sliding effect\n\tFVector NewVelocity = GetCharacterMovement()->Velocity;\n\tNewVelocity.Z = FMath::Clamp(NewVelocity.Z, -200.f, 0.f);\n\tGetCharacterMovement()->Velocity = NewVelocity;\n}\n\nvoid AWallSlideCharacter::OnWallHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\n{\n\t// Check if the hit surface is a wall\n\tFVector Normal = Hit.Normal;\n\n\tif (FMath::Abs(Normal.Z) < KINDA_SMALL_NUMBER)\n\t{\n\t\tbIsSliding = true;\n\t}\n\telse\n\t{\n\t\tbIsSliding = false;\n\t}\n}\n```"}
{"requirement": "Add a function to detect actor overlap events.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"OverlapActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AOverlapActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AOverlapActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION()\n    void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    class UBoxComponent* CollisionComponent;\n};\n```", "cpp_code": "```cpp\n#include \"OverlapActor.h\"\n#include \"Components/BoxComponent.h\"\n\nAOverlapActor::AOverlapActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    CollisionComponent = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BoxComponent\"));\n    RootComponent = CollisionComponent;\n\n    CollisionComponent->SetGenerateOverlapEvents(true);\n    CollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &AOverlapActor::OnOverlapBegin);\n}\n\nvoid AOverlapActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AOverlapActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AOverlapActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n    if (OtherActor && (OtherActor != this) && OtherComp)\n    {\n        UE_LOG(LogTemp, Warning, TEXT(\"Overlap Begin with: %s\"), *OtherActor->GetName());\n    }\n}\n```"}
{"requirement": "Implement a basic shooting mechanic.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyShootingActor.generated.h\"\n\nUCLASS()\nclass MYGAME_API AMyShootingActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AMyShootingActor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category=\"Shooting\")\n    void Shoot();\n\nprivate:\n    UPROPERTY(EditAnywhere, Category=\"Shooting\")\n    TSubclassOf<AActor> ProjectileClass;\n\n    UPROPERTY(EditAnywhere, Category=\"Shooting\")\n    FVector MuzzleOffset;\n};\n```", "cpp_code": "```cpp\n#include \"MyShootingActor.h\"\n#include \"Engine/World.h\"\n#include \"GameFramework/Actor.h\"\n\nAMyShootingActor::AMyShootingActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyShootingActor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AMyShootingActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AMyShootingActor::Shoot()\n{\n    if (ProjectileClass)\n    {\n        FVector MuzzleLocation = GetActorLocation() + FTransform(GetActorRotation()).TransformVector(MuzzleOffset);\n        FRotator MuzzleRotation = GetActorRotation();\n        UWorld* World = GetWorld();\n        if (World)\n        {\n            World->SpawnActor<AActor>(ProjectileClass, MuzzleLocation, MuzzleRotation);\n        }\n    }\n}\n```"}
{"requirement": "Create a simple level transition system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LevelTransitionSystem.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API ALevelTransitionSystem : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    ALevelTransitionSystem();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    UFUNCTION(BlueprintCallable, Category = \"LevelTransition\")\n    void TransitionToLevel(FName LevelName);\n};\n```", "cpp_code": "```cpp\n#include \"LevelTransitionSystem.h\"\n#include \"Kismet/GameplayStatics.h\"\n\nALevelTransitionSystem::ALevelTransitionSystem()\n{\n    PrimaryActorTick.bCanEverTick = false;\n}\n\nvoid ALevelTransitionSystem::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ALevelTransitionSystem::TransitionToLevel(FName LevelName)\n{\n    if (!LevelName.IsNone())\n    {\n        UGameplayStatics::OpenLevel(this, LevelName);\n    }\n}\n```"}
{"requirement": "Add a function to invert character controls.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"InvertControlsCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AInvertControlsCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this character's properties\n    AInvertControlsCharacter();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Called to bind functionality to input\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n    // Function to invert controls\n    UFUNCTION(BlueprintCallable, Category=\"Character\")\n    void InvertControls();\n\nprivate:\n    bool bAreControlsInverted;\n\n    void MoveForward(float Value);\n    void MoveRight(float Value);\n};\n```", "cpp_code": "```cpp\n#include \"InvertControlsCharacter.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/InputComponent.h\"\n\nAInvertControlsCharacter::AInvertControlsCharacter()\n{\n    // Set default values\n    bAreControlsInverted = false;\n}\n\nvoid AInvertControlsCharacter::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AInvertControlsCharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AInvertControlsCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    PlayerInputComponent->BindAxis(\"MoveForward\", this, &AInvertControlsCharacter::MoveForward);\n    PlayerInputComponent->BindAxis(\"MoveRight\", this, &AInvertControlsCharacter::MoveRight);\n}\n\nvoid AInvertControlsCharacter::MoveForward(float Value)\n{\n    if (bAreControlsInverted)\n    {\n        Value = -Value;\n    }\n    AddMovementInput(GetActorForwardVector(), Value);\n}\n\nvoid AInvertControlsCharacter::MoveRight(float Value)\n{\n    if (bAreControlsInverted)\n    {\n        Value = -Value;\n    }\n    AddMovementInput(GetActorRightVector(), Value);\n}\n\nvoid AInvertControlsCharacter::InvertControls()\n{\n    bAreControlsInverted = !bAreControlsInverted;\n}\n```"}
{"requirement": "Implement a basic auto-save feature.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AutoSaveActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AAutoSaveActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    AAutoSaveActor();\n\nprotected:\n    virtual void BeginPlay() override;\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    void AutoSave();\n\n    UPROPERTY(EditAnywhere, Category=\"AutoSave\")\n    float SaveInterval;\n\n    FTimerHandle AutoSaveTimerHandle;\n};\n```", "cpp_code": "```cpp\n#include \"AutoSaveActor.h\"\n#include \"TimerManager.h\"\n#include \"Engine/World.h\"\n\nAAutoSaveActor::AAutoSaveActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    SaveInterval = 300.0f; // default to 5 minutes\n}\n\nvoid AAutoSaveActor::BeginPlay()\n{\n    Super::BeginPlay();\n    GetWorld()->GetTimerManager().SetTimer(AutoSaveTimerHandle, this, &AAutoSaveActor::AutoSave, SaveInterval, true);\n}\n\nvoid AAutoSaveActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AAutoSaveActor::AutoSave()\n{\n    UE_LOG(LogTemp, Log, TEXT(\"Auto-saving game state...\"));\n    // Implement your save logic here\n}\n```"}
{"requirement": "Create an actor that emits light periodically.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"TimerManager.h\"\n#include \"PeriodicLightActor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API APeriodicLightActor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:\n    // Sets default values for this actor's properties\n    APeriodicLightActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\nprivate:\n    UPROPERTY(VisibleAnywhere)\n    UPointLightComponent* PointLight;\n\n    UPROPERTY(EditAnywhere)\n    float LightOnDuration;\n\n    UPROPERTY(EditAnywhere)\n    float LightOffDuration;\n\n    FTimerHandle LightTimerHandle;\n\n    void ToggleLight();\n};\n```", "cpp_code": "```cpp\n#include \"PeriodicLightActor.h\"\n#include \"Components/PointLightComponent.h\"\n\n// Sets default values\nAPeriodicLightActor::APeriodicLightActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    PointLight = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight\"));\n    RootComponent = PointLight;\n\n    LightOnDuration = 1.0f;\n    LightOffDuration = 1.0f;\n}\n\n// Called when the game starts or when spawned\nvoid APeriodicLightActor::BeginPlay()\n{\n    Super::BeginPlay();\n    ToggleLight();\n}\n\n// Called every frame\nvoid APeriodicLightActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid APeriodicLightActor::ToggleLight()\n{\n    PointLight->ToggleVisibility();\n    float NextDuration = PointLight->IsVisible() ? LightOffDuration : LightOnDuration;\n    GetWorldTimerManager().SetTimer(LightTimerHandle, this, &APeriodicLightActor::ToggleLight, NextDuration);\n}\n```"}
{"requirement": "Add a function to check the player's health status.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"PlayerCharacter.generated.h\"\n\nUCLASS()\nclass MYGAME_API APlayerCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this character's properties\n    APlayerCharacter();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Called to bind functionality to input\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n    // Function to check the player's health status\n    UFUNCTION(BlueprintCallable, Category=\"Health\")\n    FString CheckHealthStatus() const;\n\nprivate:\n    // Player's health\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Health\", meta=(AllowPrivateAccess = \"true\"))\n    float Health;\n};\n```", "cpp_code": "```cpp\n#include \"PlayerCharacter.h\"\n#include \"GameFramework/Actor.h\"\n\n// Sets default values\nAPlayerCharacter::APlayerCharacter()\n{\n    // Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    // Initialize health\n    Health = 100.0f;\n}\n\n// Called when the game starts or when spawned\nvoid APlayerCharacter::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid APlayerCharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid APlayerCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\n// Function to check the player's health status\nFString APlayerCharacter::CheckHealthStatus() const\n{\n    if (Health > 75.0f)\n    {\n        return TEXT(\"Healthy\");\n    }\n    else if (Health > 50.0f)\n    {\n        return TEXT(\"Injured\");\n    }\n    else if (Health > 25.0f)\n    {\n        return TEXT(\"Critical\");\n    }\n    else\n    {\n        return TEXT(\"Near Death\");\n    }\n}\n```"}
{"requirement": "Implement a basic toggle for character abilities.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"AbilityToggleCharacter.generated.h\"\n\nUCLASS()\nclass YOURGAME_API AAbilityToggleCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    AAbilityToggleCharacter();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic: \n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category=\"Abilities\")\n    void ToggleAbility();\n\nprivate:\n    bool bIsAbilityActive;\n};\n```", "cpp_code": "```cpp\n#include \"AbilityToggleCharacter.h\"\n\nAAbilityToggleCharacter::AAbilityToggleCharacter()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    bIsAbilityActive = false;\n}\n\nvoid AAbilityToggleCharacter::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AAbilityToggleCharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    // Example logic when ability is active\n    if (bIsAbilityActive)\n    {\n        // Ability active logic here\n    }\n}\n\nvoid AAbilityToggleCharacter::ToggleAbility()\n{\n    bIsAbilityActive = !bIsAbilityActive;\n    UE_LOG(LogTemp, Log, TEXT(\"Ability is now %s\"), bIsAbilityActive ? TEXT(\"Active\") : TEXT(\"Inactive\"));\n}\n```"}
{"requirement": "Create a simple interactive door system.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"InteractiveDoor.generated.h\"\n\nUCLASS()\nclass YOURPROJECT_API AInteractiveDoor : public AActor\n{\n    GENERATED_BODY()\n    \npublic:    \n    AInteractiveDoor();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:    \n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable, Category=\"Door\")\n    void OpenDoor();\n\n    UFUNCTION(BlueprintCallable, Category=\"Door\")\n    void CloseDoor();\n\nprivate:\n    UPROPERTY(EditAnywhere)\n    float OpenAngle;\n\n    UPROPERTY(EditAnywhere)\n    float CloseAngle;\n\n    UPROPERTY(EditAnywhere)\n    float DoorSpeed;\n\n    UPROPERTY(VisibleAnywhere)\n    bool bIsOpen;\n\n    UPROPERTY(VisibleAnywhere)\n    FRotator CurrentRotation;\n\n    UPROPERTY(VisibleAnywhere)\n    FRotator TargetRotation;\n\n    void UpdateDoorRotation(float DeltaTime);\n};\n```", "cpp_code": "```cpp\n#include \"InteractiveDoor.h\"\n#include \"GameFramework/Actor.h\"\n\nAInteractiveDoor::AInteractiveDoor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    OpenAngle = 90.0f;\n    CloseAngle = 0.0f;\n    DoorSpeed = 2.0f;\n    bIsOpen = false;\n    CurrentRotation = GetActorRotation();\n    TargetRotation = CurrentRotation;\n}\n\nvoid AInteractiveDoor::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid AInteractiveDoor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    UpdateDoorRotation(DeltaTime);\n}\n\nvoid AInteractiveDoor::OpenDoor()\n{\n    if (!bIsOpen)\n    {\n        TargetRotation = FRotator(CurrentRotation.Pitch, CurrentRotation.Yaw + OpenAngle, CurrentRotation.Roll);\n        bIsOpen = true;\n    }\n}\n\nvoid AInteractiveDoor::CloseDoor()\n{\n    if (bIsOpen)\n    {\n        TargetRotation = FRotator(CurrentRotation.Pitch, CurrentRotation.Yaw + CloseAngle, CurrentRotation.Roll);\n        bIsOpen = false;\n    }\n}\n\nvoid AInteractiveDoor::UpdateDoorRotation(float DeltaTime)\n{\n    if (CurrentRotation.Equals(TargetRotation, 1.0f))\n    {\n        return;\n    }\n    CurrentRotation = FMath::RInterpConstantTo(CurrentRotation, TargetRotation, DeltaTime, DoorSpeed);\n    SetActorRotation(CurrentRotation);\n}\n```"}
{"requirement": "Add a function to reset the player's position.", "header_code": "```cpp\nUCLASS()\nclass MYGAME_API AMyPlayerCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    // Function to reset the player's position\n    UFUNCTION(BlueprintCallable, Category=\"Player\")\n    void ResetPlayerPosition();\n\nprivate:\n    // Default position to reset the player to\n    FVector DefaultPosition;\n};\n```", "cpp_code": "```cpp\n#include \"MyPlayerCharacter.h\"\n#include \"GameFramework/Actor.h\"\n\nAMyPlayerCharacter::AMyPlayerCharacter()\n{\n    // Initialize the default position (example position)\n    DefaultPosition = FVector(0.0f, 0.0f, 0.0f);\n}\n\nvoid AMyPlayerCharacter::ResetPlayerPosition()\n{\n    SetActorLocation(DefaultPosition);\n}\n```"}
{"requirement": "Implement a basic stealth mechanic.", "header_code": "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"StealthCharacter.generated.h\"\n\nUCLASS()\nclass STEALTHGAME_API AStealthCharacter : public ACharacter\n{\n\tGENERATED_BODY()\n\npublic:\n\tAStealthCharacter();\n\nprotected:\n\tvirtual void BeginPlay() override;\n\npublic:\n\tvirtual void Tick(float DeltaTime) override;\n\n\tUFUNCTION(BlueprintCallable, Category = \"Stealth\")\n\tvoid EnterStealthMode();\n\n\tUFUNCTION(BlueprintCallable, Category = \"Stealth\")\n\tvoid ExitStealthMode();\n\nprivate:\n\tbool bIsStealthed;\n\tUPROPERTY(EditAnywhere, Category = \"Stealth\")\n\tfloat StealthSpeedMultiplier;\n};\n```", "cpp_code": "```cpp\n#include \"StealthCharacter.h\"\n\nAStealthCharacter::AStealthCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\tbIsStealthed = false;\n\tStealthSpeedMultiplier = 0.5f; // Default to half speed\n}\n\nvoid AStealthCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid AStealthCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (bIsStealthed)\n\t{\n\t\t// Implement any logic that should occur while in stealth mode\n\t}\n}\n\nvoid AStealthCharacter::EnterStealthMode()\n{\n\tbIsStealthed = true;\n\tGetCharacterMovement()->MaxWalkSpeed *= StealthSpeedMultiplier;\n\t// Additional logic for entering stealth mode (e.g., change material)\n}\n\nvoid AStealthCharacter::ExitStealthMode()\n{\n\tbIsStealthed = false;\n\tGetCharacterMovement()->MaxWalkSpeed /= StealthSpeedMultiplier;\n\t// Additional logic for exiting stealth mode (e.g., revert material)\n}\n```"}
